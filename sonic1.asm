; /=========================================================================\
; ยบ	This file is generated by The Interactive Disassembler (IDA)		ยบ
; ยบ	Copyright (c) 2003 by DataRescue sa/nv,	<ida@datarescue.com>		ยบ
; \=========================================================================/
;
; Disassembly created by Hivebrain
; thanks to drx and Stealth

; Processor:		68000
; Target Assembler: 680x0 Assembler in MRI compatible mode
; This file should be compiled with "as	-M"
		org 0
		include 	"macros.asm"

StartOfRom:
Vectors:	dc.l $FFFE00, EntryPoint, BusError, AddressError
		dc.l IllegalInstr, ZeroDivide, ChkInstr, TrapvInstr
		dc.l PrivilegeViol, Trace, Line1010Emu,	Line1111Emu
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorTrap, ErrorTrap,	ErrorTrap
		dc.l PalToCRAM,	ErrorTrap, loc_B10, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
Console:	dc.b 'SEGA MEGA DRIVE ' ; Hardware system ID
Date:		dc.b '(C)SEGA 2017.AAA' ; Release date
Title_Local:	dc.b 'SONIC NEXT GENESIS                              ' ; Domestic name
Title_Int:	dc.b 'SONIC NEXT GENESIS                              ' ; International name
Serial:		dc.b 'GM 00001009-00'   ; Serial/version number
Checksum:	dc.w 0
		dc.b 'J               ' ; I/O support
RomStartLoc:	dc.l StartOfRom		; ROM start
RomEndLoc:	dc.l EndOfRom-1		; ROM end
RamStartLoc:	dc.l $FF0000		; RAM start
RamEndLoc:	dc.l $FFFFFF		; RAM end
SRAMSupport:	dc.l $20202020		; change to $5241E020 to create	SRAM
		dc.l $20202020		; SRAM start
		dc.l $20202020		; SRAM end
Notes:		dc.b '                                                    '
Region:		dc.b 'JUE             ' ; Region

; ===========================================================================

ErrorTrap:
		nop
		nop	
		bra.s	ErrorTrap
; ===========================================================================

EntryPoint:
		tst.l	($A10008).l	; test port A control
		bne.s	PortA_Ok
		tst.w	($A1000C).l	; test port C control

PortA_Ok:
		bne.s	PortC_Ok
		lea	SetupValues(pc),a5
		movem.w	(a5)+,d5-d7
		movem.l	(a5)+,a0-a4
		move.b	-$10FF(a1),d0	; get hardware version
		andi.b	#$F,d0
		beq.s	SkipSecurity
		move.l	#'SEGA',$2F00(a1)

SkipSecurity:
		move.w	(a4),d0		; check	if VDP works
		moveq	#0,d0
		movea.l	d0,a6
		move.l	a6,usp		; set usp to $0
		moveq	#$17,d1

VDPInitLoop:
		move.b	(a5)+,d5	; add $8000 to value
		move.w	d5,(a4)		; move value to	VDP register
		add.w	d7,d5		; next register
		dbf	d1,VDPInitLoop
		move.l	(a5)+,(a4)
		move.w	d0,(a3)		; clear	the screen
		move.w	d7,(a1)		; stop the Z80
		move.w	d7,(a2)		; reset	the Z80

WaitForZ80:
		btst	d0,(a1)		; has the Z80 stopped?
		bne.s	WaitForZ80	; if not, branch
		moveq	#$25,d2

Z80InitLoop:
		move.b	(a5)+,(a0)+
		dbf	d2,Z80InitLoop
		move.w	d0,(a2)
		move.w	d0,(a1)		; start	the Z80
		move.w	d7,(a2)		; reset	the Z80

ClrRAMLoop:
		move.l	d0,-(a6)
		dbf	d6,ClrRAMLoop	; clear	the entire RAM
		move.l	(a5)+,(a4)	; set VDP display mode and increment
		move.l	(a5)+,(a4)	; set VDP to CRAM write
		moveq	#$1F,d3

ClrCRAMLoop:
		move.l	d0,(a3)
		dbf	d3,ClrCRAMLoop	; clear	the CRAM
		move.l	(a5)+,(a4)
		moveq	#$13,d4

ClrVDPStuff:
		move.l	d0,(a3)
		dbf	d4,ClrVDPStuff
		moveq	#3,d5

PSGInitLoop:
		move.b	(a5)+,$11(a3)	; reset	the PSG
		dbf	d5,PSGInitLoop
		move.w	d0,(a2)
		movem.l	(a6),d0-a6	; clear	all registers
		move	#$2700,sr	; set the sr

PortC_Ok:
		bra.s	GameProgram
; ===========================================================================
SetupValues:	dc.w $8000		; XREF: PortA_Ok
		dc.w $3FFF
		dc.w $100

		dc.l $A00000		; start	of Z80 RAM
		dc.l $A11100		; Z80 bus request
		dc.l $A11200		; Z80 reset
		dc.l $C00000
		dc.l $C00004		; address for VDP registers

		dc.b 4,	$14, $30, $3C	; values for VDP registers
		dc.b 7,	$6C, 0,	0
		dc.b 0,	0, $FF,	0
		dc.b $81, $37, 0, 1
		dc.b 1,	0, 0, $FF
		dc.b $FF, 0, 0,	$80

		dc.l $40000080

		dc.b $AF, 1, $D9, $1F, $11, $27, 0, $21, $26, 0, $F9, $77 ; Z80	instructions
		dc.b $ED, $B0, $DD, $E1, $FD, $E1, $ED,	$47, $ED, $4F
		dc.b $D1, $E1, $F1, 8, $D9, $C1, $D1, $E1, $F1,	$F9, $F3
		dc.b $ED, $56, $36, $E9, $E9

		dc.w $8104		; value	for VDP	display	mode
		dc.w $8F02		; value	for VDP	increment
		dc.l $C0000000		; value	for CRAM write mode
		dc.l $40000010

		dc.b $9F, $BF, $DF, $FF	; values for PSG channel volumes
; ===========================================================================

GameProgram:
	;	tst.w	($C00004).l
	;	btst	#6,($A1000D).l
	;	beq.s	CheckSumCheck
	;	cmpi.l	#'init',($FFFFFFFC).w ; has checksum routine already run?
	;	beq.w	GameInit	; if yes, branch

CheckSumCheck:
	;	movea.l	#ErrorTrap,a0	; start	checking bytes after the header	($200)
	;	movea.l	#RomEndLoc,a1	; stop at end of ROM
	;	move.l	(a1),d0
	;	moveq	#0,d1

loc_32C:
	;	add.w	(a0)+,d1
	;	cmp.l	a0,d0
	;	bcc.s	loc_32C
	;	movea.l	#Checksum,a1	; read the checksum
	;	cmp.w	(a1),d1		; compare correct checksum to the one in ROM
	;	bne.w	CheckSumError	; if they don't match, branch
	;	lea	($FFFFFE00).w,a6
	;	moveq	#0,d7
	;	move.w	#$7F,d6

loc_348:
	;	move.l	d7,(a6)+
	;	dbf	d6,loc_348
	;	move.b	($A10001).l,d0
	;	andi.b	#$C0,d0
	;	move.b	d0,($FFFFFFF8).w
	;	move.l	#'init',($FFFFFFFC).w ; set flag so checksum won't be run again

GameInit:
		lea	($FF0000).l,a6
		moveq	#0,d7
		move.w	#$3F7F,d6

GameClrRAM:
		move.l	d7,(a6)+
		dbf	d6,GameClrRAM	; fill RAM ($0000-$FDFF) with $0
		bsr.w	VDPSetupGame
		bsr.w	SoundDriverLoad
		bsr.w	JoypadInit
		move.b	#0,($FFFFF600).w ; set Game Mode to Sega Screen

MainGameLoop:
		move.b	($FFFFF600).w,d0 ; load	Game Mode
		andi.w	#$3C,d0
		jsr	GameModeArray(pc,d0.w) ; jump to apt location in ROM
		bra.s	MainGameLoop
; ===========================================================================
; ---------------------------------------------------------------------------
; Main game mode array
; ---------------------------------------------------------------------------

GameModeArray:
		bra.w	SegaScreen	; Sega Screen ($00)
; ===========================================================================
		bra.w	TitleScreen	; Title	Screen ($04)
; ===========================================================================
		bra.w	Level		; Demo Mode ($08)
; ===========================================================================
		bra.w	Level		; Normal Level ($0C)
; ===========================================================================
		bra.w	BonusStage	; Bonus Stage	($10)
; ===========================================================================
		bra.w	ContinueScreen	; Continue Screen ($14)
; ===========================================================================
		bra.w	EndingBranch	; End of game sequence ($18)
; ===========================================================================
		bra.w	CreditsBranch		; Credits ($1C)
; ===========================================================================
		bra.w	SSRGScreen	; SSRG Screen ($20)
; ===========================================================================
		bra.w	Options	; Options Screen ($24)
; ===========================================================================
		bra.w	SegaScreen	; Null ($28)
; ===========================================================================
		bra.w	Options	; Level Select ($2C)
; ===========================================================================
		rts	
; ===========================================================================

CreditsBranch:
		jmp	Credits

EndingBranch:
		jmp	EndingSequence

loc_43A:
		addq.w	#2,sp
		move.l	(sp)+,($FFFFFC40).w
		addq.w	#2,sp
		movem.l	d0-a7,($FFFFD600).w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA
		move.l	($FFFFFC40).w,d0
		bsr.w	sub_5BA
		bra.s	loc_478
; ===========================================================================

loc_462:
		move	#$2700,sr
		movem.l	d0-a7,($FFFFD600).w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA

loc_478:
		bsr.w	ErrorWaitForC
		movem.l	($FFFFD600).w,d0-a7
		move	#$2300,sr
		rte	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowErrorMsg:				; XREF: loc_43A; loc_462
		lea	($C00000).l,a6
		move.l	#$78000003,($C00004).l
		lea	(Art_Text).l,a0
		move.w	#$27F,d1

Error_LoadGfx:
		move.w	(a0)+,(a6)
		dbf	d1,Error_LoadGfx
		moveq	#0,d0		; clear	d0
		move.b	($FFFFFC44).w,d0 ; load	error code
		move.w	ErrorText(pc,d0.w),d0
		lea	ErrorText(pc,d0.w),a0
		move.l	#$46040003,($C00004).l ; position
		moveq	#$12,d1		; number of characters

Error_LoopChars:
		moveq	#0,d0
		move.b	(a0)+,d0
		addi.w	#$790,d0
		move.w	d0,(a6)
		dbf	d1,Error_LoopChars ; repeat for	number of characters
		rts	
; End of function ShowErrorMsg

; ===========================================================================
ErrorText:	dc.w asc_4E8-ErrorText,	asc_4FB-ErrorText ; XREF: ShowErrorMsg
		dc.w asc_50E-ErrorText,	asc_521-ErrorText
		dc.w asc_534-ErrorText,	asc_547-ErrorText
		dc.w asc_55A-ErrorText,	asc_56D-ErrorText
		dc.w asc_580-ErrorText,	asc_593-ErrorText
		dc.w asc_5A6-ErrorText
asc_4E8:	dc.b 'ERROR EXCEPTION	'
asc_4FB:	dc.b 'BUS ERROR		  '
asc_50E:	dc.b 'ADDRESS ERROR	  '
asc_521:	dc.b 'ILLEGAL INSTRUCTION'
asc_534:	dc.b '@ERO DIVIDE		'
asc_547:	dc.b 'CHK INSTRUCTION	'
asc_55A:	dc.b 'TRAPV INSTRUCTION  '
asc_56D:	dc.b 'PRIVILEGE VIOLATION'
asc_580:	dc.b 'TRACE			  '
asc_593:	dc.b 'LINE 1010 EMULATOR '
asc_5A6:	dc.b 'LINE 1111 EMULATOR '
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5BA:				; XREF: loc_43A; loc_462
		move.w	#$7CA,(a6)
		moveq	#7,d2

loc_5C0:
		rol.l	#4,d0
		bsr.s	sub_5CA
		dbf	d2,loc_5C0
		rts	
; End of function sub_5BA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5CA:				; XREF: sub_5BA
		move.w	d0,d1
		andi.w	#$F,d1
		cmpi.w	#$A,d1
		bcs.s	loc_5D8
		addq.w	#7,d1

loc_5D8:
		addi.w	#$7C0,d1
		move.w	d1,(a6)
		rts	
; End of function sub_5CA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ErrorWaitForC:				; XREF: loc_478
		bsr.w	ReadJoypads
		cmpi.b	#$20,($FFFFF605).w ; is	button C pressed?
		bne.w	ErrorWaitForC	; if not, branch
		rts	
; End of function ErrorWaitForC

; ===========================================================================

Art_Text:	incbin	artunc\menutext.bin	; text used in level select and debug mode
		even
Art_TextS2:	incbin	artunc\menutexts2.bin	; text used in level select and debug mode
		even
Art_MText:	incbin	artunc\musictext.bin	; text used in level select and debug mode
		even

; ===========================================================================

loc_B10:				; XREF: Vectors
		movem.l	d0-a6,-(sp)
		tst.b	($FFFFF62A).w
		beq.s	loc_B88
		move.w	($C00004).l,d0
		move.l	#$40000010,($C00004).l
		move.l	($FFFFF616).w,($C00000).l
		btst	#6,($FFFFFFF8).w
		beq.s	loc_B42
		move.w	#$700,d0

loc_B3E:
		dbf	d0,loc_B3E

loc_B42:
		move.b	($FFFFF62A).w,d0
		move.b	#0,($FFFFF62A).w
		move.w	#1,($FFFFF644).w
		andi.w	#$3E,d0
		move.w	off_B6E(pc,d0.w),d0
		jsr	off_B6E(pc,d0.w)

loc_B5E:				; XREF: loc_B88
		nop			; The nop was placed here in order to make sure
					; that the same number of cycles was used.
					; not doing so could put things slightly out of sync.

loc_B64:				; XREF: loc_D50
		addq.l	#1,($FFFFFE0C).w
		movem.l	(sp)+,d0-a6
		rte	
; ===========================================================================
off_B6E:	dc.w loc_B88-off_B6E, loc_C32-off_B6E
		dc.w loc_C44-off_B6E, loc_C5E-off_B6E
		dc.w loc_C6E-off_B6E, loc_DA6-off_B6E
		dc.w loc_E72-off_B6E, loc_F8A-off_B6E
		dc.w loc_C64-off_B6E, loc_F9A-off_B6E
		dc.w loc_C36-off_B6E, loc_FA6-off_B6E
		dc.w loc_E72-off_B6E
; ===========================================================================

loc_B88:				; XREF: loc_B10; off_B6E
		cmpi.b	#$8C,($FFFFF600).w
		beq.s	loc_B9A
		cmpi.b	#$C,($FFFFF600).w
		bne.w	loc_B5E

loc_B9A:
	;	cmpi.b	#1,($FFFFFE10).w
	;	bne.w	loc_B5E
		tst.b	(Water_flag).w
		beq.w	loc_B5E ; if not, branch
		move.w	($C00004).l,d0
		btst	#6,($FFFFFFF8).w
		beq.s	loc_BBA
		move.w	#$700,d0

loc_BB6:
		dbf	d0,loc_BB6

loc_BBA:
		move.w	#1,($FFFFF644).w
		move.w	#$100,($A11100).l

loc_BC8:
		btst	#0,($A11100).l
		bne.s	loc_BC8
		tst.b	($FFFFF64E).w
		bne.s	loc_BFE
		lea	($C00004).l,a5
		move.l	#$94009340,(a5)
		move.l	#$96FD9580,(a5)
		move.w	#$977F,(a5)
		move.w	#$C000,(a5)
		move.w	#$80,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		bra.s	loc_C22
; ===========================================================================

loc_BFE:				; XREF: loc_BC8
		lea	($C00004).l,a5
		move.l	#$94009340,(a5)
		move.l	#$96FD9540,(a5)
		move.w	#$977F,(a5)
		move.w	#$C000,(a5)
		move.w	#$80,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)

loc_C22:				; XREF: loc_BC8
		move.w	($FFFFF624).w,(a5)
		move.w	#0,($A11100).l
		bra.w	loc_B5E
; ===========================================================================

loc_C32:				; XREF: off_B6E
		bsr.w	sub_106E

loc_C36:				; XREF: off_B6E
		tst.w	($FFFFF614).w
		beq.w	locret_C42
		subq.w	#1,($FFFFF614).w

locret_C42:
		rts	
; ===========================================================================

loc_C44:				; XREF: off_B6E
		bsr.w	sub_106E
		jsr	sub_6886
		bsr.w	sub_1642
		tst.w	($FFFFF614).w
		beq.w	locret_C5C
		subq.w	#1,($FFFFF614).w

locret_C5C:
		rts	
; ===========================================================================

loc_C5E:				; XREF: off_B6E
		bsr.w	sub_106E
		rts	
; ===========================================================================

loc_C64:				; XREF: off_B6E
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)	?
		beq.w	loc_DA6		; if yes, branch

loc_C6E:				; XREF: off_B6E
		move.w	#$100,($A11100).l ; stop the Z80

loc_C76:
		btst	#0,($A11100).l	; has Z80 stopped?
		bne.s	loc_C76		; if not, branch
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	VInt_8_UW
		writeCRAM	$FFFFFB00,$80,0
		bra.s	VInt_8_Load

VInt_8_UW:
		writeCRAM	$FFFFFA80,$80,0

VInt_8_Load:
		move.w	($FFFFF624).w,(a5)

VInt_8_Cont:
		writeVRAM	$FFFFE000,$380,$FC00
		writeVRAM	$FFFFF800,$280,$F800

		jsr	(ProcessDMAQueue).l

loc_D50:
		move.w	#0,($A11100).l
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w
		cmpi.b	#$60,($FFFFF625).w
		bcc.s	Demo_Time
		move.b	#1,($FFFFF64F).w
		addq.l	#4,sp
		bra.w	loc_B64

; ---------------------------------------------------------------------------
; Subroutine to	run a demo for an amount of time
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Demo_Time:				; XREF: loc_D50; PalToCRAM
		jsr	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_165E
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.w	Demo_TimeEnd	; if not, branch
		subq.w	#1,($FFFFF614).w ; subtract 1 from time	left

Demo_TimeEnd:
		rts	
; End of function Demo_Time

; ===========================================================================

loc_DA6:				; XREF: off_B6E
		move.w	#$100,($A11100).l ; stop the Z80

loc_DAE:
		btst	#0,($A11100).l	; has Z80 stopped?
		bne.s	loc_DAE		; if not, branch
		bsr.w	ReadJoypads
		writeCRAM	$FFFFFB00,$80,0
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		move.w	#0,($A11100).l
		jsr	(ProcessDMAQueue).l

loc_E64:
		cmpi.b	#96,($FFFFF625).w
		bcc.s	loc_E64update
		bra.w	locret_E70

loc_E64update:
		jsr	SS_LoadWalls
		tst.w	($FFFFF614).w
		beq.w	locret_E70
		subq.w	#1,($FFFFF614).w

locret_E70:
		rts	
; ===========================================================================

loc_E72:				; XREF: off_B6E
		move.w	#$100,($A11100).l ; stop the Z80

loc_E7A:
		btst	#0,($A11100).l	; has Z80 stopped?
		bne.s	loc_E7A		; if not, branch
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_EB4
		writeCRAM	$FFFFFB00,$80,0
		bra.s	loc_ED8
; ===========================================================================

loc_EB4:				; XREF: loc_E7A
		writeCRAM	$FFFFFA80,$80,0

loc_ED8:				; XREF: loc_E7A
		move.w	($FFFFF624).w,(a5)
		lea	($C00004).l,a5

loc_EEE:
		writeVRAM	$FFFFE000,$380,$FC00
		writeVRAM	$FFFFF800,$280,$F800
		jsr	(ProcessDMAQueue).l

loc_F54:
		move.w	#0,($A11100).l	; start	the Z80
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w
		jsr	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_1642
		rts	
; ===========================================================================

loc_F8A:				; XREF: off_B6E
		bsr.w	sub_106E
		addq.b	#1,($FFFFF628).w
		move.b	#$E,($FFFFF62A).w
		rts	
; ===========================================================================

loc_F9A:				; XREF: off_B6E
		bsr.w	sub_106E
		move.w	($FFFFF624).w,(a5)
		bra.w	sub_1642
; ===========================================================================

loc_FA6:				; XREF: off_B6E
		move.w	#$100,($A11100).l ; stop the Z80

loc_FAE:
		btst	#0,($A11100).l	; has Z80 stopped?
		bne.s	loc_FAE		; if not, branch
		bsr.w	ReadJoypads
		writeCRAM	$FFFFFB00,$80,0
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		move.w	#0,($A11100).l	; start	the Z80
		jsr	(ProcessDMAQueue).l

loc_1060:
		cmpi.b	#96,($FFFFF625).w
		bcc.s	loc_1060update
		bra.w	locret_106C

loc_1060update:
		tst.w	($FFFFF614).w
		beq.w	locret_106C
		subq.w	#1,($FFFFF614).w

locret_106C:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_106E:				; XREF: loc_C32; et al
		move.w	#$100,($A11100).l ; stop the Z80

loc_1076:
		btst	#0,($A11100).l	; has Z80 stopped?
		bne.s	loc_1076	; if not, branch
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_10B0
		writeCRAM	$FFFFFB00,$80,0
		bra.s	loc_10D4
; ===========================================================================

loc_10B0:				; XREF: sub_106E
		writeCRAM	$FFFFFA80,$80,0
loc_10D4:				; XREF: sub_106E
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		move.w	#0,($A11100).l	; start	the Z80
		rts	
; End of function sub_106E

; ---------------------------------------------------------------------------
; Subroutine to	move pallets from the RAM to CRAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalToCRAM:
		move	#$2700,sr
		tst.w	($FFFFF644).w
		beq.s	HInt3_Done
		move.w	#0,($FFFFF644).w
		movem.l	d0-d1/a0-a2,-(sp)

		lea	($C00000).l,a1
		move.w	#$8AFF,4(a1)		; Reset HInt timing
		stopZ80
		movea.l	($FFFFF610).w,a2
		moveq	#$C,d0
HIntA:
		dbf	d0,HIntA	; waste a few cycles here

		move.w	(a2)+,d1
		move.b	($FFFFF60E).w,d0
		subi.b	#200,d0	; is H-int occuring below line 200?
		bcs.s	transferColors	; if it is, branch
		sub.b	d0,d1
		bcs.s	skipTransfer

transferColors:
		move.w	(a2)+,d0
		lea	($FFFFFA80).w,a0
		adda.w	d0,a0
		addi.w	#$C000,d0
		swap	d0
		move.l	d0,4(a1)	; write to CRAM at appropriate address
		move.l	(a0)+,(a1)	; transfer two colors
		move.w	(a0)+,(a1)	; transfer the third color
		nop
		nop
		moveq	#$24,d0

wasteSomeCycles:
		dbf	d0,wasteSomeCycles
		dbf	d1,transferColors	; repeat for number of colors

skipTransfer:
		startZ80
		movem.l	(sp)+,d0-d1/a0-a2
		tst.b	($FFFFF64F).w
		bne.s	loc_119E

HInt3_Done:
		rte
; ---------------------------------------------------------------------------
; ===========================================================================

loc_119E:				; XREF: PalToCRAM
		clr.b	($FFFFF64F).w
		movem.l	d0-a6,-(sp)
		bsr.w	Demo_Time
		nop			; The nop was placed here in order to make sure
					; that the same number of cycles was used.
					; not doing so could put things slightly out of sync.
 		movem.l	(sp)+,d0-a6
		rte	
; End of function PalToCRAM

; ---------------------------------------------------------------------------
; Subroutine to	initialise joypads
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


JoypadInit:				; XREF: GameClrRAM
		move.w	#$100,($A11100).l ; stop the Z80

Joypad_WaitZ80:
		btst	#0,($A11100).l	; has the Z80 stopped?
		bne.s	Joypad_WaitZ80	; if not, branch
		moveq	#$40,d0
		move.b	d0,($A10009).l	; init port 1 (joypad 1)
		move.b	d0,($A1000B).l	; init port 2 (joypad 2)
		move.b	d0,($A1000D).l	; init port 3 (extra)
		move.w	#0,($A11100).l	; start	the Z80
		rts	
; End of function JoypadInit

; ---------------------------------------------------------------------------
; Subroutine to	read joypad input, and send it to the RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ReadJoypads:
		lea	($FFFFF604).w,a0 ; address where joypad	states are written
		lea	($A10003).l,a1	; first	joypad port
		bsr.s	Joypad_Read	; do the first joypad
		addq.w	#2,a1		; do the second	joypad

Joypad_Read:
		move.b	#0,(a1)
		nop	
		nop	
		move.b	(a1),d0
		lsl.b	#2,d0
		andi.b	#$C0,d0
		move.b	#$40,(a1)
		nop	
		nop	
		move.b	(a1),d1
		andi.b	#$3F,d1
		or.b	d1,d0
		not.b	d0
		move.b	(a0),d1
		eor.b	d0,d1
		move.b	d0,(a0)+
		and.b	d0,d1
		move.b	d1,(a0)+
		rts	
; End of function ReadJoypads


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


VDPSetupGame:				; XREF: GameClrRAM; ChecksumError
		lea	($C00004).l,a0
		lea	($C00000).l,a1
		lea	(VDPSetupArray).l,a2
		moveq	#$12,d7

VDP_Loop:
		move.w	(a2)+,(a0)
		dbf	d7,VDP_Loop	; set the VDP registers

		move.w	(VDPSetupArray+2).l,d0
		move.w	d0,($FFFFF60C).w
		move.w	#$8ADF,($FFFFF624).w
		moveq	#0,d0
		move.l	#$C0000000,($C00004).l ; set VDP to CRAM write
		move.w	#$3F,d7

VDP_ClrCRAM:
		move.w	d0,(a1)
		dbf	d7,VDP_ClrCRAM	; clear	the CRAM

		clr.l	($FFFFF616).w
		clr.l	($FFFFF61A).w
		move.l	d1,-(sp)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$94FF93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000080,(a5)
		move.w	#0,($C00000).l	; clear	the screen

loc_128E:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_128E

		move.w	#$8F02,(a5)
		move.l	(sp)+,d1
		rts	
; End of function VDPSetupGame

; ===========================================================================
VDPSetupArray:	dc.w $8004, $8134, $8230, $8328	; XREF: VDPSetupGame
		dc.w $8407, $857C, $8600, $8700
		dc.w $8800, $8900, $8A00, $8B00
		dc.w $8C81, $8D3F, $8E00, $8F02
		dc.w $9001, $9100, $9200

; ---------------------------------------------------------------------------
; Subroutine to	clear the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearScreen:
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000083,(a5)
		move.w	#0,($C00000).l

loc_12E6:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_12E6

		move.w	#$8F02,(a5)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$60000083,(a5)
		move.w	#0,($C00000).l

loc_1314:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_1314

		move.w	#$8F02,(a5)
		move.l	#0,($FFFFF616).w
		move.l	#0,($FFFFF61A).w
		lea	($FFFFF800).w,a1
		moveq	#0,d0
		move.w	#$A0,d1

loc_133A:
		move.l	d0,(a1)+
		dbf	d1,loc_133A

		lea	($FFFFE000).w,a1
		moveq	#0,d0
		move.w	#$100,d1

loc_134A:
		move.l	d0,(a1)+
		dbf	d1,loc_134A
		rts	
; End of function ClearScreen

; ---------------------------------------------------------------------------
; Subroutine to	load the sound driver
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

SoundDriverLoad:					; XREF: GameClrRAM;	TitleScreen
		nop
		move.w	#$100,($A11100).l	; Z80 bus request - Start
		move.w	#$100,($A11200).l	; Z80 stop reset
		lea	(Driver_Data).l,a0
		lea	($A00000).l,a1
		move.w	#Driver_Data_End-Driver_Data,d0

DriverLoadLoop:
		move.b	(a0)+,(a1)+
		dbf	d0,DriverLoadLoop
		lea	(Driver_Pointers).l,a0
		lea	($A01300).l,a1
		move.w	#Driver_Pointers_End-Driver_Pointers,d0

DriverPointersLoadLoop:
		move.b	(a0)+,(a1)+
		dbf	d0,	DriverPointersLoadLoop
		lea	(UniversalVoices).l,a0
		lea	($A017D8).l,a1
		move.w	#UniversalVoices_End-UniversalVoices,d0

UniversalVoiceBankLoadLoop:
		move.b	(a0)+,(a1)+
		dbf	d0,UniversalVoiceBankLoadLoop
		lea	(DriverResetData).l,a0
		lea	($A01C00).l,a1
		move.w	#DriverResetDataEnd-DriverResetData,d0

DriverResetDataLoadLoop:
		move.b	(a0)+,(a1)+
		dbf	d0,DriverResetDataLoadLoop
		btst	#6,($FFFFFFF8).w
		beq.s	DriverAlreadyInitialized
		move.b	#1,($A01C02).l

DriverAlreadyInitialized:
		move.w	#0,($A11200).l
		nop
		nop
		nop
		nop
		move.w	#$100,($A11200).l	; Z80 start reset
		move.w	#0,($A11100).l		; Z80 bus request - Stop
		rts
; End of function SoundDriverLoad


DriverResetData:
		dc.b	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DriverResetDataEnd:

; ---------------------------------------------------------------------------
; Subroutine to	play a sound or	music track
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlaySound:
		cmpi.w	#$FB,d0
		blt.s	PlayNotSpecialFlag
		bhi.s	TestForNormalSpeed
		move	#8,d0
		jmp	SetTempo

TestForNormalSpeed:
		cmpi.w	#$FC,d0
		bne.s	PlayNotSpecialFlag
		clr.w	d0
		jmp	SetTempo

PlayNotSpecialFlag:
		move.w	#$100,($A11100).l

PlaySoundZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	PlaySoundZ80NotStopped	; loop until it says it's stopped
		move.b	d0,($A01C0A).l
		move.w	#0,($A11100).l
		rts
; End of function PlaySound

; ---------------------------------------------------------------------------
; Exclusive sound/music subroutine
; ---------------------------------------------------------------------------


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||



PlaySound_Ex:
		tst.b	4(A0)
		bpl.s	SkipPlaySound_Special

; ---------------------------------------------------------------------------
; Unused sound/music subroutine
; ---------------------------------------------------------------------------

PlaySound_Unk:
		nop
; ---------------------------------------------------------------------------
; Subroutine to	play a special sound/music (FB-FF)
; ---------------------------------------------------------------------------

PlaySound_Special:
		move.w	#$100,($A11100).l

PlaySound_SpeciaTJZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	PlaySound_SpeciaTJZ80NotStopped
		cmp.b	($A01C0B).l,d0
		beq.s	PlaySound_Special1
		tst.b	($A01C0B).l
		bne.s	PlaySound_Special0
		move.b	d0,($A01C0B).l
		move.w	#0,($A11100).l
		rts

PlaySound_Special0:
		move.b	d0,($A01C0C).l

PlaySound_Special1:
		move.w	#0,($A11100).l

SkipPlaySound_Special:
		rts
; End of function PlaySound_Special

; ---------------------------------------------------------------------------
; Subroutine to change the music tempo
; ---------------------------------------------------------------------------

SetTempo:
		move.w	#$100,($A11100).l

SetTempoZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	SetTempoZ80NotStopped
		move.b	D0,($A01C08).l
		move.w	#0,($A11100).l
		rts

; ---------------------------------------------------------------------------
; Subroutine to	pause the game
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PauseGame:				; XREF: Level_MainLoop; et al
		nop
		tst.b	($FFFFFE12).w ; do you have any lives left
		beq	Unpause           ; if not, branch
		tst.w	($FFFFF63A).w ;is the game already paused?
		bne.s	PauseGame_AlreadyPaused ;if yes, branch
		move.b	($FFFFF605).w,d0 ;did you press start
		or.b	($FFFFF607).w,d0         ;on either controller?
		andi.b	#$80,d0
		beq	Pause_DoNothing         ;if not, branch

PauseGame_AlreadyPaused:	
		move.w	#1,($FFFFF63A).w ;unpause the game
		move.w	#$100,($A11100).l  ;stop the z80

PauseGameZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	PauseGameZ80NotStopped
		move.b	#1,($A01C10).l ;unpause the music ;)
		move.w	#0,($A11100).l ;start the z80

PauseGameLoop:
		move.b	#$10,($FFFFF62A).w ;re-pause the game (used in slow-mo and frame advance)
		jsr	DelayProgram ;wait...
		btst	#6,($FFFFF605).w ;is player 1 pressing either A?
		beq.s	Pause_ChkBC ;if not, branch
		move.b	#$4,($FFFFF600).w ; Go To Title Screen
		nop
		bra.s	PauseGame1 ;time to stop the z80 again

Pause_ChkBC:
		btst	#4,($FFFFF604).w ;did you press a?
		bne.s	Pause_SlowMo ;if so, branch
		btst	#5,($FFFFF605).w ;did you press b?
		bne.s	Pause_SlowMo ;if so, branch

PauseGame0:
		move.b	($FFFFF605).w,d0  ;on controller 1?
		or.b	($FFFFF607).w,d0          ;or 2?
		andi.b	#$80,d0                 ;if not, no change
		beq.s	PauseGameLoop   ;in other words, don't pause

PauseGame1:
		move.w	#$100,($A11100).l  ;stop the z80

Pause_ChkStartZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	Pause_ChkStartZ80NotStopped
		move.b	#$80,($A01C10).l ;pause the music
		move.w	#0,($A11100).l     ;start the z80

Unpause:
		move.w	#0,($FFFFF63A).w ;unpause the game

Pause_DoNothing:
		rts

Pause_SlowMo:
		move.w	#1,($FFFFF63A).w ;unpause the music for a frame
		move.w	#$100,($A11100).l  ;stop the z80

Pause_SlowMoZ80NotStopped:
		btst	#0,($A11100).l
		bne.s	Pause_SlowMoZ80NotStopped
		move.b	#$80,($A01C10).l ;pause the music again
		move.w	#0,($A11100).l ;start the z80
		rts
; End of function PauseGame

; ---------------------------------------------------------------------------
; Subroutine to	display	patterns via the VDP
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowVDPGraphics:			; XREF: SegaScreen; TitleScreen; SS_BGLoad
		lea	($C00000).l,a6
		move.l	#$800000,d4

loc_142C:
		move.l	d0,4(a6)
		move.w	d1,d3

loc_1432:
		move.w	(a1)+,(a6)
		dbf	d3,loc_1432
		add.l	d4,d0
		dbf	d2,loc_142C
		rts	
; End of function ShowVDPGraphics

; ---------------------------------------------------------------------------
; Subroutine for queueing VDP commands (seems to only queue transfers to VRAM),
; to be issued the next time ProcessDMAQueue is called.
; Can be called a maximum of 18 times before the buffer needs to be cleared
; by issuing the commands (this subroutine DOES check for overflow)
; ---------------------------------------------------------------------------
; In case you wish to use this queue system outside of the spin dash, this is the
; registers in which it expects data in:
; d1.l: Address to data (In 68k address space)
; d2.w: Destination in VRAM
; d3.w: Length of data
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
 
; sub_144E: DMA_68KtoVRAM: QueueCopyToVRAM: QueueVDPCommand: Add_To_DMA_Queue:
QueueDMATransfer:
		movea.l	($FFFFDCFC).w,a1
		cmpa.w	#-$2304,a1
		beq.s	QueueDMATransfer_Done
		move.w	#-$6D00,d0
		move.b	d3,d0
		move.w	d0,(a1)+
		move.w	#-$6C00,d0
		lsr.w	#8,d3
		move.b	d3,d0
		move.w	d0,(a1)+
		move.w	#-$6B00,d0
		lsr.l	#1,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		move.w	#-$6A00,d0
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		move.w	#-$6900,d0
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		andi.l	#$FFFF,d2
		lsl.l	#2,d2
		lsr.w	#2,d2
		swap	d2
		ori.l	#$40000080,d2
		move.l	d2,(a1)+
		move.l	a1,($FFFFDCFC).w
		cmpa.w	#-$2304,a1
		beq.s	QueueDMATransfer_Done
		move.w	#0,(a1)
; return_14AA:
QueueDMATransfer_Done:
		rts
; End of function QueueDMATransfer
 
 
; ---------------------------------------------------------------------------
; Subroutine for issuing all VDP commands that were queued
; (by earlier calls to QueueDMATransfer)
; Resets the queue when it's done
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
 
; sub_14AC: CopyToVRAM: IssueVDPCommands: Process_DMA: Process_DMA_Queue:
ProcessDMAQueue:
		lea	($C00004).l,a5
		lea	($FFFFDC00).w,a1
; loc_14B6:
ProcessDMAQueue_Loop:
		move.w	(a1)+,d0
		beq.s	ProcessDMAQueue_Done ; branch if we reached a stop token
		; issue a set of VDP commands...
		move.w	d0,(a5)		; transfer length
		move.w	(a1)+,(a5)	; transfer length
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; destination
		move.w	(a1)+,(a5)	; destination
		cmpa.w	#-$2304,a1
		bne.s	ProcessDMAQueue_Loop ; loop if we haven't reached the end of the buffer
; loc_14CE:
ProcessDMAQueue_Done:
		move.w	#0,($FFFFDC00).w
		move.l	#-$2400,($FFFFDCFC).w
		rts
; End of function ProcessDMAQueue

; ==============================================================================
; ------------------------------------------------------------------------------
; Nemesis decompression routine
; ------------------------------------------------------------------------------
; Optimized by vladikcomper
; ------------------------------------------------------------------------------
 
NemDec_RAM:
        movem.l d0-a1/a3-a6,-(sp)
        lea     NemDec_WriteRowToRAM(pc),a3
        bra.s   NemDec_Main
 
; ------------------------------------------------------------------------------
NemDec:
        movem.l d0-a1/a3-a6,-(sp)
        lea     $C00000,a4              ; load VDP Data Port    
        lea     NemDec_WriteRowToVDP(pc),a3
 
NemDec_Main:
        lea     $FFFFAA00,a1            ; load Nemesis decompression buffer
        move.w  (a0)+,d2                ; get number of patterns
        bpl.s   @0                      ; are we in Mode 0?
        lea     $A(a3),a3               ; if not, use Mode 1
@0      lsl.w   #3,d2
        movea.w d2,a5
        moveq   #7,d3
        moveq   #0,d2
        moveq   #0,d4
        bsr.w   NemDec4
        move.b  (a0)+,d5                ; get first byte of compressed data
        asl.w   #8,d5                   ; shift up by a byte
        move.b  (a0)+,d5                ; get second byte of compressed data
        move.w  #$10,d6                 ; set initial shift value
        bsr.s   NemDec2
        movem.l (sp)+,d0-a1/a3-a6
        rts
 
; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, processes the actual compressed data
; ---------------------------------------------------------------------------
 
NemDec2:
        move.w  d6,d7
        subq.w  #8,d7                   ; get shift value
        move.w  d5,d1
        lsr.w   d7,d1                   ; shift so that high bit of the code is in bit position 7
        cmpi.b  #%11111100,d1           ; are the high 6 bits set?
        bcc.s   NemDec_InlineData       ; if they are, it signifies inline data
        andi.w  #$FF,d1
        add.w   d1,d1
        sub.b   (a1,d1.w),d6            ; ~~ subtract from shift value so that the next code is read next time around
        cmpi.w  #9,d6                   ; does a new byte need to be read?
        bcc.s   @0                      ; if not, branch
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5                ; read next byte
@0      move.b  1(a1,d1.w),d1
        move.w  d1,d0
        andi.w  #$F,d1                  ; get palette index for pixel
        andi.w  #$F0,d0
 
NemDec_GetRepeatCount:
        lsr.w   #4,d0                   ; get repeat count
 
NemDec_WritePixel:
        lsl.l   #4,d4                   ; shift up by a nybble
        or.b    d1,d4                   ; write pixel
        dbf     d3,NemDec_WritePixelLoop; ~~
        jmp     (a3)                    ; otherwise, write the row to its destination
; ---------------------------------------------------------------------------
 
NemDec3:
        moveq   #0,d4                   ; reset row
        moveq   #7,d3                   ; reset nybble counter
 
NemDec_WritePixelLoop:
        dbf     d0,NemDec_WritePixel
        bra.s   NemDec2
; ---------------------------------------------------------------------------
 
NemDec_InlineData:
        subq.w  #6,d6                   ; 6 bits needed to signal inline data
        cmpi.w  #9,d6
        bcc.s   @0
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5
@0      subq.w  #7,d6                   ; and 7 bits needed for the inline data itself
        move.w  d5,d1
        lsr.w   d6,d1                   ; shift so that low bit of the code is in bit position 0
        move.w  d1,d0
        andi.w  #$F,d1                  ; get palette index for pixel
        andi.w  #$70,d0                 ; high nybble is repeat count for pixel
        cmpi.w  #9,d6
        bcc.s   NemDec_GetRepeatCount
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5
        bra.s   NemDec_GetRepeatCount
 
; ---------------------------------------------------------------------------
; Subroutines to output decompressed entry
; Selected depending on current decompression mode
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToVDP:
loc_1502:
        move.l  d4,(a4)                 ; write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4                   ; have all the 8-pixel rows been written?
        bne.s   NemDec3                 ; if not, branch
        rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToVDP_XOR:
        eor.l   d4,d2                   ; XOR the previous row by the current row
        move.l  d2,(a4)                 ; and write the result
        subq.w  #1,a5
        move.w  a5,d4
        bne.s   NemDec3
        rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToRAM:
        move.l  d4,(a4)+                ; write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4                   ; have all the 8-pixel rows been written?
        bne.s   NemDec3                 ; if not, branch
        rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToRAM_XOR:
        eor.l   d4,d2                   ; XOR the previous row by the current row
        move.l  d2,(a4)+                ; and write the result
        subq.w  #1,a5
        move.w  a5,d4
        bne.s   NemDec3
        rts
 
; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, builds the code table (in RAM)
; ---------------------------------------------------------------------------
 
NemDec4:
        move.b  (a0)+,d0                ; read first byte
 
@ChkEnd:
        cmpi.b  #$FF,d0                 ; has the end of the code table description been reached?
        bne.s   @NewPalIndex            ; if not, branch
        rts
; ---------------------------------------------------------------------------
 
@NewPalIndex:
        move.w  d0,d7
 
@ItemLoop:
        move.b  (a0)+,d0                ; read next byte
        bmi.s   @ChkEnd                 ; ~~
        move.b  d0,d1
        andi.w  #$F,d7                  ; get palette index
        andi.w  #$70,d1                 ; get repeat count for palette index
        or.w    d1,d7                   ; combine the two
        andi.w  #$F,d0                  ; get the length of the code in bits
        move.b  d0,d1
        lsl.w   #8,d1
        or.w    d1,d7                   ; combine with palette index and repeat count to form code table entry
        moveq   #8,d1
        sub.w   d0,d1                   ; is the code 8 bits long?
        bne.s   @ItemShortCode          ; if not, a bit of extra processing is needed
        move.b  (a0)+,d0                ; get code
        add.w   d0,d0                   ; each code gets a word-sized entry in the table
        move.w  d7,(a1,d0.w)            ; store the entry for the code
        bra.s   @ItemLoop               ; repeat
; ---------------------------------------------------------------------------
 
@ItemShortCode:
        move.b  (a0)+,d0                ; get code
        lsl.w   d1,d0                   ; shift so that high bit is in bit position 7
        add.w   d0,d0                   ; get index into code table
        moveq   #1,d5
        lsl.w   d1,d5
        subq.w  #1,d5                   ; d5 = 2^d1 - 1
        lea     (a1,d0.w),a6            ; ~~
 
@ItemShortCodeLoop:
        move.w  d7,(a6)+                ; ~~ store entry
        dbf     d5,@ItemShortCodeLoop   ; repeat for required number of entries
        bra.s   @ItemLoop

; ---------------------------------------------------------------------------
; Subroutine to load the art for the animals for the current zone
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadAnimalPLC:
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		cmpi.w	#7,d0
		bhs.s	LoadAnimalPLC_New
		addi.w	#$15,d0
		bra.s	LoadPLC
; ---------------------------------------------------------------------------

LoadAnimalPLC_New:
		subi.w	#7,d0
		; multiply d0 by 3
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		; add $22 (this is the index of the animal PLC for the first added zone)
		addi.w	#$20,d0
		; bra.s	LoadPLC
; End of function LoadAnimalPLC

; ---------------------------------------------------------------------------
; Subroutine to	load pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		lea	($FFFFF680).w,a2

loc_1598:
		tst.l	(a2)
		beq.s	loc_15A0
		addq.w	#6,a2
		bra.s	loc_1598
; ===========================================================================

loc_15A0:				; XREF: LoadPLC
		move.w	(a1)+,d0
		bmi.s	loc_15AC

loc_15A4:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15A4

loc_15AC:
		movem.l	(sp)+,a1-a2
		rts	
; End of function LoadPLC


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC2:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		bsr.s	ClearPLC
		lea	($FFFFF680).w,a2
		move.w	(a1)+,d0
		bmi.s	loc_15D8

loc_15D0:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15D0

loc_15D8:
		movem.l	(sp)+,a1-a2
		rts	
; End of function LoadPLC2

; ---------------------------------------------------------------------------
; Subroutine to	clear the pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearPLC:				; XREF: LoadPLC2
		lea	($FFFFF680).w,a2
		moveq	#$1F,d0

ClearPLC_Loop:
		clr.l	(a2)+
		dbf	d0,ClearPLC_Loop
		rts	
; End of function ClearPLC

; ---------------------------------------------------------------------------
; Subroutine to	use graphics listed in a pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_RAM:				; XREF: Pal_FadeTo
		tst.l	($FFFFF680).w
		beq.s	locret_1640
		tst.w	($FFFFF6F8).w
		bne.s	locret_1640
		movea.l	($FFFFF680).w,a0
		lea	(loc_1502).l,a3
		lea	($FFFFAA00).w,a1
		move.w	(a0)+,d2
		bpl.s	loc_160E
		adda.w	#$A,a3

loc_160E:
		andi.w	#$7FFF,d2
		move.w	d2,($FFFFF6F8).w
		bsr.w	NemDec4
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5
		moveq	#$10,d6
		moveq	#0,d0
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d0,($FFFFF6E8).w
		move.l	d0,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w

locret_1640:
		rts	
; End of function RunPLC_RAM


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1642:				; XREF: loc_C44; loc_F54; loc_F9A
		tst.w	($FFFFF6F8).w
		beq.w	locret_16DA
		move.w	#9,($FFFFF6FA).w
		moveq	#0,d0
		move.w	($FFFFF684).w,d0
		addi.w	#$120,($FFFFF684).w
		bra.s	loc_1676
; End of function sub_1642


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_165E:				; XREF: Demo_Time
		tst.w	($FFFFF6F8).w
		beq.s	locret_16DA
		move.w	#3,($FFFFF6FA).w
		moveq	#0,d0
		move.w	($FFFFF684).w,d0
		addi.w	#$60,($FFFFF684).w

loc_1676:				; XREF: sub_1642
		lea	($C00004).l,a4
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,(a4)
		subq.w	#4,a4
		movea.l	($FFFFF680).w,a0
		movea.l	($FFFFF6E0).w,a3
		move.l	($FFFFF6E4).w,d0
		move.l	($FFFFF6E8).w,d1
		move.l	($FFFFF6EC).w,d2
		move.l	($FFFFF6F0).w,d5
		move.l	($FFFFF6F4).w,d6
		lea	($FFFFAA00).w,a1

loc_16AA:				; XREF: sub_165E
		movea.w	#8,a5
		bsr.w	NemDec3
		subq.w	#1,($FFFFF6F8).w
		beq.s	loc_16DC
		subq.w	#1,($FFFFF6FA).w
		bne.s	loc_16AA
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d1,($FFFFF6E8).w
		move.l	d2,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w

locret_16DA:				; XREF: sub_1642
		rts	
; ===========================================================================

loc_16DC:			; XREF: sub_165E
		lea	($FFFFF680).w,a0
		lea	6(a0),a1
		moveq	#$E,d0		; do $F cues

loc_16E2:				; XREF: sub_165E
		move.l	(a1)+,(a0)+
		move.w	(a1)+,(a0)+
		dbf	d0,loc_16E2

		moveq	#0,d0
		move.l	d0,(a0)+	; clear the last cue to avoid overcopying it
		move.w	d0,(a0)+	;
		rts

; End of function sub_165E

; ---------------------------------------------------------------------------
; Subroutine to	execute	the pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_ROM:
		lea	(ArtLoadCues).l,a1 ; load the PLC index
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		move.w	(a1)+,d1	; load number of entries in the	PLC

RunPLC_Loop:
		movea.l	(a1)+,a0	; get art pointer
		moveq	#0,d0
		move.w	(a1)+,d0	; get VRAM address
		lsl.l	#2,d0		; divide address by $20
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,($C00004).l	; put the VRAM address into VDP
		bsr.w	NemDec		; decompress
		dbf	d1,RunPLC_Loop	; loop for number of entries
		rts	
; End of function RunPLC_ROM

; ---------------------------------------------------------------------------
; Enigma decompression algorithm
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


EniDec:
		movem.l	d0-d7/a1-a5,-(sp)
		movea.w	d0,a3
		move.b	(a0)+,d0
		ext.w	d0
		movea.w	d0,a5
		move.b	(a0)+,d4
		lsl.b	#3,d4
		movea.w	(a0)+,a2
		adda.w	a3,a2
		movea.w	(a0)+,a4
		adda.w	a3,a4
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5
		moveq	#$10,d6

loc_173E:				; XREF: loc_1768
		moveq	#7,d0
		move.w	d6,d7
		sub.w	d0,d7
		move.w	d5,d1
		lsr.w	d7,d1
		andi.w	#$7F,d1
		move.w	d1,d2
		cmpi.w	#$40,d1
		bcc.s	loc_1758
		moveq	#6,d0
		lsr.w	#1,d2

loc_1758:
		bsr.w	sub_188C
		andi.w	#$F,d2
		lsr.w	#4,d1
		add.w	d1,d1
		jmp	loc_17B4(pc,d1.w)
; End of function EniDec

; ===========================================================================

loc_1768:				; XREF: loc_17B4
		move.w	a2,(a1)+
		addq.w	#1,a2
		dbf	d2,loc_1768
		bra.s	loc_173E
; ===========================================================================

loc_1772:				; XREF: loc_17B4
		move.w	a4,(a1)+
		dbf	d2,loc_1772
		bra.s	loc_173E
; ===========================================================================

loc_177A:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_177E:
		move.w	d1,(a1)+
		dbf	d2,loc_177E
		bra.s	loc_173E
; ===========================================================================

loc_1786:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_178A:
		move.w	d1,(a1)+
		addq.w	#1,d1
		dbf	d2,loc_178A
		bra.s	loc_173E
; ===========================================================================

loc_1794:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_1798:
		move.w	d1,(a1)+
		subq.w	#1,d1
		dbf	d2,loc_1798
		bra.s	loc_173E
; ===========================================================================

loc_17A2:				; XREF: loc_17B4
		cmpi.w	#$F,d2
		beq.s	loc_17C4

loc_17A8:
		bsr.w	loc_17DC
		move.w	d1,(a1)+
		dbf	d2,loc_17A8
		bra.s	loc_173E
; ===========================================================================

loc_17B4:				; XREF: EniDec
		bra.s	loc_1768
; ===========================================================================
		bra.s	loc_1768
; ===========================================================================
		bra.s	loc_1772
; ===========================================================================
		bra.s	loc_1772
; ===========================================================================
		bra.s	loc_177A
; ===========================================================================
		bra.s	loc_1786
; ===========================================================================
		bra.s	loc_1794
; ===========================================================================
		bra.s	loc_17A2
; ===========================================================================

loc_17C4:				; XREF: loc_17A2
		subq.w	#1,a0
		cmpi.w	#$10,d6
		bne.s	loc_17CE
		subq.w	#1,a0

loc_17CE:
		move.w	a0,d0
		lsr.w	#1,d0
		bcc.s	loc_17D6
		addq.w	#1,a0

loc_17D6:
		movem.l	(sp)+,d0-d7/a1-a5
		rts	
; ===========================================================================

loc_17DC:				; XREF: loc_17A2
		move.w	a3,d3
		move.b	d4,d1
		add.b	d1,d1
		bcc.s	loc_17EE
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_17EE
		ori.w	#-$8000,d3

loc_17EE:
		add.b	d1,d1
		bcc.s	loc_17FC
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_17FC
		addi.w	#$4000,d3

loc_17FC:
		add.b	d1,d1
		bcc.s	loc_180A
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_180A
		addi.w	#$2000,d3

loc_180A:
		add.b	d1,d1
		bcc.s	loc_1818
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_1818
		ori.w	#$1000,d3

loc_1818:
		add.b	d1,d1
		bcc.s	loc_1826
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_1826
		ori.w	#$800,d3

loc_1826:
		move.w	d5,d1
		move.w	d6,d7
		sub.w	a5,d7
		bcc.s	loc_1856
		move.w	d7,d6
		addi.w	#$10,d6
		neg.w	d7
		lsl.w	d7,d1
		move.b	(a0),d5
		rol.b	d7,d5
		add.w	d7,d7
		and.w	word_186C-2(pc,d7.w),d5
		add.w	d5,d1

loc_1844:				; XREF: loc_1868
		move.w	a5,d0
		add.w	d0,d0
		and.w	word_186C-2(pc,d0.w),d1
		add.w	d3,d1
		move.b	(a0)+,d5
		lsl.w	#8,d5
		move.b	(a0)+,d5
		rts	
; ===========================================================================

loc_1856:				; XREF: loc_1826
		beq.s	loc_1868
		lsr.w	d7,d1
		move.w	a5,d0
		add.w	d0,d0
		and.w	word_186C-2(pc,d0.w),d1
		add.w	d3,d1
		move.w	a5,d0
		bra.s	sub_188C
; ===========================================================================

loc_1868:				; XREF: loc_1856
		moveq	#$10,d6

loc_186A:
		bra.s	loc_1844
; ===========================================================================
word_186C:	dc.w 1,	3, 7, $F, $1F, $3F, $7F, $FF, $1FF, $3FF, $7FF
		dc.w $FFF, $1FFF, $3FFF, $7FFF,	$FFFF	; XREF: loc_1856

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_188C:				; XREF: EniDec
		sub.w	d0,d6
		cmpi.w	#9,d6
		bcc.s	locret_189A
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5

locret_189A:
		rts	
; End of function sub_188C

; ===========================================================================
; ---------------------------------------------------------------------------
; Kosinski decompression routine
;
; Created by vladikcomper
; Special thanks to flamewing and MarkeyJester
; ---------------------------------------------------------------------------

KosDec:
        moveq   #7,d7
        moveq   #0,d0
        moveq   #0,d1
        lea     KosDec_ByteMap(pc),a4
        move.b  (a0)+,d0                        ; get desc field low-byte
        move.b  (a0)+,d1                        ; get desc field hi-byte
        move.b  (a4,d0.w),d0                    ; reload converted desc. bitfield from a LUT
        move.b  (a4,d1.w),d1                    ;
        moveq   #7,d2                           ; set repeat count to 8
        moveq   #-1,d3                          ; d3 will be desc field switcher
        clr.w   d3                              ;
        bra.s   KosDec_FetchNewCode
 
KosDec_FetchCodeLoop:
        ; code 1 (Uncompressed byte)
        _Kos_RunBitStream
        move.b  (a0)+,(a1)+
 
KosDec_FetchNewCode:
        add.b   d0,d0                           ; get a bit from the bitstream
        bcs.s   KosDec_FetchCodeLoop            ; if code = 0, branch
 
        ; codes 00 and 01
        _Kos_RunBitStream
        moveq   #0,d4                           ; d4 will contain copy count
        add.b   d0,d0                           ; get a bit from the bitstream
        bcs.s   KosDec_Code_01
 
        ; code 00 (Dictionary ref. short)
        _Kos_RunBitStream
        add.b   d0,d0                           ; get a bit from the bitstream
        addx.w  d4,d4
        _Kos_RunBitStream
        add.b   d0,d0                           ; get a bit from the bitstream
        addx.w  d4,d4
        _Kos_RunBitStream
        moveq   #-1,d5
        move.b  (a0)+,d5                        ; d5 = displacement
 
KosDec_StreamCopy:
        lea     (a1,d5),a3
        move.b  (a3)+,(a1)+                     ; do 1 extra copy (to compensate for +1 to copy counter)
 
KosDec_copy:
        move.b  (a3)+,(a1)+
        dbf     d4,KosDec_copy
        bra.w   KosDec_FetchNewCode
; ---------------------------------------------------------------------------
KosDec_Code_01:
        ; code 01 (Dictionary ref. long / special)
        _Kos_RunBitStream
        move.b  (a0)+,d6                        ; d6 = %LLLLLLLL
        move.b  (a0)+,d4                        ; d4 = %HHHHHCCC
        moveq   #-1,d5
        move.b  d4,d5                           ; d5 = %11111111 HHHHHCCC
        lsl.w   #5,d5                           ; d5 = %111HHHHH CCC00000
        move.b  d6,d5                           ; d5 = %111HHHHH LLLLLLLL
        and.w   d7,d4                           ; d4 = %00000CCC
        bne.s   KosDec_StreamCopy               ; if CCC=0, branch
 
        ; special mode (extended counter)
        move.b  (a0)+,d4                        ; read cnt
        beq.s   KosDec_Quit                     ; if cnt=0, quit decompression
        subq.b  #1,d4
        beq.w   KosDec_FetchNewCode             ; if cnt=1, fetch a new code
 
        lea     (a1,d5),a3
        move.b  (a3)+,(a1)+                     ; do 1 extra copy (to compensate for +1 to copy counter)
        move.w  d4,d6
        not.w   d6
        and.w   d7,d6
        add.w   d6,d6
        lsr.w   #3,d4
        jmp     KosDec_largecopy(pc,d6.w)
 
KosDec_largecopy:
        rept 8
        move.b  (a3)+,(a1)+
        endr
        dbf     d4,KosDec_largecopy
        bra.w   KosDec_FetchNewCode
 
KosDec_Quit:
        rts
 
; ---------------------------------------------------------------------------
; A look-up table to invert bits order in desc. field bytes
; ---------------------------------------------------------------------------
 
KosDec_ByteMap:
        dc.b    $00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
        dc.b    $08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
        dc.b    $04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
        dc.b    $0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
        dc.b    $02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
        dc.b    $0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
        dc.b    $06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
        dc.b    $0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
        dc.b    $01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
        dc.b    $09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
        dc.b    $05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
        dc.b    $0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
        dc.b    $03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
        dc.b    $0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
        dc.b    $07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
        dc.b    $0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF

; ===============================================================
; ---------------------------------------------------------------
; COMPER Decompressor
; ---------------------------------------------------------------
; INPUT:
;	a0	- Source Offset
;	a1	- Destination Offset
; ---------------------------------------------------------------

CompDec

@newblock
	move.w	(a0)+,d0		; fetch description field
	moveq	#15,d3			; set bits counter to 16

@mainloop
	add.w	d0,d0			; roll description field
	bcs.s	@flag			; if a flag issued, branch
	move.w	(a0)+,(a1)+		; otherwise, do uncompressed data
	dbf	d3,@mainloop		; if bits counter remains, parse the next word
	bra.s	@newblock		; start a new block

; ---------------------------------------------------------------
@flag	moveq	#-1,d1			; init displacement
	move.b	(a0)+,d1		; load displacement
	add.w	d1,d1
	moveq	#0,d2			; init copy count
	move.b	(a0)+,d2		; load copy length
	beq.s	@end			; if zero, branch
	lea	(a1,d1),a2		; load start copy address

@loop	move.w	(a2)+,(a1)+		; copy given sequence
	dbf	d2,@loop		; repeat
	dbf	d3,@mainloop		; if bits counter remains, parse the next word
	bra.s	@newblock		; start a new block

@end	rts

; ---------------------------------------------------------------------------
; Pallet cycling routine loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Load:				; XREF: Demo; Level_MainLoop; End_MainLoop
		moveq	#0,d2
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0 ; get level number
		add.w	d0,d0		; multiply by 2
		move.w	PalCycle(pc,d0.w),d0 ; load animated pallets offset index into d0
		jmp	PalCycle(pc,d0.w) ; jump to PalCycle + offset index
; End of function PalCycle_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet cycling routines
; ---------------------------------------------------------------------------
PalCycle:	dc.w PalCycle_WOZ-PalCycle
		dc.w PalCycle_TJZ-PalCycle
		dc.w PalCycle_DDZ-PalCycle
		dc.w PalCycle_KVZ-PalCycle
		dc.w PalCycle_CCZ-PalCycle
		dc.w PalCycle_ABZ-PalCycle
		dc.w PalCycle_WOZ-PalCycle
		dc.w PalCycle_SSZ-PalCycle
		dc.w PalCycle_WAZ-PalCycle
		dc.w PalCycle_FCZ-PalCycle
		dc.w PalCycle_RTZ-PalCycle
		dc.w PalCycle_SZ-PalCycle

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Title:				; XREF: TitleScreen
		rts	
; End of function PalCycle_Title

; ===========================================================================

PalCycle_WOZ:				; XREF: PalCycle
		lea	(Pal_WOZCyc).l,a0

loc_196A:				; XREF: PalCycle_Title
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1990
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB42).w,a1
		lea	($FFFFFAC2).w,a2
		move.l	(a0,d0.w),(a1)+
		move.l	(a0,d0.w),(a2)+
		move.l	4(a0,d0.w),(a1)
		move.l	4(a0,d0.w),(a2)

locret_1990:
		rts	
; End of function PalCycle_WOZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_TJZ:				; XREF: PalCycle
		lea	(Pal_WOZCyc).l,a0
		subq.w	#1,($FFFFF634).w
		bpl.s	PalCycle_TJZ2
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB44).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

PalCycle_TJZ2:
		rts	

PalCycle_DDZ:				; XREF: PalCycle
		lea	(Pal_DDZCyc).l,a0

loc2_196A:				; XREF: PalCycle_Title
		subq.w	#1,($FFFFF634).w
		bpl.s	locret2_1990
		move.w	#3,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB78).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

locret2_1990:
		rts	

PalCycle_KVZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	locret7_1990
		move.w	#5,($FFFFF634).w
		lea	(Pal_KVZCyc).l,a0
		move.w	($FFFFF632).w,d0
		subq.w	#2,($FFFFF632).w
		tst.w	($FFFFF632).w
		bgt.s	@KVZ
		move.w	#6,($FFFFF632).w

@KVZ:
		lea	($FFFFFB42).w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	4(a0,d0.w),(a1)

locret7_1990:
		rts	

PalCycle_CCZ:				; XREF: PalCycle
		lea	(Pal_CCZCyc).l,a0
		subq.w	#1,($FFFFF634).w
		bpl.s	CCZCyc_Return
		move.w	#0,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#$F,d0
		move.b	PalCycle_HTZ_LavaDelayData(pc,d0.w),($FFFFF635).w
		lsl.w	#3,d0
		move.l	(a0,d0.w),($FFFFFB66).w
		move.l	4(a0,d0.w),($FFFFFB7C).w

CCZCyc_Return:	
		rts

; ===========================================================================
; byte_1B40:
PalCycle_HTZ_LavaDelayData: ; number of frames between changes of the lava palette
	dc.b	$B, $B, $B, $A
	dc.b	 8, $A, $B, $B
	dc.b	$B, $B, $D, $F
	dc.b	$D, $B, $B, $B
; ===========================================================================

PalCycle_ABZ:				; XREF: PalCycle
		lea	(Pal_WOZCyc).l,a0
		subq.w	#1,($FFFFF634).w
		bpl.s	locret3_1990
		move.w	#3,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		subq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB44).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		lea	($FFFFFAC4).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

locret3_1990:
		rts	
; End of function PalCycle_ABZ

PalCycle_SSZ:
		rts

PalCycle_WAZ:
		rts

PalCycle_FCZ:
		rts

PalCycle_RTZ:
		rts

PalCycle_SZ:
		rts

; ===========================================================================
Pal_WOZCyc:	incbin	pallet\c_WOZ.bin
Pal_DDZCyc:	incbin	pallet\c_DDZ.bin
Pal_CCZCyc:	incbin	pallet\c_CCZ.bin
Pal_KVZCyc:	incbin	pallet\c_KVZ.bin

; ---------------------------------------------------------------------------
; Subroutine to	fade out and fade in
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeTo:
		move.w	#$3F,($FFFFF626).w
 
Pal_FadeTo2:
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		moveq	#0,d1
		move.b	($FFFFF627).w,d0
 
Pal_ToBlack:
		move.w	d1,(a0)+
		dbf	d0,Pal_ToBlack	; fill pallet with $000	(black)
		moveq	#$0E,d4					; MJ: prepare maximum colour check
		moveq	#$00,d6					; MJ: clear d6
 
loc_1DCE:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1DCE				; MJ: if null, delay a frame
		bsr.s	Pal_FadeIn
		subq.b	#$02,d4					; MJ: decrease colour check
		bne	loc_1DCE				; MJ: if it has not reached null, branch
		move.b	#$12,($FFFFF62A).w			; MJ: wait for V-blank again (so colours transfer)
		bra	DelayProgram				; MJ: ''
 
; End of function Pal_FadeTo
 
; ---------------------------------------------------------------------------
; Pallet fade-in subroutine
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeIn:				; XREF: Pal_FadeTo
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		lea	($FFFFFB80).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1DFA:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1DFA
	;	cmpi.b	#1,($FFFFFE10).w
	;	bne.s	locret_1E24
		tst.b 	(Water_Flag).w
		beq.s	locret_1E24
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1E1E:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1E1E
 
locret_1E24:
		rts	
; End of function Pal_FadeIn
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_AddColor:				; XREF: Pal_FadeIn
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bhi	FCI_NoBlue				; MJ: if not, branch
		addi.w	#$0200,d3				; MJ: increase blue
 
FCI_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bhi	FCI_NoGreen				; MJ: if not, branch
		addi.b	#$20,d3					; MJ: increase green
 
FCI_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bhi	FCI_NoRed				; MJ: if not, branch
		addq.b	#$02,d3					; MJ: increase red
 
FCI_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return
 
; End of function Pal_AddColor
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeFrom:
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6
 
loc_1E5C:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1E5C				; MJ: if null, delay a frame
		bsr.s	Pal_FadeOut
		dbf	d4,loc_1E5C
		rts	
; End of function Pal_FadeFrom
 
; ---------------------------------------------------------------------------
; Pallet fade-out subroutine
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeOut:				; XREF: Pal_FadeFrom
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1E82:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E82
 
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1E98:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E98
		rts	
; End of function Pal_FadeOut
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_DecColor:				; XREF: Pal_FadeOut
		move.w	(a0),d5					; MJ: load colour
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		beq	FCO_NoBlue				; MJ: if blue is finished, branch
		subi.w	#$0200,d5				; MJ: decrease blue
 
FCO_NoBlue:
		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		beq	FCO_NoGreen				; MJ: if green is finished, branch
		subi.b	#$20,d5					; MJ: decrease green
 
FCO_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		beq	FCO_NoRed				; MJ: if red is finished, branch
		subq.b	#$02,d5					; MJ: decrease red
 
FCO_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return
 
; End of function Pal_DecColor

; ---------------------------------------------------------------------------
; Subroutine to	fill the pallet	with white (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeWhite:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.w	#$EEE,d1
		move.b	($FFFFF627).w,d0
 
PalWhite_Loop:
		move.w	d1,(a0)+
		dbf	d0,PalWhite_Loop	; fill pallet with $000	(black)
		moveq	#$0E,d4					; MJ: prepare maximum colour check
		moveq	#$00,d6					; MJ: clear d6
 
loc_1EF4:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1EF4				; MJ: if null, delay a frame
		bsr.s	Pal_WhiteToBlack
		subq.b	#$02,d4					; MJ: decrease colour check
		bne	loc_1EF4				; MJ: if it has not reached null, branch
		move.b	#$12,($FFFFF62A).w			; MJ: wait for V-blank again (so colours transfer)
		bra	DelayProgram				; MJ: ''
; End of function Pal_MakeWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_WhiteToBlack:			; XREF: Pal_MakeWhite
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		lea	($FFFFFB80).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1F20:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F20
		cmpi.b	#1,($FFFFFE10).w
		bne.s	locret_1F4A
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1F44:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F44
 
locret_1F4A:
		rts	
; End of function Pal_WhiteToBlack


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_DecColor2:				; XREF: Pal_WhiteToBlack
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bcs	FCI2_NoBlue				; MJ: if not, branch
		subi.w	#$0200,d3				; MJ: dencrease blue
 
FCI2_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bcs	FCI2_NoGreen				; MJ: if not, branch
		subi.b	#$20,d3					; MJ: dencrease green
 
FCI2_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bcs	FCI2_NoRed				; MJ: if not, branch
		subq.b	#$02,d3					; MJ: dencrease red
 
FCI2_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return
; End of function Pal_DecColor2

; ---------------------------------------------------------------------------
; Subroutine to	make a white flash when	you enter a special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeFlash:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6
 
loc_1F86:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1F86				; MJ: if null, delay a frame
		bsr.s	Pal_ToWhite
		dbf	d4,loc_1F86
		rts	
; End of function Pal_MakeFlash


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_ToWhite:				; XREF: Pal_MakeFlash
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1FAC:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FAC
 
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1FC2:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FC2
		rts		
; End of function Pal_ToWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_AddColor2:				; XREF: Pal_ToWhite
		move.w	(a0),d5					; MJ: load colour
		cmpi.w	#$EEE,d5
		beq.s	FCO2_NoRed
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		cmpi.w	#$0E00,d1
		beq	FCO2_NoBlue				; MJ: if blue is finished, branch
		addi.w	#$0200,d5				; MJ: increase blue
 
FCO2_NoBlue:
		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		cmpi.w	#$00E0,d2
		beq	FCO2_NoGreen				; MJ: if green is finished, branch
		addi.b	#$20,d5					; MJ: increase green
 
FCO2_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		cmpi.b	#$0E,d3
		beq	FCO2_NoRed				; MJ: if red is finished, branch
		addq.b	#$02,d5					; MJ: increase red
 
FCO2_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return
; End of function Pal_AddColor2

; ---------------------------------------------------------------------------
; Pallet cycling routine - Sega	logo
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


;PalCycle_Sega:				; XREF: SegaScreen
;		tst.b	($FFFFF635).w
;		bne.s	loc_206A
;		lea	($FFFFFB20).w,a1
;		lea	(Pal_Sega1).l,a0
;		moveq	#5,d1
;		move.w	($FFFFF632).w,d0
;
;loc_2020:
;		bpl.s	loc_202A
;		addq.w	#2,a0
;		subq.w	#1,d1
;		addq.w	#2,d0
;		bra.s	loc_2020
; ===========================================================================
;
;loc_202A:				; XREF: PalCycle_Sega
;		move.w	d0,d2
;		andi.w	#$1E,d2
;		bne.s	loc_2034
;		addq.w	#2,d0

;loc_2034:
;		cmpi.w	#$60,d0
;		bcc.s	loc_203E
;		move.w	(a0)+,(a1,d0.w)

;loc_203E:
;		addq.w	#2,d0
;		dbf	d1,loc_202A
;		move.w	($FFFFF632).w,d0
;		addq.w	#2,d0
;		move.w	d0,d2
;		andi.w	#$1E,d2
;		bne.s	loc_2054
;		addq.w	#2,d0

;loc_2054:
;		cmpi.w	#$64,d0
;		blt.s	loc_2062
;		move.w	#$401,($FFFFF634).w
;		moveq	#-$C,d0

;loc_2062:
;		move.w	d0,($FFFFF632).w
;		moveq	#1,d0
;		rts	
; ===========================================================================

;loc_206A:				; XREF: loc_202A
;		subq.b	#1,($FFFFF634).w
;		bpl.s	loc_20BC
;		move.b	#4,($FFFFF634).w
;		move.w	($FFFFF632).w,d0
;		addi.w	#$C,d0
;		cmpi.w	#$30,d0
;		bcs.s	loc_2088
;		moveq	#0,d0
;		rts	
; ===========================================================================

;loc_2088:				; XREF: loc_206A
;		move.w	d0,($FFFFF632).w
;		lea	(Pal_Sega2).l,a0
;		lea	(a0,d0.w),a0
;		lea	($FFFFFB04).w,a1
;		move.l	(a0)+,(a1)+
;		move.l	(a0)+,(a1)+
;		move.w	(a0)+,(a1)
;		lea	($FFFFFB20).w,a1
;		moveq	#0,d0
;		moveq	#$2C,d1

;loc_20A8:
;		move.w	d0,d2
;		andi.w	#$1E,d2
;		bne.s	loc_20B2
;		addq.w	#2,d0

;loc_20B2:
;		move.w	(a0),(a1,d0.w)
;		addq.w	#2,d0
;		dbf	d1,loc_20A8

;loc_20BC:
;		moveq	#1,d0
;		rts	
;; End of function PalCycle_Sega

; ===========================================================================

;Pal_Sega1:	incbin	pallet\sega1.bin
;Pal_Sega2:	incbin	pallet\sega2.bin

; ---------------------------------------------------------------------------
; Subroutines to load pallets
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad1:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		adda.w	#$80,a3
		move.w	(a1)+,d7

loc_2110:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2110
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad2:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		move.w	(a1)+,d7

loc_2128:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2128
		rts	
; End of function PalLoad2

; ---------------------------------------------------------------------------
; Underwater pallet loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad3_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$80,a3
		move.w	(a1)+,d7

loc_2144:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2144
		rts	
; End of function PalLoad3_Water


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad4_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$100,a3
		move.w	(a1)+,d7

loc_2160:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2160
		rts	
; End of function PalLoad4_Water
; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet pointers
; ---------------------------------------------------------------------------
PalPointers:
	include "_inc\Pallet pointers.asm"

; ---------------------------------------------------------------------------
; Pallet data
; ---------------------------------------------------------------------------
Pal_SegaBG:	incbin	pallet\sega_bg.bin
Pal_Title:	incbin	pallet\title.bin
Pal_LevelSel:	incbin	pallet\levelsel.bin
Pal_Sonic:	incbin	pallet\sonic.bin
Pal_Sonic2:	incbin	pallet\sonic2.bin
Pal_Silver:	incbin	pallet\silver.bin
Pal_SilverGlow:	incbin	pallet\silverglow.bin
Pal_SilverSon:	incbin	pallet\silver1.bin
Pal_SilverSha:	incbin	pallet\silver2.bin
Pal_Shadow:	incbin	pallet\shadow.bin
Pal_WOZ:	incbin	pallet\WOZ.bin
Pal_WOZWater:	incbin	pallet\WOZwater.bin
Pal_TJZ:		incbin	pallet\TJZ.bin
Pal_TJZWater:	incbin	pallet\TJZ_uw.bin	; TJZ underwater pallets
Pal_DDZ:		incbin	pallet\DDZ.bin
Pal_KVZ:	incbin	pallet\KVZ.bin
Pal_KVZWater:	incbin	pallet\KVZ_uw.bin	; KVZ underwater pallets
Pal_CCZ:	incbin	pallet\CCZ.bin
Pal_ABZ:	incbin	pallet\ABZ.bin	; ABZ act 1 pallets
Pal_ABZWater:	incbin	pallet\ABZ_uw.bin	; ABZ act 2 & Final Zone pallets
Pal_Special:	incbin	pallet\special.bin	; special stage pallets
Pal_TJZSonWater:	incbin	pallet\son_TJZuw.bin	; Sonic (underwater in TJZ) pallet
Pal_TJZSonWater2:	incbin	pallet\son2_TJZuw.bin
Pal_TJZSilWater:	incbin	pallet\sil_TJZuw.bin
Pal_TJZSilGWater:	incbin	pallet\silg_TJZuw.bin
Pal_TJZShaWater:	incbin	pallet\sha_TJZuw.bin
Pal_ABZ3SonWat:	incbin	pallet\son_ABZu.bin	; Sonic (underwater in ABZ act 3) pallet
Pal_SpeResult:	incbin	pallet\ssresult.bin	; special stage results screen pallets
Pal_SpeContinue:incbin	pallet\sscontin.bin	; special stage results screen continue pallet
Pal_Ending:	incbin	pallet\ending.bin	; ending sequence pallets
Pal_SSZ:	incbin	pallet\ssz.bin
Pal_WAZ:	incbin	pallet\waz.bin
Pal_FCZ:	incbin	pallet\fcz.bin
Pal_RTZ:	incbin	pallet\rtz.bin
Pal_SZ:	incbin	pallet\sz.bin
Pal_Eggman:	incbin	pallet\eggman.bin

; ---------------------------------------------------------------------------
; Subroutine to	delay the program by ($FFFFF62A) frames
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DelayProgram:				; XREF: PauseGame
		move	#$2300,sr

loc_29AC:
		tst.b	($FFFFF62A).w
		bne.s	loc_29AC
		rts	
; End of function DelayProgram

; ---------------------------------------------------------------------------
; Subroutine to	generate a pseudo-random number	in d0
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RandomNumber:
		move.l	($FFFFF636).w,d1
		bne.s	loc_29C0
		move.l	#$2A6D365A,d1

loc_29C0:
		move.l	d1,d0
		asl.l	#2,d1
		add.l	d0,d1
		asl.l	#3,d1
		add.l	d0,d1
		move.w	d1,d0
		swap	d1
		add.w	d1,d0
		move.w	d0,d1
		swap	d1
		move.l	d1,($FFFFF636).w
		rts	
; End of function RandomNumber


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcSine:				; XREF: SS_BGAnimate; et al
		andi.w	#$FF,d0
		add.w	d0,d0
		addi.w	#$80,d0
		move.w	Sine_Data(pc,d0.w),d1
		subi.w	#$80,d0
		move.w	Sine_Data(pc,d0.w),d0
		rts	
; End of function CalcSine

; ===========================================================================

Sine_Data:	incbin	misc\sinewave.bin	; values for a 360ยบ sine wave

; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcAngle:
		movem.l	d3-d4,-(sp)
		moveq	#0,d3
		moveq	#0,d4
		move.w	d1,d3
		move.w	d2,d4
		or.w	d3,d4
		beq.s	loc_2D04
		move.w	d2,d4
		tst.w	d3
		bpl.w	loc_2CC2
		neg.w	d3

loc_2CC2:
		tst.w	d4
		bpl.w	loc_2CCA
		neg.w	d4

loc_2CCA:
		cmp.w	d3,d4
		bcc.w	loc_2CDC
		lsl.l	#8,d4
		divu.w	d3,d4
		moveq	#0,d0
		move.b	Angle_Data(pc,d4.w),d0
		bra.s	loc_2CE6
; ===========================================================================

loc_2CDC:				; XREF: CalcAngle
		lsl.l	#8,d3
		divu.w	d4,d3
		moveq	#$40,d0
		sub.b	Angle_Data(pc,d3.w),d0

loc_2CE6:
		tst.w	d1
		bpl.w	loc_2CF2
		neg.w	d0
		addi.w	#$80,d0

loc_2CF2:
		tst.w	d2
		bpl.w	loc_2CFE
		neg.w	d0
		addi.w	#$100,d0

loc_2CFE:
		movem.l	(sp)+,d3-d4
		rts	
; ===========================================================================

loc_2D04:				; XREF: CalcAngle
		move.w	#$40,d0
		movem.l	(sp)+,d3-d4
		rts	
; End of function CalcAngle

; ===========================================================================

Angle_Data:	incbin	misc\angles.bin

; ===========================================================================

; ---------------------------------------------------------------------------
; Sega screen
; ---------------------------------------------------------------------------

;SegaScreen:				; XREF: GameModeArray
	;	move.b	#$E4,d0
	;	bsr.w	PlaySound_Special ; stop music
	;	bsr.w	ClearPLC
	;	bsr.w	Pal_FadeFrom
	;	lea	($C00004).l,a6
	;	move.w	#$8004,(a6)
	;	move.w	#$8230,(a6)
	;	move.w	#$8407,(a6)
	;	move.w	#$8700,(a6)
	;	move.w	#$8B00,(a6)
	;	clr.b	($FFFFF64E).w
	;	move	#$2700,sr
	;	move.w	($FFFFF60C).w,d0
	;	andi.b	#$BF,d0
	;	move.w	d0,($C00004).l
	;	bsr.w	ClearScreen
	;	move.l	#$40000000,($C00004).l
	;	lea	(Nem_SegaLogo).l,a0 ; load Sega	logo patterns
	;	bsr.w	NemDec
	;	lea	($FF0000).l,a1
	;	lea	(Eni_SegaLogo).l,a0 ; load Sega	logo mappings
	;	move.w	#0,d0
	;	bsr.w	EniDec
	;	lea	($FF0000).l,a1
	;	move.l	#$65100003,d0
	;	moveq	#$17,d1
	;	moveq	#7,d2
	;	bsr.w	ShowVDPGraphics
	;	lea	($FF0180).l,a1
	;	move.l	#$40000003,d0
	;	moveq	#$27,d1
	;	moveq	#$1B,d2
	;	bsr.w	ShowVDPGraphics
	;	moveq	#0,d0
	;	bsr.w	PalLoad2	; load Sega logo pallet
	;	move.w	#-$A,($FFFFF632).w
	;	move.w	#0,($FFFFF634).w
	;	move.w	#0,($FFFFF662).w
	;	move.w	#0,($FFFFF660).w
	;	move.w	($FFFFF60C).w,d0
	;	ori.b	#$40,d0
	;	move.w	d0,($C00004).l

;Sega_WaitPallet:
	;	move.b	#2,($FFFFF62A).w
	;	bsr.w	DelayProgram
	;	bsr.w	PalCycle_Sega
	;	bne.s	Sega_WaitPallet

	;	move.b	#$E1,d0
	;	bsr.w	PlaySound_Special ; play "SEGA"	sound
	;	move.b	#$14,($FFFFF62A).w
	;	bsr.w	DelayProgram
	;	move.w	#$1E,($FFFFF614).w

;Sega_WaitEnd:
	;	move.b	#2,($FFFFF62A).w
	;	bsr.w	DelayProgram
	;	tst.w	($FFFFF614).w
	;	beq.s	Sega_GotoTitle
	;	andi.b	#$80,($FFFFF605).w ; is	Start button pressed?
	;	beq.s	Sega_WaitEnd	; if not, branch
; ---------------------------------------------------------------------------
; Sega screen
; ---------------------------------------------------------------------------

SegaScreen:			; XREF: GameModeArray
		move.b	#$E1,d0
		bsr.w	PlaySound			; fade out music
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8200+($C000>>10),(a6)	; set foreground nametable address
		move.w	#$8400+($E000>>13),(a6)	; set background nametable address
		move.w	#$8700,(a6)			; set background colour (palette entry 0)
		move.w	#$8B00,(a6)			; full-screen vertical scrolling
		move.w	#$8134,(a6)			; disable display
		move.w	#$8C81,(a6)
		clr.b	($FFFFF64E).w
		move	#$2700,sr
		bsr.w	ClearScreen
		vram	$20
		lea	(Nem_SegaLogo).l,a0		; load Sega logo patterns on tile #1
		bsr.w	NemDec
		lea	($FF0000).l,a1
		lea	(Eni_SegaLogo).l,a0		; load Sega logo mappings
		moveq	#1,d0				; start from tile #1
		bsr.w	EniDec
		copyTilemap	$FF0000,($E61E),((96/8)-1),((32/8)-1)

		tst.b   ($FFFFFFF8).w			; is console Japanese?
		bpl.s   @jmp0				; if yes, branch
		vram	($C634),4(a6)		; set position to write to..
		move.l	#$00310032,(a6)			; and write "TM"
@jmp0:		move.w	#$EEE,($FFFFFB82).w
		move.w	#-2,($FFFFF632).w			; minus size of an entry
		move.w	#1,($FFFFF634).w

		lea	($FFFFFB84).w,a1
		bsr	Palcycle_Sega
		move.w	#$8174,$C00004			; enable display
		bsr.w	Pal_FadeTo
		move.b	#$FF,d0			; play "SEGA" sound
		bsr.w	PlaySound
		move.w	#3*60,($FFFFF614).w		; stay for 3 seconds

Sega_WaitEnd:
		move.b	#2,($FFFFF62A).w
		bsr.w	DelayProgram
		lea	($FFFFFB04).w,a1
		bsr	Palcycle_Sega
		tst.w	($FFFFF614).w
		beq.s	Sega_GotoTitle
		andi.b	#$80,($FFFFF605).w	; is Start button pressed?
		beq.s	Sega_WaitEnd			; if not, branch

Sega_GotoTitle:
		move.b	#$20,($FFFFF600).w			; set screen mode to "SSRG Screen"
		rts

Palcycle_Sega:
		subq.w	#1,($FFFFF634).w
		bne.s	@return
		move.w	#3,($FFFFF634).w
		addq.w	#2,($FFFFF632).w
		cmpi.w	#$1C,($FFFFF632).w		; past cycle's size?
		bne.s	@jmp0				; if not, branch
		move.w	#0,($FFFFF632).w			; if yes, reset
@jmp0:		move.w	($FFFFF632).w,d0
		lea	@cycle(pc,d0.w),a0
		rept	4				; repeat next line 4 times		; --> transfer 9 colors in total
			move.l	(a0)+,(a1)+		; copy 2 colors and increment pointers
		endr
		move.w	(a0),(a1)			; copy last color
@return:	rts

@cycle:		dc.w	$EC0
		dc.w	$EA0, $E80, $E60, $E40, $E20, $E00
		dc.w	$C00
		dc.w	$E00, $E20, $E40, $E60, $E80, $EA0
@cycle_end:	; remaining half copy before loop. Making it CPU-friendly
		dc.w	$EC0
		dc.w	$EA0, $E80, $E60, $E40, $E20, $E00
		dc.w	$C00
Bcycle_size:=	@cycle_end-@cycle

	include	"SSRG/SSRG.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Title	screen
; ---------------------------------------------------------------------------

TitleScreen:				; XREF: GameModeArray
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; stop music
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		move	#$2700,sr
		bsr.w	SoundDriverLoad
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		move.w	#$9200,(a6)
		move.w	#$8B03,(a6)
		move.w	#$8720,(a6)
		clr.b	($FFFFF64E).w
		move.w	#$8C89,(a6)		; H res 40 cells, no interlace, S/H enabled
	;	bsr.w	ClearScreen
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Title_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Title_ClrObjRam ; fill object RAM ($D000-$EFFF) with	$0

	;	move.l	#$54C00000,($C00004).l
	;	lea	(Nem_CreditText).l,a0 ;	load alphabet
	;	bsr.w	NemDec
	;	moveq	#$27,d1
	;	moveq	#$1B,d2
	;	bsr.w	ShowVDPGraphics
	;	lea	($FFFFFB80).w,a1
	;	moveq	#0,d0
	;	move.w	#$1F,d1

Title_ClrPallet:
	;	move.l	d0,(a1)+
	;	dbf	d1,Title_ClrPallet ; fill pallet with 0	(black)

	;	moveq	#3,d0		; load Sonic's pallet
	;	bsr.w	PalLoad1
	;	move.b	#$8A,($FFFFB080).w ; load "SONIC TEAM PRESENTS"	object
	;	jsr	ObjectsLoad
	;	jsr	BuildSprites
	;	bsr.w	Pal_FadeTo
		move	#$2700,sr
		move.l	#$40000001,($C00004).l
		lea	(Nem_TitleFg).l,a0 ; load title	screen patterns
		bsr.w	NemDec
		move.l	#$60000001,($C00004).l
		lea	(Nem_Title).l,a0 ;	load Sonic title screen	patterns
		bsr.w	NemDec
		move.l	#$62000002,($C00004).l
		lea	(Nem_TitleTM).l,a0 ; load "TM" patterns
		bsr.w	NemDec
		lea	($C00000).l,a6
		move.l	#$50000003,4(a6)
		lea	(Art_TextS2).l,a5
		move.w	#$28F,d1

Title_LoadText:
		move.w	(a5)+,(a6)
		dbf	d1,Title_LoadText ; load uncompressed text patterns

		move.b	#0,($FFFFFE30).w ; clear lamppost counter
		move.w	#0,($FFFFFE08).w ; disable debug item placement	mode
		move.w	#0,($FFFFFFF0).w ; disable debug mode
		move.w	#0,($FFFFFE10).w ; set level to	WOZ (00)
		move.w	#0,($FFFFF634).w ; disable pallet cycling
		move.b	#0,($FFFFF74F).w
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		move.l	#$40000000,($C00004).l
		lea	(Nem_TIT).l,a0 ; load WOZ patterns
		bsr.w	NemDec
		lea	($FFFF9000).w,a1
		lea	(Blk16_TIT).l,a0 ; load	WOZ 16x16 mappings
		move.w	#0,d0
		bsr.w	EniDec
		lea	(Blk256_TIT).l,a0 ; load WOZ 256x256 mappings
		lea	($FF0000).l,a1
		bsr.w	KosDec
		bsr.w	LevelLayoutLoad
	;	bsr.w	Pal_FadeFrom
		move	#$2700,sr
		bsr.w	ClearScreen
		bsr.w	LoadTilesFromStart
		moveq	#1,d0		; load title screen pallet
		bsr.w	PalLoad1
		move.b	#1,d0		; play title screen music
		bsr.w	PlaySound_Special
		move.b	#0,($FFFFFFFA).w ; disable debug mode
		move.w	#$400,($FFFFF614).w ; run title	screen for $400	frames
		lea	($FFFFB080).w,a1
		jsr	DeleteObject2	; clear object RAM to make room for the "Press Start Button" object
		move.b	#$E,($FFFFB040).w ; load big Sonic object
		move.b	#$8F,($FFFFB080).w ; load "PRESS	START BUTTON" object
		move.b	#$8F,($FFFFB0C0).w ; load "TM" object
		move.b	#3,($FFFFB0DA).w
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		move.w	#0,($FFFFFFE4).w
		move.w	#0,($FFFFFFE6).w
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_FadeTo

loc_317C:
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		move.w	($FFFFB008).w,d0
		addq.w	#2,d0
		move.w	d0,($FFFFB008).w ; move	Sonic to the right
		cmpi.w	#$1C00,d0	; has Sonic object passed x-position $1C00?
		bcs.s	loc_3230	; if not, branch
		move.b	#0,($FFFFF600).w ; go to Sega screen
		rts	

loc_3230:
	;	tst.w	($FFFFF614).w
	;	beq.w	Demo
		cmpi.b	#$F,($FFFFB080).w
		bne.s	loc_317C
		cmpi.b	#4,($FFFFB0A4).w
		bne.s	loc_317C
		andi.b	#$80,($FFFFF605).w ; check if Start is pressed
		beq.w	loc_317C	; if not, branch
		tst.b	($FFFFF62B).w
		bne.s	Title_ChkOptions	; branch if not a 1-player game
		bra.w	PlayLevel

Title_ChkOptions:
		cmpi.b	#1,($FFFFF62B).w
		bne.s	Title_ChkLevSel	; branch if not a 1-player game
		move.b	#$24,($FFFFF600).w
		move.w	#0,($FFFFFF82).w
		bra.s	Options

Title_ChkLevSel:
		move.w	#0,($FFFFFF82).w
		move.b	#$2C,($FFFFF600).w
	;	bra.s	 Options; Go to Sonic 2 Level Select

Options:
		move.b	#$E1,d0
		bsr.w	PlaySound_Special
		bsr.w	Pal_FadeFrom
		move	#$2700,sr
		move.w	($FFFFF60C).w,d0
		andi.b	#-$41,d0
		move.w	d0,($C00004).l
		bsr.w	ClearScreen
		lea	($C00004).l,a6
		move.w	#-$7FFC,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7BF9,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7900,(a6)
		move.w	#-$737F,(a6)
		move.w	#-$6FFF,(a6)
		lea	($FFFFAC00).w,a1
		moveq	#0,d0
		move.w	#$FF,d1

loc_8C1AA:
		move.l	d0,(a1)+
		dbf	d1,loc_8C1AA
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

loc_8C2A:
		move.l	d0,(a1)+
		dbf	d1,loc_8C2A
		clr.w	($FFFFBC00).w
		move.l	#-$2400,($FFFFBCFC).w
		move.l	#$42000000,($C00004).l
		lea	(Menu_Font).l,a0
		bsr.w	NemDec
		move.l	#$4E000000,($C00004).l
		lea	(Menu_Box).l,a0
		bsr.w	NemDec
		move.l	#$52000000,($C00004).l
		lea	(Level_Icons).l,a0
		bsr.w	NemDec
		lea	($FFFF0000).l,a1
		lea	(Menu_Mappings).l,a0
		move.w	#$6000,d0
		bsr.w	EniDec
		lea	($FFFF0000).l,a1
		move.l	#$60000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		bsr.w	ShowVDPGraphics
		cmpi.b	#$2C,($FFFFF600).w	; level select menu?
		beq.w	LevelSelect	; if yes, branch

; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_8FCC:
		lea	($FFFF0000).l,a1
		lea	(Options_Mappings).l,a0
		move.w	#$70,d0
		bsr.w	EniDec
		lea	($FFFF0160).l,a1
		lea	(Options_Mappings).l,a0
		move.w	#$2070,d0
		bsr.w	EniDec
		clr.b	($FFFFFF82).w
		bsr.w	sub_9186
		addq.b	#1,($FFFFFF82).w
		bsr.w	loc_91F8
		addq.b	#1,($FFFFFF82).w
		bsr.w	loc_91F8
		addq.b	#1,($FFFFFF82).w
		bsr.w	loc_91F8
		addq.b	#1,($FFFFFF82).w
		bsr.w	loc_91F8
		addq.b	#1,($FFFFFF82).w
		bsr.w	loc_91F8
		clr.b	($FFFFFF82).w
		move.b	#0,($FFFFF74F).w
		clr.w	($FFFFF7F0).w
		jsr	Dynamic_Menu
		moveq	#$14,d0
		bsr.w	PalLoad1
		moveq	#2,d0
		bsr.w	PlaySound
	;	clr.w	($FFFFFFD8).w
		clr.l	($FFFFF700).w
		clr.l	($FFFFF704).w
	;	clr.w	(Some_cheat_value).w
		clr.w	($FFFFFFD6).w
		move.b	#$16,($FFFFF62A).w
		bsr.w	DelayProgram
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_FadeTo

loc_9060:
		move.b	#$16,($FFFFF62A).w
		bsr.w	DelayProgram
		move	#$2700,sr
		bsr.w	loc_91F8
		bsr.w	sub_90E0
		bsr.w	sub_9186
		move	#$2300,sr
		jsr	Dynamic_Menu
		move.b	($FFFFF605).w,d0
		or.b	($FFFFF607).w,d0
		andi.b	#-$80,d0
		bne.s	loc_909A
		bra.w	loc_9060
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_909A:
		move.b	($FFFFFF82).w,d0
		bne.s	loc_90B6
		bra.w	PlayLevel
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_90B6:
		subq.b	#1,d0
		bne.s	loc_90D8
		moveq	#1,d0
		move.w	d0,($FFFFFFD8).w
		move.w	d0,($FFFFFF8A).w
		move.b	#$1C,($FFFFF600).w
		move.b	#0,($FFFFFF88).w
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_90D8:
		move.b	#4,($FFFFF600).w
		rts	

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_90E0:
		moveq	#0,d2
		move.b	($FFFFFF82).w,d2
		move.b	($FFFFF605).w,d0
		or.b	($FFFFF607).w,d0
		btst	#0,d0
		beq.s	loc_90FC
		subq.b	#1,d2
		bcc.s	loc_90FC
		move.b	#5,d2

loc_90FC:
		btst	#1,d0
		beq.s	loc_910C
		addq.b	#1,d2
		cmpi.b	#6,d2
		bcs.s	loc_910C
		moveq	#0,d2

loc_910C:
		move.b	d2,($FFFFFF82).w
		lsl.w	#2,d2
		move.b	word_917A(pc,d2.w),d3
		movea.l	word_917A(pc,d2.w),a1
		move.w	(a1),d2
		btst	#2,d0
		beq.s	loc_9128
		subq.b	#1,d2
		bcc.s	loc_9128
		move.b	d3,d2

loc_9128:
		btst	#3,d0
		beq.s	loc_9136
		addq.b	#1,d2
		cmp.b	d3,d2
		bls.s	loc_9136
		moveq	#0,d2

loc_9136:
		cmpi.b	#2,($FFFFFF82).w
		bne.s	locret_91782
		btst	#6,d0
		beq.s	loc_91362
		addi.b	#$10,d2
	;	cmp.b	d3,d2
	;	bls.s	loc_9146
	;	moveq	#0,d2

loc_91362:
		btst	#4,d0
		beq.s	loc_9146
		subi.b	#$10,d2
	;	cmp.b	d3,d2
	;	bls.s	loc_9146
	;	moveq	#0,d2

loc_9146:
		move.w	d2,(a1)
		andi.w	#$20,d0
		beq.s	locret_9178
		move.w	($FFFFFF84).w,d0
	;	addi.w	#$80,d0
		bsr.w	PlaySound
	;	lea	(level_select_cheat).l,a0
	;	lea	(byte_97B7).l,a2
	;	lea	(Level_select_flag).w,a1
	;	moveq	#0,d2
	;	bsr.w	loc_9746

locret_9178:
		rts	

locret_91782:
		move.w	d2,(a1)
		rts
; End of function sub_90E0

; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
word_917A:	dc.w  $4FF		; 0
		dc.w $FFEC		; 1
		dc.w  $4FF		; 2
		dc.w $FFEE		; 3
		dc.w $FFFF		; 4
		dc.w $FF84		; 5

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_9186:
		bsr.w	loc_9268
		moveq	#0,d1
		move.b	($FFFFFF82).w,d1
		lsl.w	#3,d1
		lea	(off_92BA).l,a3
		lea	(a3,d1.w),a3
		move.w	#$6000,d0
		lea	($FFFF0030).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF00B6).l,a2
		moveq	#0,d1
		cmpi.b	#2,($FFFFFF82).w
		beq.s	loc_91CE
		move.b	($FFFFFF82).w,d1
		lsl.w	#2,d1
		lea	(word_917A,pc),a1
		movea.l	(a1,d1.w),a1
		move.w	(a1),d1
		lsl.w	#2,d1

loc_91CE:
		movea.l	(a4,d1.w),a1
		bsr.w	sub_8FBE
		cmpi.b	#2,($FFFFFF82).w
		bne.s	loc_91E8
		lea	($FFFF00C2).l,a2
		bsr.w	loc_9296

loc_91E8:
		lea	($FFFF0000).l,a1
		move.l	(a3)+,d0
		moveq	#$15,d1
		moveq	#7,d2
		bra.w	ShowVDPGraphics
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_91F8:
		bsr.w	loc_9268
		moveq	#0,d1
		move.b	($FFFFFF82).w,d1
		lsl.w	#3,d1
		lea	(off_92BA).l,a3
		lea	(a3,d1.w),a3
		moveq	#0,d0
		lea	($FFFF0190).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF0216).l,a2
		moveq	#0,d1
		cmpi.b	#2,($FFFFFF82).w
		beq.s	loc_923E
		move.b	($FFFFFF82).w,d1
		lsl.w	#2,d1
		lea	(word_917A,pc),a1
		movea.l	(a1,d1.w),a1
		move.w	(a1),d1
		lsl.w	#2,d1

loc_923E:
		movea.l	(a4,d1.w),a1
		bsr.w	sub_8FBE
		cmpi.b	#2,($FFFFFF82).w
		bne.s	loc_9258
		lea	($FFFF0222).l,a2
		bsr.w	loc_9296

loc_9258:
		lea	($FFFF0160).l,a1
		move.l	(a3)+,d0
		moveq	#$15,d1
		moveq	#7,d2
		bra.w	ShowVDPGraphics
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_9268:
		lea	(off_92DE).l,a4
		tst.b	($FFFFFF82).w
		beq.s	loc_9286
		lea	(off_92EA).l,a4
		tst.w	(Current_Character).w
		beq.s	loc_9286
		lea	(off_92EC).l,a4
		cmpi.w	#1,(Current_Character).w
		beq.s	loc_9286
		lea	(off_92EE).l,a4
		cmpi.w	#2,(Current_Character).w
		beq.s	loc_9286
		lea	(off_92F0).l,a4
		cmpi.w	#3,(Current_Character).w
		beq.s	loc_9286
		lea	(off_92F4).l,a4

loc_9286:
		cmpi.b	#2,($FFFFFF82).w
		bne.s	locret_9294
		lea	(off_92F2).l,a4

locret_9294:
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_9296:
		move.w	($FFFFFF84).w,d1
		move.b	d1,d2
		lsr.b	#4,d1
		bsr.s	loc_92A2
		move.b	d2,d1

loc_92A2:
		andi.w	#$F,d1
		cmpi.b	#$A,d1
		bcs.s	loc_92B0
		addi.b	#4,d1

loc_92B0:
		addi.b	#$10,d1
		move.b	d1,d0
		move.w	d0,(a2)+
		rts	

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_8FBE:
		moveq	#0,d1
		move.b	(a1)+,d1

loc_8FC2:
		move.b	(a1)+,d0
		move.w	d0,(a2)+
		dbf	d1,loc_8FC2
		rts	
; End of function sub_8FBE

word_87C6:
Anim_SonicMilesBG:	dc.w   0		; 0
; Sonic/Miles animated background
		dc.l $FF000000+Sonic_Miles_Spr
		dc.w $20
		dc.b 6
		dc.b $A
		dc.b   0,$C7		; 0
		dc.b  $A,  5		; 2
		dc.b $14,  5		; 4
		dc.b $1E,$C7		; 6
		dc.b $14,  5		; 8
		dc.b  $A,  5		; 10
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_92BA:	dc.l TextOptScr_PlayerSelect
		dc.w $4192
		dc.w 3
		dc.l TextOptScr_PartnerSelect
		dc.w $4392
		dc.w 3
		dc.l TextOptScr_ExtendedCamera
		dc.w $4592
		dc.w 3
		dc.l TextOptScr_JumpSound
		dc.w $4792
		dc.w 3
		dc.l TextOptScr_SoundTest
		dc.w $4992
		dc.w 3
		dc.l TextOptScr_SoundTest
		dc.w $4B92
		dc.w 3
off_92DE:
	dc.l TextOptScr_Sonic
	dc.l TextOptScr_Shadow
	dc.l TextOptScr_Silver
	dc.l TextOptScr_Tails
	dc.l TextOptScr_Knuckles
off_92EA:
	dc.l TextOptScr_None
	dc.l TextOptScr_Shadow
	dc.l TextOptScr_Silver
	dc.l TextOptScr_Tails
	dc.l TextOptScr_Knuckles
off_92EC:
	dc.l TextOptScr_Sonic
	dc.l TextOptScr_None
	dc.l TextOptScr_Silver
	dc.l TextOptScr_Tails
	dc.l TextOptScr_Knuckles
off_92EE:
	dc.l TextOptScr_Sonic
	dc.l TextOptScr_Shadow
	dc.l TextOptScr_None
	dc.l TextOptScr_Tails
	dc.l TextOptScr_Knuckles
off_92F0:
	dc.l TextOptScr_Sonic
	dc.l TextOptScr_Shadow
	dc.l TextOptScr_Silver
	dc.l TextOptScr_None
	dc.l TextOptScr_Knuckles
off_92F4:
	dc.l TextOptScr_Sonic
	dc.l TextOptScr_Shadow
	dc.l TextOptScr_Silver
	dc.l TextOptScr_Tails
	dc.l TextOptScr_None
off_92F2:
	dc.l TextOptScr_0
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
TextOptScr_PlayerSelect:		dc.b $10, $1A,   0, 0, 0, 0, $2D, $29, $1E, $36, $22, $2F, 0, 0, 0, 0
			dc.b   0, $1A
TextOptScr_Sonic:		dc.b  $E, 0, 0, 0, 0, 0, $30,$2C,$2B,$26,$20, 0, 0, 0, 0, 0
TextOptScr_Shadow:		dc.b  $E, 0, 0, 0, 0, 0, $30,$25,$1E,$21,$2C,$34, 0, 0, 0, 0
TextOptScr_Silver:		dc.b  $E, 0, 0, 0, 0, 0, $30,$26,$29,$33,$22,$2F, 0, 0, 0, 0
TextOptScr_Tails:		dc.b  $E, 0, 0, 0, 0, 0, $31,$1E,$26,$29,$30,0, 0, 0, 0, 0
TextOptScr_Knuckles:	dc.b  $E, 0, 0, 0, 0, $28,$2B,$32,$20,$28,$29,$22,$30, 0, 0, 0
TextOptScr_None:		dc.b  $E, 0, 0, 0, 0, 0, $2B,$2C,$2B,$22, 0, 0, 0, 0, 0, 0
TextOptScr_PartnerSelect:		dc.b $10,$1A, 0, 0, 0, 0,$2D,$1E,$2F,$31,$2B,$22,$2F, 0, 0, 0
			dc.b   0,$1A		; 16
TextOptScr_SoundTest:	dc.b $10,$1A,  0,  0,$30,$2C,$32,$2B,$21,  0, 0,$31,$22,$30,$31, 0; 0
		dc.b   0,$1A		; 16
TextOptScr_0:	dc.b  $E,  0,  0,  0,  0,  0,  0,$10,$10,  0,  0,  0,  0,  0,  0,  0; 0
TextOptScr_JumpSound:		dc.b $10, $1A,   0, 0, 0, 0, $2D, $29, $1E, $36, $22, $2F, 0, 0, 0, 0
			dc.b   0, $1A
TextOptScr_FM:		dc.b  $E, 0, 0, 0, 0, 0, $30,$2C,$2B,$26,$20, 0, 0, 0, 0, 0
TextOptScr_PSG:		dc.b  $E, 0, 0, 0, 0, 0, $30,$2C,$2B,$26,$20, 0, 0, 0, 0, 0
TextOptScr_ExtendedCamera:		dc.b $10, $1A,   0, 0, 0, 0, $2D, $29, $1E, $36, $22, $2F, 0, 0, 0, 0
			dc.b   0, $1A
TextOptScr_On:		dc.b  $E, 0, 0, 0, 0, 0, $30,$2C,$2B,$26,$20, 0, 0, 0, 0, 0
TextOptScr_Off:		dc.b  $E, 0, 0, 0, 0, 0, $30,$2C,$2B,$26,$20, 0, 0, 0, 0, 0
		even

;-------------------------------------------------------------------------------
LevelSelect:
	lea	($FFFF0000).l,a1
	lea	(MapEng_LevSel).l,a0	; 2 bytes per 8x8 tile, compressed
	move.w	#0,d0
	bsr.w	EniDec
	lea	($FFFF0000).l,a1
	move.l	#$40000003,d0
	moveq	#$27,d1
	moveq	#$1B,d2	; 40x28 = whole screen
	jsr	(ShowVDPGraphics).l	; display patterns
	moveq	#0,d3
	bsr.w	LevelSelect_DrawSoundNumber
	lea	($FFFF08C0).l,a1
	lea	(MapEng_LevSelIcon).l,a0
	move.w	#$90,d0
	bsr.w	EniDec
	bsr.w	LevelSelect_DrawIcon
;	clr.w	($FFFFFFEC).w
;	clr.w	($FFFFFFEE).w	; VsRSID_Act
	clr.b	($FFFFF74F).w
	clr.w	($FFFFF7F0).w
	lea	(Anim_SonicMilesBG).l,a2
	jsr	(Dynamic_Menu).l
	moveq	#$14,d0
	bsr.w	PalLoad1
	lea	($FFFFFB40).w,a1
	lea	($FFFFFBC0).w,a2

	moveq	#7,d1
@1	move.l	(a1),(a2)+
	clr.l	(a1)+
	dbf	d1,@1

	move.b	#2,d0
	jsr	(PlaySound).l
	move.w	#$707,($FFFFF614).w
	clr.l	($FFFFF700).w
	clr.l	($FFFFF704).w
;	clr.w	(Correct_cheat_entries).w
;	clr.w	(Correct_cheat_entries_2).w
	move.b	#$16,($FFFFF62A).w
	bsr.w	DelayProgram
	move.w	($FFFFF60C).w,d0
	ori.b	#$40,d0
	move.w	d0,($C00004).l
	bsr.w	Pal_FadeTo

;loc_93AC:
LevelSelect_Main:	; routine running during level select
	move.b	#$16,($FFFFF62A).w
	bsr.w	DelayProgram
	move	#$2700,sr
	moveq	#0,d3	; palette line << 13
	bsr.w	LevelSelect_MarkFields	; unmark fields
	bsr.w	LevSelControls	; possible change selected fields
	move.w	#$6000,d3
	bsr.w	LevelSelect_MarkFields	; mark fields
	bsr.w	LevelSelect_DrawIcon
	move	#$2300,sr
	lea	(Anim_SonicMilesBG).l,a2
	jsr	(Dynamic_Menu).l
	move.b	($FFFFF605).w,d0
	or.b	($FFFFF607).w,d0
	andi.b	#$80,d0	; start pressed?
	bne.s	LevelSelect_PressStart	; yes
	bra.w	LevelSelect_Main	; no
; ===========================================================================

;loc_93F0:
LevelSelect_PressStart:
	move.w	($FFFFFF82).w,d0
	add.w	d0,d0
	move.w	LevelSelect_Order(pc,d0.w),d0
	bmi.w	LevelSelect_Return	; sound test
	cmpi.w	#$4000,d0
	bne.s	LevelSelect_StartZone

;LevelSelect_SpecialStage:
	move.b	#$10,($FFFFF600).w ; => SpecialStage
	clr.w	($FFFFFE10).w
	move.b	#6,($FFFFFE12).w
	moveq	#0,d0
	move.w	d0,($FFFFFE20).w
	move.l	d0,($FFFFFE22).w
	move.l	d0,($FFFFFE26).w
;	move.l	#5000,(Next_Extra_life_score).w
;	move.w	(Player_option).w,(Player_mode).w
	rts
; ===========================================================================

;loc_944C:
LevelSelect_Return:
	move.b	#0,($FFFFF600).w ; => SegaScreen
	rts
; ===========================================================================
; -----------------------------------------------------------------------------
; Level Select Level Order

; One entry per item in the level select menu. Just set the value for the item
; you want to link to the level/act number of the level you want to load when
; the player selects that item.
; -----------------------------------------------------------------------------
;Misc_9454:
LevelSelect_Order:
	dc.w	wave_ocean_act_1
	dc.w	wave_ocean_act_2
	dc.w	wave_ocean_act_3
	dc.w	wave_ocean_act_4
	dc.w	dusty_desert_act_1
	dc.w	dusty_desert_act_2
	dc.w	dusty_desert_act_3
	dc.w	dusty_desert_act_4
	dc.w	white_acropolis_act_1
	dc.w	white_acropolis_act_2
	dc.w	white_acropolis_act_3
	dc.w	white_acropolis_act_4
	dc.w	crisis_city_act_1
	dc.w	crisis_city_act_2
	dc.w	crisis_city_act_3
	dc.w	crisis_city_act_4
	dc.w	flame_core_act_1
	dc.w	flame_core_act_2
	dc.w	flame_core_act_3
	dc.w	flame_core_act_4
	dc.w	radical_train_act_1
	dc.w	radical_train_act_2
	dc.w	radical_train_act_3
	dc.w	radical_train_act_4
	dc.w	tropical_jungle_act_1
	dc.w	tropical_jungle_act_2
	dc.w	tropical_jungle_act_3
	dc.w	tropical_jungle_act_4
	dc.w	kingdom_valley_act_1
	dc.w	kingdom_valley_act_2
	dc.w	kingdom_valley_act_3
	dc.w	kingdom_valley_act_4
	dc.w	aquatic_base_act_1
	dc.w	aquatic_base_act_2
	dc.w	aquatic_base_act_3
	dc.w	aquatic_base_act_4
	dc.w	special_stage_act_1
	dc.w	$4000	; - special stage
	dc.w	$FFFF	; - sound test
; ===========================================================================

;loc_9480:
LevelSelect_StartZone:
	andi.w	#$3FFF,d0
	move.w	d0,($FFFFFE10).w
	move.b	#$C,($FFFFF600).w ; => Level (Zone play mode)
	move.b	#6,($FFFFFE12).w
	moveq	#0,d0
	move.w	d0,($FFFFFE20).w
	move.l	d0,($FFFFFE22).w
	move.l	d0,($FFFFFE26).w
;	move.b	d0,(Continue_count).w
;	move.l	#5000,(Next_Extra_life_score).w
	move.b	#$E1,d0
	jsr	(PlaySound).l
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Change what you're selecting in the level select
; ---------------------------------------------------------------------------
; loc_94DC:
LevSelControls:
	move.b	($FFFFF605).w,d1
	andi.b	#3,d1
	bne.s	@2	; up/down pressed
	subq.w	#1,($FFFFFF80).w
	bpl.s	LevSelControls_CheckLR

@2
	move.w	#$B,($FFFFFF80).w
	move.b	($FFFFF604).w,d1
	andi.b	#3,d1
	beq.s	LevSelControls_CheckLR	; up/down not pressed, check for left & right
	move.w	($FFFFFF82).w,d0
	btst	#0,d1
	beq.s	@3
	subq.w	#1,d0	; decrease by 1
	bcc.s	@3	; >= 0?
	moveq	#$26,d0	; set to $15

@3
	btst	#1,d1
	beq.s	@4
	addq.w	#1,d0	; yes, add 1
	cmpi.w	#$27,d0
	blo.s	@4	; smaller than $16?
	moveq	#0,d0	; if not, set to 0

@4
	move.w	d0,($FFFFFF82).w
	rts
; ===========================================================================
; loc_9522:
LevSelControls_CheckLR:
	cmpi.w	#$26,($FFFFFF82).w	; are we in the sound test?
	bne.s	LevSelControls_SwitchSide	; no
	move.w	($FFFFFF84).w,d0
	move.b	($FFFFF605).w,d1
	btst	#2,d1
	beq.s	@5
	subq.b	#1,d0

@5
	btst	#3,d1
	beq.s	@6
	addq.b	#1,d0

@6
	btst	#6,d1
	beq.s	@7
	addi.b	#$10,d0

@7
	btst	#4,d1
	beq.s	@F7
	subi.b	#$10,d0
@F7

	move.w	d0,($FFFFFF84).w
	andi.w	#$20,d1
	beq.s	@8	; rts
	move.w	($FFFFFF84).w,d0
	jsr	(PlaySound_Special).w 
	lea	(debug_cheat).l,a0
;	lea	(super_sonic_cheat).l,a2
;	lea	(Night_mode_flag).w,a1
	moveq	#1,d2	; flag to tell the routine to enable the Super Sonic cheat
	bra.w	CheckCheats

@8
	rts
; ===========================================================================
; loc_958A:
LevSelControls_SwitchSide:	; not in soundtest, not up/down pressed
	move.b	($FFFFF605).w,d1
	andi.b	#$C,d1
	beq.s	@9				; no direction key pressed
	move.w	($FFFFFF82).w,d0	; left or right pressed
	move.b	LevelSelect_SwitchTable(pc,d0.w),d0 ; set selected zone according to table
	move.w	d0,($FFFFFF82).w
@9
	rts
; ===========================================================================
;byte_95A2:
LevelSelect_SwitchTable:
	dc.b $18
	dc.b $19	; 1
	dc.b $1A	; 2
	dc.b $1B	; 3
	dc.b $1C	; 4
	dc.b $1D	; 5
	dc.b $1E	; 6
	dc.b $1F	; 7
	dc.b $20	; 8
	dc.b $21	; 9
	dc.b $22	; $A
	dc.b $23	; $B
	dc.b $24	; $C
	dc.b $25	; $D
	dc.b $25	; $E
	dc.b $26	; $F
	dc.b $26	; $10
	dc.b $26	; $11
	dc.b $26	; $12
	dc.b $26	; $13
	dc.b $26	; $14
	dc.b $26	; $15
	dc.b $26	; $16
	dc.b $26	; $17
	dc.b 0		; $18
	dc.b 1		; $19
	dc.b 2		; $1A
	dc.b 3		; $1B
	dc.b 4		; $1C
	dc.b 5		; $1D
	dc.b 6		; $1E
	dc.b 7		; $1F
	dc.b 8		; $20
	dc.b 9		; $21
	dc.b $A		; $22
	dc.b $B		; $23
	dc.b $C		; $24
	dc.b $D		; $25
	dc.b $10	; $26
	even
; ===========================================================================

;loc_95B8:
LevelSelect_MarkFields:
	lea	($FFFF0000).l,a4
	lea	(LevSel_MarkTable).l,a5
	lea	($C00000).l,a6
	moveq	#0,d0
	move.w	($FFFFFF82).w,d0
	lsl.w	#2,d0
	lea	(a5,d0.w),a3
	moveq	#0,d0
	move.b	(a3),d0
	mulu.w	#$50,d0
	moveq	#0,d1
	move.b	1(a3),d1
	add.w	d1,d0
	lea	(a4,d0.w),a1
	moveq	#0,d1
	move.b	(a3),d1
	lsl.w	#7,d1
	add.b	1(a3),d1
	addi.w	#-$4000,d1
	lsl.l	#2,d1
	lsr.w	#2,d1
	ori.w	#$4000,d1
	swap	d1
	move.l	d1,4(a6)

	moveq	#$E,d2
@10	move.w	(a1)+,d0
	add.w	d3,d0
	move.w	d0,(a6)
	dbf	d2,@10

	addq.w	#2,a3
	moveq	#0,d0
	move.b	(a3),d0
	beq.s	@11
	mulu.w	#$50,d0
	moveq	#0,d1
	move.b	1(a3),d1
	add.w	d1,d0
	lea	(a4,d0.w),a1
	moveq	#0,d1
	move.b	(a3),d1
	lsl.w	#7,d1
	add.b	1(a3),d1
	addi.w	#-$4000,d1
	lsl.l	#2,d1
	lsr.w	#2,d1
	ori.w	#$4000,d1
	swap	d1
	move.l	d1,4(a6)
	move.w	(a1)+,d0
	add.w	d3,d0
	move.w	d0,(a6)

@11
	cmpi.w	#$26,($FFFFFF82).w
	bne.s	@12	; rts
	bsr.w	LevelSelect_DrawSoundNumber
@12
	rts
; ===========================================================================
;loc_965A:
LevelSelect_DrawSoundNumber:
	move.l	#$49440003,($C00004).l
	move.w	($FFFFFF84).w,d0
	move.b	d0,d2
	lsr.b	#4,d0
	bsr.s	@13
	move.b	d2,d0

@13
	andi.w	#$F,d0
	cmpi.b	#$A,d0
	blo.s	@14
	addi.b	#4,d0

@14
	addi.b	#$10,d0
	add.w	d3,d0
	move.w	d0,(a6)
	rts
; ===========================================================================

;loc_9688:
LevelSelect_DrawIcon:
	move.w	($FFFFFF82).w,d0
	lea	(LevSel_IconTable).l,a3
	lea	(a3,d0.w),a3
	lea	($FFFF08C0).l,a1
	moveq	#0,d0
	move.b	(a3),d0
	lsl.w	#3,d0
	move.w	d0,d1
	add.w	d0,d0
	add.w	d1,d0
	lea	(a1,d0.w),a1
	move.l	#$4B360003,d0
	moveq	#3,d1
	moveq	#2,d2
	jsr	(ShowVDPGraphics).l
	lea	(Pal_LevelIcons).l,a1
	moveq	#0,d0
	move.b	(a3),d0
	lsl.w	#5,d0
	lea	(a1,d0.w),a1
	lea	($FFFFFB40).w,a2

	moveq	#7,d1
@15	move.l	(a1)+,(a2)+
	dbf	d1,@15

	rts
; ===========================================================================
;byte_96D8
LevSel_IconTable:
	dc.b   0,0	;0	EHZ
	dc.b   7,7	;2	CPZ
	dc.b   8,8	;4	ARZ
	dc.b   6,6	;6	CNZ
	dc.b   2,2	;8	HTZ
	dc.b   5,5	;$A	MCZ
	dc.b   4,4	;$C	OOZ
	dc.b   1,1,1	;$E	MTZ
	dc.b   9	;$11	SCZ
	dc.b  $A	;$12	WFZ
	dc.b  $B	;$13	DEZ
	dc.b  $C	;$14	Special Stage
	dc.b  $E	;$15	Sound Test
	even
;byte_96EE:
LevSel_MarkTable:	; 4 bytes per level select entry
; line primary, 2*column ($E fields), line secondary, 2*column secondary (1 field)
	dc.b   2,  6,  2,$24	;0
	dc.b   2,  6,  3,$24
	dc.b   2,  6,  4,$24
	dc.b   2,  6,  5,$24
	dc.b   6,  6,  6,$24
	dc.b   6,  6,  7,$24
	dc.b   6,  6,  8,$24
	dc.b   6,  6,  9,$24
	dc.b   $A, 6, $A,$24
	dc.b   $A, 6, $B,$24
	dc.b   $A, 6, $C,$24
	dc.b   $A, 6, $D,$24
	dc.b  $E,  6, $E,$24
	dc.b  $E,  6, $F,$24
	dc.b  $E,  6, $10,$24
	dc.b  $E,  6, $11,$24
	dc.b  $12, 6, $12,$24
	dc.b  $12, 6, $13,$24
	dc.b  $12, 6, $14,$24
	dc.b  $12, 6, $15,$24
	dc.b  $16, 6, $16,$24
	dc.b  $16, 6, $17,$24
	dc.b  $16, 6, $18,$24
	dc.b  $16, 6, $19,$24
; --- second column ---
	dc.b   2,$2A,  2,$48
	dc.b   2,$2A,  3,$48
	dc.b   2,$2A,  4,$48
	dc.b   2,$2A,  5,$48
	dc.b   6,$2A,  6,$48
	dc.b   6,$2A,  7,$48
	dc.b   6,$2A,  8,$48
	dc.b   6,$2A,  9,$48
	dc.b   $A,$2A, $A,$48
	dc.b   $A,$2A, $B,$48
	dc.b   $A,$2A, $C,$48
	dc.b   $A,$2A, $D,$48
	dc.b  $E,$2A,  0,  0
	dc.b  $F,$2A,  0,  0	;$14
	dc.b $12,$2A,$12,$48
; ===========================================================================
; loc_9746:
CheckCheats:	; This is called from 2 places: the options screen and the level select screen
	move.w	($FFFFFFDE).w,d0	; Get the number of correct sound IDs entered so far
	adda.w	d0,a0				; Skip to the next entry
	move.w	($FFFFFF84).w,d0		; Get the current sound test sound
	cmp.b	(a0),d0				; Compare it to the cheat
	bne.s	@16				; If they're different, branch
	addq.w	#1,($FFFFFFDE).w	; Add 1 to the number of correct entries
	tst.b	1(a0)				; Is the next entry 0?
	bne.s	@17				; If not, branch
	move.b	#1,($FFFFFFE2).w			; Enable the cheat
	move.b	#$33,d0			; Play the ring sound
	jsr	(PlaySound).l
@16
	move.w	#0,($FFFFFFDE).w	; Clear the number of correct entries
;+
;	move.w	(Correct_cheat_entries_2).w,d0	; Do the same procedure with the other cheat
;	adda.w	d0,a2
;	move.w	(Sound_test_sound).w,d0
;	cmp.b	(a2),d0
;	bne.s	++
;	addq.w	#1,(Correct_cheat_entries_2).w
;	tst.b	1(a2)
;	bne.s	+++	; rts
;	tst.w	d2				; Test this to determine which cheat to enable
;	bne.s	+				; If not 0, branch
;	move.b	#$F,(Continue_count).w		; Give 15 continues
;	; The next line causes the bug where the OOZ music plays until reset.
;	; Remove "&$7F" to fix the bug.
;	move.b	#SndID_ContinueJingle&$7F,d0	; Play the continue jingle
;	jsrto	(PlayMusic).l, JmpTo_PlayMusic
;	bra.s	++
; ===========================================================================
;+
;	move.w	#7,(Got_Emerald).w		; Give 7 emeralds to the player
;	move.b	#MusID_Emerald,d0		; Play the emerald jingle
;	jsrto	(PlayMusic).l, JmpTo_PlayMusic
;+
;	move.w	#0,(Correct_cheat_entries_2).w	; Clear the number of correct entries
@17
	rts
; ===========================================================================
;level_select_cheat:	dc.b $19, $65,   9, $17,   0
;	rev02even
;continues_cheat:	dc.b   1,   1,   2,   4,   0	; byte_97B7
;	rev02even
debug_cheat:		dc.b   1,   9,   9,   2,   1,   1,   2,   4,   0
	even
;super_sonic_cheat:	dc.b   4,   1,   2,   6,   0	; byte_97C5
;	rev02even

; level select picture palettes
; byte_9880:
Pal_LevelIcons:	incbin "pallet\Level Select Icons.bin"

; level select screen mappings (Enigma compressed)
; byte_9ADE:
MapEng_LevSel:	incbin "mapeni\Level Select.bin"

; 1P and 2P level select icon mappings (Enigma compressed)
; byte_9C32:
MapEng_LevSelIcon:	incbin "mapeni\Level Select Icons.bin"

;-------------------------------------------------------------------------------                            
Dynamic_Menu:                           
                subq.b  #$01, ($FFFFF7B9).w          ; Decrementa em 1 o Tempo
                bpl.s   Exit_Dinamic_Menu            ; Se for maior ou igual a 0 sai da funรงรฃo
                move.b  #$07, ($FFFFF7B9).w          ; Inicializa o tempo de duraรงรฃo de cada frame
                move.b  ($FFFFF7B8).w, D0            ; Carrega o Id do Frame Atual em D0
                addq.b  #$01, ($FFFFF7B8).w          ; Carrega o prรณximo frame em $FFFFFFB8
                andi.w  #$003F, D0
                move.b  Sonic_Miles_Frame_Select(PC, D0), D0  ; Carrega o Id do frame em D0
              ; muls.w  #$0140, D0                   ; Multiplica o Id pelo tamanho em bytes de cada frame
                lsl.w   #$06, D0
                lea     ($00C00000), A6
                move.l  #$40200000, $0004(A6)
                lea     (Sonic_Miles_Spr), A1
                lea     $00(A1, D0), A1
                move.w  #$0009, D0                   ; Tiles-1 a serem carregados por vez 
Menu_Loop_Load_Tiles:
                move.l  (A1)+, (A6)
                move.l  (A1)+, (A6)     
                move.l  (A1)+, (A6)     
                move.l  (A1)+, (A6)     
                move.l  (A1)+, (A6)     
                move.l  (A1)+, (A6)
                move.l  (A1)+, (A6)
                move.l  (A1)+, (A6)
                dbra    D0, Menu_Loop_Load_Tiles
Exit_Dinamic_Menu:                
                rts              
Sonic_Miles_Frame_Select:     
                dc.b    $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
                dc.b    $05, $0A
                dc.b    $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F
                dc.b    $14, $19   
                dc.b    $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E
                dc.b    $23, $28 
                ; 0 = 0000000000  ; 1 = 0101000000  ; 2 = 1010000000 ; 3 = 1111000000
;-------------------------------------------------------------------------------   
Menu_Palette:
                incbin  'data\menu\menu.pal'            
Menu_ClearScreen:
                jmp     ClearScreen
Menu_ShowVDPGraphics:                
                jmp     ShowVDPGraphics                
Menu_NemesisDec: 
                jmp     NemDec  
Menu_LoadPLC2:      
                jmp     LoadPLC2
Menu_RunPLC:                    
                jmp     RunPLC_RAM                           
Menu_EnigmaDec
                jmp     EniDec
Menu_Pal_FadeTo:
                jmp     Pal_FadeTo
Menu_Pal_FadeFrom:
                jmp     Pal_FadeFrom     
Menu_Play_Music:
                jmp     PlaySound   
Menu_PalLoad1:
                jmp     PalLoad1
Menu_DelayProgram:
                jmp     DelayProgram
		
PlayLevel:				; XREF: ROM:00003246j ...
		move.b	#$C,($FFFFF600).w ; set	screen mode to $0C (Level)
		move.b	#6,($FFFFFE12).w ; set lives to	6
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.l	d0,($FFFFFE26).w ; clear score
		move.b	d0,($FFFFFE16).w ; clear special stage number
		move.b	d0,($FFFFFE57).w ; clear emeralds
		move.l	d0,($FFFFFE58).w ; clear emeralds
		move.l	d0,($FFFFFE5C).w ; clear emeralds
		move.b	d0,($FFFFFE18).w ; clear continues
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; fade out music
		tst.w	(Current_Character).w
		beq.s	PlayLevel_Sonic
		cmpi.w	#1,(Current_Character).w
		beq.s	PlayLevel_Shadow
		move.w	#$900,($FFFFFE10).w

PlayLevel_Sonic:
		rts

PlayLevel_Shadow:
		move.w	#$803,($FFFFFE10).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Level	select - level pointers
; ---------------------------------------------------------------------------
LSelectPointers:
		incbin	misc\ls_point.bin
		even
;-----------------------------------------------------------------------
; Demo mode
; ---------------------------------------------------------------------------

Demo:					; XREF: TitleScreen
		move.w	#$1E,($FFFFF614).w

loc_33B6:				; XREF: loc_33E4
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		bsr.w	DeformBgLayer
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		move.w	($FFFFB008).w,d0
		addq.w	#2,d0
		move.w	d0,($FFFFB008).w
		cmpi.w	#$1C00,d0
		bcs.s	loc_33E4
		move.b	#0,($FFFFF600).w ; set screen mode to 00 (level)
		rts	
; ===========================================================================

loc_33E4:				; XREF: Demo
		andi.b	#$80,($FFFFF605).w ; is	Start button pressed?
		bne.w	Title_ChkLevSel	; if yes, branch
		tst.w	($FFFFF614).w
		bne.w	loc_33B6
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; fade out music
		move.w	($FFFFFFF2).w,d0 ; load	demo number
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Demo_Levels(pc,d0.w),d0	; load level number for	demo
		move.w	d0,($FFFFFE10).w
		addq.w	#1,($FFFFFFF2).w ; add 1 to demo number
		cmpi.w	#4,($FFFFFFF2).w ; is demo number less than 4?
		bcs.s	loc_3422	; if yes, branch
		move.w	#0,($FFFFFFF2).w ; reset demo number to	0

loc_3422:
		move.w	#1,($FFFFFFF0).w ; turn	demo mode on
		move.b	#8,($FFFFF600).w ; set screen mode to 08 (demo)
		cmpi.w	#$600,d0	; is level number 0600 (special	stage)?
		bne.s	Demo_Level	; if not, branch
		move.b	#$10,($FFFFF600).w ; set screen	mode to	$10 (Special Stage)
		clr.w	($FFFFFE10).w	; clear	level number
		clr.b	($FFFFFE16).w	; clear	special	stage number

Demo_Level:
		move.b	#6,($FFFFFE12).w ; set lives to	6
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.l	d0,($FFFFFE26).w ; clear score
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Levels used in demos
; ---------------------------------------------------------------------------
Demo_Levels:	incbin	misc\dm_ord1.bin
		even
; ---------------------------------------------------------------------------
; Music	playlist
; ---------------------------------------------------------------------------
MusicList1:	incbin	misc\muslist1.bin
		even
MusicList2:	incbin	misc\muslist2.bin
		even
MusicList3:	incbin	misc\muslist3.bin
		even
MusicList4:	incbin	misc\muslist4.bin
		even
; ===========================================================================

; ---------------------------------------------------------------------------
; Level
; ---------------------------------------------------------------------------

Level:					; XREF: GameModeArray
		bset	#7,($FFFFF600).w ; add $80 to screen mode (for pre level sequence)
		tst.w	($FFFFFFF0).w
		bmi.s	loc_37B6
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; fade out music

loc_37B6:
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		moveq	#0,d0
		bsr.w	LoadPLC
		tst.w	($FFFFFFF0).w
		bmi.s	Level_ClrRam
		move	#$2300,sr
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	loc_37FC
		bsr.w	LoadPLC		; load level patterns

loc_37FC:
		moveq	#1,d0
		bsr.w	LoadPLC		; load standard	patterns

Level_ClrRam:
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Level_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrObjRam ; clear object RAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1

Level_ClrVars:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars ; clear misc variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

Level_ClrVars2:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1

Level_ClrVars3:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars3 ; clear object variables

		move	#$2700,sr
		bsr.w	ClearScreen
		cmpi.b	#1,($FFFFFE10).w	
		beq.s	Level_InitWater
		cmpi.b	#3,($FFFFFE10).w	
		beq.s	Level_InitWater
		cmpi.b	#5,($FFFFFE10).w	
		bne.s	Level_ClearWater
		cmpi.b	#2,($FFFFFE11).w	
		beq.s	Level_ClearWater

Level_InitWater:
		move.b	#1,(Water_flag).w
		bra.s	Level_ClrVars3_Continue

Level_ClearWater:
		move.b	#0,(Water_flag).w

Level_ClrVars3_Continue:
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8004,(a6)
		move.w	#$8730,(a6)
        move.w  #$8C81,(a6)

loc_4262:
		move.w	#$8AFF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		clr.w	($FFFFDC00).w
		move.l	#-$2400,($FFFFDCFC).w
		tst.b	($FFFFFE10).w
		beq.s	Level_WOZPal
		tst.b	(Water_flag).w	; does level have water
		beq.s	Level_LoadPal	;if not, branch
		move.w	#$8014,(a6)
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		ror.b	#2,d0
		lsr.w	#6,d0
		add.w	d0,d0
		lea	(WaterHeight).l,a1 ; load water	height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement
		move.b	#1,($FFFFF64C).w ; enable water
		bra.s	Level_LoadPal

Level_WOZPal:
		move.w	#$8014,(a6)
		move.w	#0,($FFFFF646).w ; set water heights
		move.w	#0,($FFFFF648).w
		move.w	#0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement


Level_LoadPal:
		move.w	#$1E,($FFFFFE14).w
		move	#$2300,sr
		moveq	#3,d0
		bsr.w	PalLoad2	; load Sonic's pallet line
		moveq	#$26,d0		; pallet number	$B (TJZ)
		tst.b	($FFFFFE10).w ; is TJZ?
		beq.s	Level_WaterPal	; if so, branch
		tst.b	(Water_flag).w	; does level have water?
		beq.s	Level_LoadCol
		moveq	#$B,d0		; pallet number	$B (TJZ)
		cmpi.b	#1,($FFFFFE10).w ; is TJZ?
		beq.s	Level_WaterPal	; if so, branch
		moveq	#$F,d0		; pallet number	$F (KVZ)
		cmpi.b	#3,($FFFFFE10).w ; is KVZ?
		beq.s	Level_WaterPal	; if so, branch
		moveq	#$E,d0		; pallet number	$10 (ABZ)

Level_WaterPal:
		bsr.w	PalLoad3_Water	; load underwater pallet (see d0)
		move.l	#WaterTransition_WOZ,($FFFFF610).w
		tst.b	($FFFFFE30).w
		beq.s	Level_LoadCol
		move.b	($FFFFFE53).w,($FFFFF64E).w

Level_LoadCol:
		bsr.s	LoadSolids
		bra.w	Level_TtlCard

LoadSolids:
		moveq 	#0,d0
		move.b 	($FFFFFE10).w,d0
		add.w	d0,d0				; multiply d3 by x2
		add.w	d0,d0				; multiply d3 by x2 again (x4)
		move.l	CollArray1Table(pc,d0.w),($FFFFF784).w
		move.l	CollArray2Table(pc,d0.w),($FFFFF788).w
		move.l	AngleMapTable(pc,d0.w),($FFFFF78C).w 
		rts

CollArray1Table:
        dc.l    CollArray21    ; WOZ
        dc.l    CollArray21    ; TJZ
        dc.l    CollArray1    ; DDZ
        dc.l    CollArray3K1    ; KVZ
        dc.l    CollArray1    ; CCZ
        dc.l    CollArray3K1    ; ABZ
        dc.l    CollArray21    ; End
        dc.l    CollArray3K1    ; SSZ
        dc.l    CollArray3K1    ; ICZ
        dc.l    CollArray3K1    ; FCZ
        dc.l    CollArrayCD1    ; RTZ
        dc.l    CollArray21    ; SZ
		
CollArray2Table:
        dc.l    CollArray22    ; WOZ
        dc.l    CollArray22    ; TJZ
        dc.l    CollArray2    ; DDZ
        dc.l    CollArray3K2    ; KVZ
        dc.l    CollArray2    ; CCZ
        dc.l    CollArray3K2    ; ABZ
        dc.l    CollArray22    ; End
        dc.l    CollArray3K2    ; SSZ
        dc.l    CollArray3K2    ; ICZ
        dc.l    CollArray3K2    ; FCZ
        dc.l    CollArrayCD2    ; RTZ
        dc.l    CollArray22    ; SZ

AngleMapTable:
        dc.l    AngleMap2    ; WOZ
        dc.l    AngleMap2    ; TJZ
        dc.l    AngleMap    ; DDZ
        dc.l    AngleMap3K    ; KVZ
        dc.l    AngleMap    ; CCZ
        dc.l    AngleMap3K    ; ABZ
        dc.l    AngleMap2    ; End
        dc.l    AngleMap3K    ; SSZ
        dc.l    AngleMap3K    ; ICZ
        dc.l    AngleMap3K    ; FCZ
        dc.l    AngleMapCD    ; RTZ
        dc.l    AngleMap2    ; SZ

WaterTransition_WOZ:	dc.w 2
		dc.w $66
		dc.w $60
		dc.w $6C
WaterTransition_WOZ_End

Level_TtlCard:
		move.b	#$C,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		tst.l	($FFFFF680).w	; are there any	items in the pattern load cue?
		bne.s	Level_TtlCard	; if yes, branch
		jsr	Hud_Base

loc_3946:
		moveq	#3,d0
		bsr.w	PalLoad1	; load Sonic's pallet line
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	LoadZoneTiles	; load level art
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	ColIndexLoad
		bsr.w	TJZWaterEffects
		tst.w	($FFFFFFF0).w
		bmi.w	Level_ChkWater
		cmpi.b	#$18,($FFFFF600).w
		beq.s	Level_LoadCharacter
		cmpi.b	#$1C,($FFFFF600).w
		move.b	#$21,($FFFFB040).w ; load HUD object

Level_LoadCharacter:
		moveq	#0,d0
		cmpi.w	#1,(Current_Character).w
		beq.s	Level_Shadow
		cmpi.w	#2,(Current_Character).w
		beq.s	Level_Silver
		cmpi.w	#4,(Current_Character).w
		beq.s	Level_Knuckles
		moveq	#3,d0
		moveq	#$F,d1
		tst.w	(Current_Partner).w
		beq.s	Level_Sonic
		moveq	#$1A,d0
		moveq	#$1C,d1
		cmpi.w	#1,(Current_Partner).w
		beq.s	Level_Sonic
		moveq	#$20,d0
		moveq	#$F,d1

Level_Sonic:
		move.b	#1,($FFFFB000).w ; load	Sonic object
		tst.w	(Current_Character).w
		beq.s	Level_ChkPartner
		move.b	#$95,($FFFFB000).w ; load	Sonic object
		bra.s	Level_ChkPartner

Level_Silver:
		moveq	#$16,d0
		moveq	#$1E,d1
		cmpi.w	#2,(Current_Partner).w
		beq.s	Level_Silver2
		moveq	#$20,d0
		moveq	#$1E,d1
		tst.w	(Current_Partner).w
		beq.s	Level_Silver2
		moveq	#$21,d0
		moveq	#$1E,d1

Level_Silver2:
		move.b	#2,($FFFFB000).w ; load	Silver object
		bra.s	Level_ChkPartner

Level_Shadow:
		moveq	#$17,d0
		moveq	#$1D,d1
		cmpi.w	#1,(Current_Partner).w
		beq.s	Level_Shadow2
		moveq	#$1A,d0
		moveq	#$1C,d1
		tst.w	(Current_Partner).w
		beq.s	Level_Shadow2
		moveq	#$21,d0
		moveq	#$1D,d1

Level_Shadow2:
		move.b	#$8E,($FFFFB000).w ; load	Shadow object
		bra.s	Level_ChkPartner

Level_Knuckles:
		moveq	#$16,d0
		moveq	#$1E,d1
		cmpi.w	#2,(Current_Partner).w
		beq.s	Level_Knuckles2
		moveq	#$20,d0
		moveq	#$1E,d1
		tst.w	(Current_Partner).w
		beq.s	Level_Knuckles2
		moveq	#$21,d0
		moveq	#$1E,d1

Level_Knuckles2:
		move.b	#$97,($FFFFB000).w ; load	Silver object

Level_ChkPartner:
		tst.b	($FFFFFE10).w
		bne.s	Level_ChkPartner3
		move.b	d0,d1

Level_ChkPartner3:
		bsr.w	PalLoad2	; load Sonic's pallet line
		tst.b	($FFFFFE10).w
		beq.s	Level_ChkPartner2
		tst.b	(Water_flag).w
		beq.s	Level_ChkUW

Level_ChkPartner2:
		move.b	d1,d0
		bsr.w	PalLoad3_Water	; load Sonic's pallet line

Level_ChkUW:
		move.w	(Current_Character),d0
		move.w	(Current_Partner),d1
		cmp.w	d0,d1
		beq.s	Level_ChkDebug
		tst.w	(Current_Partner).w
		beq.s	Level_SonicP
		cmpi.w	#1,(Current_Partner).w
		beq.s	Level_ShadowP
		cmpi.w	#2,(Current_Partner).w
		beq.s	Level_SilverP
		cmpi.w	#3,(Current_Partner).w
		beq.s	Level_TailsP
		cmpi.w	#4,(Current_Partner).w
		beq.s	Level_KnucklesP
		bra.s	Level_ChkDebug

Level_SonicP:
		move.b	#1,($FFFFB380).w ; load	Sonic object
		bra.s	Level_ChkDebug

Level_SilverP:
		move.b	#2,($FFFFB380).w ; load	Silver object
		bra.s	Level_ChkDebug

Level_ShadowP:
		move.b	#$8E,($FFFFB380).w ; load	Shadow object
		bra.s	Level_ChkDebug

Level_TailsP:
		move.b	#$95,($FFFFB380).w ; load	Shadow object
		bra.s	Level_ChkDebug

Level_KnucklesP:
		move.b	#$97,($FFFFB380).w ; load	Shadow object

Level_ChkDebug:
		bset	#7,($FFFFB3A2).w
		tst.b	($FFFFFFE2).w	; has debug cheat been entered?
		beq.s	Level_ChkWater	; if not, branch
		btst	#6,($FFFFF604).w ; is A	button pressed?
		beq.s	Level_ChkWater	; if not, branch
		move.b	#1,($FFFFFFFA).w ; enable debug	mode

Level_ChkWater:
		move.w	#0,($FFFFF602).w
		move.w	#0,($FFFFF670).w
		move.w	#0,($FFFFF604).w
		move.w	#0,($FFFFF606).w
		move.b	#0,($FFFFF74F).w
		tst.b	(Water_flag).w	; does level have water?
		beq.s	Level_LoadObj	; if not, branch
		move.b	#$1B,($FFFFB780).w ; load water	surface	object
		move.w	#$60,($FFFFB788).w
		move.b	#$1B,($FFFFB7C0).w
		move.w	#$120,($FFFFB7C8).w

Level_LoadObj:
		jsr	ObjPosLoad
		move.b	#0,($FFFFFE17).w
		jsr	RingsManager
		jsr	ObjectsLoad
		jsr	BuildSprites
		moveq	#0,d0
		tst.b	($FFFFFE30).w	; are you starting from	a lamppost?
		bne.s	loc_39E8	; if yes, branch
		tst.l 	($FFFFF608).w
		bne.s 	loc_39E8
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE1B).w ; clear lives counter
		move.b	d0,($FFFFFE2D).w

loc_39E8:
		tst.l 	($FFFFF608).w
		bne.s 	Level_Update
		move.b	d0,($FFFFFE1A).w
		bclr	#1,($FFFFFE2C).w ; clear invincibility
		move.b	d0,($FFFFFE2E).w ; clear speed shoes
		move.b	d0,($FFFFFE2F).w

Level_Update:
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		move.b	d0,($FFFFFE07).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1F).w ; update score	counter
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w
		move.b	#0,($FFFFF746).w
		lea	(Demo_Index).l,a1 ; load demo data
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	Level_Demo	; if yes, branch
		lea	(Demo_EndIndex).l,a1 ; load ending demo	data
		move.w	($FFFFFFF4).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1

Level_Demo:
		move.b	1(a1),($FFFFF792).w ; load key press duration
		subq.b	#1,($FFFFF792).w ; subtract 1 from duration
		move.w	#1800,($FFFFF614).w
		tst.w	($FFFFFFF0).w
		bpl.s	Level_ChkWaterPal
		move.w	#540,($FFFFF614).w
		cmpi.w	#4,($FFFFFFF4).w
		bne.s	Level_ChkWaterPal
		move.w	#510,($FFFFF614).w

Level_ChkWaterPal:
	;	moveq	#$B,d0        ; pallet $1E (TJZ underwater)
	;	cmpi.b	#1,($FFFFFE10).w
	;	beq.s	ChkWaterPal
	;	moveq	#$15,d0        ; pallet $15 (KVZ underwater)
	;	cmpi.b	#3,($FFFFFE10).w
	;	beq.s	ChkWaterPal
	;	moveq	#$16,d0        ; pallet $16 (ABZ underwater)
	;	cmpi.b	#5,($FFFFFE10).w	
	;	bne.s	Level_Delay
	;	cmpi.b	#2,($FFFFFE11).w	
	;	beq.s	Level_Delay
; ===========================================================================

ChkWaterPal:
	;	bsr.w	PalLoad4_Water

Level_Delay:
		move.w	#3,d1

Level_DelayLoop:
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		dbf	d1,Level_DelayLoop

		move.w	#$202F,($FFFFF626).w
		bsr.w	Pal_FadeTo2
	;	tst.w	($FFFFFFF0).w
	;	bpl.s	Level_GetBgm
; ===========================================================================

Level_ClrCardArt:

Level_GetBgm:
		tst.w	($FFFFFFF0).w
		bmi.w	Level_StartGame	; change from bmi.s to bmi.w or you'll get an error
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
 
		cmpi.b	#$0,($FFFFFE11).w	; is this act 1?
		bne.s	Level_GetBgm2	; if not, branch
		lea	(MusicList1).l,a1	; load Music Playlist for Acts 1
		bra.s	Level_PlayBgm	; go to PlayBgm
 
Level_GetBgm2:
		cmpi.b	#$1,($FFFFFE11).w	; is this act 2?
		bne.s	Level_GetBgm3	; if not, branch
		lea	(MusicList2).l,a1	; load Music Playlist for Acts 2
		bra.s	Level_PlayBgm	; go to PlayBgm
 
Level_GetBgm3:
		cmpi.b	#$2,($FFFFFE11).w	; is this act 3?
		bne.s	Level_GetBgm4	; if not, branch
		lea	(MusicList3).l,a1	; load Music Playlist for Acts 3
		bra.s	Level_PlayBgm	; go to PlayBgm
 
Level_GetBgm4:
		cmpi.b	#$3,($FFFFFE11).w	; is this act 4?
		bne.s	Level_PlayBgm	; if not, branch
		lea	(MusicList4).l,a1	; load Music Playlist for Acts 4
 
Level_PlayBgm:
		move.b	(a1,d0.w),d0	; add d0 to a1
		move.b	d0,($FFFFF75D).w	; store level music
		bsr.w	PlaySound	; play music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w

Level_StartGame:
		move.b	#1,($FFFFF74F).w
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.b	#$38,($FFFFB180).w ; load "shield" object
	;	cmpi.w	#2,($FFFFFE10).w
	;	bne.s	Level_StartGame3
	;	move.b	#$8D,($FFFFB180).w	; load WOZ boss	object
	;	bra.s	Level_StartGame2

Level_StartGame3:
		jsr	BuildSprites
		bclr	#7,($FFFFF600).w ; subtract 80 from screen mode

; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

Level_MainLoop:
		bsr.w	PauseGame
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		bsr.w	TJZWaterEffects
		bsr.w	WallRunning
		jsr	ObjectsLoad
		tst.w	($FFFFFE02).w	; is the level set to restart?
		bne.w	Level		; if yes, branch
		tst.b	($FFFFFE13).w	; is the level set to restart?
		bne.w	ContinueLevel		; if yes, branch	
		jsr	RingsManager
		tst.w	($FFFFFE08).w
		bne.s	loc_3B10
		cmpi.b	#6,($FFFFB024).w
		bcc.s	loc_3B14

loc_3B10:
		bsr.w	DeformBgLayer

loc_3B14:
		jsr	BuildSprites
		jsr	ObjPosLoad	
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		bsr.w	SignpostArtLoad
		cmpi.b	#8,($FFFFF600).w
		beq.s	Level_ChkDemo	; if screen mode is 08 (demo), branch
		cmpi.b	#$C,($FFFFF600).w
		beq.w	Level_MainLoop	; if screen mode is $0C	(level), branch
		rts	
; ===========================================================================

Level_ChkDemo:				; XREF: Level_MainLoop
		tst.w	($FFFFFE02).w	; is level set to restart?
		bne.s	Level_EndDemo	; if yes, branch
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.s	Level_EndDemo	; if not, branch
		cmpi.b	#8,($FFFFF600).w
		beq.w	Level_MainLoop	; if screen mode is 08 (demo), branch
		move.b	#0,($FFFFF600).w ; go to Sega screen
		rts	
; ===========================================================================

Level_EndDemo:				; XREF: Level_ChkDemo
		cmpi.b	#8,($FFFFF600).w ; is screen mode 08 (demo)?
		bne.s	loc_3B88	; if not, branch
		move.b	#0,($FFFFF600).w ; go to Sega screen
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	loc_3B88	; if yes, branch
		move.b	#$1C,($FFFFF600).w ; go	to credits

loc_3B88:
		move.w	#$3C,($FFFFF614).w
		move.w	#$3F,($FFFFF626).w

loc_3B98:
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	ObjPosLoad
		bsr.w	Pal_FadeOut

loc_3BC8:
		tst.w	($FFFFF614).w
		bne.s	loc_3B98
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	do special water effects in Labyrinth Zone
; ---------------------------------------------------------------------------

TJZWaterEffects:				; XREF: Level
		tst.b	($FFFFFE10).w
		beq.s	TJZWOZ
		tst.b	(Water_flag).w
		beq.s	locret_3C28
		tst.b	($FFFFF744).w
		bne.s	TJZMoveWater
		cmpi.b 	#6,($FFFFB024).w
		bcc.s	TJZMoveWater
		cmpi.b	#3,($FFFFFE10).w
		beq.s	TJZMoveWater

TJZWaterEffects_Cont:
		bsr.w	TJZWindTunnels
		bsr.w	TJZDynamicWater

TJZMoveWater:
		clr.b	($FFFFF64E).w
		moveq	#0,d0
		move.b	($FFFFFE60).w,d0
		lsr.w	#1,d0
		add.w	($FFFFF648).w,d0
		move.w	d0,($FFFFF646).w
		move.w	($FFFFF646).w,d0
		sub.w	($FFFFF704).w,d0
		bcc.s	loc_3C1A
		tst.w	d0
		bpl.s	loc_3C1A
		move.b	#-$21,($FFFFF625).w
		move.b	#1,($FFFFF64E).w

loc_3C1A:
		cmpi.w	#$DF,d0
		bcs.s	loc_3C24
		move.w	#$DF,d0

loc_3C24:
		move.b	d0,($FFFFF625).w

locret_3C28:
		rts	

TJZWOZ:
		move.b	#$97,($FFFFF625).w ; enable water
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Default water heights
; ---------------------------------------------------------------------------
WaterHeight:	
		dc.w $FFF, $FFF, $FFF, $FFF; 0 - WOZ
		dc.w $C00, $328, $900, $FFF; 1 - TJZ
		dc.w $FFF, $FFF, $FFF, $FFF; 2 - DDZ
		dc.w $C00, $C00, $C00, $FFF; 3 - KVZ
		dc.w $FFF, $FFF, $FFF, $FFF; 4 - CCZ
		dc.w $500, $A00, $200, $FFF; 5 - ABZ
		dc.w $FFF, $FFF, $FFF, $FFF; 6 - END
; ===========================================================================

; ---------------------------------------------------------------------------
; Labyrinth dynamic water routines
; ---------------------------------------------------------------------------

TJZDynamicWater:				; XREF: TJZWaterEffects
		rts
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	DynWater_Index(pc,d0.w),d0
		jsr	DynWater_Index(pc,d0.w)
		moveq	#0,d1
		move.b	($FFFFF64C).w,d1
		move.w	($FFFFF64A).w,d0
		sub.w	($FFFFF648).w,d0
		beq.s	locret_3C5A
		bcc.s	loc_3C56
		neg.w	d1

loc_3C56:
		add.w	d1,($FFFFF648).w

locret_3C5A:
		rts	
; ===========================================================================
DynWater_Index:	dc.w DynWater_TJZ1-DynWater_Index
		dc.w DynWater_TJZ2-DynWater_Index
		dc.w DynWater_TJZ3-DynWater_Index
		dc.w DynWater_ABZ3-DynWater_Index
; ===========================================================================

DynWater_TJZ1:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3CD0
		move.w	#$B8,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		cmpi.w	#$200,($FFFFB00C).w
		bcs.s	loc_3CBA
		cmpi.w	#$C00,d0
		bcs.s	loc_3CB4
		move.w	#$318,d1
		cmpi.w	#$1080,d0
		bcs.s	loc_3CB4
		move.b	#-$80,($FFFFF7E5).w
		move.w	#$5C8,d1
		cmpi.w	#$1380,d0
		bcs.s	loc_3CB4
		move.w	#$3A8,d1
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3CB4
		move.b	#1,($FFFFF64D).w

loc_3CB4:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3CBA:				; XREF: DynWater_TJZ1
		cmpi.w	#$C80,d0
		bcs.s	loc_3CB4
		move.w	#$E8,d1
		cmpi.w	#$1500,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		bra.s	loc_3CB4
; ===========================================================================

loc_3CD0:				; XREF: DynWater_TJZ1
		subq.b	#1,d2
		bne.s	locret_3CF4
		cmpi.w	#$2E0,($FFFFB00C).w
		bcc.s	locret_3CF4
		move.w	#$3A8,d1
		cmpi.w	#$1300,d0
		bcs.s	loc_3CF0
		move.w	#$108,d1
		move.b	#2,($FFFFF64D).w

loc_3CF0:
		move.w	d1,($FFFFF64A).w

locret_3CF4:
		rts	
; ===========================================================================

DynWater_TJZ2:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.w	#$328,d1
		cmpi.w	#$500,d0
		bcs.s	loc_3D12
		move.w	#$3C8,d1
		cmpi.w	#$B00,d0
		bcs.s	loc_3D12
		move.w	#$428,d1

loc_3D12:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

DynWater_TJZ3:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3D5E
		move.w	#$900,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3D54
		cmpi.w	#$3C0,($FFFFB00C).w
		bcs.s	loc_3D54
		cmpi.w	#$600,($FFFFB00C).w
		bcc.s	loc_3D54
		move.w	#$4C8,d1
		move.l	#Level_TJZ3,($FFFF8000).w		; MJ: Set normal version of act 3's layout to be read
		move.b	#1,($FFFFF64D).w
		move.w	#$6F,d0
		bsr.w	PlaySound_Special ; play sound $B7 (rumbling)

loc_3D54:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3D5E:				; XREF: DynWater_TJZ3
		subq.b	#1,d2
		bne.s	loc_3DA8
		move.w	#$4C8,d1
		cmpi.w	#$770,d0
		bcs.s	loc_3DA2
		move.w	#$308,d1
		cmpi.w	#$1400,d0
		bcs.s	loc_3DA2
		cmpi.w	#$508,($FFFFF64A).w
		beq.s	loc_3D8E
		cmpi.w	#$600,($FFFFB00C).w
		bcc.s	loc_3D8E
		cmpi.w	#$280,($FFFFB00C).w
		bcc.s	loc_3DA2

loc_3D8E:
		move.w	#$508,d1
		move.w	d1,($FFFFF648).w
		cmpi.w	#$1770,d0
		bcs.s	loc_3DA2
		move.b	#2,($FFFFF64D).w

loc_3DA2:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DA8:
		subq.b	#1,d2
		bne.s	loc_3DD2
		move.w	#$508,d1
		cmpi.w	#$1860,d0
		bcs.s	loc_3DCC
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcc.s	loc_3DC6
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3DCC

loc_3DC6:
		move.b	#3,($FFFFF64D).w

loc_3DCC:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DD2:
		subq.b	#1,d2
		bne.s	loc_3E0E
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcs.s	loc_3E04
		move.w	#$900,d1
		cmpi.w	#$1BC0,d0
		bcs.s	loc_3E04
		move.b	#4,($FFFFF64D).w
		move.w	#$608,($FFFFF64A).w
		move.w	#$7C0,($FFFFF648).w
		move.b	#1,($FFFFF7E8).w
		rts	
; ===========================================================================

loc_3E04:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3E0E:
		cmpi.w	#$1E00,d0
		bcs.s	locret_3E1A
		move.w	#$128,($FFFFF64A).w

locret_3E1A:
		rts	
; ===========================================================================

DynWater_ABZ3:				; XREF: DynWater_Index
		move.w	#$228,d1
		cmpi.w	#$F00,($FFFFF700).w
		bcs.s	loc_3E2C
		move.w	#$4C8,d1

loc_3E2C:
		move.w	d1,($FFFFF64A).w
		rts

; ---------------------------------------------------------------------------
; Labyrinth Zone "wind tunnels"	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TJZWindTunnels:				; XREF: TJZWaterEffects
		cmpi.b	#5,($FFFFFE10).w
		bra.w	locret_3EF2
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret_3F0A	; if yes, branch
		lea	(TJZWind_Data).l,a2
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		lsl.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1
	;	tst.b	($FFFFFE11).w
	;	bne.s	loc_3E56
	;	moveq	#1,d1
	;	subq.w	#8,a2

loc_3E56:
		lea	($FFFFB000).w,a1

TJZWind_Loop:
		move.w	8(a1),d0
		cmp.w	(a2),d0
		bcs.w	loc_3EF4
		cmp.w	4(a2),d0
		bcc.w	loc_3EF4
		move.w	$C(a1),d2
		cmp.w	2(a2),d2
		bcs.s	loc_3EF4
		cmp.w	6(a2),d2
		bcc.s	loc_3EF4
		move.b	($FFFFFE0F).w,d0
		andi.b	#$3F,d0
		bne.s	loc_3E90
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play rushing water sound

loc_3E90:
		tst.b	($FFFFF7C9).w
		bne.w	locret_3F0A
		cmpi.b	#4,$24(a1)
		bcc.s	loc_3F06
		move.b	#1,($FFFFF7C7).w
		subi.w	#$80,d0
		cmp.w	(a2),d0
		bcc.s	TJZWind_Move
		moveq	#2,d0
		cmpi.b	#1,($FFFFFE11).w
		bne.s	loc_3EBA
		neg.w	d0

loc_3EBA:
		add.w	d0,$C(a1)

TJZWind_Move:
		addq.w	#4,8(a1)
		move.w	#$400,$10(a1)	; move Sonic horizontally
		move.w	#0,$12(a1)
		move.b	#$14,$1C(a1)	; use floating animation
		bset	#1,$22(a1)
		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	TJZWind_MoveDown	; if not, branch
		subq.w	#1,$C(a1)	; move Sonic up

TJZWind_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret_3EF2	; if not, branch
		addq.w	#1,$C(a1)	; move Sonic down

locret_3EF2:
		rts	
; ===========================================================================

loc_3EF4:				; XREF: TJZWindTunnels
		addq.w	#8,a2
		dbf	d1,TJZWind_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret_3F0A
		move.b	#0,$1C(a1)

loc_3F06:
		clr.b	($FFFFF7C7).w

locret_3F0A:
		rts	
; End of function TJZWindTunnels

; ===========================================================================
TJZWind_Data:				; XREF: TJZWindTunnels
		even
; ---------------------------------------------------------------------------
; Wall running subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


WallRunning:				; XREF: TJZWaterEffects
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret2_3F0A	; if yes, branch
		lea	(WallRun_Data).l,a2
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1

WallRun_Loop:
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		cmp.w	(a2),d0
		bcs.w	loc2_3EF4
		cmp.w	4(a2),d0
		bcc.w	loc2_3EF4
		move.w	$C(a1),d2
		cmp.w	2(a2),d2
		bcs.w	loc2_3EF4
		cmp.w	6(a2),d2
		bcc.w	loc2_3EF4
		tst.b	($FFFFF7C9).w
		bne.w	locret2_3F0A
		cmpi.b	#4,$24(a1)
		bcc.w	loc2_3F06
		move.b	#1,($FFFFF7C7).w

WallRun_Move:
		cmpi.b	#$10,$1C(a1)
		beq.w	locret2_3EF2
		tst.b	$2F(a1)
		bne.s	locret2_3EF2
		move.b	$22(a1),d0
		btst	#1,d0
		beq.s	WallRun_Move2
		btst	#2,d0
		bne.w	loc2_3F06

WallRun_Move2:
		move.b	($FFFFF603).w,d0
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	loc2_3F0A	
		move.w	$10(a1),d0	; get Sonic's speed
		cmpi.w	#2,($FFFFFE10).w
		beq.s	loc4_13A9E
		move.w	$10(a1),d0	; get Sonic's speed
		bpl.s	loc4_13A9C
		neg.w	d0
		add.w	#8,$10(a1)
		btst	#3,($FFFFF602).w ; is right being pressed?
		bne.s	loc2_3F08
		bra.s	loc4_13A9E

loc4_13A9C:
		sub.w	#8,$10(a1)
		btst	#2,($FFFFF602).w ; is left being pressed?
		bne.s	loc2_3F08

loc4_13A9E:
		cmpi.w	#$400,d0	; is Sonic at running speed?
		bcs.s	loc2_3F08	; if yes, branch
		move.w	#0,$12(a1)
		move.b	#$1D,$1C(a1)	; use floating animation
		bset	#1,$22(a1)
		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	WallRun_MoveDown	; if not, branch
		subq.w	#2,$C(a1)	; move Sonic up

WallRun_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret2_3EF2	; if not, branch
		addq.w	#2,$C(a1)	; move Sonic down

locret2_3EF2:
		rts	
; ===========================================================================

loc2_3EF4:				; XREF: TJZWindTunnels
		addq.w	#8,a2
		dbf	d1,WallRun_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret2_3F0A
		move.b	#0,$1C(a1)

loc2_3F06:
		clr.b	($FFFFF7C7).w

locret2_3F0A:
		rts	

loc2_3F0A:
		move.w	#$60,d0
		jsr	PlaySound ;	play jumping sound

loc2_3F08:
		clr.b	($FFFFF7C7).w
		bset	#2,$22(a1)
		move.b #$C,$1C(a1)  ; use falling animation
		rts
; End of function WallRunning

; ===========================================================================
WallRun_Data:
	dc.w $280, $3A0, $680,	$4D0
	dc.w $1F8, $100, $580,	$200
	dc.w $1F8, $100, $580,	$200
		even

; ---------------------------------------------------------------------------
; Labyrinth Zone water slide subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TJZWaterSlides:				; XREF: TJZWaterEffects
		cmpi.b	#5,($FFFFFE10).w
		bra.s	locret_3F7A
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_3F6A
		move.w	$0C(a1),d0				; MJ: Load Y position
		move.w	$08(a1),d1				; MJ: Load X position
		and.w	#$0780,d0				; MJ: keep Y position within 800 pixels (in multiples of 80)
		lsl.w	#$01,d0					; MJ: multiply by 2 (Because every 80 bytes switch from FG to BG..)
		lsr.w	#$07,d1					; MJ: divide X position by 80 (00 = 0, 80 = 1, etc)
		and.b	#$7F,d1					; MJ: keep within 4000 pixels (4000 / 80 = 80)
		add.w	d1,d0					; MJ: add together
		movea.l	($FFFF8000).w,a2			; MJ: Load address of layout
		move.b	(a2,d0.w),d0				; MJ: collect correct chunk ID based on the position of Sonic
		lea	Slide_Chunks(pc),a2
		moveq	#$00,d1					; MJ: clear d2
		bra	TJZLoadChunk				; MJ: continue

TJZFindChunk:
		cmp.b	d2,d0					; MJ: does the chunk match?
		beq	TJZSlide_Move				; MJ: if so, branch
		addq.w	#$01,d1					; MJ: increase counter

TJZLoadChunk:
		move.b	(a2)+,d2				; MJ: load chunk ID
		bne	TJZFindChunk				; MJ: if it's not null, branch

loc_3F6A:
		tst.b	($FFFFF7CA).w
		beq.s	locret_3F7A
		move.w	#5,$3E(a1)
		clr.b	($FFFFF7CA).w

locret_3F7A:
		rts	
; ===========================================================================

TJZSlide_Move:				; XREF: TJZWaterSlides
		cmpi.w	#3,d1
		bcc.s	loc_3F84
		nop	

loc_3F84:
		bclr	#0,$22(a1)
		move.b	Slide_Speeds(pc,d1.w),d0
		move.b	d0,$20(a1)
		bpl.s	loc_3F9A
		bset	#0,$22(a1)

loc_3F9A:
		clr.b	$15(a1)
		move.b	#$1B,$1C(a1)	; use Sonic's "sliding" animation
		move.b	#1,($FFFFF7CA).w ; lock	controls (except jumping)
		move.b	($FFFFFE0F).w,d0
		andi.b	#$1F,d0
		bne.s	locret_3FBE
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play water sound

locret_3FBE:
		rts	
; End of function TJZWaterSlides

; ===========================================================================
; ---------------------------------------------------------------------------
Slide_Chunks:	dc.b	$DF,$E0,$E1,$E2
		dc.b	$E3,$E4,$E5,$E6
		dc.b	$E7,$E8
		dc.b	$00					; MJ: End marker
		even
; ---------------------------------------------------------------------------
Slide_Speeds:	dc.b	$0A,$F6,$0A,$0A				; MJ: Values for speed, format XX00 = Speed in $20(a-)
		dc.b	$F6,$F6,$0A,$0A
		dc.b	$F6,$F6
		even
; ---------------------------------------------------------------------------
; ===========================================================================
; ---------------------------------------------------------------------------
; Demo sequence	pointers
; ---------------------------------------------------------------------------
Demo_Index:
	include "_inc\Demo pointers for intro.asm"

Demo_EndIndex:
	include "_inc\Demo pointers for ending.asm"

		dc.b 0,	$8B, 8,	$37, 0,	$42, 8,	$5C, 0,	$6A, 8,	$5F, 0,	$2F, 8,	$2C
		dc.b 0,	$21, 8,	3, $28,	$30, 8,	8, 0, $2E, 8, $15, 0, $F, 8, $46
		dc.b 0,	$1A, 8,	$FF, 8,	$CA, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		even

; ---------------------------------------------------------------------------
; Collision index loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ColIndexLoad:				; XREF: Level
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#$03,d0					; MJ: multiply by 8 not 4
		move.l	ColPointers(pc,d0.w),($FFFFFFD0).w	; MJ: get first collision set
		add.w	#$04,d0					; MJ: increase to next location
		move.l	ColPointers(pc,d0.w),($FFFFFFD4).w	; MJ: get second collision set
		rts	
; End of function ColIndexLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision index pointers
; ---------------------------------------------------------------------------
ColPointers:
	include "_inc\Collision index pointers.asm"

; ---------------------------------------------------------------------------
; Oscillating number subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumInit:			; XREF: Level
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data).l,a2
		moveq	#$20,d1

Osc_Loop:
		move.w	(a2)+,(a1)+
		dbf	d1,Osc_Loop
		rts	
; End of function OscillateNumInit

; ===========================================================================
Osc_Data:	dc.w $7C, $80		; baseline values
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$50F0
		dc.w $11E, $2080
		dc.w $B4, $3080
		dc.w $10E, $5080
		dc.w $1C2, $7080
		dc.w $276, $80
		dc.w 0,	$80
		dc.w 0
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumDo:				; XREF: Level
		cmpi.b	#6,($FFFFB024).w
		bcc.s	locret_41C4
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data2).l,a2
		move.w	(a1)+,d3
		moveq	#$F,d1

loc_4184:
		move.w	(a2)+,d2
		move.w	(a2)+,d4
		btst	d1,d3
		bne.s	loc_41A4
		move.w	2(a1),d0
		add.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bhi.s	loc_41BA
		bset	d1,d3
		bra.s	loc_41BA
; ===========================================================================

loc_41A4:				; XREF: OscillateNumDo
		move.w	2(a1),d0
		sub.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bls.s	loc_41BA
		bclr	d1,d3

loc_41BA:
		addq.w	#4,a1
		dbf	d1,loc_4184
		move.w	d3,($FFFFFE5E).w

locret_41C4:
		rts	
; End of function OscillateNumDo

; ===========================================================================
Osc_Data2:	dc.w 2,	$10		; XREF: OscillateNumDo
		dc.w 2,	$18
		dc.w 2,	$20
		dc.w 2,	$30
		dc.w 4,	$20
		dc.w 8,	8
		dc.w 8,	$40
		dc.w 4,	$40
		dc.w 2,	$50
		dc.w 2,	$50
		dc.w 2,	$20
		dc.w 3,	$30
		dc.w 5,	$50
		dc.w 7,	$70
		dc.w 2,	$10
		dc.w 2,	$10
		even

; ---------------------------------------------------------------------------
; Subroutine to	change object animation	variables (rings, giant	rings)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChangeRingFrame:			; XREF: Level
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_421C
		move.b	#$B,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_421C:
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_4232
		move.b	#3,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#7,($FFFFFEC3).w
		movea.l	#RingDynPLC,a2	; get DPLC location
		move.w	#$D800,d4		; offset in VRAM to store art
		move.l	#Art_Ring,d6	; get art location
		moveq	#0,d0
		move.b	($FFFFFEC3).w,d0	; load frame number
		jsr 	Load_DPLC

loc_171EC2:

loc_4232:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_4250
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		cmpi.b	#6,($FFFFFEC5).w
		bcs.s	loc_4250
		move.b	#0,($FFFFFEC5).w

loc_4250:
		tst.b	($FFFFFEC6).w
		beq.s	locret_4272
		moveq	#0,d0
		move.b	($FFFFFEC6).w,d0
		add.w	($FFFFFEC8).w,d0
		move.w	d0,($FFFFFEC8).w
		rol.w	#7,d0
		andi.w	#3,d0
		move.b	d0,($FFFFFEC7).w
		subq.b	#1,($FFFFFEC6).w

locret_4272:
		rts	
; End of function ChangeRingFrame

; ---------------------------------------------------------------------------
; End-of-act signpost pattern loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SignpostArtLoad:			; XREF: Level
		cmpi.b	#2,($FFFFFE11).w ; is act number 02 (act 3)?
		beq.s	Signpost_Exit	; if yes, branch
		tst.b	($FFFFFE1E).w
		beq.s	Signpost_Exit
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	Signpost_Exit	; if yes, branch
		move.w	($FFFFF700).w,d0
		move.w	($FFFFF72A).w,d1
		cmpi.w	#$3E80,($FFFFF72A).w
		bne.s	Signpost_Exit
		cmp.w	d1,d0		; has Sonic reached the	edge of	the level?
		blt.s	Signpost_Exit	; if not, branch
		moveq	#$12,d0
		bsr.w	LoadPLC2	; load signpost	patterns
		addi.w	#$A0,d1
		move.w	($FFFFB00C).w,d2
		subi.w	#$A0,d2
		move.b	#$D,($FFFFB780).w	; load signpost object
		move.w	d1,($FFFFB788).w
		move.w	d2,($FFFFB78C).w
; ===========================================================================

Signpost_Exit:
		rts	
; End of function SignpostArtLoad

; ===========================================================================
Demo_WOZ:	incbin	demodata\i_WOZ.bin
Demo_DDZ:	incbin	demodata\i_DDZ.bin
Demo_CCZ:	incbin	demodata\i_CCZ.bin
Demo_SS:	incbin	demodata\i_ss.bin
; ===========================================================================

ContinueLevel:					; XREF: GameModeArray
		move.b	#0,($FFFFFE13).w
		move.b	#1,($FFFFF7A6).w
		bset	#7,($FFFFF600).w ; add $80 to screen mode (for pre level sequence)

loc2_37B6:
	;	bsr.w	ClearPLC
	;	move	#$2300,sr
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	CLevel_ClrRam
		bsr.w	LoadPLC		; load level patterns

CLevel_ClrRam:
		lea	($FFFFB800).w,a1
		moveq	#0,d0
		move.w	#$5FF,d1

CLevel_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,CLevel_ClrObjRam ; clear object RAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1

CLevel_ClrVars:
		move.l	d0,(a1)+
		dbf	d1,CLevel_ClrVars ; clear misc variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#9,d1

CLevel_ClrVars2:
		move.l	d0,(a1)+
		dbf	d1,CLevel_ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1

CLevel_ClrVars3:
		move.l	d0,(a1)+
		dbf	d1,CLevel_ClrVars3 ; clear object variables
		cmpi.b	#1,($FFFFFE10).w	
		beq.s	CLevel_InitWater
		cmpi.b	#3,($FFFFFE10).w	
		beq.s	CLevel_InitWater
		cmpi.b	#5,($FFFFFE10).w	
		bne.s	CLevel_NoPal
		cmpi.b	#2,($FFFFFE11).w	
		beq.s	CLevel_NoPal

CLevel_InitWater:
		move.b	#1,(Water_flag).w
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		ror.b	#2,d0
		lsr.w	#6,d0
		add.w	d0,d0
		lea	(WaterHeight).l,a1 ; load water	height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement
		move.b	#1,($FFFFF64C).w ; enable water
		move.w	#$1E,($FFFFFE14).w
	;	move	#$2300,sr
		moveq	#$26,d0		; pallet number	$26 (WOZ)
	;	tst.b	($FFFFFE10).w ; is WOZ?
	;	beq.s	CLevel_WaterPal	; if so, branch
		moveq	#$B,d0		; pallet number	$B (TJZ)
		cmpi.b	#1,($FFFFFE10).w ; is TJZ?
		beq.s	CLevel_WaterPal	; if so, branch
		moveq	#$F,d0		; pallet number	$F (KVZ)
		cmpi.b	#3,($FFFFFE10).w ; is KVZ?
		beq.s	CLevel_WaterPal	; if so, branch
		moveq	#$E,d0		; pallet number	$10 (ABZ)

CLevel_WaterPal:
		bsr.w	PalLoad3_Water	; load underwater pallet (see d0)
		tst.b	($FFFFFE30).w
		beq.s	CLevel_LoadCol
		move.b	($FFFFFE53).w,($FFFFF64E).w
		bra.s	CLevel_LoadCol

CLevel_NoPal:
		move.b	#0,(Water_flag).w
		move.b	#0,($FFFFF64C).w ; enable water
		move.w	#$1E,($FFFFFE14).w
	;	move	#$2300,sr
		clr.l	($FFFFF646).w ; set water heights
		clr.l	($FFFFF64A).w
		clr.b	($FFFFF64E).w	; clear	water movement

CLevel_LoadCol:
		moveq 	#0,d0
		move.b 	($FFFFFE10).w,d0
		add.w	d0,d0				; multiply d3 by x2
		add.w	d0,d0				; multiply d3 by x2 again (x4)
		move.l	CollArray1Table2(pc,d0.w),($FFFFF784).w
		move.l	CollArray2Table2(pc,d0.w),($FFFFF788).w
		move.l	AngleMapTable2(pc,d0.w),($FFFFF78C).w 	
		bra.s 	CLevel_TtlCard

CollArray1Table2:
        dc.l    CollArray21    ; WOZ
        dc.l    CollArray21    ; TJZ
        dc.l    CollArray1    ; DDZ
        dc.l    CollArray3K1    ; KVZ
        dc.l    CollArray1    ; CCZ
        dc.l    CollArray3K1    ; ABZ
        dc.l    CollArray21    ; End
        dc.l    CollArray3K1    ; SSZ
		
CollArray2Table2:
        dc.l    CollArray22    ; WOZ
        dc.l    CollArray22    ; TJZ
        dc.l    CollArray2    ; DDZ
        dc.l    CollArray3K2    ; KVZ
        dc.l    CollArray2    ; CCZ
        dc.l    CollArray3K2    ; ABZ
        dc.l    CollArray22    ; End
        dc.l    CollArray3K2    ; SSZ

AngleMapTable2:
        dc.l    AngleMap2    ; WOZ
        dc.l    AngleMap2    ; TJZ
        dc.l    AngleMap    ; DDZ
        dc.l    AngleMap3K    ; KVZ
        dc.l    AngleMap    ; CCZ
        dc.l    AngleMap3K    ; ABZ
        dc.l    AngleMap2    ; End
        dc.l    AngleMap3K    ; SSZ

CLevel_TtlCard:
;		move.b	#$C,($FFFFF62A).w
;		bsr.w	DelayProgram
;		jsr	ObjectsLoad
;		jsr	BuildSprites
;		bsr.w	RunPLC_RAM
;		tst.l	($FFFFF680).w	; are there any	items in the pattern load cue?
;		bne.s	CLevel_TtlCard	; if yes, branch
;		jsr	Hud_Base

loc2_3946:
;		moveq	#3,d0
;		bsr.w	PalLoad1	; load Sonic's pallet line
		bsr.w	LevelSizeLoad
;		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	LoadZoneTiles	; load level art
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	ColIndexLoad
;		bsr.w	TJZWaterEffects

CLevel_LoadObj:
		move.b	#0,($FFFFF76C).w
		jsr	ObjPosLoad
		move.b	#0,($FFFFFE17).w
		jsr	RingsManager
;		jsr	ObjectsLoad
;		jsr	BuildSprites
		moveq	#0,d0
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE1B).w ; clear lives counter
		move.b	d0,($FFFFFE2D).w

CLevel_Update:
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		move.b	d0,($FFFFFE07).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1F).w ; update score	counter
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w
		move.b	#0,($FFFFF746).w
		move.b	#0,($FFFFB5C0).w
	;	move.w	#1800,($FFFFF614).w

CLevel_Delay:
		move.w	#3,d1

CLevel_DelayLoop:
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		dbf	d1,CLevel_DelayLoop

; ===========================================================================

CLevel_GetBgm:
;		tst.w	($FFFFFFF0).w
;		bmi.w	CLevel_StartGame	; change from bmi.s to bmi.w or you'll get an error
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
 
		cmpi.b	#$0,($FFFFFE11).w	; is this act 1?
		bne.s	CLevel_GetBgm2	; if not, branch
		lea	(MusicList1).l,a1	; load Music Playlist for Acts 1
		bra.s	CLevel_PlayBgm	; go to PlayBgm
 
CLevel_GetBgm2:
		cmpi.b	#$1,($FFFFFE11).w	; is this act 2?
		bne.s	CLevel_GetBgm3	; if not, branch
		lea	(MusicList2).l,a1	; load Music Playlist for Acts 2
		bra.s	CLevel_PlayBgm	; go to PlayBgm
 
CLevel_GetBgm3:
		cmpi.b	#$2,($FFFFFE11).w	; is this act 3?
		bne.s	CLevel_GetBgm4	; if not, branch
		lea	(MusicList3).l,a1	; load Music Playlist for Acts 3
		bra.s	CLevel_PlayBgm	; go to PlayBgm
 
CLevel_GetBgm4:
		cmpi.b	#$3,($FFFFFE11).w	; is this act 4?
		bne.s	CLevel_PlayBgm	; if not, branch
		lea	(MusicList4).l,a1	; load Music Playlist for Acts 4
 
CLevel_PlayBgm:
		move.b	(a1,d0.w),d0	; add d0 to a1
		move.b	d0,($FFFFF75D).w	; store level music
		bsr.w	PlaySound	; play music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w

CLevel_StartGame:
		move.b	#0,($FFFFF7A6).w
		move.b	#1,($FFFFF74F).w
		clr.b	($FFFFF7CC).w	; unlock controls

CLevel_StartGame3:
;		jsr	BuildSprites
		bclr	#7,($FFFFF600).w ; subtract 80 from screen mode
		move.b	#0,($FFFFF7C8).w 		; fully unlock the controls

		jmp	Level_MainLoop

; ---------------------------------------------------------------------------
; Bonus Stage
; ---------------------------------------------------------------------------

BonusStage:				; XREF: GameModeArray
		move.w	#$AF,d0
		bsr.w	PlaySound_Special ; play special stage entry sound
		bsr.w	Pal_MakeFlash
		move	#$2700,sr
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8004,(a6)
		move.w	#$8AAF,($FFFFF624).w
		move.w	#$9001,(a6)
		move.w	($FFFFF60C).w,d0
		andi.b	#$BF,d0
		move.w	d0,($C00004).l
		bsr.w	ClearScreen
		move	#$2300,sr
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$946F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$50000081,(a5)
		move.w	#0,($C00000).l

loc_463C:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_463C
		move.w	#$8F02,(a5)
		bsr.w	SS_BGLoad
		moveq	#$14,d0
		bsr.w	RunPLC_ROM	; load special stage patterns
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

SS_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,SS_ClrObjRam	; clear	the object RAM

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

SS_ClrRam:
		move.l	d0,(a1)+
		dbf	d1,SS_ClrRam	; clear	variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$27,d1

SS_ClrRam2:
		move.l	d0,(a1)+
		dbf	d1,SS_ClrRam2	; clear	variables

		lea	($FFFFAA00).w,a1
		moveq	#0,d0
		move.w	#$7F,d1

SS_ClrNemRam:
		move.l	d0,(a1)+
		dbf	d1,SS_ClrNemRam	; clear	Nemesis	buffer

		clr.b	($FFFFF64E).w
		clr.w	($FFFFFE02).w
		moveq	#$A,d0
		bsr.w	PalLoad1	; load special stage pallet
		moveq	#3,d0
		tst.w	(Current_Character).w
		beq.s	SS_Cont
		moveq	#$17,d0
		cmpi.w	#1,(Current_Character).w
		beq.s	SS_Cont
		moveq	#$16,d0
		cmpi.w	#2,(Current_Character).w
		beq.s	SS_Cont
		moveq	#3,d0
		cmpi.w	#3,(Current_Character).w
		beq.s	SS_Cont
		moveq	#3,d0

SS_Cont:
		bsr.w	PalLoad1	; load special stage pallet
		jsr	SS_Load	
		move.b	#0,($FFFFF74F).w
		move.l	#0,($FFFFF700).w
		move.l	#0,($FFFFF704).w
		move.b	#9,($FFFFB000).w ; load	special	stage Sonic object
		move.b	#$FF,($FFFFF743).w	; fill previous angle with obviously false value to force an update
		clr.w	($FFFFF780).w	; set stage angle to "upright"
		move.w	#$40,($FFFFF782).w ; set stage rotation	speed
		moveq	#$18,d0
		bsr.w	PlaySound	; play special stage BG	music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w
		move.w	#0,($FFFFF790).w
		lea	(Demo_Index).l,a1
		moveq	#6,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1
		move.b	1(a1),($FFFFF792).w
		subq.b	#1,($FFFFF792).w
		clr.b	($FFFFFE1B).w
		move.w	#0,($FFFFFE08).w
		move.w	#1800,($FFFFF614).w
		tst.b	($FFFFFFE2).w	; has debug cheat been entered?
		beq.s	SS_NoDebug	; if not, branch
		btst	#6,($FFFFF604).w ; is A	button pressed?
		beq.s	SS_NoDebug	; if not, branch
		move.b	#1,($FFFFFFFA).w ; enable debug	mode

SS_NoDebug:
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_MakeWhite

; ---------------------------------------------------------------------------
; Main Special Stage loop
; ---------------------------------------------------------------------------

SS_MainLoop:
		bsr.w	PauseGame
		move.b	#$A,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	SS_ShowLayout
		jsr	OscillateNumDo
		jsr	Deform_BonusStage
		bsr.w	SS_BGAnimate
		tst.w	($FFFFFFF0).w	; is demo mode on?
		beq.s	SS_ChkEnd	; if not, branch
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.w	SS_ToSegaScreen	; if not, branch

SS_ChkEnd:
		cmpi.b	#$10,($FFFFF600).w ; is	game mode $10 (special stage)?
		beq.w	SS_MainLoop	; if yes, branch

		tst.w	($FFFFFFF0).w	; is demo mode on?
		bne.w	SS_ToSegaScreen	; if yes, branch
		move.b	#$C,($FFFFF600).w ; set	screen mode to $0C (level)

SS_End:
		move.w	#60,($FFFFF614).w ; set	delay time to 1	second
		move.w	#$3F,($FFFFF626).w

SS_EndLoop:
		move.b	#$16,($FFFFF62A).w
		bsr.w	DelayProgram
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	SS_ShowLayout
		jsr	OscillateNumDo
		bsr.w	SS_BGAnimate
		bsr.w	Pal_ToWhite

loc_47D4:
		tst.w	($FFFFF614).w
		bne.s	SS_EndLoop

		move	#$2700,sr
		lea	($C00004).l,a6
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		bsr.w	ClearScreen
		clr.w	($FFFFDC00).w
		move.l	#$FFFFDC00,($FFFFDCFC).w
		move	#$2300,sr
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

SS_EndClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,SS_EndClrObjRam ; clear object RAM

		move.w	#1,($FFFFFE02).w ; restart level

SS_NormalExit:
		bsr.w	PauseGame
		move.b	#$C,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		tst.w	($FFFFFE02).w
		beq.s	SS_NormalExit
		tst.l	($FFFFF680).w
		bne.s	SS_NormalExit
		move.w	#$AF,d0
		bsr.w	PlaySound_Special ; play special stage exit sound
		bsr.w	Pal_MakeFlash
		rts	
; ===========================================================================

SS_ToSegaScreen:
		move.b	#0,($FFFFF600).w ; set screen mode to 00 (Sega screen)
		rts

; ---------------------------------------------------------------------------
; Special stage	background loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_BGLoad:				; XREF: SpecialStage
		lea	($FF0000).l,a1
		lea	(Eni_SSBg).l,a0 ; load	mappings for the birds and fish
		move.w	#$6000,d0
		bsr.w	EniDec
		copyTilemap	$FF0000,($E000),($3F),($1F)

		lea	($FF0000).l,a1
		lea	(Eni_SSFg).l,a0 ; load	mappings for the clouds
		move.w	#$C200,d0
		bsr.w	EniDec
		copyTilemap	$FF0000,($C000),($3F),($1F)
		rts	
; End of function SS_BGLoad

; ---------------------------------------------------------------------------
; Subroutine to	make the special stage background animated
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_BGAnimate:				; XREF: SpecialStage
		rts	
; End of function SS_BGAnimate

; ===========================================================================

; ---------------------------------------------------------------------------
; Continue screen
; ---------------------------------------------------------------------------

ContinueScreen:				; XREF: GameModeArray
		bsr.w	Pal_FadeFrom
		move	#$2700,sr
		move.w	($FFFFF60C).w,d0
		andi.b	#$BF,d0
		move.w	d0,($C00004).l
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8700,(a6)
		bsr.w	ClearScreen
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Cont_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Cont_ClrObjRam ; clear object RAM

		move.l	#$70000002,($C00004).l
		lea	(Nem_TitleCard).l,a0 ; load title card patterns
		bsr.w	NemDec
		move.l	#$60000002,($C00004).l
		lea	(Nem_ContSonic).l,a0 ; load Sonic patterns
		bsr.w	NemDec
		move.l	#$6A200002,($C00004).l
		lea	(Nem_MiniSonic).l,a0 ; load continue screen patterns
		bsr.w	NemDec
		moveq	#10,d1
		jsr	ContScrCounter	; run countdown	(start from 10)
		moveq	#$12,d0
		bsr.w	PalLoad1	; load continue	screen pallet
		moveq	#$1F,d0
		bsr.w	PlaySound	; play continue	music
		move.w	#659,($FFFFF614).w ; set time delay to 11 seconds
		move.b	#0,($FFFFF74F).w
		clr.l	($FFFFF700).w
		move.l	#$1000000,($FFFFF704).w
		move.b	#$81,($FFFFB000).w ; load Sonic	object
		move.b	#$80,($FFFFB040).w ; load continue screen objects
		move.b	#$80,($FFFFB080).w
		move.b	#3,($FFFFB098).w
		move.b	#4,($FFFFB09A).w
		move.b	#$80,($FFFFB0C0).w
		move.b	#4,($FFFFB0E4).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_FadeTo

; ---------------------------------------------------------------------------
; Continue screen main loop
; ---------------------------------------------------------------------------

Cont_MainLoop:
		move.b	#$16,($FFFFF62A).w
		bsr.w	DelayProgram
		cmpi.b	#6,($FFFFB024).w
		bcc.s	loc_4DF2
		move	#$2700,sr
		move.w	($FFFFF614).w,d1
		divu.w	#$3C,d1
		andi.l	#$F,d1
		jsr	ContScrCounter
		move	#$2300,sr

loc_4DF2:
		jsr	ObjectsLoad
		jsr	BuildSprites
		cmpi.w	#$180,($FFFFB008).w ; has Sonic	run off	screen?
		bcc.s	Cont_GotoLevel	; if yes, branch
		cmpi.b	#6,($FFFFB024).w
		bcc.s	Cont_MainLoop
		tst.w	($FFFFF614).w
		bne.w	Cont_MainLoop
		move.b	#0,($FFFFF600).w ; go to Sega screen
		rts	
; ===========================================================================

Cont_GotoLevel:				; XREF: Cont_MainLoop
		move.b	#$28,($FFFFF600).w ; set	screen mode to $28 (title card)
		move.b	#6,($FFFFFE12).w ; set lives to	6
		moveq	#0,d0
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE2D).w
		move.l	d0,($FFFFFE26).w ; clear score
		move.b	d0,($FFFFFE30).w ; clear lamppost count
		move.l	d0,($FFFFFFC4).w
		cmpi.w	#2,($FFFFFE10).w
		beq.s	Cont_GotoLevel_WOZ
		rts	

Cont_GotoLevel_WOZ:
		move.w	d0,($FFFFFE10).w
		rts
; ===========================================================================

; ---------------------------------------------------------------------------
; Object 80 - Continue screen elements
; ---------------------------------------------------------------------------

Obj80:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj80_Index(pc,d0.w),d1
		jmp	Obj80_Index(pc,d1.w)
; ===========================================================================
Obj80_Index:	dc.w Obj80_Main-Obj80_Index
		dc.w Obj80_Display-Obj80_Index
		dc.w Obj80_MakeMiniSonic-Obj80_Index
		dc.w Obj80_ChkType-Obj80_Index
; ===========================================================================

Obj80_Main:				; XREF: Obj80_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj80,4(a0)
		move.w	#$8500,2(a0)
		move.b	#0,1(a0)
		move.b	#$3C,$14(a0)
		move.w	#$120,8(a0)
		move.w	#$C0,$A(a0)
		move.w	#0,($FFFFFE20).w ; clear rings

Obj80_Display:				; XREF: Obj80_Index
		jmp	DisplaySprite
; ===========================================================================
Obj80_MiniSonicPos:
		dc.w $116, $12A, $102, $13E, $EE, $152, $DA, $166, $C6
		dc.w $17A, $B2,	$18E, $9E, $1A2, $8A
; ===========================================================================

Obj80_MakeMiniSonic:			; XREF: Obj80_Index
		movea.l	a0,a1
		lea	(Obj80_MiniSonicPos).l,a2
		moveq	#0,d1
		move.b	#1,d1
		bcc.s	loc_4EC4
		jmp	DeleteObject
; ===========================================================================

loc_4EC4:				; XREF: Obj80_MakeMiniSonic
		moveq	#1,d3
		cmpi.b	#$E,d1
		bcs.s	loc_4ED0
		moveq	#0,d3
		moveq	#$E,d1

loc_4ED0:
		move.b	d1,d2
		andi.b	#1,d2

Obj80_MiniSonLoop:
		move.b	#$80,0(a1)	; load mini Sonic object
		move.w	(a2)+,8(a1)
		tst.b	d2
		beq.s	loc_4EEA
		subi.w	#$A,8(a1)

loc_4EEA:
		move.w	#$D0,$A(a1)
		move.b	#6,$1A(a1)
		move.b	#6,$24(a1)
		move.l	#Map_obj80,4(a1)
		move.w	#$8551,2(a1)
		move.b	#0,1(a1)
		lea	$40(a1),a1
		dbf	d1,Obj80_MiniSonLoop ; repeat for number of continues
		lea	-$40(a1),a1
		move.b	d3,$28(a1)

Obj80_ChkType:				; XREF: Obj80_Index
		tst.b	$28(a0)
		beq.s	loc_4F40
		cmpi.b	#6,($FFFFB024).w
		bcs.s	loc_4F40
		move.b	($FFFFFE0F).w,d0
		andi.b	#1,d0
		bne.s	loc_4F40
		tst.w	($FFFFB010).w
		bne.s	Obj80_Delete
		rts	
; ===========================================================================

loc_4F40:				; XREF: Obj80_ChkType
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	Obj80_Display2
		bchg	#0,$1A(a0)

Obj80_Display2:
		jmp	DisplaySprite
; ===========================================================================

Obj80_Delete:				; XREF: Obj80_ChkType
		jmp	DeleteObject
; ===========================================================================

; ---------------------------------------------------------------------------
; Object 81 - Sonic on the continue screen
; ---------------------------------------------------------------------------

Obj81:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj81_Index(pc,d0.w),d1
		jsr	Obj81_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj81_Index:	dc.w Obj81_Main-Obj81_Index
		dc.w Obj81_ChkLand-Obj81_Index
		dc.w Obj81_Animate-Obj81_Index
		dc.w Obj81_Run-Obj81_Index
; ===========================================================================

Obj81_Main:				; XREF: Obj81_Index
		addq.b	#2,$24(a0)
		move.w	#$A0,8(a0)
		move.w	#$C0,$C(a0)
		move.l	#Map_Sonic,4(a0)
		move.w	#$780,2(a0)
		move.b	#4,1(a0)
		move.w	#$100,$18(a0)
		move.b	#$1D,$1C(a0)	; use "floating" animation
		move.w	#$400,$12(a0)	; make Sonic fall from above

Obj81_ChkLand:				; XREF: Obj81_Index
		cmpi.w	#$1A0,$C(a0)	; has Sonic landed yet?
		bne.s	Obj81_ShowFall	; if not, branch
		addq.b	#2,$24(a0)
		clr.w	$12(a0)		; stop Sonic falling
		move.l	#Map_obj80,4(a0)
		move.w	#$8500,2(a0)
		move.b	#0,$1C(a0)
		bra.s	Obj81_Animate
; ===========================================================================

Obj81_ShowFall:				; XREF: Obj81_ChkLand
		jsr	SpeedToPos
		jsr	Sonic_Animate
		jmp	LoadSonicDynPLC
; ===========================================================================

Obj81_Animate:				; XREF: Obj81_Index
		tst.b	($FFFFF605).w	; is any button	pressed?
		bmi.s	Obj81_GetUp	; if yes, branch
		lea	(Ani_obj81).l,a1
		jmp	AnimateSprite
; ===========================================================================

Obj81_GetUp:				; XREF: Obj81_Animate
		addq.b	#2,$24(a0)
		move.l	#Map_Sonic,4(a0)
		move.w	#$780,2(a0)
		move.b	#$1E,$1C(a0)	; use "getting up" animation
		clr.w	$20(a0)
		subq.w	#8,$C(a0)
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; fade out music

Obj81_Run:				; XREF: Obj81_Index
		cmpi.w	#$800,$20(a0)	; check	Sonic's "run speed" (not moving)
		bne.s	Obj81_AddSpeed	; if too low, branch
		move.w	#$1000,$10(a0)	; move Sonic to	the right
		bra.s	Obj81_ShowRun
; ===========================================================================

Obj81_AddSpeed:				; XREF: Obj81_Run
		addi.w	#$20,$20(a0)	; increase "run	speed"

Obj81_ShowRun:				; XREF: Obj81_Run
		jsr	SpeedToPos
		jsr	Sonic_Animate
		jmp	LoadSonicDynPLC
; ===========================================================================
Ani_obj81:
	include "_anim\obj81.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Continue screen
; ---------------------------------------------------------------------------
Map_obj80:
	include "_maps\obj80.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Ending sequence in Green Hill	Zone
; ---------------------------------------------------------------------------

EndingSequence:				; XREF: GameModeArray
		move.b	#$E1,d0
		bsr.w	PlaySound_Special ; stop music
		bsr.w	Pal_FadeFrom
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

End_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,End_ClrObjRam ; clear object	RAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1

End_ClrRam:
		move.l	d0,(a1)+
		dbf	d1,End_ClrRam	; clear	variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

End_ClrRam2:
		move.l	d0,(a1)+
		dbf	d1,End_ClrRam2	; clear	variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1

End_ClrRam3:
		move.l	d0,(a1)+
		dbf	d1,End_ClrRam3	; clear	variables

		move	#$2700,sr
		move.w	($FFFFF60C).w,d0
		andi.b	#$BF,d0
		move.w	d0,($C00004).l
		bsr.w	ClearScreen
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8004,(a6)
		move.w	#$8730,(a6)
		move.w	#$8AFF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		move.w	#$1E,($FFFFFE14).w
		move.w	#$600,($FFFFFE10).w ; set level	number to 0600 (extra flowers)
		cmpi.b	#6,($FFFFFE57).w ; do you have all 6 emeralds?
		beq.s	End_LoadData	; if yes, branch
		move.w	#$601,($FFFFFE10).w ; set level	number to 0601 (no flowers)

End_LoadData:
		moveq	#$1C,d0
		bsr.w	RunPLC_ROM	; load ending sequence patterns
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	LoadZoneTiles	; load level art
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	LoadSolids
		move.l	#Col_WOZ_1,($FFFFFFD0).w			; MJ: Set first collision for ending
		move.l	#Col_WOZ_2,($FFFFFFD4).w			; MJ: Set second collision for ending
		move	#$2300,sr
		lea	(Kos_EndFlowers).l,a0 ;	load extra flower patterns
		lea	($FFFF9400).w,a1 ; RAM address to buffer the patterns
		bsr.w	KosDec
		moveq	#$23,d0
		bsr.w	PlaySound	; play ending sequence music
		btst	#6,($FFFFF604).w ; is button A pressed?
		beq.s	End_LoadSonic	; if not, branch
		move.b	#1,($FFFFFFFA).w ; enable debug	mode

End_LoadSonic:
		moveq	#0,d0
		cmpi.w	#1,(Current_Character).w
		beq.s	End_Shadow
		cmpi.w	#2,(Current_Character).w
		beq.s	End_Silver
		moveq	#3,d0
		move.b	#1,($FFFFB000).w ; load	Sonic object
		bra.s	End_CharCont

End_Silver:
		moveq	#$16,d0
		move.b	#2,($FFFFB000).w ; load	Silver object
		bra.s	End_CharCont

End_Shadow:
		moveq	#$17,d0
		move.b	#$8E,($FFFFB000).w ; load	Shadow object

End_CharCont:
		bsr.w	PalLoad1	; load Sonic's pallet line
		bset	#0,($FFFFB022).w ; make	Sonic face left
		move.b	#1,($FFFFF7CC).w ; lock	controls
		move.w	#$400,($FFFFF602).w ; move Sonic to the	left
		move.w	#$F800,($FFFFB020).w ; set Sonic's speed
		jsr	ObjPosLoad
		jsr	ObjectsLoad
		jsr	BuildSprites
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w
		move.l	d0,($FFFFFE22).w
		move.b	d0,($FFFFFE1B).w
		move.b	d0,($FFFFFE2C).w
		move.b	d0,($FFFFFE2E).w
		move.b	d0,($FFFFFE2F).w
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1F).w
		move.b	#1,($FFFFFE1D).w
		move.b	#0,($FFFFFE1E).w
		move.w	#1800,($FFFFF614).w
		move.b	#$18,($FFFFF62A).w
		bsr.w	DelayProgram
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		move.w	#$3F,($FFFFF626).w
		bsr.w	Pal_FadeTo

; ---------------------------------------------------------------------------
; Main ending sequence loop
; ---------------------------------------------------------------------------

End_MainLoop:
		bsr.w	PauseGame
		move.b	#$18,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w
		bsr.w	End_MoveSonic
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		jsr	ObjPosLoad
		bsr.w	PalCycle_Load
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		cmpi.b	#$18,($FFFFF600).w ; is	scene number $18 (ending)?
		beq.s	loc_52DA	; if yes, branch
		move.b	#$1C,($FFFFF600).w ; set scene to $1C (credits)
		move.b	#$22,d0
		add.b	($FFFFFFED).w,d0
		bsr.w	PlaySound_Special ; play credits music
		move.b	#0,($FFFFB000).w
		move.w	#0,($FFFFFFF4).w ; set credits index number to 0
		rts	
; ===========================================================================

loc_52DA:
		tst.w	($FFFFFE02).w	; is level set to restart?
		beq.w	End_MainLoop	; if not, branch

		clr.w	($FFFFFE02).w
		move.w	#$3F,($FFFFF626).w

End_AllEmlds:				; XREF: loc_5334
		bsr.w	PauseGame
		move.b	#$18,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w
		bsr.w	End_MoveSonic
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		jsr	ObjPosLoad
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		bsr.w	Pal_ToWhite

loc_5334:
		tst.w	($FFFFFE02).w
		beq.w	End_AllEmlds
		clr.w	($FFFFFE02).w
		move.w	#$2E2F,($FFFF8080).w ; modify level layout
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFF700).w,a3
		movea.l	($FFFF8000).w,a4			; MJ: Load address of layout
		move.w	#$4000,d2
		bsr.w	LoadTilesFromStart2
		moveq	#$13,d0
		bsr.w	PalLoad1	; load ending pallet
		bsr.w	Pal_MakeWhite
		bra.w	End_MainLoop

; ---------------------------------------------------------------------------
; Subroutine controlling Sonic on the ending sequence
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


End_MoveSonic:				; XREF: End_MainLoop
		move.b	($FFFFF7D7).w,d0
		bne.s	End_MoveSonic2
		cmpi.w	#$90,($FFFFB008).w ; has Sonic passed $90 on y-axis?
		bcc.s	End_MoveSonExit	; if not, branch
		addq.b	#2,($FFFFF7D7).w
		move.b	#1,($FFFFF7CC).w ; lock	player's controls
		move.w	#$800,($FFFFF602).w ; move Sonic to the	right
		rts	
; ===========================================================================

End_MoveSonic2:				; XREF: End_MoveSonic
		subq.b	#2,d0
		bne.s	End_MoveSonic3
		cmpi.w	#$A0,($FFFFB008).w ; has Sonic passed $A0 on y-axis?
		bcs.s	End_MoveSonExit	; if not, branch
		addq.b	#2,($FFFFF7D7).w
		moveq	#0,d0
		move.b	d0,($FFFFF7CC).w
		move.w	d0,($FFFFF602).w ; stop	Sonic moving
		move.w	d0,($FFFFB020).w
		move.b	#$81,($FFFFF7C8).w
		move.b	#3,($FFFFB01A).w
		move.w	#$505,($FFFFB01C).w ; use "standing" animation
		move.b	#3,($FFFFB01E).w
		rts	
; ===========================================================================

End_MoveSonic3:				; XREF: End_MoveSonic
		subq.b	#2,d0
		bne.s	End_MoveSonExit
		addq.b	#2,($FFFFF7D7).w
		move.w	#$A0,($FFFFB008).w
		move.b	#$87,($FFFFB000).w ; load Sonic	ending sequence	object
		clr.w	($FFFFB024).w

End_MoveSonExit:
		rts	
; End of function End_MoveSonic

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 87 - Sonic on ending sequence
; ---------------------------------------------------------------------------

Obj87:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj87_Index(pc,d0.w),d1
		jsr	Obj87_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj87_Index:	dc.w Obj87_Main-Obj87_Index, Obj87_MakeEmlds-Obj87_Index
		dc.w Obj87_Animate-Obj87_Index,	Obj87_LookUp-Obj87_Index
		dc.w Obj87_ClrObjRam-Obj87_Index, Obj87_Animate-Obj87_Index
		dc.w Obj87_MakeLogo-Obj87_Index, Obj87_Animate-Obj87_Index
		dc.w Obj87_Leap-Obj87_Index, Obj87_Animate-Obj87_Index
; ===========================================================================

Obj87_Main:				; XREF: Obj87_Index
		cmpi.b	#6,($FFFFFE57).w ; do you have all 6 emeralds?
		beq.s	Obj87_Main2	; if yes, branch
		addi.b	#$10,$25(a0)	; else,	skip emerald sequence
		move.w	#$D8,$30(a0)
		rts	
; ===========================================================================

Obj87_Main2:				; XREF: Obj87_Main
		addq.b	#2,$25(a0)
		move.l	#Map_obj87,4(a0)
		move.w	#$3E1,2(a0)
		move.b	#4,1(a0)
		clr.b	$22(a0)
		move.w	#$100,$18(a0)
		move.b	#0,$1A(a0)
		move.w	#$50,$30(a0)	; set duration for Sonic to pause

Obj87_MakeEmlds:			; XREF: Obj87_Index
		subq.w	#1,$30(a0)	; subtract 1 from duration
		bne.s	Obj87_Wait
		addq.b	#2,$25(a0)
		move.w	#1,$1C(a0)
		move.b	#$88,($FFFFB400).w ; load chaos	emeralds objects

Obj87_Wait:
		rts	
; ===========================================================================

Obj87_LookUp:				; XREF: Obj87_Index
		cmpi.w	#$2000,($FFD43C).l
		bne.s	locret_5480
		move.w	#1,($FFFFFE02).w ; set level to	restart	(causes	flash)
		move.w	#$5A,$30(a0)
		addq.b	#2,$25(a0)

locret_5480:
		rts	
; ===========================================================================

Obj87_ClrObjRam:			; XREF: Obj87_Index
		subq.w	#1,$30(a0)
		bne.s	Obj87_Wait2
		lea	($FFFFB400).w,a1
		move.w	#$FF,d1

Obj87_ClrLoop:
		clr.l	(a1)+
		dbf	d1,Obj87_ClrLoop ; clear the object RAM
		move.w	#1,($FFFFFE02).w
		addq.b	#2,$25(a0)
		move.b	#1,$1C(a0)
		move.w	#$3C,$30(a0)

Obj87_Wait2:
		rts	
; ===========================================================================

Obj87_MakeLogo:				; XREF: Obj87_Index
		subq.w	#1,$30(a0)
		bne.s	Obj87_Wait3
		addq.b	#2,$25(a0)
		move.w	#$B4,$30(a0)
		move.b	#2,$1C(a0)
		move.b	#$89,($FFFFB400).w ; load "SONIC THE HEDGEHOG" object

Obj87_Wait3:
		rts	
; ===========================================================================

Obj87_Animate:				; XREF: Obj87_Index
		lea	(Ani_obj87).l,a1
		jmp	AnimateSprite
; ===========================================================================

Obj87_Leap:				; XREF: Obj87_Index
		subq.w	#1,$30(a0)
		bne.s	Obj87_Wait4
		addq.b	#2,$25(a0)
		move.l	#Map_obj87,4(a0)
		move.w	#$3E1,2(a0)
		move.b	#4,1(a0)
		clr.b	$22(a0)
		move.w	#$100,$18(a0)
		move.b	#5,$1A(a0)
		move.b	#2,$1C(a0)	; use "leaping"	animation
		move.b	#$89,($FFFFB400).w ; load "SONIC THE HEDGEHOG" object
		bra.s	Obj87_Animate
; ===========================================================================

Obj87_Wait4:				; XREF: Obj87_Leap
		rts	
; ===========================================================================
Ani_obj87:
	include "_anim\obj87.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 88 - chaos emeralds on	the ending sequence
; ---------------------------------------------------------------------------

Obj88:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj88_Index(pc,d0.w),d1
		jsr	Obj88_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj88_Index:	dc.w Obj88_Main-Obj88_Index
		dc.w Obj88_Move-Obj88_Index
; ===========================================================================

Obj88_Main:				; XREF: Obj88_Index
		cmpi.b	#2,($FFFFB01A).w
		beq.s	Obj88_Main2
		addq.l	#4,sp
		rts	
; ===========================================================================

Obj88_Main2:				; XREF: Obj88_Main
		move.w	($FFFFB008).w,8(a0) ; match X position with Sonic
		move.w	($FFFFB00C).w,$C(a0) ; match Y position	with Sonic
		movea.l	a0,a1
		moveq	#0,d3
		moveq	#1,d2
		moveq	#5,d1

Obj88_MainLoop:
		move.b	#$88,(a1)	; load chaos emerald object
		addq.b	#2,$24(a1)
		move.l	#Map_obj88,4(a1)
		move.w	#$3C5,2(a1)
		move.b	#4,1(a1)
		move.w	#$80,$18(a1)
		move.w	8(a0),$38(a1)
		move.w	$C(a0),$3A(a1)
		move.b	d2,$1C(a1)
		move.b	d2,$1A(a1)
		addq.b	#1,d2
		move.b	d3,$26(a1)
		addi.b	#$2A,d3
		lea	$40(a1),a1
		dbf	d1,Obj88_MainLoop ; repeat 5 more times

Obj88_Move:				; XREF: Obj88_Index
		move.w	$3E(a0),d0
		add.w	d0,$26(a0)
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		moveq	#0,d4
		move.b	$3C(a0),d4
		muls.w	d4,d1
		asr.l	#8,d1
		muls.w	d4,d0
		asr.l	#8,d0
		add.w	$38(a0),d1
		add.w	$3A(a0),d0
		move.w	d1,8(a0)
		move.w	d0,$C(a0)
		cmpi.w	#$2000,$3C(a0)
		beq.s	loc_55FA
		addi.w	#$20,$3C(a0)

loc_55FA:
		cmpi.w	#$2000,$3E(a0)
		beq.s	loc_5608
		addi.w	#$20,$3E(a0)

loc_5608:
		cmpi.w	#$140,$3A(a0)
		beq.s	locret_5614
		subq.w	#1,$3A(a0)

locret_5614:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 89 - "SONIC THE HEDGEHOG" text	on the ending sequence
; ---------------------------------------------------------------------------

Obj89:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj89_Index(pc,d0.w),d1
		jmp	Obj89_Index(pc,d1.w)
; ===========================================================================
Obj89_Index:	dc.w Obj89_Main-Obj89_Index
		dc.w Obj89_Move-Obj89_Index
		dc.w Obj89_GotoCredits-Obj89_Index
; ===========================================================================

Obj89_Main:				; XREF: Obj89_Index
		addq.b	#2,$24(a0)
		move.w	#-$20,8(a0)	; object starts	outside	the level boundary
		move.w	#$D8,$A(a0)
		move.l	#Map_obj89,4(a0)
		move.w	#$5C5,2(a0)
		move.b	#0,1(a0)
		move.w	#0,$18(a0)

Obj89_Move:				; XREF: Obj89_Index
		cmpi.w	#$C0,8(a0)	; has object reached $C0?
		beq.s	Obj89_Delay	; if yes, branch
		addi.w	#$10,8(a0)	; move object to the right
		jmp		DisplaySprite
; ===========================================================================

Obj89_Delay:				; XREF: Obj89_Move
		addq.b	#2,$24(a0)
		move.w	#120,$30(a0)	; set duration for delay (2 seconds)

Obj89_GotoCredits:			; XREF: Obj89_Index
		subq.w	#1,$30(a0)	; subtract 1 from duration
		bpl.s	Obj89_Display
		move.b	#$1C,($FFFFF600).w ; exit to credits

Obj89_Display:
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic on the ending	sequence
; ---------------------------------------------------------------------------
Map_obj87:
	include "_maps\obj87.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - chaos emeralds on the ending sequence
; ---------------------------------------------------------------------------
Map_obj88:
	include "_maps\obj88.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - "SONIC THE HEDGEHOG" text on the ending sequence
; ---------------------------------------------------------------------------
Map_obj89:
	include "_maps\obj89.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Credits ending sequence
; ---------------------------------------------------------------------------

Credits:				; XREF: GameModeArray
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		move.w	#$9200,(a6)
		move.w	#$8B03,(a6)
		move.w	#$8730,(a6)
		clr.b	($FFFFF64E).w
		bsr.w	ClearScreen
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Cred_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Cred_ClrObjRam ; clear object RAM

		move.l	#$74000002,($C00004).l
		lea	(Nem_CreditText).l,a0 ;	load credits alphabet patterns
		bsr.w	NemDec
		lea	($FFFFFB80).w,a1
		moveq	#0,d0
		move.w	#$1F,d1

Cred_ClrPallet:
		move.l	d0,(a1)+
		dbf	d1,Cred_ClrPallet ; fill pallet	with black ($0000)

		move.b	#$8A,($FFFFB080).w ; load credits object
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	EndingDemoLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2 ;	load block mappings etc
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	loc_5862
		bsr.w	LoadPLC		; load level patterns

loc_5862:
		moveq	#1,d0
		bsr.w	LoadPLC		; load standard	level patterns
		move.w	#120,($FFFFF614).w ; display a credit for 2 seconds
		bsr.w	Pal_FadeTo

Cred_WaitLoop:
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		bsr.w	RunPLC_RAM
		tst.w	($FFFFF614).w	; have 2 seconds elapsed?
		bne.s	Cred_WaitLoop	; if not, branch
		tst.l	($FFFFF680).w	; have level gfx finished decompressing?
		bne.s	Cred_WaitLoop	; if not, branch
		cmpi.w	#9,($FFFFFFF4).w ; have	the credits finished?
		beq.w	TryAgainEnd	; if yes, branch
		rts	

; ---------------------------------------------------------------------------
; Ending sequence demo loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


EndingDemoLoad:				; XREF: Credits
		move.w	($FFFFFFF4).w,d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	EndDemo_Levels(pc,d0.w),d0 ; load level	array
		move.w	d0,($FFFFFE10).w ; set level from level	array
		addq.w	#1,($FFFFFFF4).w
		cmpi.w	#9,($FFFFFFF4).w ; have	credits	finished?
		bcc.s	EndDemo_Exit	; if yes, branch
		move.w	#$8001,($FFFFFFF0).w ; force demo mode
		move.b	#8,($FFFFF600).w ; set game mode to 08 (demo)
		move.b	#6,($FFFFFE12).w ; set lives to	6
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.l	d0,($FFFFFE26).w ; clear score
		move.b	d0,($FFFFFE30).w ; clear lamppost counter
		cmpi.w	#4,($FFFFFFF4).w ; is KVZ demo running?
		bne.s	EndDemo_Exit	; if not, branch
		lea	(EndDemo_LampVar).l,a1 ; load lamppost variables
		lea	($FFFFFE30).w,a2
		move.w	#8,d0

EndDemo_LampLoad:
		move.l	(a1)+,(a2)+
		dbf	d0,EndDemo_LampLoad

EndDemo_Exit:
		rts	
; End of function EndingDemoLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Levels used in the end sequence demos
; ---------------------------------------------------------------------------
EndDemo_Levels:	incbin	misc\dm_ord2.bin

; ---------------------------------------------------------------------------
; Lamppost variables in the end sequence demo (Star Light Zone)
; ---------------------------------------------------------------------------
EndDemo_LampVar:
		dc.b 1,	1		; XREF: EndingDemoLoad
		dc.w $A00, $62C, $D
		dc.l 0
		dc.b 0,	0
		dc.w $800, $957, $5CC, $4AB, $3A6, 0, $28C, 0, 0, $308
		dc.b 1,	1
; ===========================================================================
; ---------------------------------------------------------------------------
; "TRY AGAIN" and "END"	screens
; ---------------------------------------------------------------------------

TryAgainEnd:				; XREF: Credits
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		move.w	#$9200,(a6)
		move.w	#$8B03,(a6)
		move.w	#$8730,(a6)
		clr.b	($FFFFF64E).w
		bsr.w	ClearScreen
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

TryAg_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,TryAg_ClrObjRam ; clear object RAM

		moveq	#$1D,d0
		bsr.w	RunPLC_ROM	; load "TRY AGAIN" or "END" patterns
		lea	($FFFFFB80).w,a1
		moveq	#0,d0
		move.w	#$1F,d1

TryAg_ClrPallet:
		move.l	d0,(a1)+
		dbf	d1,TryAg_ClrPallet ; fill pallet with black ($0000)

		moveq	#$13,d0
		bsr.w	PalLoad1	; load ending pallet
		clr.w	($FFFFFBC0).w
		move.b	#$8B,($FFFFB080).w ; load Eggman object
		jsr	ObjectsLoad
		jsr	BuildSprites
		move.w	#1800,($FFFFF614).w ; show screen for 30 seconds
		bsr.w	Pal_FadeTo
		move.b	#$E1,d0
		bsr.w	PlaySound

; ---------------------------------------------------------------------------
; "TRY AGAIN" and "END"	screen main loop
; ---------------------------------------------------------------------------
TryAg_MainLoop:
		bsr.w	PauseGame
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		andi.b	#$80,($FFFFF605).w ; is	Start button pressed?
		bne.s	TryAg_Exit	; if yes, branch
		tst.w	($FFFFF614).w	; has 30 seconds elapsed?
		beq.s	TryAg_Exit	; if yes, branch
		cmpi.b	#$1C,($FFFFF600).w
		beq.s	TryAg_MainLoop

TryAg_Exit:
		move.b	#0,($FFFFF600).w ; go to Sega screen
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8B - Eggman on "TRY AGAIN" and "END"	screens
; ---------------------------------------------------------------------------

Obj8B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8B_Index(pc,d0.w),d1
		jsr	Obj8B_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj8B_Index:	dc.w Obj8B_Main-Obj8B_Index
		dc.w Obj8B_Animate-Obj8B_Index
		dc.w Obj8B_Juggle-Obj8B_Index
		dc.w loc_5A8E-Obj8B_Index
; ===========================================================================

Obj8B_Main:				; XREF: Obj8B_Index
		addq.b	#2,$24(a0)
		move.w	#$120,8(a0)
		move.w	#$F4,$A(a0)
		move.l	#Map_obj8B,4(a0)
		move.w	#$3E1,2(a0)
		move.b	#0,1(a0)
		move.w	#$100,$18(a0)
		move.b	#2,$1C(a0)	; use "END" animation
		cmpi.b	#6,($FFFFFE57).w ; do you have all 6 emeralds?
		beq.s	Obj8B_Animate	; if yes, branch
		move.b	#$8A,($FFFFB0C0).w ; load credits object
		move.w	#9,($FFFFFFF4).w ; use "TRY AGAIN" text
		move.b	#$8C,($FFFFB800).w ; load emeralds object on "TRY AGAIN" screen
		move.b	#0,$1C(a0)	; use "TRY AGAIN" animation

Obj8B_Animate:				; XREF: Obj8B_Index
		lea	(Ani_obj8B).l,a1
		jmp	AnimateSprite
; ===========================================================================

Obj8B_Juggle:				; XREF: Obj8B_Index
		addq.b	#2,$24(a0)
		moveq	#2,d0
		btst	#0,$1C(a0)
		beq.s	loc_5A6A
		neg.w	d0

loc_5A6A:
		lea	($FFFFB800).w,a1
		moveq	#5,d1

loc_5A70:
		move.b	d0,$3E(a1)
		move.w	d0,d2
		asl.w	#3,d2
		add.b	d2,$26(a1)
		lea	$40(a1),a1
		dbf	d1,loc_5A70
		addq.b	#1,$1A(a0)
		move.w	#112,$30(a0)

loc_5A8E:				; XREF: Obj8B_Index
		subq.w	#1,$30(a0)
		bpl.s	locret_5AA0
		bchg	#0,$1C(a0)
		move.b	#2,$24(a0)

locret_5AA0:
		rts	
; ===========================================================================
Ani_obj8B:
	include "_anim\obj8B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8C - chaos emeralds on	the "TRY AGAIN"	screen
; ---------------------------------------------------------------------------

Obj8C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8C_Index(pc,d0.w),d1
		jsr	Obj8C_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj8C_Index:	dc.w Obj8C_Main-Obj8C_Index
		dc.w Obj8C_Move-Obj8C_Index
; ===========================================================================

Obj8C_Main:				; XREF: Obj8C_Index
		movea.l	a0,a1
		moveq	#0,d2
		moveq	#0,d3
		moveq	#5,d1
		sub.b	($FFFFFE57).w,d1

Obj8C_MakeEms:				; XREF: loc_5B42
		move.b	#$8C,(a1)	; load emerald object
		addq.b	#2,$24(a1)
		move.l	#Map_obj88,4(a1)
		move.w	#$3C5,2(a1)
		move.b	#0,1(a1)
		move.w	#$80,$18(a1)
		move.w	#$104,8(a1)
		move.w	#$120,$38(a1)
		move.w	#$EC,$A(a1)
		move.w	$A(a1),$3A(a1)
		move.b	#$1C,$3C(a1)
		lea	($FFFFFE58).w,a3

Obj8C_ChkEms:
		moveq	#0,d0
		move.b	($FFFFFE57).w,d0
		subq.w	#1,d0
		bcs.s	loc_5B42

Obj8C_ChkEmLoop:
		cmp.b	(a3,d0.w),d2
		bne.s	loc_5B3E
		addq.b	#1,d2
		bra.s	Obj8C_ChkEms
; ===========================================================================

loc_5B3E:
		dbf	d0,Obj8C_ChkEmLoop ; checks which emeralds you have

loc_5B42:
		move.b	d2,$1A(a1)
		addq.b	#1,$1A(a1)
		addq.b	#1,d2
		move.b	#$80,$26(a1)
		move.b	d3,$23(a1)
		move.b	d3,$29(a1)
		addi.w	#$A,d3
		lea	$40(a1),a1
		dbf	d1,Obj8C_MakeEms

Obj8C_Move:				; XREF: Obj8C_Index
		tst.w	$3E(a0)
		beq.s	locret_5BBA
		tst.b	$23(a0)
		beq.s	loc_5B78
		subq.b	#1,$23(a0)
		bne.s	loc_5B80

loc_5B78:
		move.w	$3E(a0),d0
		add.w	d0,$26(a0)

loc_5B80:
		move.b	$26(a0),d0
		beq.s	loc_5B8C
		cmpi.b	#$80,d0
		bne.s	loc_5B96

loc_5B8C:
		clr.w	$3E(a0)
		move.b	$29(a0),$23(a0)

loc_5B96:
		jsr	(CalcSine).l
		moveq	#0,d4
		move.b	$3C(a0),d4
		muls.w	d4,d1
		asr.l	#8,d1
		muls.w	d4,d0
		asr.l	#8,d0
		add.w	$38(a0),d1
		add.w	$3A(a0),d0
		move.w	d1,8(a0)
		move.w	d0,$A(a0)

locret_5BBA:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Eggman on	the "TRY AGAIN"	and "END" screens
; ---------------------------------------------------------------------------
Map_obj8B:
	include "_maps\obj8B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8D - egg carrier in WOZ
; ---------------------------------------------------------------------------

Obj8D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8D_Index(pc,d0.w),d1
		jsr	Obj8D_Index(pc,d1.w)
		jsr	SpeedToPos
		jmp	DisplaySprite
; ===========================================================================
Obj8D_Index:	dc.w Obj8D_Main-Obj8D_Index
		dc.w Obj8D_Move-Obj8D_Index
; ===========================================================================

Obj8D_Main:
		move.w	#$120,8(a0)
		move.w	#$90,$A(a0)
		addq.b	#2,$24(a0)
		move.l	#Map_obj8D,4(a0)
		move.w	#$250C,2(a0)
		move.w	#$380,$18(a0)

Obj8D_Move:
		tst.b	($FFFFF734).w
		bne.s	Obj8D_MoveF
		move.w	#-$10,$10(a0)	; increase falling speed
		cmpi.w	#$100,8(a0)
		bls.s	Obj8D_Done
		move.b	#2,($FFFFF734).w
		rts

Obj8D_MoveF:
		move.w	#$20,$10(a0)	; increase falling speed
		cmpi.w	#$140,8(a0)
		bcs.s	Obj8D_Done
		move.b	#0,($FFFFF734).w

Obj8D_Done:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Eggman on	the "TRY AGAIN"	and "END" screens
; ---------------------------------------------------------------------------
Map_obj8D:
	include "_maps\obj8D.asm"

LoadSubObject:
	moveq	#0,d0
	move.b	$28(a0),d0
; loc_365FA:
LoadSubObject_Part2:
	move.w	SubObjData_Index(pc,d0.w),d0
	lea	SubObjData_Index(pc,d0.w),a1
; loc_36602:
LoadSubObject_Part3:
	move.l	(a1)+,4(a0)
	move.w	(a1)+,2(a0)
	move.b	(a1)+,d0
	or.b	d0,1(a0)
	move.b	(a1)+,$18(a1)
	move.b	$18(a1),d0
	lsr.w 	#1,d0
	andi.w 	#$280,d0
	move.w	d0,$18(a0)
	move.b	(a1)+,$14(a0)
	move.b	(a1),$20(a0)
	addq.b	#2,$24(a0)
	rts

SubObjData_Index:
		dc.w off_3AFC8-SubObjData_Index

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 97 - The Tornado (Tails' plane)
; ----------------------------------------------------------------------------
; Sprite_3A790:
Obj97:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_3A79E(pc,d0.w),d1
		jmp	off_3A79E(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3A79E:	dc.w loc_3A7AE-off_3A79E; 0 ; DATA XREF: h+2382Ao h+2382Co ...
		dc.w loc_3A7DE-off_3A79E; 1
		dc.w loc_3A7DE-off_3A79E; 2
		dc.w loc_3A7DE-off_3A79E; 3
		dc.w loc_3AC6A-off_3A79E; 4
		dc.w loc_3AD0C-off_3A79E; 5
		dc.w loc_3AD2A-off_3A79E; 6
		dc.w loc_3AD42-off_3A79E; 7
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A7AE:				; DATA XREF: h+2382Ao
		jsr	LoadSubObject
		moveq	#0,d0
	;	move.b	$28(a0),d0
	;	subi.b	#$4E,d0	; 'N'
		move.b	2,$24(a0)
	;	cmpi.w	#2,($FFFFFF70).w
	;	bne.s	loc_3A7DA
	;	cmpi.b	#8,d0
	;	bcc.s	loc_3A7DA
	;	move.b	#4,$1A(a0)
	;	move.b	#1,$1C(a0)

loc_3A7DA:				; CODE XREF: h+23852j h+23858j
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A7DE:				; DATA XREF: h+2382Ao
		bsr.w	loc_3AF58
		tst.w	($FFFFFE08).w
		bne.w	loc_3A880
		lea	($FFFFB000).w,a1
		move.w	2(a1),d0
		andi.w	#-$8000,d0
		move.w	2(a0),d1
		andi.w	#$7FFF,d1
		or.w	d0,d1
		move.w	d1,2(a0)
		move.w	8(a0),-(sp)
		bsr.w	loc_3ADAA
		move.b	$22(a0),$2E(a0)
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jsr	SolidObject
		bsr.w	loc_3AE3A
		move.b	$2E(a0),d0
		move.b	$22(a0),d1
		andi.b	#8,d0
		andi.b	#8,d1
		eor.b	d0,d1
		move.b	d1,$2E(a0)
		lea	($FFFFB000).w,a1
		move.w	8(a1),d1
		move.w	($FFFFF700).w,d0
		move.w	d0,($FFFFF728).w
		move.w	d0,d2
		addi.w	#$11,d2
		cmp.w	d2,d1
		bhi.s	loc_3A85E
		addq.w	#1,d1
		move.w	d1,8(a1)

loc_3A85E:				; CODE XREF: h+238E2j
		cmpi.w	#$1400,d0
		bcs.s	loc_3A878
		cmpi.w	#$1568,d1
		bcc.s	loc_3A88E
		st	($FFFFF7CC).w
		move.w	#$808,($FFFFF602).w
		bra.w	loc_3A87C
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A878:				; CODE XREF: h+238EEj
		subi.w	#$40,d0	; '@'

loc_3A87C:				; CODE XREF: h+23900j
		move.w	d0,($FFFFEECA).w

loc_3A880:				; CODE XREF: h+23872j h+23924j
		lea	(off_3AFDC).l,a1
		bsr.w	AnimateSprite
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A88E:				; CODE XREF: h+238F4j
		bsr.w	loc_3AC46
		move.w	#$000,($FFFFFE10).w
		bra.s	loc_3A880
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A954:				; DATA XREF: h+2382Ao
		bsr.w	loc_3AF58
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_3A970(pc,d0.w),d1
		jsr	off_3A970(pc,d1.w)
		lea	(off_3AFDC).l,a1
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3A970:	dc.w loc_3A982-off_3A970; 0 ; DATA XREF: h+239FCo h+239FEo ...
		dc.w loc_3AA0E-off_3A970; 1
		dc.w loc_3AA4C-off_3A970; 2
		dc.w loc_3AA74-off_3A970; 3
		dc.w loc_3AAA8-off_3A970; 4
		dc.w loc_3AAFE-off_3A970; 5
		dc.w loc_3AB68-off_3A970; 6
		dc.w loc_3AB7C-off_3A970; 7
		dc.w loc_3ABDE-off_3A970; 8
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A982:				; DATA XREF: h+239FCo
		lea	($FFFFB000).w,a1
		cmpi.w	#$5EC,$C(a1)
		bcs.s	locret_3A99E
		clr.w	($FFFFF602).w
		addq.w	#1,$2E(a0)
		cmpi.w	#$40,$2E(a0) ; '@'
		bcc.s	loc_3A9A0

locret_3A99E:				; CODE XREF: h+23A18j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3A9A0:				; CODE XREF: h+23A28j
		addq.b	#2,$25(a0)
		move.w	#$2E58,8(a0)
		move.w	#$66C,$C(a0)
		lea	($FFFFB000).w,a1
		bsr.w	loc_3AC56
		lea	(word_3AFBC).l,a2
		jsr	LoadChildObject
		move.w	#$3118,8(a1)
		move.w	#$3F0,$C(a1)
		lea	(word_3AFB8).l,a2
		jsr	LoadChildObject
		move.w	#$3070,8(a1)
		move.w	#$3B0,$C(a1)
		lea	(word_3AFB8).l,a2
		jsr	LoadChildObject
		move.w	#$3070,8(a1)
		move.w	#$430,$C(a1)
		lea	(word_3AFC0).l,a2
		jsr	LoadChildObject
		clr.w	8(a1)
		clr.w	$C(a1)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AA0E:				; DATA XREF: h+239FCo
		lea	($FFFFB000).w,a1
		cmpi.w	#$2E30,8(a1)
		bcc.s	loc_3AA22
		move.w	#$808,($FFFFF602).w
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AA22:				; CODE XREF: h+23AA4j
		addq.b	#2,$25(a0)
		clr.w	($FFFFF602).w
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$14(a1)
		move.w	#$600,($FFFFF760).w
		move.w	#$C,($FFFFF762).w
		move.w	#$80,($FFFFF764).w ; 'โฌ'
		bra.w	loc_3AC56
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AA4C:				; DATA XREF: h+239FCo
		cmpi.w	#$380,($FFFFEEE2).w
		bcc.s	loc_3AA5C
		clr.w	($FFFFF602).w
		bra.w	loc_3AC56
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AA5C:				; CODE XREF: h+23ADEj
		addq.b	#2,$25(a0)
		move.w	#$100,$10(a0)
		move.w	#-$100,$12(a0)
		clr.w	$2A(a0)
		bra.w	loc_3AC56
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AA74:				; DATA XREF: h+239FCo
		bsr.w	loc_3AC56
		addq.w	#1,$2A(a0)
		cmpi.w	#$30,$2A(a0) ; '0'
		bne.s	loc_3AAA0
		addq.b	#2,$25(a0)
		move.w	#$4040,($FFFFF602).w
		move.w	#$38,$2E(a0) ; '8'

loc_3AAA0:				; CODE XREF: h+23B0Ej h+23974j
		bsr.w	loc_3AD8C
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AAA8:				; DATA XREF: h+239FCo
		clr.w	($FFFFF602).w
		addq.w	#1,$2A(a0)
		subq.w	#1,$2E(a0)
		bmi.s	loc_3AABC
		move.w	#$4848,($FFFFF602).w

loc_3AABC:				; CODE XREF: h+23B40j
		bsr.w	loc_3AD8C
		btst	#3,$22(a0)
		beq.s	loc_3AAFA
		addq.b	#2,$25(a0)
		move.w	#$20,$2E(a0) ; ' '
		lea	($FFFF80D2).w,a1
		move.l	#$501F0025,(a1)+
		lea	($FFFF81D2).w,a1
		move.l	#$25001F50,(a1)+
		lea	($FFFF8BD6).w,a1
		move.l	#$501F0025,(a1)+
		lea	($FFFF8CD6).w,a1
		move.l	#$25001F50,(a1)+

loc_3AAFA:				; CODE XREF: h+23B52j
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AAFE:				; DATA XREF: h+239FCo
		addq.w	#1,$2A(a0)
		cmpi.w	#$100,$2A(a0)
		bcs.s	loc_3AB18
		addq.b	#2,$25(a0)
		movea.w	$3A(a0),a1
		move.b	#2,$25(a1)

loc_3AB18:				; CODE XREF: h+23B94j
		clr.w	($FFFFF602).w
		lea	($FFFFB000).w,a1
		move.w	8(a0),8(a1)
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$14(a1)
		bclr	#1,$22(a1)
		bclr	#2,$22(a1)
		move.l	#$1000505,$1A(a1)
		move.w	#$100,$1E(a1)
		move.b	#$13,$16(a1)
		cmpi.w	#2,($FFFFFF70).w
		bne.s	loc_3AB60
		move.b	#$F,$16(a1)

loc_3AB60:				; CODE XREF: h+23BE4j
		bsr.w	loc_3AD8C
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AB68:				; DATA XREF: h+239FCo
		clr.w	($FFFFF602).w
		bsr.w	loc_3AC56
		cmpi.w	#$437,$2A(a0)
		bcs.s	loc_3AB8A
		addq.b	#2,$25(a0)

loc_3AB7C:				; DATA XREF: h+239FCo
		cmpi.w	#$447,$2A(a0)
		bcc.s	loc_3AB8A
		move.w	#$4040,($FFFFF602).w

loc_3AB8A:				; CODE XREF: h+23C02j h+23C0Ej
		cmpi.w	#$460,$2A(a0)
		bcs.s	loc_3ABDE
		move.b	#6,($FFFFEEDF).w
		addq.b	#2,$25(a0)
		lea	(word_3AFB8).l,a2
		jsr	LoadChildObject
		move.w	#$3090,8(a1)
		move.w	#$3D0,$C(a1)
		lea	(word_3AFB8).l,a2
		jsr	LoadChildObject
		move.w	#$30C0,8(a1)
		move.w	#$3F0,$C(a1)
		lea	(word_3AFB8).l,a2
		jsr	LoadChildObject
		move.w	#$3090,8(a1)
		move.w	#$410,$C(a1)

loc_3ABDE:				; CODE XREF: h+23C1Cj
					; DATA XREF: h+239FCo
		cmpi.w	#$9C0,$2A(a0)
		bcc.s	loc_3AC40
		move.w	$2A(a0),d0
		addq.w	#1,d0
		move.w	d0,$2A(a0)
		move.w	$34(a0),d1
		move.w	word_3AC16(pc,d1.w),d2
		cmp.w	d2,d0
		bcs.s	loc_3AC0E
		addq.w	#2,d1
		move.w	d1,$34(a0)
		lea	byte_3AC2A(pc,d1.w),a1
		move.b	(a1)+,$10(a0)
		move.b	(a1)+,$12(a0)

loc_3AC0E:				; CODE XREF: h+23C86j
		bsr.w	loc_3AD8C
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
word_3AC16:	dc.w  $1E0		; 0
		dc.w  $260		; 1
		dc.w  $2A0		; 2
		dc.w  $2C0		; 3
		dc.w  $300		; 4
		dc.w  $3A0		; 5
		dc.w  $3F0		; 6
		dc.w  $460		; 7
		dc.w  $4A0		; 8
		dc.w  $580		; 9
byte_3AC2A:	dc.b $FF		; 0
		dc.b $FF		; 1
		dc.b   1		; 2
		dc.b   0		; 3
		dc.b   0		; 4
		dc.b   1		; 5
		dc.b   1		; 6
		dc.b $FF		; 7
		dc.b   1		; 8
		dc.b   1		; 9
		dc.b   1		; 10
		dc.b $FF		; 11
		dc.b $FF		; 12
		dc.b   1		; 13
		dc.b $FF		; 14
		dc.b $FF		; 15
		dc.b $FF		; 16
		dc.b   1		; 17
		dc.b $FE		; 18
		dc.b   0		; 19
		dc.b   0		; 20
		dc.b   0		; 21
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AC40:				; CODE XREF: h+23C70j
		move.w	#$E00,($FFFFFE10).w

loc_3AC46:				; CODE XREF: h+2391Ap
		move.w	#1,($FFFFFE02).w
		clr.b	($FFFFFE30).w
		clr.b	($FFFFFEE0).w
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AC56:				; CODE XREF: h+23A40p h+23AD4j ...
		lea	($FFFFB000).w,a1
		move.l	#$1000505,$1A(a1)
		move.w	#$100,$1E(a1)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AC6A:				; DATA XREF: h+2382Ao
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_3AC78(pc,d0.w),d1
		jmp	off_3AC78(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3AC78:	dc.w loc_3AC7E-off_3AC78; 0 ; DATA XREF: h+23D04o h+23D06o ...
		dc.w loc_3AC84-off_3AC78; 1
		dc.w loc_3ACF2-off_3AC78; 2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AC7E:				; DATA XREF: h+23D04o
		move.b	#-$39,$20(a0)

loc_3AC84:				; DATA XREF: h+23D04o
		tst.b	$21(a0)
		beq.s	locret_3ACF0
		addq.b	#2,$25(a0)
		clr.b	$20(a0)
		move.w	#$78,($FFFFEED8).w ; 'x'
		movea.w	$2C(a0),a1
		bset	#6,$22(a1)
		lea	($FFFFB000).w,a1
		clr.w	$10(a1)
		clr.w	$12(a1)
		move.w	8(a0),d0
		subi.w	#$10,d0
		move.w	d0,8(a1)
		cmpi.w	#2,($FFFFFF70).w
		bne.s	loc_3ACC8
		subi.w	#$10,$C(a1)

loc_3ACC8:				; CODE XREF: h+23D4Cj
		bset	#0,$22(a1)
		bclr	#1,$22(a1)
		bclr	#2,$22(a1)
		move.b	#$11,$1C(a1)
		move.b	#1,($FFFFB02A).w
		move.b	#1,($FFFFF7C9).w
		clr.w	($FFFFF602).w

locret_3ACF0:				; CODE XREF: h+23D14j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3ACF2:				; DATA XREF: h+23D04o
		lea	($FFFFB000).w,a1
		clr.w	$10(a1)
		clr.w	$12(a1)
		move.w	8(a0),d0
		subi.w	#$10,d0
		move.w	d0,8(a1)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD0C:				; DATA XREF: h+2382Ao
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_3AD1A(pc,d0.w),d1
		jmp	off_3AD1A(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3AD1A:	dc.w loc_3AD1C-off_3AD1A ; DATA	XREF: h+23DA6o
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD1C:				; DATA XREF: h+23DA6o
		bchg	#2,$22(a0)
		bne.s	locret_37A48
		jmp	DisplaySprite

locret_37A48:				; CODE XREF: h+20A32j h+20A3Aj ...
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD2A:				; DATA XREF: h+2382Ao
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_3AD38(pc,d0.w),d1
		jmp	off_3AD38(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3AD38:	dc.w loc_3AD3A-off_3AD38 ; DATA	XREF: h+23DC4o
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD3A:				; DATA XREF: h+23DC4o
		jsr	SpeedToPos
		jmp	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD42:				; DATA XREF: h+2382Ao
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_3AD50(pc,d0.w),d1
		jmp	off_3AD50(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_3AD50:	dc.w loc_3AD54-off_3AD50; 0 ; DATA XREF: h+23DDCo h+23DDEo
		dc.w loc_3AD5C-off_3AD50; 1
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD54:				; DATA XREF: h+23DDCo
		bsr.w	loc_3AD6E
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD5C:				; DATA XREF: h+23DDCo
		bsr.w	loc_3AD6E
		lea	(off_3AFEC).l,a1
		bsr.w	AnimateSprite
		jmp	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD6E:				; CODE XREF: h+23DE0p h+23DE8p
		movea.w	$2C(a0),a1
		move.w	8(a1),d0
		subi.w	#$C,d0
		move.w	d0,8(a0)
		move.w	$C(a1),d0
		addi.w	#$28,d0	; '('
		move.w	d0,$C(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AD8C:				; CODE XREF: h+239BCp h+2397Cp ...
		move.w	8(a0),-(sp)
		jsr	SpeedToPos
		bsr.w	loc_36776
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jmp	SolidObject
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3ADAA:				; CODE XREF: h+23894p
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	loc_3ADC6
		bsr.w	loc_3ADF6
		bsr.w	loc_3AF0C
		jsr	SpeedToPos
		bra.w	loc_36776
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3ADC6:				; CODE XREF: h+23E40j
		tst.b	$2E(a0)
		beq.s	loc_3ADD4
		jsr	Obj_GetOrientationToPlayer
		move.w	d2,$38(a0)

loc_3ADD4:				; CODE XREF: h+23E56j
		move.w	#1,d0
		move.w	$38(a0),d3
		beq.s	loc_3ADE8
		bmi.s	loc_3ADE2
		neg.w	d0

loc_3ADE2:				; CODE XREF: h+23E6Aj
		add.w	d0,d3
		move.w	d3,$38(a0)

loc_3ADE8:				; CODE XREF: h+23E68j
		move.w	8(a1),d1
		add.w	d3,d1
		move.w	d1,8(a0)
		bra.w	loc_36776
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3ADF6:				; CODE XREF: h+23E42p
		tst.b	$2F(a0)
		bne.s	loc_3AE16
		tst.b	$2E(a0)
		beq.s	locret_3AE38
		st	$2F(a0)
		clr.b	$30(a0)
		move.w	#$200,$12(a0)
		move.b	#$14,$31(a0)

loc_3AE16:				; CODE XREF: h+23E86j
		subq.b	#1,$31(a0)
		bpl.s	loc_3AE26
		clr.b	$2F(a0)
		clr.w	$12(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AE26:				; CODE XREF: h+23EA6j
		move.w	$12(a0),d0
		cmpi.w	#-$100,d0
		ble.s	loc_3AE34
		addi.w	#-$20,d0

loc_3AE34:				; CODE XREF: h+23EBAj
		move.w	d0,$12(a0)

locret_3AE38:				; CODE XREF: h+23E8Cj
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AE3A:				; CODE XREF: h+238B0p
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	loc_3AEA0
		tst.b	$2F(a0)
		bne.s	loc_3AE72
		clr.w	$12(a0)
		move.w	($FFFFF605).w,d2
		move.w	#$80,d3	; 'โฌ'
		andi.w	#$300,d2
		beq.s	loc_3AE72
		andi.w	#$200,d2
		bne.s	loc_3AE66
		neg.w	d3

loc_3AE66:				; CODE XREF: h+23EEEj
		move.w	d3,$12(a0)
		bsr.w	loc_3AF0C
		jsr	SpeedToPos

loc_3AE72:				; CODE XREF: h+23ED6j h+23EE8j
		jsr	Obj_GetOrientationToPlayer
		moveq	#$10,d3
		add.w	d3,d2
		cmpi.w	#$20,d2	; ' '
		bcs.s	locret_3AE9E
		move.w	$14(a1),d2
		bpl.s	loc_3AE88
		neg.w	d2

loc_3AE88:				; CODE XREF: h+23F10j
		cmpi.w	#$900,d2
		bcc.s	locret_3AE9E
		tst.w	d0
		beq.s	loc_3AE94
		neg.w	d3

loc_3AE94:				; CODE XREF: h+23F1Cj
		move.w	8(a1),d1
		add.w	d3,d1
		move.w	d1,8(a0)

locret_3AE9E:				; CODE XREF: h+23F0Aj h+23F18j ...
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AEA0:				; CODE XREF: h+23ED0j
		tst.b	$30(a0)
		bne.s	loc_3AEC0
		tst.b	$2E(a0)
		beq.s	locret_3AE9E
		st	$30(a0)
		clr.b	$2F(a0)
		move.w	#$200,$12(a0)
		move.b	#$2B,$31(a0) ; '+'

loc_3AEC0:				; CODE XREF: h+23F30j
		subq.b	#1,$31(a0)
		bpl.s	loc_3AED0
		clr.b	$30(a0)
		clr.w	$12(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AED0:				; CODE XREF: h+23F50j
		move.w	$12(a0),d0
		cmpi.w	#-$100,d0
		ble.s	loc_3AEDE
		addi.w	#-$20,d0

loc_3AEDE:				; CODE XREF: h+23F64j
		move.w	d0,$12(a0)
		bsr.w	loc_3AF0C
		jsr	SpeedToPos
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AEEC:				; CODE XREF: h+23984j
		jsr	Obj_GetOrientationToPlayer
		moveq	#$10,d3
		add.w	d3,d2
		cmpi.w	#$20,d2	; ' '
		bcs.s	locret_3AF0A
		tst.w	d0
		beq.s	loc_3AF00
		neg.w	d3

loc_3AF00:				; CODE XREF: h+23F88j
		move.w	8(a0),d1
		sub.w	d3,d1
		move.w	d1,8(a1)

locret_3AF0A:				; CODE XREF: h+23F84j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF0C:				; CODE XREF: h+23E46p h+23EF6p ...
		move.w	($FFFFF704).w,d0
		move.w	$C(a0),d1
		move.w	$12(a0),d2
		beq.s	locret_3AF32
		bpl.s	loc_3AF26
		addi.w	#$34,d0	; '4'
		cmp.w	d0,d1
		bcs.s	loc_3AF2E
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF26:				; CODE XREF: h+23FA6j
		addi.w	#$A8,d0	; 'ยจ'
		cmp.w	d0,d1
		bcs.s	locret_3AF32

loc_3AF2E:				; CODE XREF: h+23FAEj
		clr.w	$12(a0)

locret_3AF32:				; CODE XREF: h+23FA4j h+23FB8j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF34:				; CODE XREF: h+239CEj
		jsr	SingleObjLoad2
		bne.s	locret_3AF56
		move.b	#-$3C,0(a1)
		move.b	#-$70,$28(a1)
		move.w	a0,$2C(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

locret_3AF56:				; CODE XREF: h+23FC4j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF58:				; CODE XREF: sub_BF7Aj	h+2386Ap ...
		subq.b	#1,$37(a0)
		bmi.s	loc_3AF60
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF60:				; CODE XREF: h+23FE8j
		move.b	#8,$37(a0)
		moveq	#0,d0
		move.b	$36(a0),d0
		moveq	#$18,d1
		cmpi.w	#2,($FFFFFF70).w
		bne.s	loc_3AF78
		moveq	#4,d1

loc_3AF78:				; CODE XREF: h+24000j
		addq.b	#1,d0
		cmp.w	d1,d0
		bcs.s	loc_3AF80
		moveq	#0,d0

loc_3AF80:				; CODE XREF: h+24008j
		move.b	d0,$36(a0)
		cmpi.w	#2,($FFFFFF70).w
		bne.s	loc_3AF94
		move.b	byte_3AF9C(pc,d0.w),d0
		jmp	LoadSonicDynPLC_Part2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_3AF94:				; CODE XREF: h+24016j
		move.b	byte_3AFA0(pc,d0.w),d0
		jmp	LoadTailsDynPLC_Part2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
byte_3AF9C:	dc.b $2D		; 0
		dc.b $2E		; 1
		dc.b $2F		; 2
		dc.b $30		; 3
byte_3AFA0:	dc.b $10		; 0
		dc.b $10		; 1
		dc.b $10		; 2
		dc.b $10		; 3
		dc.b   1		; 4
		dc.b   2		; 5
		dc.b   3		; 6
		dc.b   2		; 7
		dc.b   1		; 8
		dc.b   1		; 9
		dc.b $10		; 10
		dc.b $10		; 11
		dc.b $10		; 12
		dc.b $10		; 13
		dc.b   1		; 14
		dc.b   2		; 15
		dc.b   3		; 16
		dc.b   2		; 17
		dc.b   1		; 18
		dc.b   1		; 19
		dc.b   4		; 20
		dc.b   4		; 21
		dc.b   1		; 22
		dc.b   1		; 23
word_3AFB8:	dc.w   $3E		; 0
		dc.w $9758		; 1
word_3AFBC:	dc.w   $3C		; 0
		dc.w $9756		; 1
word_3AFC0:	dc.w   $3A		; 0
		dc.w $975C		; 1
		dc.w   $3E		; 0
		dc.w $975A		; 1
off_3AFC8:	dc.l MapUnc_3AFF2	; 0
		dc.w $8500
		dc.w $404
		dc.w $6000
off_3AFD2:	dc.l MapUnc_39792
		dc.w $561
		dc.w $403
		dc.w $4000
off_3AFDC:	dc.w byte_3AFE0-off_3AFDC; 0
		dc.w byte_3AFE6-off_3AFDC; 1
byte_3AFE0:	dc.b   0,  0,  1,  2,  3,$FF; 0
byte_3AFE6:	dc.b   0,  4,  5,  6,  7,$FF; 0
off_3AFEC:	dc.w byte_3AFEE-off_3AFEC
byte_3AFEE:	dc.b   0,  1,  2,$FF	; 0
; -----------------------------------------------------------------------------
; Unknown sprite mappings
; -----------------------------------------------------------------------------
MapUnc_3AFF2:
		dc.w byte_3AFFE-byte_3AFEE; 0
		dc.w byte_3B050-byte_3AFEE; 1
		dc.w byte_3B0A2-byte_3AFEE; 2
		dc.w byte_3B0F4-byte_3AFEE; 3
		dc.w byte_3B146-byte_3AFEE; 4
		dc.w byte_3B198-byte_3AFEE; 5
byte_3AFFE:	dc.b   1,$FC,  2,$4E,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$A0,  1,$50,$FF,$D0,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$3F,  0,$1F,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
byte_3B050:	dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$A0,  1,$50,$FF,$D0,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$46,  0,$23,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
byte_3B0A2:	dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
					; DATA XREF: h+2407Eo
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$A0,  1,$50,$FF,$D0,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$49,  0,$24,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
byte_3B0F4:	dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
					; DATA XREF: h+2407Eo
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$A0,  1,$50,$FF,$D0,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$4C,  0,$26,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
byte_3B146:	dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
					; DATA XREF: h+2407Eo
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$80,  1,$40,$FF,$CE,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$3F,  0,$1F,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
byte_3B198:	dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
					; DATA XREF: h+2407Eo
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$80,  1,$40,$FF,$CE,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$46,  0,$23,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
		dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$80,  1,$40,$FF,$CE,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$49,  0,$24,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
		dc.b   0,$21,$FF,$F4,  0, $A,$F0, $B,  0,  0,  0,  0,$FF,$A0,$10,  8; 0
		dc.b   0, $C,  0,  6,$FF,$A0,  3, $A,  0, $F,  0,  7,$FF,$B8,$F8,  9; 16
		dc.b   2,$80,  1,$40,$FF,$CE,  8, $E,  0,$1E,  0, $F,$FF,$D0,$F8, $D; 32
		dc.b   0,$2A,  0,$15,$FF,$E8,$F8,  0,  0,$32,  0,$19,  0,  8,  8, $E; 48
		dc.b   0,$33,  0,$19,$FF,$F0,  8,  2,  0,$4C,  0,$26,  0,$10,$20,  5; 64
		dc.b   0,$42		; 80
		dc.b   0,$21,$FF,$F4	; 0
; -----------------------------------------------------------------------------
; Unknown sprite mappings
; -----------------------------------------------------------------------------
MapUnc_39792:				; DATA XREF: h+2405Eo h+2431Eo ...
		dc.w word_39798-MapUnc_39792; 0
		dc.w word_397AA-MapUnc_39792; 1
		dc.w word_397C4-MapUnc_39792; 2
word_39798:	dc.w 2			; DATA XREF: h+2431Eo
		dc.w $F809,$2000,$2000,$FFE4; 0
		dc.w $F80D,$2006,$2003,$FFFC; 4
word_397AA:	dc.w 3			; DATA XREF: h+2431Eo
		dc.w $F809,$2000,$2000,$FFE4; 0
		dc.w $F80D,$2006,$2003,$FFFC; 4
		dc.w $F80D,$400E,$4007,$FFC4; 8
word_397C4:	dc.w 3			; DATA XREF: h+2431Eo
		dc.w $F809,$2000,$2000,$FFE4; 0
		dc.w $F80D,$2006,$2003,$FFFC; 4
		dc.w $F805,$4016,$400B,$FFD4; 8

; ----------------------------------------------------------------------------
; Sprite
;
; Unknown
; ----------------------------------------------------------------------------

Obj98:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_21170(pc,d0.w),d1
		jsr	off_21170(pc,d1.w)
		jmp	MarkObjGone3
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_21170:	dc.w loc_21176-off_21170; 0 ; DATA XREF: h+A1FCo h+A1FEo ...
		dc.w loc_21224-off_21170; 1
		dc.w loc_212F6-off_21170; 2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21176:				; DATA XREF: h+A1FCo
		addq.b	#2,$24(a0)
		move.l	#Map_Obj25,4(a0)
		move.w	#$26C0,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$280,$18(a0)
		move.b	$28(a0),d0
		btst	#2,d0
		beq.s	loc_211F0
		addq.b	#2,$24(a0)
		andi.w	#7,d0
		move.b	d0,$1A(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	$C(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	$C(a1),d1
		bcc.s	loc_211D4
		move.b	#1,$34(a0)

loc_211D4:				; CODE XREF: h+A258j
		lea	($FFFFB380).w,a1
		cmp.w	$C(a1),d1
		bcc.s	loc_211E4
		move.b	#1,$35(a0)

loc_211E4:				; CODE XREF: h+A268j
		bra.w	loc_212F6
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
word_211E8:	dc.w   $20		; 0
		dc.w   $40		; 1
		dc.w   $80		; 2
		dc.w  $100		; 3
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_211F0:				; CODE XREF: h+A232j
		andi.w	#3,d0
		move.b	d0,$1A(a0)
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	8(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	8(a1),d1
		bcc.s	loc_21214

loc_2120E:
		move.b	#1,$34(a0)

loc_21214:				; CODE XREF: h+A298j
		lea	($FFFFB380).w,a1
		cmp.w	8(a1),d1
		bcc.s	loc_21224

loc_2121E:
		move.b	#1,$35(a0)

loc_21224:				; CODE XREF: h+A2A8j
					; DATA XREF: h+A1FCo
		tst.w	($FFFFFE08).w
		bne.s	locret_21284
		move.w	8(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_21244
		lea	($FFFFB380).w,a1
		cmpi.w	#4,($FFFFF678).w
		beq.s	locret_21284

loc_21244:				; CODE XREF: h+A2C2p
		tst.b	(a2)+
		bne.s	loc_21286
		cmp.w	8(a1),d1
		bhi.s	locret_21284
		move.b	#1,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#0,1(a0)
		bne.s	loc_2127E
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_2127E:				; CODE XREF: h+A300j
		move.b	#0,$39(a1)

locret_21284:				; CODE XREF: h+A2B4j h+A2CEj ...
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21286:				; CODE XREF: h+A2D2j
		cmp.w	8(a1),d1
		bls.s	locret_21284
		move.b	#0,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#0,1(a0)
		beq.s	loc_212BC
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_212BC:				; CODE XREF: h+A33Ej
		move.b	#0,$39(a1)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_212C4:				; CODE XREF: h+4D66p h+A308j ...
		btst	#2,$22(a1)
		beq.s	loc_212CE
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_212CE:				; CODE XREF: h+A356j
		bset	#2,$22(a1)
		move.b	#$E,$16(a1)
		move.b	#7,$17(a1)
		move.b	#2,$1C(a1)
		addq.w	#5,$C(a1)
		move.w	#$33,d0	; 'ยพ'
		jsr	(PlaySound).l
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_212F6:				; CODE XREF: h+A270j
					; DATA XREF: h+A1FCo
		tst.w	($FFFFFE08).w
		bne.s	locret_21350
		move.w	$C(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_2130E
		lea	($FFFFB380).w,a1

loc_2130E:				; CODE XREF: h+A394p
		tst.b	(a2)+
		bne.s	loc_21352
		cmp.w	$C(a1),d1
		bhi.s	locret_21350
		move.b	#1,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#0,1(a0)
		bne.s	loc_2134A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_2134A:				; CODE XREF: h+A3CAj
		move.b	#0,$39(a1)

locret_21350:				; CODE XREF: h+A386j h+A3A2j ...
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21352:				; CODE XREF: h+A39Cj
		cmp.w	$C(a1),d1
		bls.s	locret_21350
		move.b	#0,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#0,1(a0)
		beq.s	loc_2138A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_2138A:				; CODE XREF: h+A40Aj
		move.b	#0,$39(a1)
		rts	

; ---------------------------------------------------------------------------
; Ending sequence demos
; ---------------------------------------------------------------------------
Demo_EndWOZ1:	incbin	demodata\e_WOZ1.bin
		even
Demo_EndDDZ:	incbin	demodata\e_DDZ.bin
		even
Demo_EndCCZ:	incbin	demodata\e_CCZ.bin
		even
Demo_EndTJZ:	incbin	demodata\e_TJZ.bin
		even
Demo_EndKVZ:	incbin	demodata\e_KVZ.bin
		even
Demo_EndABZ1:	incbin	demodata\e_ABZ1.bin
		even
Demo_EndABZ2:	incbin	demodata\e_ABZ2.bin
		even
Demo_EndWOZ2:	incbin	demodata\e_WOZ2.bin
		even
; ---------------------------------------------------------------------------
; Subroutine to	load level boundaries and start	locations
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LevelSizeLoad:				; XREF: TitleScreen; Level; EndingSequence
		moveq	#0,d0
		move.b	d0,($FFFFF740).w
		move.b	d0,($FFFFF741).w
		move.b	d0,($FFFFF742).w
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	TitleSize
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	LevelSizeArray(pc,d0.w),a0 ; load level	boundaries
		bra.s 	LevelSizeCont

TitleSize:
		lea	TitleSizeArray,a0 ; load level	boundaries

LevelSizeCont:
		move.w	(a0)+,d0
		move.w	d0,($FFFFF730).w
		move.l	(a0)+,d0
		move.l	d0,($FFFFF728).w
		move.l	d0,($FFFFF720).w
		move.l	(a0)+,d0
		move.l	d0,($FFFFF72C).w
		move.l	d0,($FFFFF724).w
		move.w	($FFFFF728).w,d0
		addi.w	#$240,d0
		move.w	d0,($FFFFF732).w
		move.w	#$1010,($FFFFF74A).w
		move.w	(a0)+,d0
		move.w	d0,($FFFFF73E).w
		bra.w	LevSz_ChkLamp
; ===========================================================================
; ---------------------------------------------------------------------------
; Level size array and ending start location array
; ---------------------------------------------------------------------------
LevelSizeArray:	incbin	misc\lvl_size.bin
		even

TitleSizeArray:	incbin	misc\ttl_size.bin
		even

EndingStLocArray:
		incbin	misc\sloc_end.bin
		even

; ===========================================================================

LevSz_ChkLamp:				; XREF: LevelSizeLoad
		tst.b	($FFFFF7A6).w
		bne.s	LevSz_SonicPos2
		tst.l 	($FFFFF608).w
		bne.s 	LevSz_SS
		tst.b	($FFFFFE30).w	; have any lampposts been hit?
		beq.s	LevSz_StartLoc	; if not, branch
		jsr	Obj79_LoadInfo
		bra.s 	LevSz_LampCont

LevSz_SS:
		move.w 	($FFFFF608).w,($FFFFB008).w
		move.w 	($FFFFF60A).w,($FFFFB00C).w

LevSz_LampCont:
		move.w	($FFFFB008).w,d1
		move.w	($FFFFB00C).w,d0
		bra.w	loc_60D0
; ===========================================================================

LevSz_StartLoc:				; XREF: LevelSizeLoad
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		lea	(StartLocArray).l,a1			; MJ: load location array
		lea	(a1,d0.w),a1				; MJ: load Sonic's start location address
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	LevSz_SonicPos	; if not, branch
		move.w	($FFFFFFF4).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		lea	EndingStLocArray(pc,d0.w),a1 ; load Sonic's start location

LevSz_SonicPos:
		moveq	#0,d1
		move.w	(a1)+,d1
		move.w	d1,($FFFFB008).w ; set Sonic's position on x-axis
		move.w	d1,($FFFFB388).w ; set Sonic's position on x-axis
		moveq	#0,d0
		move.w	(a1),d0
		move.w	d0,($FFFFB00C).w ; set Sonic's position on y-axis
		move.w	d0,($FFFFB38C).w ; set Sonic's position on y-axis
		bra.s	LevSz_SonicPos3

LevSz_SonicPos2:
		moveq	#0,d1
		sub.w	#$3680,($FFFFB388).w ; set Sonic's position on x-axis
		clr.l	($FFFFF728).w
		sub.w	#$3E80,($FFFFB788).w
		move.w	($FFFFB008).w,d1
		sub.w	#$3E80,d1
		move.w	d1,($FFFFB008).w ; set Sonic's position on x-axis
		move.w	($FFFFB00C).w,d0 ; set Sonic's position on y-axis

LevSz_SonicPos3:
		move.b	($FFFFF600).w,d2			; MJ: load game mode
		andi.w	#$00FC,d2				; MJ: keep in range
		cmpi.b	#$04,d2					; MJ: is screen mode at title?
		bne	loc_60D0				; MJ: if not, branch
		move.w	#$1A2,d1				; MJ: set positions for title screen
		move.w	#0,d0				; MJ: ''
		move.w	d1,($FFFFB008).w			; MJ: save to object 1 so title screen follows
		move.w	d0,($FFFFB00C).w			; MJ: ''

loc_60D0:				; XREF: LevSz_ChkLamp
		clr.b	($FFFFFEB3).w
		clr.w	($FFFFF7A8).w		; reset Sonic's position tracking index
		lea	($FFFFE500).w,a2	; load the tracking array into a2
		moveq	#63,d2			; begin a 64-step loop

	@looppoint:
		move.w	d1,(a2)+		; fill in X
		move.w	d0,(a2)+		; fill in Y
		dbf	d2,@looppoint		; loop
		subi.w	#$A0,d1
		bcc.s	loc_60D8
		moveq	#0,d1

loc_60D8:
		move.w	($FFFFF72A).w,d2
		cmp.w	d2,d1
		bcs.s	loc_60E2
		move.w	d2,d1

loc_60E2:
		move.w	d1,($FFFFF700).w
		subi.w	#$60,d0
		bcc.s	loc_60EE
		moveq	#0,d0

loc_60EE:
		cmp.w	($FFFFF72E).w,d0
		blt.s	loc_60F8
		move.w	($FFFFF72E).w,d0

loc_60F8:
		move.w	d0,($FFFFF704).w
		bsr.w	BgScrollSpeed
		bra.w	LevSz_Unk

; ===========================================================================
; ---------------------------------------------------------------------------
; MJ: Sonic start location array
; ---------------------------------------------------------------------------

StartLocArray:	incbin	startpos\WOZ1.bin
		incbin	startpos\WOZ2.bin
		incbin	startpos\WOZ3.bin
		incbin	startpos\WOZ4.bin
		incbin	startpos\TJZ1.bin
		incbin	startpos\TJZ2.bin
		incbin	startpos\TJZ3.bin
		incbin	startpos\TJZ4.bin
		incbin	startpos\DDZ1.bin
		incbin	startpos\DDZ2.bin
		incbin	startpos\DDZ3.bin
		incbin	startpos\DDZ4.bin
		incbin	startpos\KVZ1.bin
		incbin	startpos\KVZ2.bin
		incbin	startpos\KVZ3.bin
		incbin	startpos\KVZ4.bin
		incbin	startpos\CCZ1.bin
		incbin	startpos\CCZ2.bin
		incbin	startpos\CCZ3.bin
		incbin	startpos\CCZ4.bin
		incbin	startpos\ABZ1.bin
		incbin	startpos\ABZ2.bin
		incbin	startpos\ABZ3.bin
		incbin	startpos\ABZ4.bin
		incbin	startpos\end1.bin
		incbin	startpos\end2.bin
		incbin	startpos\end3.bin
		incbin	startpos\end4.bin
		incbin	startpos\SSZ1.bin
		incbin	startpos\SSZ2.bin
		incbin	startpos\SSZ3.bin
		incbin	startpos\SSZ4.bin
		incbin	startpos\WAZ1.bin
		incbin	startpos\WAZ2.bin
		incbin	startpos\WAZ3.bin
		incbin	startpos\WAZ4.bin
		incbin	startpos\FCZ1.bin
		incbin	startpos\FCZ2.bin
		incbin	startpos\FCZ3.bin
		incbin	startpos\FCZ4.bin
		incbin	startpos\RTZ1.bin
		incbin	startpos\RTZ2.bin
		incbin	startpos\RTZ3.bin
		incbin	startpos\RTZ4.bin
		incbin	startpos\SZ1.bin
		incbin	startpos\SZ2.bin
		incbin	startpos\SZ3.bin
		incbin	startpos\SZ4.bin
		even

; ===========================================================================

LevSz_Unk:				; XREF: LevelSizeLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#3,d0
		lea	dword_61B4(pc,d0.w),a1
		lea	($FFFFF7F0).w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		rts	
; End of function LevelSizeLoad

; ===========================================================================
dword_61B4:	dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000

; ---------------------------------------------------------------------------
; Subroutine to	set scroll speed of some backgrounds
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BgScrollSpeed:				; XREF: LevelSizeLoad
		tst.b	($FFFFFE30).w
		bne.s	loc_6206
		tst.l 	($FFFFF608).w
		bne.s 	loc_6206
		move.w	d0,($FFFFF70C).w
		move.w	d0,($FFFFF714).w
		move.w	d1,($FFFFF708).w
		move.w	d1,($FFFFF710).w
		move.w	d1,($FFFFF718).w

loc_6206:
		cmpi.b	#4,($FFFFF600).w
		beq.w	BgScroll_Title
		moveq	#0,d2
		move.b	($FFFFFE10).w,d2
		add.w	d2,d2
		move.w	BgScroll_Index(pc,d2.w),d2
		jmp	BgScroll_Index(pc,d2.w)
; End of function BgScrollSpeed

; ===========================================================================
BgScroll_Index:	dc.w BgScroll_WOZ-BgScroll_Index, BgScroll_TJZ-BgScroll_Index
		dc.w BgScroll_DDZ-BgScroll_Index, BgScroll_KVZ-BgScroll_Index
		dc.w BgScroll_CCZ-BgScroll_Index, BgScroll_ABZ-BgScroll_Index
		dc.w BgScroll_End-BgScroll_Index, BgScroll_SSZ-BgScroll_Index
		dc.w BgScroll_WOZ-BgScroll_Index, BgScroll_FCZ-BgScroll_Index
		dc.w BgScroll_RTZ-BgScroll_Index, BgScroll_SZ-BgScroll_Index
; ===========================================================================

BgScroll_WOZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.w	#$3E00,$FFFFF708	; reset position for all BG scroll layers
		move.w	d0,$FFFFF70C	; ''
		move.w	d0,$FFFFF710	; ''
		move.w	d0,$FFFFF714	; ''
		move.w	d0,$FFFFF718	; ''
		move.w	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_TJZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_DDZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.w	d0,$FFFFF708	; reset position for all BG scroll layers
		move.w	d0,$FFFFF70C	; ''
		move.w	d0,$FFFFF710	; ''
		move.w	d0,$FFFFF714	; ''
		move.w	d0,$FFFFF718	; ''
		move.w	d0,$FFFFF71C	; ''
		rts	
; ===========================================================================
 
BgScroll_KVZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_CCZ:				; XREF: BgScroll_Index
		move.w	#$100,($FFFFF708).w
		asl.l	#4,d0
		move.l	d0,d2
		asl.l	#1,d0
		add.l	d2,d0
		asr.l	#8,d0
		addq.w	#1,d0
		move.w	d0,($FFFFF70C).w
		rts	
; ===========================================================================
 
BgScroll_ABZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_End:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 

BgScroll_SSZ:
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 

BgScroll_Title:
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_WAZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_FCZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_RTZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_SZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 

; ---------------------------------------------------------------------------
; Background layer deformation subroutines
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeformBgLayer:				; XREF: TitleScreen; Level; EndingSequence
		tst.b	($FFFFF744).w
		beq.s	loc_628E
		rts	
; ===========================================================================

loc_628E:
		clr.w	($FFFFF754).w
		clr.w	($FFFFF756).w
		clr.w	($FFFFF758).w
		clr.w	($FFFFF75A).w
		bsr.w	ScrollHoriz
		bsr.w	ScrollVertical
		bsr.w	DynScrResizeLoad
		move.w	($FFFFF700).w,($FFFFF61A).w
		move.w	($FFFFF704).w,($FFFFF616).w
		move.w	($FFFFF708).w,($FFFFF61C).w
		move.w	($FFFFF70C).w,($FFFFF618).w
		move.w	($FFFFF718).w,($FFFFF620).w
		move.w	($FFFFF71C).w,($FFFFF61E).w
		moveq	#0,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.w 	Deform_Title
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Deform_Index(pc,d0.w),d0
		jmp	Deform_Index(pc,d0.w)
; End of function DeformBgLayer

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for background layer deformation	code
; ---------------------------------------------------------------------------
Deform_Index:	dc.w Deform_WOZ-Deform_Index, Deform_TJZ-Deform_Index
		dc.w Deform_DDZ-Deform_Index, Deform_KVZ-Deform_Index
		dc.w Deform_CCZ-Deform_Index, Deform_ABZ-Deform_Index
		dc.w Deform_WOZ-Deform_Index, Deform_SSZ-Deform_Index
		dc.w Deform_WAZ-Deform_Index, Deform_FCZ-Deform_Index
		dc.w Deform_RTZ-Deform_Index, Deform_SSZ-Deform_Index
; ---------------------------------------------------------------------------
; Green	Hill Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_WOZ:			
		tst.b	($FFFFFE07).w				; has switch $F	been pressed?
		bne.w	HTZ_Screen_Shake				; if not, branch
		lea	ParallaxScriptWOZ,a1
		jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

ParallaxScriptWOZ:

_normal = $0000
_moving	= $0200
_linear = $0400
_ripple = $0600

	;	Mode	    	Speed coef.    	Number of lines
	dc.w	_moving|$01,    $0016,		68			; Clouds
	dc.w	_moving|$02,    $0014,		20			; Clouds
	dc.w	_moving|$03,    $0012,		16			; Clouds
	dc.w	_normal,		$0008,		48			; Mountain
	dc.w	_ripple,		$0008,		72			; Reflection
	dc.w	-1

;Deform_WOZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
	;	lsl.l	#7,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 8
		move.w	d0,($FFFFD900).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD902).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFD904).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFD906).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD908).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD90A).w			; set speed 2

		lea	DWOZ_Act2(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DWOZ_Act2:	dc.w	$D900,  8				; top 70 scroll
		dc.w	$D902,  8				; top 70 scroll
		dc.w	$D904,  $16				; top 70 scroll
		dc.w	$D906,  $16				; top 70 scroll
		dc.w	$D908,  $16				; bottom 70 scroll
		dc.w	$D90A,  $64				; bottom 70 scroll
		dc.w	$D90C,  $96				; bottom 70 scroll
		dc.w	$0000

HTZ_Screen_Shake:
	move.w	($FFFFF73A).w,d4	; Copy
	ext.l	d4
	lsl.l	#8,d4
	move.w	($FFFFF73C).w,d5 ;Copy
	ext.l	d5
	lsl.l	#8,d5
	bsr.w	ScrollBlock1
	move.w	($FFFFF70C).w,($FFFFF618).w
	move.w	($FFFFF704).w,($FFFFF616).w
	move.w	($FFFFF70C).w,($FFFFF618).w
	moveq	#0,d2
;	tst.b	(Screen_Shaking_Flag).w
;	beq.s	HSS1
	move.w	($FFFFFE04).w,d0
	andi.w	#$3F,d0
	lea	SwScrl_RippleData,a1
	lea	(a1,d0.w),a1
	moveq	#0,d0
	move.b	(a1)+,d0
	add.w	d0,($FFFFF616).w
	add.w	d0,($FFFFF618).w
	add.w	d0,($FFFFF73C).w
	move.b	(a1)+,d2
	add.w	d2,($FFFFF73A).w

HSS1:
	lea	($FFFFE000).w,a1
	move.w	#$DF,d1	; 'ร'
	move.w	($FFFFF700).w,d0
	add.w	d2,d0
	neg.w	d0
	swap	d0
	move.w	($FFFFF708).w,d0
	add.w	d2,d0
	neg.w	d0

HSS2:
	move.l	d0,(a1)+
	dbf	d1,HSS2
;	add.w	#1,($FFFFF70C).w
	rts
; End of function Deform_WOZ
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Deform_TJZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#7,d0					; divide by 8
		move.w	d0,($FFFFD900).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD902).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	($FFFFFE04).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#4,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFD904).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	($FFFFFE04).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#3,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFD906).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFD908).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD90A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFD90C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD90E).w			; set speed 2

		lea	DTJZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DTJZ_Act1:	dc.w	$D900,  $B0				; sky
		dc.w	$D902,  $30				; structures
		dc.w	$D904,  8				; small rocks
		dc.w	$D906,  $20				; large rocks
		dc.w	$D908,  $10				; grass 1
		dc.w	$D90A,  $28				; grass 2
		dc.w	$D90C,  $38				; leaves
		dc.w	$D90E,  $108			; trees
		dc.w	$0000

TJZ_Wave_Data:	dc.b   1,  1,  2,  2,  3,  3,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b $FF,$FF,$FE,$FE,$FD,$FD,$FD,$FD,$FE,$FE,$FF,$FF,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   1,  1,  2,  2,  3,  3,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Deform_DDZ:
	tst.b	($FFFFF746).w
	beq.s	Deform_DDZNorm
	move.w	($FFFFFE04).w,d0
	andi.w	#$3F,d0
	lea	SwScrl_RippleData,a1
	lea	(a1,d0.w),a1
	moveq	#0,d0
	move.b	(a1)+,d0
	add.w	d0,($FFFFF616).w
	add.w	d0,($FFFFF73C).w
	move.b	(a1)+,d2
	add.w	d2,($FFFFF73A).w
	move.w	($FFFFFE04).w,d0
	andi.w	#$F,d0
	tst.w	d0
	bne.s	Deform_DDZNorm
	move.b	#$6F,d0
	jsr	PlaySound

Deform_DDZNorm:
	lea	ParallaxScriptDDZ,a1
	jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

ParallaxScriptDDZ:

_normal = $0000
_moving	= $0200
_linear = $0400

	;	Mode	    	Speed coef.    	Number of lines
	dc.w	_normal,		$0008,		144			; Mountains
	dc.w	_normal,		$000C,		8			; Sand 1
	dc.w	_normal,		$0010,		8			; Sand 2
	dc.w	_normal,		$0018,		12			; Sand 3
	dc.w	_normal,		$0028,		12			; Sand 4
	dc.w	_normal,		$0048,		40			; Sand 5
	dc.w	-1

; ===========================================================================
; horizontal offsets for the water rippling effect
; byte_C682:
SwScrl_RippleData:
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 48
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 64
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32

SwScrl_RippleData2:
	dc.b $FE,    1,    2,    2,$FF,    2,    2,    1,    2,$FF,$FE,$FE,$FE,    1,$FF,$FF
	dc.b $FF,    0,$FE,    0,    0,    0,$FE,    0,$FE,    2,    0,$FE,    2,    2,$FF,$FE
	dc.b $FE,    1,    2,    2,$FF,    2,    2,    1,    2,$FF,$FE,$FE,$FE,    1,$FF,$FF
	dc.b $FF,    0,$FE,    0,    0,    0,$FE,    0,$FE,    2,    0,$FE,    2,    2,$FF,$FE
	dc.b $FE,    1,    2,    2,$FF,    2,    2,    1,    2,$FF,$FE,$FE,$FE,    1,$FF,$FF
	dc.b $FF,    0,$FE,    0,    0,    0,$FE,    0,$FE,    2,    0,$FE,    2,    2,$FF,$FE
	dc.b $FE,    1,    2,    2,$FF,    2,    2,    1,    2,$FF,$FE,$FE,$FE,    1,$FF,$FF
	dc.b $FF,    0,$FE,    0,    0,    0,$FE,    0,$FE,    2,    0,$FE,    2,    2,$FF,$FE
	dc.b $FE,    1,    2,    2,$FF,    2,    2,    1,    2,$FF,$FE,$FE,$FE,    1,$FF,$FF
; ===========================================================================

Deform_DDZ2:
		move.w	($FFFFF73A).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.l	d4,d1
		asl.l	#1,d4
		add.l	d1,d4
		moveq	#0,d5
		bsr.w	ScrollBlock1
		move.w	#$200,d0
		move.w	($FFFFF704).w,d1
		subi.w	#$1C8,d1
		bcs.s	loc_6402
		move.w	d1,d2
		add.w	d1,d1
		add.w	d2,d1
		asr.w	#2,d1
		add.w	d1,d0

loc_6402:
		move.w	d0,($FFFFF714).w
		bsr.w	ScrollBlock3
		move.w	($FFFFF70C).w,($FFFFF618).w
		lea	($FFFFE000).w,a1
		move.w	#$DF,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		move.w	($FFFFF708).w,d0
		neg.w	d0

loc_6426:
		move.l	d0,(a1)+
		dbf	d1,loc_6426
		rts	
; End of function Deform_DDZ
; ===========================================================================
 
Deform_KVZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 8
		move.w	($FFFFFE04).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#3,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFA800).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	($FFFFFE04).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#2,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA808).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA80A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#2,d1
		add.w	d1,d0
		move.w	d0,($FFFFA80C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA80E).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA810).w			; set speed 2
		lea	DKVZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DKVZ_Act1:	dc.w	$A800,  $20				; 
		dc.w	$A802,  $20				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A800,  $20				; 
		dc.w	$A802,  $20				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A804,  $48				; 
		dc.w	$A806,  $15				; 
		dc.w	$A808,  $E				; 
		dc.w	$A80A,  $A				; 
		dc.w	$A80C,  $6				; 
		dc.w	$A80E,  $E				; 
		dc.w	$A810,  $11F				; 
		dc.w	$0000
; End of function Deform_KVZ

Deform_All:				; XREF: Deform_DDZ, Deform_CCZ, ...
		lea	($FFFFE000).w,a1
		move.w	#$E,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		andi.w	#$F,d2
		add.w	d2,d2
		move.w	(a2)+,d0
		jmp	Deform_All_2(pc,d2.w)
; End of function Deform_DDZ
 
; ===========================================================================
 
Deform_All_1:				; XREF: Deform_All
		move.w	(a2)+,d0
 
Deform_All_2:
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		dbf	d1,Deform_All_1
		rts	
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

 
Deform_CCZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 8
		move.w	d0,($FFFFD900).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD902).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFD904).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFD906).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFD908).w			; set speed 2

		lea	DWOZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DWOZ_Act1:	dc.w	$D900,  $20				; top 70 scroll
		dc.w	$D902,  $20				; top 70 scroll
		dc.w	$D904,  $20				; top 70 scroll
		dc.w	$D906,  $20				; top 70 scroll
		dc.w	$D908,  $40				; bottom 70 scroll
		dc.w	$D906,  $C0				; bottom 70 scroll
		dc.w	$D904,  $A0				; bottom 70 scroll
		dc.w	$0000

; ===========================================================================		

 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Deform_ABZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#7,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 8
		move.w	d0,($FFFFA800).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DABZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DABZ_Act1:	dc.w	$A800,  $50				; middle metal
		dc.w	$A802,  $20				; way back mountains
		dc.w	$A804,  8				; back mountains
		dc.w	$A806,  $20				; middle stuff
		dc.w	$A808,  $20				; foreground mountains
		dc.w	$A800,  $198				; metal
		dc.w	$A802,  $20				; way back mountains
		dc.w	$A804,  8				; back mountains
		dc.w	$A806,  $20				; middle stuff
		dc.w	$A808,  $20				; foreground mountains
		dc.w	$A800,  $198				; metal
		dc.w	$0000

; ===========================================================================

 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
Deform_SSZ:
		lea	ParallaxScriptSSZ,a1
		jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

ParallaxScriptSSZ:

_normal = $0000
_moving	= $0200
_linear = $0400

	;	Mode	    	Speed coef.    	Number of lines
	dc.w	_moving|$02,    $0004,		16			; Clouds
	dc.w	_moving|$03,    $0004,		16			; Clouds
	dc.w	_moving|$04,    $0004,		8			; Clouds
	dc.w	_normal,   		$0004,		8			; Mountains
	dc.w	_normal, 	  	$0006,		208			; Ground
	dc.w	-1
; End of function Deform_SSZ
; ===========================================================================

Deform_Title:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		move.w	#0,($FFFFA800).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		move.w	#0,($FFFFA808).w			; set speed 2

		lea	DTitleB(pc),a0			; load scroll data to use
		bsr.w	DeformScroll2				; continue

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA80A).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA80C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA80E).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA810).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA812).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA814).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		move.w	d0,($FFFFA816).w			; set speed 2

		lea	DTitleF(pc),a0			; load scroll data to use
		bra.w	DeformScroll3				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DTitleB:	dc.w	$A800,  $38				; Sun
		dc.w	$A802,  $20				; Clouds
		dc.w	$A804,  $18				; Grass
		dc.w	$A806,  $50				; Water
		dc.w	$A808,  $20				; Blank
		dc.w	$0000

DTitleF:	dc.w	$A80A,  $48				; Clouds
		dc.w	$A80C,  $28				; Mountains
		dc.w	$A80E,  $10				; Islands 1
		dc.w	$A810,  $10				; Islands 2
		dc.w	$A812,  8				; Islands 3
		dc.w	$A814,  8				; Islands 4
		dc.w	$A816,  $40				; Bushes
		dc.w	$0000

;		lea	ParallaxScriptTitle,a1
;		jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

Deform_WAZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DWAZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DWAZ_Act1:	dc.w	$A800,  $D0				; stars
		dc.w	$A802,  $78				; mountains
		dc.w	$A804,  $78				; snow 1
		dc.w	$A806,  $40				; snow 2
		dc.w	$A808,  $80				; water
		dc.w	$0000

Deform_FCZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DWAZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

Deform_RTZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#5,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA80A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA80C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA80E).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA810).w			; set speed 2

		lea	DRTZ(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DRTZ:	dc.w	$A800,  $30				; big clouds
		dc.w	$A802,  $10				; medium clouds
		dc.w	$A804,  $10				; small clouds
		dc.w	$A806,  $50				; transition
		dc.w	$A808,  $80				; top mountains
		dc.w	$A80A,  $20				; middle mountains
		dc.w	$A80C,  $58				; lower mountains
		dc.w	$A80E,  $38				; bush 1
		dc.w	$A810,  $20				; bush 2
		dc.w	$0000

; ---------------------------------------------------------------

ParallaxScriptSZ:

_normal = $0000
_moving	= $0200
_linear = $0400

	;	Mode	    	Speed coef.    	Number of lines
	dc.w	_normal,		$0008,		144			; Mountains
	dc.w	_normal,		$000C,		8			; Sand 1
	dc.w	_normal,		$0010,		8			; Sand 2
	dc.w	_normal,		$0018,		12			; Sand 3
	dc.w	_normal,		$0028,		12			; Sand 4
	dc.w	_normal,		$0048,		40			; Sand 5
	dc.w	-1

Deform_BonusStage:
		bsr.w	ScrollHoriz
		bsr.w	DynScrResizeLoad
		lea	($FFFFE000).w,a1			; load H-scroll buffer

		move.w	($FFFFFE04).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		move.w	($FFFFFE9E).w,d2
		lsr.w	#6,d2
		add.w	d2,($FFFFF616).w
		asr.w	#$03,d0					; divide by 8 (/8 the speed of the FG)
		move.w	#$0058-1,d1				; set number of scanlines to write

DBS_TopLoop:
		addi.w	#0,(a1)+
		move.w	d0,(a1)+				; write AAAA BBBB
		dbf	d1,DBS_TopLoop				; repeat for all $70 scanlines)

		move.w	($FFFFFE04).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		asr.w	#$02,d0					; divide by 4 (/4 the speed of the FG)
		move.w	#$0088-1,d1				; set number of scanlines to write

DBS_NextLoop:
		addi.w	#0,(a1)+
		move.w	d0,(a1)+				; write AAAA BBBB
		dbf	d1,DBS_NextLoop			; repeat for all $70 scanlines)

		lea	($FFFFE000).w,a1			; load H-scroll buffer
		move.w	($FFFFFE04).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		move.w	d0,d2
		asl.w	#$02,d0					; divide by 4 (/4 the speed of the FG)
		asl.w	#$03,d2					; divide by 4 (/4 the speed of the FG)
		move.w	#$0070-1,d1				; set number of scanlines to write

DBS_FrontLoop:
		move.w	d0,(a1)+				; write AAAA BBBB
		addi.w	#0,(a1)+
		move.w	d2,(a1)+				; write AAAA BBBB
		addi.w	#0,(a1)+
		dbf	d1,DBS_FrontLoop			; repeat for all $70 scanlines)

		rts		
; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DBonusB:	dc.w	$A800,  $58				; Clouds
		dc.w	$A802,  $88				; Clouds

DBonusF:	dc.w	$A804,  $E0				; Clouds
		dc.w	$0000

; ===========================================================================
; ---------------------------------------------------------------------------
; Deform scanlines correctly using a list
; ---------------------------------------------------------------------------

DeformScroll:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF70C).w,d6			; load Y position
		move.l	($FFFFF700).w,d1			; prepare FG X position
		neg.l	d1					; reverse position

DS_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS_EndSection				; if the screen is finished, branch

DS_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS_NextScanline:
		move.l	d1,(a2)+				; save scroll position
		dbf	d6,DS_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS_NextSection				; if the screen is not finished, branch

DS_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS_Finish				; if finished, branch
		move.w	(a1),d1					; load X position

DS_LastScanlines:
		move.l	d1,(a2)+				; save scroll position
		dbf	d7,DS_LastScanlines			; repeat for all scanlines

DS_Finish:
		rts						; return

DeformScroll2:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF70C).w,d6			; load Y position

DS2_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS2_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS2_EndSection				; if the screen is finished, branch

DS2_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS2_NextScanline:
		add.w	#0,(a2)+				; save scroll position
		move.w	d1,(a2)+				; save scroll position
		dbf	d6,DS2_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS2_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS2_NextSection				; if the screen is not finished, branch

DS2_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS2_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS2_Finish				; if finished, branch
		move.w	(a1),d1					; load X position

DS2_LastScanlines:
		add.w	#0,(a2)+				; save scroll position
		move.w	d1,(a2)+				; save scroll position
		dbf	d7,DS2_LastScanlines			; repeat for all scanlines

DS2_Finish:
		rts						; return

DeformScroll3:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF704).w,d6			; load Y position

DS3_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS3_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS3_EndSection				; if the screen is finished, branch

DS3_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS3_NextScanline:
		move.w	d1,(a2)+				; save scroll position
		add.w	#0,(a2)+				; save scroll position
		dbf	d6,DS3_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS3_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS3_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS3_NextSection				; if the screen is not finished, branch

DS3_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS3_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS3_Finish				; if finished, branch
		swap	d1
		move.w	(a1),d1					; load X position
		swap	d1

DS3_LastScanlines:
		move.w	d1,(a2)+				; save scroll position
		add.w	#0,(a2)+				; save scroll position
		dbf	d7,DS3_LastScanlines			; repeat for all scanlines

DS3_Finish:
		rts						; return

; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	scroll the level horizontally as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz:				; XREF: DeformBgLayer
		move.w	($FFFFF700).w,d4
		bsr.s	ScrollHoriz2
		move.w	($FFFFF700).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74A).w,d1
		eor.b	d1,d0
		bne.s	locret_65B0
		eori.b	#$10,($FFFFF74A).w
		move.w	($FFFFF700).w,d0
		sub.w	d4,d0
		bpl.s	loc_65AA
		bset	#2,($FFFFF754).w
		rts	
; ===========================================================================

loc_65AA:
		bset	#3,($FFFFF754).w

locret_65B0:
		rts	
; End of function ScrollHoriz


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz2:				; XREF: ScrollHoriz
		move.w	($FFFFB008).w,d0
		sub.w	($FFFFF700).w,d0
		subi.w	#$90,d0
		bcs.s	loc_65F6
		subi.w	#$10,d0
		bcc.s	loc_65CC
		clr.w	($FFFFF73A).w
		rts	
; ===========================================================================

loc_65CC:
		cmpi.w	#$10,d0
		bcs.s	loc_65D6
		move.w	#$10,d0

loc_65D6:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF72A).w,d0
		blt.s	loc_65E4
		move.w	($FFFFF72A).w,d0

loc_65E4:
		move.w	d0,d1
		sub.w	($FFFFF700).w,d1
		asl.w	#8,d1
		move.w	d0,($FFFFF700).w
		move.w	d1,($FFFFF73A).w
		rts	
; ===========================================================================

loc_65F6:
		cmpi.w	#$FFF0,d0				; has the screen moved more than 10 pixels left?
		bcc.s	Left_NoMax				; if not, branch
		move.w	#$FFF0,d0				; set the maximum move distance to 10 pixels left

Left_NoMax:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF728).w,d0
		bgt.s	loc_65E4
		move.w	($FFFFF728).w,d0
		bra.s	loc_65E4
; End of function ScrollHoriz2

; ===========================================================================


; ---------------------------------------------------------------------------
; Subroutine to	scroll the level vertically as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollVertical:				; XREF: DeformBgLayer
		moveq	#0,d1
		move.w	($FFFFB00C).w,d0
		sub.w	($FFFFF704).w,d0
		btst	#2,($FFFFB022).w
		beq.s	loc_662A
		subq.w	#5,d0

loc_662A:
		btst	#1,($FFFFB022).w
		beq.s	loc_664A
		addi.w	#$20,d0
		sub.w	($FFFFF73E).w,d0
		bcs.s	loc_6696
		subi.w	#$40,d0
		bcc.s	loc_6696
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8
		bra.s	loc_6656
; ===========================================================================

loc_664A:
		sub.w	($FFFFF73E).w,d0
		bne.s	loc_665C
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8

loc_6656:
		clr.w	($FFFFF73C).w
		rts	
; ===========================================================================

loc_665C:
		cmpi.w	#$60,($FFFFF73E).w
		bne.s	loc_6684
		move.w	($FFFFB020).w,d1
		bpl.s	loc_666C
		neg.w	d1

loc_666C:
		cmpi.w	#$800,d1
		bcc.s	loc_6696
		move.w	#$600,d1
		cmpi.w	#6,d0
		bgt.s	loc_66F6
		cmpi.w	#-6,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6684:
		move.w	#$200,d1
		cmpi.w	#2,d0
		bgt.s	loc_66F6
		cmpi.w	#-2,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6696:
		move.w	#$1000,d1
		cmpi.w	#$10,d0
		bgt.s	loc_66F6
		cmpi.w	#-$10,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_66A8:
		moveq	#0,d0
		move.b	d0,($FFFFF75C).w

loc_66AE:
		moveq	#0,d1
		move.w	d0,d1
		add.w	($FFFFF704).w,d1
		tst.w	d0
		bpl.w	loc_6700
		bra.w	loc_66CC
; ===========================================================================

loc_66C0:
		neg.w	d1
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_66CC:
		cmp.w	($FFFFF72C).w,d1
		bgt.s	loc_6724
		cmpi.w	#-$100,d1
		bgt.s	loc_66F0
		andi.w	#$7FF,d1
		andi.w	#$7FF,($FFFFB00C).w
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_66F0:
		move.w	($FFFFF72C).w,d1
		bra.s	loc_6724
; ===========================================================================

loc_66F6:
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_6700:
		cmp.w	($FFFFF72E).w,d1
		blt.s	loc_6724
		subi.w	#$800,d1
		bcs.s	loc_6720
		andi.w	#$7FF,($FFFFB00C).w
		subi.w	#$800,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_6720:
		move.w	($FFFFF72E).w,d1

loc_6724:
		move.w	($FFFFF704).w,d4
		swap	d1
		move.l	d1,d3
		sub.l	($FFFFF704).w,d3
		ror.l	#8,d3
		move.w	d3,($FFFFF73C).w
		move.l	d1,($FFFFF704).w
		move.w	($FFFFF704).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74B).w,d1
		eor.b	d1,d0
		bne.s	locret_6766
		eori.b	#$10,($FFFFF74B).w
		move.w	($FFFFF704).w,d0
		sub.w	d4,d0
		bpl.s	loc_6760
		bset	#0,($FFFFF754).w
		rts	
; ===========================================================================

loc_6760:
		bset	#1,($FFFFF754).w

locret_6766:
		rts	
; End of function ScrollVertical


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock1:				; XREF: Deform_TJZ, Deform_ABZ
		move.l	($FFFFF708).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF708).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74C).w,d3
		eor.b	d3,d1
		bne.s	ScrollBlock1_2
		eori.b	#$10,($FFFFF74C).w
		sub.l	d2,d0
		bpl.s	ScrollBlock1_1
		bset	#2,($FFFFF756).w
		bra.s	ScrollBlock1_2
; ===========================================================================
 
ScrollBlock1_1:				; XREF: ScrollBlock1
		bset	#3,($FFFFF756).w
 
ScrollBlock1_2:				; XREF: ScrollBlock1, Deform_ABZ, ...
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	ScrollBlock1_End
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	ScrollBlock1_3
		bset	#0,($FFFFF756).w
		rts	
; ===========================================================================
 
ScrollBlock1_3:				; XREF: ScrollBlock1
		bset	#1,($FFFFF756).w
 
ScrollBlock1_End:			; XREF: ScrollBlock1
		rts	
; End of function ScrollBlock1
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock2:				; XREF: Deform_DDZ, Deform_CCZ
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	ScrollBlock2_End
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	ScrollBlock2_1
		bset	#4,($FFFFF756).w
		rts	
; ===========================================================================
 
ScrollBlock2_1:				; XREF: ScrollBlock2
		bset	#5,($FFFFF756).w
 
ScrollBlock2_End:			; XREF: ScrollBlock2
		rts	
; End of function ScrollBlock2
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock3:				; XREF: Deform_DDZ
		move.w	($FFFFF70C).w,d3
		move.w	d0,($FFFFF70C).w
		move.w	d0,d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	ScrollBlock3_End
		eori.b	#$10,($FFFFF74D).w
		sub.w	d3,d0
		bpl.s	ScrollBlock3_1
		bset	#0,($FFFFF756).w
		rts	
; ===========================================================================
 
ScrollBlock3_1:				; XREF: ScrollBlock3
		bset	#1,($FFFFF756).w
 
ScrollBlock3_End:			; XREF: ScrollBlock3
		rts	
; End of function ScrollBlock3
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock4:				; XREF: Deform_DDZ, Deform_ABZ
		move.l	($FFFFF708).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF708).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74C).w,d3
		eor.b	d3,d1
		bne.s	ScrollBlock4_End
		eori.b	#$10,($FFFFF74C).w
		sub.l	d2,d0
		bpl.s	ScrollBlock4_1
		bset	d6,($FFFFF756).w
		bra.s	ScrollBlock4_End
; ===========================================================================
 
ScrollBlock4_1:				; XREF: ScrollBlock4
		addq.b	#1,d6
		bset	d6,($FFFFF756).w
 
ScrollBlock4_End:			; XREF: ScrollBlock4
		rts	
; End of function ScrollBlock4
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock5:				; XREF: Deform_WOZ, Deform_DDZ, ...
		move.l	($FFFFF710).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF710).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74E).w,d3
		eor.b	d3,d1
		bne.s	ScrollBlock5_End
		eori.b	#$10,($FFFFF74E).w
		sub.l	d2,d0
		bpl.s	ScrollBlock5_1
		bset	d6,($FFFFF758).w
		bra.s	ScrollBlock5_End
; ===========================================================================
 
ScrollBlock5_1:				; XREF: ScrollBlock5
		addq.b	#1,d6
		bset	d6,($FFFFF758).w
 
ScrollBlock5_End:			; XREF: ScrollBlock5
		rts	
; End of function ScrollBlock5
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock6:				; XREF: Deform_WOZ, Deform_DDZ, ...
		move.l	($FFFFF718).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF718).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF750).w,d3
		eor.b	d3,d1
		bne.s	ScrollBlock6_End
		eori.b	#$10,($FFFFF750).w
		sub.l	d2,d0
		bpl.s	ScrollBlock6_1
		bset	d6,($FFFFF75A).w
		bra.s	ScrollBlock6_End
; ===========================================================================
 
ScrollBlock6_1:				; XREF: ScrollBlock6
		addq.b	#1,d6
		bset	d6,($FFFFF75A).w
 
ScrollBlock6_End:			; XREF: ScrollBlock6
		rts	
; End of function ScrollBlock6


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6886:		
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFF756).w,a2
		lea	($FFFFF708).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6D0A
		lea	($FFFFF758).w,a2
		lea	($FFFFF710).w,a3
		bra.w	sub_6DA6
; End of function sub_6886
 
; ---------------------------------------------------------------------------
; Subroutine to	display	correct	tiles as you move
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesAsYouMove:			; XREF: Demo_Time
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFFF32).w,a2
		lea	($FFFFFF18).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6D0A
		lea	($FFFFFF34).w,a2
		lea	($FFFFFF20).w,a3
		bsr.w	sub_6DA6
		lea	($FFFFFF36).w,a2
		lea	($FFFFFF28).w,a3
		bsr.w	sub_6EA4
		lea	($FFFFFF30).w,a2
		lea	($FFFFFF10).w,a3
		movea.l	($FFFF8000).w,a4; MJ: Load address of layout
		move.w	#$4000,d2
		tst.b	($FFFFF745).w
		beq.s	Draw_FG
		move.b	#0,($FFFFF745).w	;Reset the redraw flag
		moveq	#-$10,d4			;Go to top line oflevel data relative camera position
		moveq	#$F,d6				;
 
Draw_All:
		movem.l	d4-d6,-(sp)			; This whole routine basically redraws the whole
		moveq	#-$10,d5			; area instead of merely a line of tiles
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos
		move.w	d1,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,Draw_All
		rts	
 
Draw_FG:
		tst.b	(a2)
		beq.s	locret_6D08
		bclr	#0,(a2)
		beq.s	loc_6CBE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6CBE:
		bclr	#1,(a2)
		beq.s	loc_6CD8
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6CD8:
		bclr	#2,(a2)
		beq.s	loc_6CEE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_TB
 
loc_6CEE:
		bclr	#3,(a2)
		beq.s	locret_6D08
		moveq	#-$10,d4
		move.w	#$150,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		move.w	#$150,d5
		bsr.w	DrawTiles_TB
 
locret_6D08:
		rts	
 
; End of function LoadTilesAsYouMove
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6D0A:
		tst.b	(a2)
		beq.w	locret_6DA4
		bclr	#0,(a2)
		beq.s	loc_6D26
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6D26:
		bclr	#1,(a2)
		beq.s	loc_6D40
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6D40:
		bclr	#2,(a2)
		beq.s	loc_6D56
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_TB
 
loc_6D56:
		bclr	#3,(a2)
		beq.s	loc_6D70
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	DrawTiles_TB
 
loc_6D70:
		bclr	#4,(a2)
		beq.s	loc_6D88
		moveq	#-$10,d4
		moveq	#0,d5
		bsr.w	loc_7176
		moveq	#-$10,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6D88:
		bclr	#5,(a2)
		beq.s	locret_6DA4
		move.w	#$E0,d4	; 'ร'
		moveq	#0,d5
		bsr.w	loc_7176
		move.w	#$E0,d4	; 'ร'
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
locret_6DA4:
		rts	
; End of function sub_6D0A
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6DA6:
		tst.b	(a2)
		beq.w	locret_6DF2
	;	cmpi.b	#5,($FFFFFE10).w
	;	beq.w	loc_6E16
		bclr	#0,(a2)
		beq.s	loc_6DD2
		move.w	#$70,d4	; 'p'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$70,d4	; 'p'
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
loc_6DD2:
		bclr	#1,(a2)
		beq.s	locret_6DF2
		move.w	#$70,d4	; 'p'
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$70,d4	; 'p'
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
locret_6DF2:
		rts	
; ===========================================================================
unk_6DF4:	dc.b   0 ;	 
unk_6DF5:	dc.b   0 ;	 
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   0 ;  
; ===========================================================================
 
loc_6E16:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_6E28
		bclr	#1,(a2)
		beq.s	loc_6E72
		move.w	#$E0,d4	; 'ร'
 
loc_6E28:
		lea	(unk_6DF5).l,a0
		move.w	($FFFFF70C).w,d0
		add.w	d4,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		lea	(unk_6FE4).l,a3
		movea.w	(a3,d0.w),a3
		beq.s	loc_6E5E
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos
		movem.l	(sp)+,d4-d5
		bsr.w	DrawTiles_LR
		bra.s	loc_6E72
; ===========================================================================
 
loc_6E5E:
		moveq	#0,d5
		movem.l	d4-d5,-(sp)
		bsr.w	loc_7176
		movem.l	(sp)+,d4-d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6E72:
		tst.b	(a2)
		bne.s	loc_6E78
		rts	
; ===========================================================================
 
loc_6E78:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_6E8C
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5
 
loc_6E8C:
		lea	(unk_6DF4).l,a0
		move.w	($FFFFF70C).w,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_6FEC
; End of function sub_6DA6
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6EA4:
		tst.b	(a2)
		beq.w	locret_6EF0
		cmpi.b	#2,($FFFFFE10).w
		beq.w	loc_6F54
		bclr	#0,(a2)
		beq.s	loc_6ED0_2
		move.w	#$40,d4	; '@'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$40,d4	; '@'
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
loc_6ED0_2:
		bclr	#1,(a2)
		beq.s	locret_6EF0
		move.w	#$40,d4	; '@'
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$40,d4	; '@'
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
locret_6EF0:
		rts	
; ===========================================================================
unk_6EF2:	dc.b   0 ;	 
unk_6EF3:	dc.b   0 ;	 
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   0 ;  
; ===========================================================================
 
loc_6F54:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_6F66
		bclr	#1,(a2)
		beq.s	loc_6FAE
		move.w	#$E0,d4	; 'ร'
 
loc_6F66:
		lea	(unk_6EF3).l,a0
		move.w	($FFFFF70C).w,d0
		subi.w	#$200,d0
		add.w	d4,d0
		andi.w	#$7F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		movea.w	unk_6FE4(pc,d0.w),a3
		beq.s	loc_6F9A
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos
		movem.l	(sp)+,d4-d5
		bsr.w	DrawTiles_LR
		bra.s	loc_6FAE
; ===========================================================================
 
loc_6F9A:
		moveq	#0,d5
		movem.l	d4-d5,-(sp)
		bsr.w	loc_7176
		movem.l	(sp)+,d4-d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6FAE:
		tst.b	(a2)
		bne.s	loc_6FB4
		rts	
; ===========================================================================
 
loc_6FB4:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_6FC8
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5
 
loc_6FC8:
		lea	(unk_6EF2).l,a0
		move.w	($FFFFF70C).w,d0
		subi.w	#$200,d0
		andi.w	#$7F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_6FEC
; ===========================================================================
unk_6FE4:	dc.b $FF ;  
		dc.b $18 ;  
		dc.b $FF ;  
		dc.b $18 ;  
		dc.b $FF ;  
		dc.b $20 ;  
		dc.b $FF ;  
		dc.b $28 ; (
; ===========================================================================
 
loc_6FEC:
		moveq	#$F,d6
		move.l	#$800000,d7
 
loc_6FF4:
		moveq	#0,d0
		move.b	(a0)+,d0
		btst	d0,(a2)
		beq.s	loc_701C
		movea.w	unk_6FE4(pc,d0.w),a3
		movem.l	d4-d5/a0,-(sp)
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		movem.l	(sp)+,d4-d5
		bsr.w	Calc_VRAM_Pos
		bsr.w	sub_70AC
		movem.l	(sp)+,d4-d5/a0
 
loc_701C:
		addi.w	#$10,d4
		dbf	d6,loc_6FF4
		clr.b	(a2)
		rts	
; End of function sub_6EA4
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR:
		moveq	#$16,d6
; End of function DrawTiles_LR
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR2:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_7032:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		move.l	d1,d0
		bsr.w	sub_70AC
		addq.b	#4,d1
		andi.b	#$7F,d1	; ''
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d5
		dbf	d6,loc_7032
		rts	
; End of function DrawTiles_LR2
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR3:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_705C:
		movem.l	d4-d5,-(sp)
		bsr.w	loc_712C
		move.l	d1,d0
		bsr.w	sub_70AC
		addq.b	#4,d1
		andi.b	#$7F,d1	; ''
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d5
		dbf	d6,loc_705C
		rts	
; End of function DrawTiles_LR3
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_TB:
		moveq	#$F,d6
; End of function DrawTiles_TB
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_TB2:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_7088:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		move.l	d1,d0
		bsr.w	sub_70AC
		addi.w	#$100,d1
		andi.w	#$FFF,d1
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d4
		dbf	d6,loc_7088
		rts	
; End of function DrawTiles_TB2
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_70AC:
		or.w	d2,d0
		swap	d0
		btst	#3,(a0)	; MJ: checking bit 3 not 4 (Flip)
		bne.s	loc_70E8
		btst	#2,(a0)	; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_70C8
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		rts	
; ===========================================================================
 
loc_70C8:
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		rts	
; ===========================================================================
 
loc_70E8:
		btst	#2,(a0) ; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_710A
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$10001000,d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$10001000,d5
		move.l	d5,(a6)
		rts	
; ===========================================================================
 
loc_710A:
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$18001800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$18001800,d5
		swap	d5
		move.l	d5,(a6)
		rts	
; End of function sub_70AC
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_712A:
		add.w	(a3),d5
 
loc_712C:
		add.w	4(a3),d4
		lea	($FFFF9000).w,a1
		move.w	d4,d3
		andi.w  #$780,d3; MJ: get within 780 (Not 380) (E00 pixels (not 700)) in multiples of 80
		lsr.w	#3,d5
		move.w	d5,d0
		lsr.w   #4,d0	; MJ: divide by 10 (Not 20)
		lsl.w   #$01,d3	; MJ: multiply by 2 (So it skips the BG)
		add.w	d3,d0
		moveq	#-1,d3
		move.b	(a4,d0.w),d3
		andi.w  #$FF,d3	; MJ: keep within FF
		ror.w	#7,d3
		ror.w   #2,d3	; MJ: ..plus an extra 2 (so it's within 80 bytes, not 200)
		andi.w  #$070,d4; MJ: keep Y pos within 80 pixels
		andi.w  #$0E,d5	; MJ: keep X pos within 10
		add.w	d4,d3
		add.w	d5,d3
		movea.l	d3,a0
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		adda.w	d3,a1
 
locret_7172:
		rts	
; End of function sub_712A
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Calc_VRAM_Pos:
		add.w	(a3),d5
 
loc_7176:
		add.w	4(a3),d4
		andi.w	#$F0,d4	; 'รฐ'
		andi.w	#$1F0,d5
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#3,d0
		swap	d0
		move.w	d4,d0
		rts	
; End of function Calc_VRAM_Pos
 
; ===========================================================================
		add.w	4(a3),d4
		add.w	(a3),d5
		andi.w	#$F0,d4	; 'รฐ'
		andi.w	#$1F0,d5
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#2,d0
		swap	d0
		move.w	d4,d0
		rts	
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesFromStart:
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFF700).w,a3
		movea.l ($FFFF8000).w,a4; MJ: Load address of layout
		move.w	#$4000,d2
		bsr.s	LoadTilesFromStart2
		lea	($FFFFF708).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG 
		move.w	#$6000,d2
; End of function LoadTilesFromStart
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesFromStart2:
		moveq	#-$10,d4
		moveq	#$F,d6
 
loc_71FC:
		movem.l	d4-d6,-(sp)
		moveq	#0,d5
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos
		move.w	d1,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR2
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_71FC
		rts	
; End of function LoadTilesFromStart2

LoadZoneTiles:
		moveq	#0,d0			; Clear d0
		move.b	($FFFFFE10).w,d0		; Load number of current zone to d0
		lsl.w	#4,d0			; Multiply by $10, converting the zone ID into an offset
		lea	(MainLoadBlocks).l,a2	; Load LevelHeaders's address into a2
		lea	(a2,d0.w),a2		; Offset LevelHeaders by the zone-offset, and load the resultant address to a2
		move.l	(a2)+,d0		; Move the first longword of data that a2 points to to d0, this contains the zone's first PLC ID and its art's address.
						; The auto increment is pointless as a2 is overwritten later, and nothing reads from a2 before then
		andi.l	#$FFFFFF,d0    		; Filter out the first byte, which contains the first PLC ID, leaving the address of the zone's art in d0
		movea.l	d0,a0			; Load the address of the zone's art into a0 (source)
		lea	($FF0000).l,a1		; Load v_256x256/StartOfRAM (in this context, an art buffer) into a1 (destination)
		jsr	KosDec			; Decompress a0 to a1 (Kosinski compression)

		move.w	a1,d3			; Move a word of a1 to d3, note that a1 doesn't exactly contain the address of v_256x256/StartOfRAM anymore, after KosDec, a1 now contains v_256x256/StartOfRAM + the size of the file decompressed to it, d3 now contains the length of the file that was decompressed
		move.w	d3,d7			; Move d3 to d7, for use in seperate calculations

		andi.w	#$FFF,d3		; Remove the high nibble of the high byte of the length of decompressed file, this nibble is how many $1000 bytes the decompressed art is
		lsr.w	#1,d3			; Half the value of 'length of decompressed file', d3 becomes the 'DMA transfer length'

		rol.w	#4,d7			; Rotate (left) length of decompressed file by one nibble
		andi.w	#$F,d7			; Only keep the low nibble of low byte (the same one filtered out of d3 above), this nibble is how many $1000 bytes the decompressed art is

LoadZoneTilesloop:
		move.w	d7,d2			; Move d7 to d2, note that the ahead dbf removes 1 byte from d7 each time it loops, meaning that the following calculations will have different results each time
		lsl.w	#7,d2
		lsl.w	#5,d2			; Shift (left) d2 by $C, making it high nibble of the high byte, d2 is now the size of the decompressed file rounded down to the nearest $1000 bytes, d2 becomes the 'destination address'

		move.l	#$FFFFFF,d1		; Fill d1 with $FF
		move.w	d2,d1			; Move d2 to d1, overwriting the last word of $FF's with d2, this turns d1 into 'StartOfRAM'+'However many $1000 bytes the decompressed art is', d1 becomes the 'source address'

		jsr	(QueueDMATransfer).l	; Use d1, d2, and d3 to locate the decompressed art and ready for transfer to VRAM
		move.w	d7,-(sp)		; Store d7 in the Stack
		move.b	#$C,($FFFFF62A).w
		jsr	DelayProgram
		jsr	RunPLC_Ram
		move.w	(sp)+,d7		; Restore d7 from the Stack
		move.w	#$800,d3		; Force the DMA transfer length to be $1000/2 (the first cycle is dynamic because the art's DMA'd backwards)
		dbf	d7,LoadZoneTilesloop		; Loop for each $1000 bytes the decompressed art is
		rts
; End of function LoadZoneTiles

; ---------------------------------------------------------------------------
; Main Load Block loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MainLoadBlockLoad:			; XREF: Level; EndingSequence
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addq.l	#4,a2
		movea.l	(a2)+,a0
		lea	($FFFF9000).w,a1 ; RAM address for 16x16 mappings
		move.w	#0,d0
		jsr	EniDec
		movea.l	(a2)+,a0
		lea	($FF0000).l,a1	; RAM address for 256x256 mappings
		jsr	KosDec
		bsr.w	LevelLayoutLoad
		move.w	(a2)+,d0
		move.w	(a2),d0
		andi.w	#$FF,d0
		tst.b	($FFFFF7A6).w
		bne.s	MLBL2
		jsr	PalLoad1	; load pallet (based on	d0)
		bra.s	MLBL3

MLBL2:
		jsr	PalLoad2

MLBL3:
		movea.l	(sp)+,a2
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	locret_6D10
		jsr	LoadPLC		; load pattern load cues

locret_6D10:
		rts	
; End of function MainLoadBlockLoad

; ---------------------------------------------------------------------------
; Level	layout loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; This method now releases free ram space from A408 - A7FF

LevelLayoutLoad:
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		move.w	d0,d2
		add.w	d0,d0
		add.w	d2,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	TitleLayout
		lea	(Level_Index).l,a1
		bra.s 	LevelLayoutCont

TitleLayout:
		lea	(Title_Index).l,a1

LevelLayoutCont:
		movea.l	(a1,d0.w),a1				; MJ: moving the address strait to a1 rather than adding a word to an address
		move.l	a1,($FFFF8000).w			; MJ: save location of layout to $FFFFA400
		adda.w	#$0080,a1				; MJ: add 80 (As the BG line is always after the FG line)
		move.l	a1,($FFFF8004).w			; MJ: save location of layout to $FFFFA404
		rts						; MJ: Return

; End of function LevelLayoutLoad2

; ---------------------------------------------------------------------------
; Dynamic screen resize	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DynScrResizeLoad:			; XREF: DeformBgLayer
		moveq	#0,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	Resize_Title
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Resize_Index(pc,d0.w),d0
		jsr	Resize_Index(pc,d0.w)
	;	bra.s 	Resize_Cont

Resize_Title:
	;	cmpi.w	#$300,($FFFFF726).w
	;	beq.s	Resize_Cont
	;	add.w	#4,($FFFFF726).w ; set lower	y-boundary

Resize_Cont:
		moveq	#2,d1
		move.w	($FFFFF726).w,d0
		sub.w	($FFFFF72E).w,d0
		beq.s	locret_6DAA
		bcc.s	loc_6DAC
		neg.w	d1
		move.w	($FFFFF704).w,d0
		cmp.w	($FFFFF726).w,d0
		bls.s	loc_6DA0
		move.w	d0,($FFFFF72E).w
		andi.w	#-2,($FFFFF72E).w

loc_6DA0:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w

locret_6DAA:
		rts	
; ===========================================================================

loc_6DAC:				; XREF: DynScrResizeLoad
		move.w	($FFFFF704).w,d0
		addq.w	#8,d0
		cmp.w	($FFFFF72E).w,d0
		bcs.s	loc_6DC4
		btst	#1,($FFFFB022).w
		beq.s	loc_6DC4
		add.w	d1,d1
		add.w	d1,d1

loc_6DC4:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w
		rts	
; End of function DynScrResizeLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for dynamic screen resizing
; ---------------------------------------------------------------------------
Resize_Index:	dc.w Resize_WOZ-Resize_Index, Resize_TJZ-Resize_Index
		dc.w Resize_DDZ-Resize_Index, Resize_KVZ-Resize_Index
		dc.w Resize_CCZ-Resize_Index, Resize_ABZ-Resize_Index
		dc.w Resize_Ending-Resize_Index, Resize_SSZ-Resize_Index
		dc.w Resize_WAZ-Resize_Index, Resize_FCZ-Resize_Index
		dc.w Resize_RTZ-Resize_Index, Resize_SZ-Resize_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_WOZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_WOZx(pc,d0.w),d0
		jmp	Resize_WOZx(pc,d0.w)
; ===========================================================================
Resize_WOZx:	dc.w Resize_WOZ1-Resize_WOZx
		dc.w Resize_WOZ2-Resize_WOZx
		dc.w Resize_WOZ3-Resize_WOZx
		dc.w Resize_WOZ4-Resize_WOZx
; ===========================================================================
Resize_WOZ1:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================

Resize_WOZ2:
		move.w	#$800,($FFFFF726).w
		move.w	#$FF00,($FFFFF72C).w
	;	move.w	#$720,($FFFFF726).w
		tst.b	($FFFFFE07).w				; has switch $F	been pressed?
		bne.s	Resize_WOZ2_Shake				; if not, branch
		tst.b	($FFFFF7EF).w				; has switch $F	been pressed?
		beq.s	Resize_WOZReturn				; if not, branch
		move.w	($FFFFF704).w,($FFFFF70C).w
		move.w	($FFFFF700).w,($FFFFF708).w
		move.b	#1,($FFFFFE07).w
		move.b	#1,($FFFFF745).w
		rts	

Resize_WOZ2_Shake:
		move.w	($FFFFFE04).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	Resize_WOZReturn
		subq.w	#1,($FFFFF70C).w
		subq.w	#1,($FFFFFE00).w
		andi.w	#$1F,d1
		bne.s	Resize_WOZReturn
		move.b	#$6F,d0
		jsr	(PlaySound).l
		bra.s	Resize_WOZReturn

; ===========================================================================

Resize_WOZ3:
		move.w	#$720,($FFFFF726).w
		cmpi.w	#$3D00,($FFFFF700).w
		bcs.s	Resize_WOZReturn
		tst.b	($FFFFF742).w
		bne.s	Resize_WOZReturn
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		jmp	LoadPLC		; load boss patterns

; ===========================================================================
Resize_WOZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts

Resize_WOZReturn:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth Zone dynamic screen	resizing
; ---------------------------------------------------------------------------

Resize_TJZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_TJZx(pc,d0.w),d0
		jmp	Resize_TJZx(pc,d0.w)
; ===========================================================================
Resize_TJZx:	dc.w Resize_TJZ12-Resize_TJZx
		dc.w Resize_TJZ12-Resize_TJZx
		dc.w Resize_TJZ3-Resize_TJZx
		dc.w Resize_TJZ4-Resize_TJZx
; ===========================================================================

Resize_TJZ12:
		move.w	#$800,($FFFFF726).w
		rts	
; ===========================================================================

Resize_TJZ3:
		tst.b	($FFFFF742).w
		bne.s	locret_6F62
		cmpi.w	#$1CA0,($FFFFF700).w
		bcs.s	locret_6F62
		cmpi.w	#$600,($FFFFF704).w
		bcc.s	locret_6F62
		jsr	SingleObjLoad
		bne.s	loc_6F4A
		move.b	#$77,0(a1)	; load TJZ boss object

loc_6F4A:
		moveq	#$15,d0
		jsr	PlaySound	; play boss music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		jmp	LoadPLC		; load boss patterns

; ===========================================================================
Resize_TJZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================

locret_6F62:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Marble Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_DDZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_DDZx(pc,d0.w),d0
		jmp	Resize_DDZx(pc,d0.w)
; ===========================================================================
Resize_DDZx:	dc.w Resize_DDZ1-Resize_DDZx
		dc.w Resize_DDZ2-Resize_DDZx
		dc.w Resize_DDZ3-Resize_DDZx
		dc.w Resize_DDZ4-Resize_DDZx
; ===========================================================================

Resize_DDZ1:
		move.w	#$800,($FFFFF726).w
		move.w	#$FF00,($FFFFF72C).w
		rts	
; ===========================================================================

Resize_DDZ2:
		rts	
; ===========================================================================

Resize_DDZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7098(pc,d0.w),d0
		jmp	off_7098(pc,d0.w)
; ===========================================================================
off_7098:	dc.w Resize_DDZ3boss-off_7098
		dc.w Resize_DDZ3end-off_7098
; ===========================================================================

Resize_DDZ3boss:
		move.w	#$210,($FFFFF726).w
		cmpi.w	#$17F0,($FFFFF700).w
		bcs.s	locret_70E8
		jsr	SingleObjLoad
		bne.s	loc_70D0
		move.b	#$73,0(a1)	; load DDZ boss object
		move.w	#$1910,8(a1)
		move.w	#$30C,$C(a1)

loc_70D0:
		moveq	#$11,d0
		jsr	LoadPLC		; load boss patterns
		move.w	#$E1,d0
		jsr	PlaySound	; fade out music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$1B,d0
		jmp	PalLoad2		; load boss palette
; ===========================================================================

locret_70E8:
		rts	
; ===========================================================================

Resize_DDZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================
Resize_DDZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Star Light Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_KVZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_KVZx(pc,d0.w),d0
		jmp	Resize_KVZx(pc,d0.w)
; ===========================================================================
Resize_KVZx:	dc.w Resize_KVZ12-Resize_KVZx
		dc.w Resize_KVZ12-Resize_KVZx
		dc.w Resize_KVZ3-Resize_KVZx
		dc.w Resize_KVZ4-Resize_KVZx
; ===========================================================================

Resize_KVZ12:
		move.w	#$800,($FFFFF726).w

locret_KVZ12:
		rts	
; ===========================================================================

Resize_KVZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7118(pc,d0.w),d0
		jmp	off_7118(pc,d0.w)
; ===========================================================================
off_7118:	dc.w Resize_KVZ3main-off_7118
		dc.w Resize_KVZ3boss-off_7118
		dc.w Resize_KVZ3end-off_7118
; ===========================================================================

Resize_KVZ3main:
		cmpi.w	#$1E70,($FFFFF700).w
		bcs.s	locret_7130
		move.w	#$210,($FFFFF726).w
		addq.b	#2,($FFFFF742).w

locret_7130:
		rts	
; ===========================================================================

Resize_KVZ3boss:
		cmpi.w	#$2000,($FFFFF700).w
		bcs.s	locret_715C
		jsr	SingleObjLoad
		bne.s	loc_7144
		move.b	#$7A,(a1)	; load KVZ boss	object

loc_7144:
		moveq	#$15,d0
		jsr	PlaySound	; play boss music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================

locret_715C:
		rts	
; ===========================================================================

Resize_KVZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts
; ===========================================================================
Resize_KVZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Spring Yard Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_CCZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_CCZx(pc,d0.w),d0
		jmp	Resize_CCZx(pc,d0.w)
; ===========================================================================
Resize_CCZx:	dc.w Resize_CCZ1-Resize_CCZx
		dc.w Resize_CCZ2-Resize_CCZx
		dc.w Resize_CCZ3-Resize_CCZx
		dc.w Resize_CCZ4-Resize_CCZx
; ===========================================================================

Resize_CCZ1:
		move.w	#$700,($FFFFF726).w
		rts	
; ===========================================================================

Resize_CCZ2:
		move.w	#$6E0,($FFFFF726).w
		rts	
; ===========================================================================

Resize_CCZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_71B2(pc,d0.w),d0
		jmp	off_71B2(pc,d0.w)
; ===========================================================================
off_71B2:	dc.w Resize_CCZ3main-off_71B2
		dc.w Resize_CCZ3boss-off_71B2
		dc.w Resize_CCZ3end-off_71B2
; ===========================================================================

Resize_CCZ3main:
		cmpi.w	#$2AC0,($FFFFF700).w
		bcs.s	locret_71CE
		jsr	SingleObjLoad
		bne.s	locret_71CE
		move.b	#$76,(a1)	; load blocks that boss	picks up
		addq.b	#2,($FFFFF742).w

locret_71CE:
		rts	
; ===========================================================================

Resize_CCZ3boss:
		cmpi.w	#$2C00,($FFFFF700).w
		bcs.s	locret_7200
		move.w	#$4CC,($FFFFF726).w
		jsr	SingleObjLoad
		bne.s	loc_71EC
		move.b	#$75,(a1)	; load CCZ boss	object
		addq.b	#2,($FFFFF742).w

loc_71EC:
		moveq	#$17,d0
		jsr 	PlaySound	; play boss music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w
		move.b	#1,($FFFFF7AA).w ; lock	screen
		moveq	#$11,d0
		jmp	LoadPLC		; load boss patterns
; ===========================================================================

locret_7200:
		rts	
; ===========================================================================

Resize_CCZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================
Resize_CCZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Scrap	Brain Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_ABZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_ABZx(pc,d0.w),d0
		jmp	Resize_ABZx(pc,d0.w)
; ===========================================================================
Resize_ABZx:	dc.w Resize_ABZ1-Resize_ABZx
		dc.w Resize_ABZ2-Resize_ABZx
		dc.w Resize_FZ-Resize_ABZx
		dc.w Resize_ABZ4-Resize_ABZx
; ===========================================================================

Resize_ABZ1:
		move.w	#$800,($FFFFF726).w
		rts	
; ===========================================================================

Resize_ABZ2:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7252(pc,d0.w),d0
		jmp	off_7252(pc,d0.w)
; ===========================================================================
off_7252:	dc.w Resize_ABZ2main-off_7252
		dc.w Resize_ABZ2boss-off_7252
		dc.w Resize_ABZ2boss2-off_7252
		dc.w Resize_ABZ2end-off_7252
; ===========================================================================

Resize_ABZ2main:
		move.w	#$800,($FFFFF726).w
		cmpi.w	#$1800,($FFFFF700).w
		bcs.s	locret_727A
		move.w	#$510,($FFFFF726).w
		cmpi.w	#$1E00,($FFFFF700).w
		bcs.s	locret_727A
		addq.b	#2,($FFFFF742).w

locret_727A:
		rts	
; ===========================================================================

Resize_ABZ2boss:
		cmpi.w	#$1EB0,($FFFFF700).w
		bcs.s	locret_7298
		jsr	SingleObjLoad
		bne.s	locret_7298
		move.b	#$83,(a1)	; load collapsing block	object
		addq.b	#2,($FFFFF742).w
		moveq	#$1E,d0
		jmp	LoadPLC		; load ABZ2 Eggman patterns
; ===========================================================================

locret_7298:
		rts	
; ===========================================================================

Resize_ABZ2boss2:
		cmpi.w	#$1F60,($FFFFF700).w
		bcs.s	loc_72B6
		jsr	SingleObjLoad
		bne.s	loc_72B0
		move.b	#$82,(a1)	; load ABZ2 Eggman object
		addq.b	#2,($FFFFF742).w

loc_72B0:
		move.b	#1,($FFFFF7AA).w ; lock	screen

loc_72B6:
		bra.s	loc_72C2
; ===========================================================================

Resize_ABZ2end:
		cmpi.w	#$2050,($FFFFF700).w
		bcs.s	loc_72C2
		rts	
; ===========================================================================

loc_72C2:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================

Resize_FZ:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_72D8(pc,d0.w),d0
		jmp	off_72D8(pc,d0.w)
; ===========================================================================
off_72D8:	dc.w Resize_FZmain-off_72D8, Resize_FZboss-off_72D8
		dc.w Resize_FZend-off_72D8, locret_7322-off_72D8
		dc.w Resize_FZend2-off_72D8
; ===========================================================================

Resize_FZmain:
		cmpi.w	#$2148,($FFFFF700).w
		bcs.s	loc_72C2
		addq.b	#2,($FFFFF742).w
		moveq	#$1F,d0
		jsr	LoadPLC		; load FZ boss patterns
		bra.s	loc_72C2
; ===========================================================================

Resize_FZboss:
		cmpi.w	#$2300,($FFFFF700).w
		bcs.s	loc_7312
		jsr	SingleObjLoad
		bne.s	loc2_7312
		move.b	#$85,(a1)	; load FZ boss object

loc2_7312:
		move.w	#$E1,d0
		jsr	PlaySound	; fade out music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w

loc_7312:
		bra.s	loc_72C2
; ===========================================================================

Resize_FZend:
		cmpi.w	#$2450,($FFFFF700).w
		bcs.s	loc_7320
		addq.b	#2,($FFFFF742).w

loc_7320:
		bra.s	loc_72C2
; ===========================================================================

locret_7322:
		rts	
; ===========================================================================

Resize_FZend2:
		bra.s	loc_72C2
; ===========================================================================
Resize_ABZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SSZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SSZx(pc,d0.w),d0
		jmp	Resize_SSZx(pc,d0.w)
; ===========================================================================
Resize_SSZx:	dc.w Resize_SSZ1-Resize_SSZx
		dc.w Resize_SSZ2-Resize_SSZx
		dc.w Resize_SSZ3-Resize_SSZx
		dc.w Resize_SSZ4-Resize_SSZx
; ===========================================================================
Resize_SSZ1:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ2:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ3:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ4:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Ending sequence dynamic screen resizing (empty)
; ---------------------------------------------------------------------------

Resize_Ending:				; XREF: Resize_Index
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; White Acropolis dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_WAZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_WAZx(pc,d0.w),d0
		jmp	Resize_WAZx(pc,d0.w)
; ===========================================================================
Resize_WAZx:	dc.w Resize_WAZ1-Resize_WAZx
		dc.w Resize_WAZ2-Resize_WAZx
		dc.w Resize_WAZ3-Resize_WAZx
		dc.w Resize_WAZ4-Resize_WAZx
; ===========================================================================
Resize_WAZ1:
		rts
; ===========================================================================
Resize_WAZ2:
		rts
; ===========================================================================
Resize_WAZ3:
		rts
; ===========================================================================
Resize_WAZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Flame Core dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_FCZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_FCZx(pc,d0.w),d0
		jmp	Resize_FCZx(pc,d0.w)
; ===========================================================================
Resize_FCZx:	dc.w Resize_FCZ1-Resize_FCZx
		dc.w Resize_FCZ2-Resize_FCZx
		dc.w Resize_FCZ3-Resize_FCZx
		dc.w Resize_FCZ4-Resize_FCZx
; ===========================================================================
Resize_FCZ1:
		rts
; ===========================================================================
Resize_FCZ2:
		rts
; ===========================================================================
Resize_FCZ3:
		rts
; ===========================================================================
Resize_FCZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Ratical Train dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_RTZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_RTZx(pc,d0.w),d0
		jmp	Resize_RTZx(pc,d0.w)
; ===========================================================================
Resize_RTZx:	dc.w Resize_RTZ1-Resize_RTZx
		dc.w Resize_RTZ2-Resize_RTZx
		dc.w Resize_RTZ3-Resize_RTZx
		dc.w Resize_RTZ4-Resize_RTZx
; ===========================================================================
Resize_RTZ1:
		rts
; ===========================================================================
Resize_RTZ2:
		rts
; ===========================================================================
Resize_RTZ3:
		rts
; ===========================================================================
Resize_RTZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Soleanna dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SZx(pc,d0.w),d0
		jmp	Resize_SZx(pc,d0.w)
; ===========================================================================
Resize_SZx:	dc.w Resize_SZ1-Resize_SZx
		dc.w Resize_SZ2-Resize_SZx
		dc.w Resize_SZ3-Resize_SZx
		dc.w Resize_SZ4-Resize_SZx
; ===========================================================================
Resize_SZ1:
		rts
; ===========================================================================
Resize_SZ2:
		rts
; ===========================================================================
Resize_SZ3:
		rts
; ===========================================================================
Resize_SZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 11 - WOZ bridge
; ---------------------------------------------------------------------------

Obj11:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj11_Index(pc,d0.w),d1
		jmp	Obj11_Index(pc,d1.w)
; ===========================================================================
Obj11_Index:	dc.w Obj11_Main-Obj11_Index, Obj11_Action-Obj11_Index
		dc.w Obj11_Action2-Obj11_Index,	Obj11_Delete2-Obj11_Index
		dc.w Obj11_Delete2-Obj11_Index,	Obj11_Display2-Obj11_Index
; ===========================================================================

Obj11_Main:				; XREF: Obj11_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj11,4(a0)
		move.w	#$437C,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$80,$14(a0)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		move.b	0(a0),d4	; copy object number ($11) to d4
		lea	$28(a0),a2	; copy bridge subtype to a2
		moveq	#0,d1
		move.b	(a2),d1		; copy a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	Obj11_Action

Obj11_MakeBdg:
		jsr	SingleObjLoad
		bne.s	Obj11_Action
		addq.b	#1,$28(a0)
		cmp.w	8(a0),d3
		bne.s	loc_73B8
		addi.w	#$10,d3
		move.w	d2,$C(a0)
		move.w	d2,$3C(a0)
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		addq.b	#1,$28(a0)

loc_73B8:				; XREF: ROM:00007398j
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,$24(a1)
		move.b	d4,0(a1)	; load bridge object (d4 = $11)
		move.w	d2,$C(a1)
		move.w	d2,$3C(a1)
		move.w	d3,8(a1)
		move.l	#Map_obj11,4(a1)
		move.w	#$437C,2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#8,$14(a1)
		addi.w	#$10,d3
		dbf	d1,Obj11_MakeBdg ; repeat d1 times (length of bridge)

Obj11_Action:				; XREF: Obj11_Index
		bsr.s	Obj11_Solid
		tst.b	$3E(a0)
		beq.s	Obj11_Display
		subq.b	#4,$3E(a0)
		bsr.w	Obj11_Bend

Obj11_Display:
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Solid:				; XREF: Obj11_Action
		moveq	#0,d1
		move.b	$28(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		cmp.w	d2,d0
		bcc.w	locret_751E
		bra.s	Platform2
; End of function Obj11_Solid

; ---------------------------------------------------------------------------
; Platform subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlatformObject:
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E

Platform2:
		move.w	$C(a0),d0
		subq.w	#8,d0

Platform3:
		move.w	$C(a1),d2
		move.b	$16(a1),d1
		ext.w	d1
		add.w	d2,d1
		addq.w	#4,d1
		sub.w	d1,d0
		bhi.w	locret_751E
		cmpi.w	#-$10,d0
		bcs.w	locret_751E
		tst.b	($FFFFF7C8).w
		bmi.w	locret_751E
		cmpi.b	#6,$24(a1)
		bcc.w	locret_751E
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,$C(a1)
		addq.b	#2,$24(a0)

loc_74AE:
		btst	#3,$22(a1)
		beq.s	loc_74DC
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)
		clr.b	$25(a2)
		cmpi.b	#4,$24(a2)
		bne.s	loc_74DC
		subq.b	#2,$24(a2)

loc_74DC:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,$26(a1)
		move.w	#0,$12(a1)
		move.w	$10(a1),$20(a1)
		btst	#1,$22(a1)
		beq.s	loc_7512
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Player_ResetOnFloor
		movea.l	(sp)+,a0

loc_7512:
		bset	#3,$22(a1)
		bset	#3,$22(a0)

locret_751E:
		rts	
; End of function PlatformObject

; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to collide Sonic/Tails with the top of a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
;
; input variables:
; d1 = object width
; d3 = object height / 2
; d4 = object x-axis position
;
; address registers:
; a0 = the object to check collision with
; a1 = sonic or tails (set inside these subroutines)
; loc_19C32:
PlatformObjectS2:
	lea	($FFFFB000).w,a1 ; a1=character
	moveq	#3,d6

PlatformObject_SingleCharacter:
	btst	d6,$22(a0)
	beq.w	PlatformObject_cont
	move.w	d1,d2
	add.w	d2,d2
	btst	#1,$22(a1)
	bne.s	PlatformObject_SingleCharacter2
	move.w	8(a1),d0
	sub.w	8(a0),d0
	add.w	d1,d0
	bmi.s	PlatformObject_SingleCharacter2
	cmp.w	d2,d0
	blo.s	loc_19C802

PlatformObject_SingleCharacter2:
	bclr	#3,$22(a1)
	bset	#1,$22(a1)
	bclr	d6,$22(a0)
	moveq	#0,d4
	rts
; ---------------------------------------------------------------------------
loc_19C802:
	move.w	d4,d2
	bsr.w	MvSonicOnPtfm
	moveq	#0,d4
	rts
; ===========================================================================

PlatformObject_cont:
	tst.w	$12(a1)
	bmi.w	return_19E8E
	move.w	8(a1),d0
	sub.w	8(a0),d0
	add.w	d1,d0
	bmi.w	return_19E8E
	add.w	d1,d1
	cmp.w	d1,d0
	bhs.w	return_19E8E

loc_19DD8:
	move.w	$C(a0),d0
	sub.w	d3,d0
;loc_19DDE:
PlatformObject_ChkYRange:
	move.w	$C(a1),d2
	move.b	$16(a1),d1
	ext.w	d1
	add.w	d2,d1
	addq.w	#4,d1
	sub.w	d1,d0
	bhi.w	return_19E8E
	cmpi.w	#-$10,d0
	blo.w	return_19E8E
	tst.b	($FFFFF7C8).w
	bmi.w	return_19E8E
	cmpi.b	#6,$24(a1)
	bhs.w	return_19E8E
	add.w	d0,d2
	addq.w	#3,d2
	move.w	d2,$C(a1)
;loc_19E14:
RideObject_SetRide:
	btst	#3,$22(a1)
	beq.s	loc_19E30
	moveq	#0,d0
	move.b	$3D(a1),d0
	lsl.w	#6,d0
	addi.l	#$FFB0000,d0
	movea.l	d0,a3	; a3=object
	bclr	d6,$22(a3)

loc_19E30:
	move.w	a0,d0
	subi.w	#$B000,d0
	lsr.w	#6,d0
	andi.w	#$7F,d0
	move.b	d0,$3D(a1)
	move.b	#0,$26(a1)
	move.w	#0,$12(a1)
	move.w	$10(a1),$20(a1)
	btst	#1,$22(a1)
	beq.s	loc_19E7E
	move.l	a0,-(sp)
	movea.l	a1,a0
	jsr	(Player_ResetOnFloor).l

loc_19E7C:
	movea.l	(sp)+,a0 ; a0=character

loc_19E7E:
	bset	#3,$22(a1)
	bclr	#1,$22(a1)
	bset	d6,$22(a0)

return_19E8E:
	rts

; ---------------------------------------------------------------------------
; Sloped platform subroutine (WOZ collapsing ledges and	KVZ seesaws)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject:				; XREF: Obj1A_Slope; Obj5E_Slope
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.s	return_19E8E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	return_19E8E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.s	return_19E8E
		btst	#0,1(a0)
		beq.s	loc_754A
		not.w	d0
		add.w	d1,d0

loc_754A:
		lsr.w	#1,d0
		moveq	#0,d3
		move.b	(a2,d0.w),d3
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function SlopeObject

SolidObjectS2:
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_19736
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		tst.b	1(a1)
		bpl.w	locret_19776
		addq.b	#1,d6

loc_19736:				; CODE XREF: h+27AEp
		btst	d6,$22(a0)
		beq.w	SolidObject_OnScreenTest
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_1975A
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_1975A
		cmp.w	d2,d0
		bcs.s	loc_1976E

loc_1975A:				; CODE XREF: h+27D4j h+27E0j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_1976E:				; CODE XREF: h+27E4j
		move.w	d4,d2
		bsr.w	MvSonicOnPtfm
		moveq	#0,d4

locret_19776:				; CODE XREF: h+27BCj
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SolidObject_Always:				; CODE XREF: h+9FD2p h+CB74j
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_1978E
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

loc_1978E:				; CODE XREF: h+1A26p h+1A3Ep ...
		btst	d6,$22(a0)
		beq.w	SolidObject_cont
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_197B2
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_197B2
		cmp.w	d2,d0
		bcs.s	loc_197C6

loc_197B2:				; CODE XREF: h+282Cj h+2838j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_197C6:				; CODE XREF: h+283Cj
		move.w	d4,d2
		bsr.w	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SlopedSolid:				; CODE XREF: h+CB7Aj h+145AEj
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	SlopedSolid_SingleCharacter
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

SlopedSolid_SingleCharacter:				; CODE XREF: h+1E10p h+1E28p ...
		btst	d6,$22(a0)
		beq.w	SlopedSolid_cont
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_1980A
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_1980A
		cmp.w	d2,d0
		bcs.s	loc_1981E

loc_1980A:				; CODE XREF: h+2884j h+2890j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_1981E:				; CODE XREF: h+2894j
		move.w	d4,d2
		bsr.w	SlopeObject
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
DoubleSlopedSolid:
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_1983E
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

loc_1983E:				; CODE XREF: h+28BEp
		btst	d6,$22(a0)
		beq.w	DoubleSlopedSolid_cont
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_19862
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_19862
		cmp.w	d2,d0
		bcs.s	loc_19876

loc_19862:				; CODE XREF: h+28DCj h+28E8j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19876:				; CODE XREF: h+28ECj
		move.w	d4,d2
	;	bsr.w	MvSonicOnDoubleSlope
		bsr.w	SlopeObject
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SolidObject45:				; CODE XREF: h+DD74j
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_19896
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

loc_19896:				; CODE XREF: h+2916p
		btst	d6,$22(a0)
		beq.w	SolidObject45_cont
		btst	#1,$22(a1)
		bne.s	loc_198B8
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_198B8
		add.w	d1,d1
		cmp.w	d1,d0
		bcs.s	loc_198CC

loc_198B8:				; CODE XREF: h+2930j h+293Cj
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_198CC:				; CODE XREF: h+2942j
		move.w	$C(a0),d0
		sub.w	d2,d0
		add.w	d3,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d4
		sub.w	d4,8(a1)
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SolidObject45_cont:				; CODE XREF: h+2926j
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d4
		add.w	d4,d4
		cmp.w	d4,d0
		bhi.w	SolidObject_TestClearPush
		move.w	$C(a0),d5
		add.w	d3,d5
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	SolidObject_TestClearPush
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	SolidObject_TestClearPush
		bra.w	SolidObject_ChkBounds
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SlopedSolid_cont:				; CODE XREF: h+2876j
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	SolidObject_TestClearPush
		move.w	d0,d5
		btst	#0,1(a0)
		beq.s	loc2_19954
		not.w	d5
		add.w	d3,d5

loc2_19954:				; CODE XREF: h+29DAj
		lsr.w	#1,d5
		move.b	(a2,d5.w),d3
		sub.b	(a2),d3
		ext.w	d3
		move.w	$C(a0),d5
		sub.w	d3,d5
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	SolidObject_TestClearPush
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	SolidObject_TestClearPush
		bra.w	SolidObject_ChkBounds
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

DoubleSlopedSolid_cont:				; CODE XREF: h+28CEj
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	SolidObject_TestClearPush
		move.w	d0,d5
		btst	#0,1(a0)
		beq.s	loc_199AE
		not.w	d5
		add.w	d3,d5

loc_199AE:				; CODE XREF: h+2A34j
		andi.w	#-2,d5
		move.b	(a2,d5.w),d3
		move.b	1(a2,d5.w),d2
		ext.w	d2
		ext.w	d3
		move.w	$C(a0),d5
		sub.w	d3,d5
		move.w	$C(a1),d3
		sub.w	d5,d3
		move.b	$16(a1),d5
		ext.w	d5
		add.w	d5,d3
		addq.w	#4,d3
		bmi.w	SolidObject_TestClearPush
		add.w	d5,d2
		move.w	d2,d4
		add.w	d5,d4
		cmp.w	d4,d3
		bcc.w	SolidObject_TestClearPush
		bra.w	SolidObject_ChkBounds
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SolidObject_OnScreenTest:				; CODE XREF: h+27C6j
		tst.b	1(a0)
		bpl.w	SolidObject_TestClearPush

SolidObject_cont:				; CODE XREF: sub_12756+Cj sub_12768+Aj ...
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	SolidObject_TestClearPush
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	SolidObject_TestClearPush
		andi.w	#$7FF,d3
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	SolidObject_TestClearPush

SolidObject_ChkBounds:				; CODE XREF: h+29B6j h+2A10j ...
		tst.b	$2A(a1)
		bmi.w	SolidObject_TestClearPush
		cmpi.b	#6,$24(a1)
		bcc.w	loc_19AEA
		tst.w	($FFFFFE08).w
		bne.w	loc_19AEA
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_19A56
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_19A56:				; CODE XREF: h+2AD8j
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_19A64
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_19A64:				; CODE XREF: h+2AE6j
		cmp.w	d1,d5
		bhi.w	loc_19AEE

loc_19A6A:				; CODE XREF: h+2BC6j
		cmpi.w	#4,d1
		bls.s	loc_19AB6
		tst.w	d0
		beq.s	loc_19A90
		bmi.s	loc_19A7E
		tst.w	$10(a1)
		bmi.s	loc_19A90
		bra.s	loc_19A84
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19A7E:				; CODE XREF: h+2B00j
		tst.w	$10(a1)
		bpl.s	loc_19A90

loc_19A84:				; CODE XREF: h+2B08j
		move.w	#0,$14(a1)
		move.w	#0,$10(a1)

loc_19A90:				; CODE XREF: h+2AFEj h+2B06j ...
		sub.w	d0,8(a1)
		btst	#1,$22(a1)
		bne.s	loc_19AB6
		move.l	d6,d4
		addq.b	#2,d4
		bset	d4,$22(a0)
		bset	#5,$22(a1)
		move.w	d6,d4
		addi.b	#$D,d4
		bset	d4,d6
		moveq	#1,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19AB6:				; CODE XREF: h+2AFAj h+2B26j
		bsr.s	loc_19ADC
		move.w	d6,d4
		addi.b	#$D,d4
		bset	d4,d6
		moveq	#1,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

SolidObject_TestClearPush:				; CODE XREF: h+2982j h+298Cj ...
		move.l	d6,d4
		addq.b	#2,d4
		btst	d4,$22(a0)
		beq.s	loc_19AEA
		cmpi.b	#2,$1C(a1)
		beq.s	loc_19ADC
		move.w	#1,$1C(a1)

loc_19ADC:				; CODE XREF: h+2B42p h+2B60j
		move.l	d6,d4
		addq.b	#2,d4
		bclr	d4,$22(a0)
		bclr	#5,$22(a1)

loc_19AEA:				; CODE XREF: h+2AC8j h+2AD0j ...
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19AEE:				; CODE XREF: h+2AF2j
		tst.w	d3
		bmi.s	loc_19B06
		cmpi.w	#$10,d3
		bcs.s	loc_19B56
		cmpi.b	#-$7B,(a0)
		bne.s	SolidObject_TestClearPush
		cmpi.w	#$14,d3
		bcs.s	loc_19B56
		bra.s	SolidObject_TestClearPush
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19B06:				; CODE XREF: h+2B7Cj
		tst.w	$12(a1)
		beq.s	loc_19B28
		bpl.s	loc_19B1C
		tst.w	d3
		bpl.s	loc_19B1C
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)

loc_19B1C:				; CODE XREF: h+2B98j h+2B9Cj ...
		move.w	d6,d4
		addi.b	#$F,d4
		bset	d4,d6
		moveq	#-2,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19B28:				; CODE XREF: h+2B96j
		btst	#1,$22(a1)
		bne.s	loc_19B1C
		move.w	d0,d4
		bpl.s	loc_19B36
		neg.w	d4

loc_19B36:				; CODE XREF: h+2BBEj
		cmpi.w	#$10,d4
		bcs.w	loc_19A6A
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	(KillSOnic).l
		movea.l	(sp)+,a0
		move.w	d6,d4
		addi.b	#$F,d4
		bset	d4,d6
		moveq	#-2,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19B56:				; CODE XREF: h+2B82j h+2B8Ej
		subq.w	#4,d3
		moveq	#0,d1
		move.b	$19(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	8(a1),d1
		sub.w	8(a0),d1
		bmi.s	loc_19B8E
		cmp.w	d2,d1
		bcc.s	loc_19B8E
		tst.w	$12(a1)
		bmi.s	loc_19B8E
		sub.w	d3,$C(a1)
		subq.w	#1,$C(a1)
		bsr.w	RideObject_SetRide
		move.w	d6,d4
		addi.b	#$11,d4
		bset	d4,d6
		moveq	#-1,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_19B8E:				; CODE XREF: h+2BF6j h+2BFAj ...
		moveq	#0,d4
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Solid:				; XREF: Obj15_SetSolid
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function Obj15_Solid

; ===========================================================================

Obj11_Action2:				; XREF: Obj11_Index
		bsr.s	Obj11_WalkOff
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk off a bridge
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_WalkOff:				; XREF: Obj11_Action2
		moveq	#0,d1
		move.b	$28(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		bsr.s	ExitPlatform2
		bcc.s	locret_75BE
		lsr.w	#4,d0
		move.b	d0,$3F(a0)
		move.b	$3E(a0),d0
		cmpi.b	#$40,d0
		beq.s	loc_75B6
		addq.b	#4,$3E(a0)

loc_75B6:
		bsr.w	Obj11_Bend
		bsr.w	Obj11_MoveSonic

locret_75BE:
		rts	
; End of function Obj11_WalkOff

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk or jump off	a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ExitPlatform:
		move.w	d1,d2

ExitPlatform2:
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_75E0
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_75E0
		cmp.w	d2,d0
		bcs.s	locret_75F2

loc_75E0:
		bclr	#3,$22(a1)
		move.b	#2,$24(a0)
		bclr	#3,$22(a0)

locret_75F2:
		rts	
; End of function ExitPlatform


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_MoveSonic:			; XREF: Obj11_WalkOff
		moveq	#0,d0
		move.b	$3F(a0),d0
		move.b	$29(a0,d0.w),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		lea	($FFFFB000).w,a1
		move.w	$C(a2),d0
		subq.w	#8,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)	; change Sonic's position on y-axis
		rts	
; End of function Obj11_MoveSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Bend:				; XREF: Obj11_Action; Obj11_WalkOff
		move.b	$3E(a0),d0
		jsr	CalcSine
		move.w	d0,d4
		lea	(Obj11_BendData2).l,a4
		moveq	#0,d0
		move.b	$28(a0),d0
		lsl.w	#4,d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		move.w	d3,d2
		add.w	d0,d3
		moveq	#0,d5
		lea	(Obj11_BendData).l,a5
		move.b	(a5,d3.w),d5
		andi.w	#$F,d3
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		lea	$29(a0),a2

loc_765C:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	(a3)+,d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,$C(a1)
		dbf	d2,loc_765C
		moveq	#0,d0
		move.b	$28(a0),d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		addq.b	#1,d3
		sub.b	d0,d3
		neg.b	d3
		bmi.s	locret_76CA
		move.w	d3,d2
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		adda.w	d2,a3
		subq.w	#1,d2
		bcs.s	locret_76CA

loc_76A4:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	-(a3),d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,$C(a1)
		dbf	d2,loc_76A4

locret_76CA:
		rts	
; End of function Obj11_Bend

; ===========================================================================
; ---------------------------------------------------------------------------
; WOZ bridge-bending data
; (Defines how the bridge bends	when Sonic walks across	it)
; ---------------------------------------------------------------------------
Obj11_BendData:	incbin	misc\WOZbend1.bin
		even
Obj11_BendData2:incbin	misc\WOZbend2.bin
		even

; ===========================================================================

Obj11_ChkDel:				; XREF: Obj11_Display; Obj11_Action2
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj11_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj11_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj11_DelAll

Obj11_Done:
		rts	
; ===========================================================================

Obj11_DelAll:				; XREF: Obj11_ChkDel
		moveq	#0,d2
		lea	$28(a0),a2	; load bridge length
		move.b	(a2)+,d2	; move bridge length to	d2
		subq.b	#1,d2		; subtract 1
		bcs.s	Obj11_Delete

Obj11_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		cmp.w	a0,d0
		beq.s	loc_791E
		bsr.w	DeleteObject2

loc_791E:
		dbf	d2,Obj11_DelLoop ; repeat d2 times (bridge length)

Obj11_Delete:
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj11_Delete2:				; XREF: Obj11_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj11_Display2:				; XREF: Obj11_Index
		bsr.w	DisplaySprite
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - WOZ	bridge
; ---------------------------------------------------------------------------
Map_obj11:
	include "_maps\obj11.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 15 - swinging platforms (WOZ, DDZ, KVZ)
;		- spiked ball on a chain (ABZ)
; ---------------------------------------------------------------------------

Obj15:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj15_Index(pc,d0.w),d1
		jmp	Obj15_Index(pc,d1.w)
; ===========================================================================
Obj15_Index:	dc.w Obj15_Main-Obj15_Index, Obj15_SetSolid-Obj15_Index
		dc.w Obj15_Action2-Obj15_Index,	Obj15_Delete-Obj15_Index
		dc.w Obj15_Delete-Obj15_Index, Obj15_Display-Obj15_Index
		dc.w Obj15_Action-Obj15_Index
; ===========================================================================

Obj15_Main:				; XREF: Obj15_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj15,4(a0) ; WOZ and DDZ specific code
		move.w	#$236C,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$20,$14(a0)
		move.b	#8,$16(a0)
		move.w	$C(a0),$38(a0)
		move.w	8(a0),$3A(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is KVZ
		bne.s	Obj15_NotKVZ
		move.l	#Map_obj15a,4(a0) ; KVZ	specific code
		move.w	#$43DC,2(a0)
		move.b	#$20,$14(a0)
		move.b	#$10,$16(a0)
		move.b	#$99,$20(a0)

Obj15_NotKVZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj15_SetLength
		move.l	#Map_obj15b,4(a0) ; ABZ	specific code
		move.w	#$391,2(a0)
		move.b	#$18,$14(a0)
		move.b	#$18,$16(a0)
		move.b	#$86,$20(a0)
		move.b	#$C,$24(a0)

Obj15_SetLength:
		move.b	0(a0),d4
		moveq	#0,d1
		lea	$28(a0),a2	; move chain length to a2
		move.b	(a2),d1		; move a2 to d1
		move.w	d1,-(sp)
		andi.w	#$F,d1
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		addq.b	#8,d3
		move.b	d3,$3C(a0)
		subq.b	#8,d3
		tst.b	$1A(a0)
		beq.s	Obj15_MakeChain
		addq.b	#8,d3
		subq.w	#1,d1

Obj15_MakeChain:
		bsr.w	SingleObjLoad
		bne.s	loc_7A92
		addq.b	#1,$28(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,$24(a1)
		move.b	d4,0(a1)	; load swinging	object
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		bclr	#6,2(a1)
		move.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#8,$14(a1)
		move.b	#1,$1A(a1)
		move.b	d3,$3C(a1)
		subi.b	#$10,d3
		bcc.s	loc_7A8E
		move.b	#2,$1A(a1)
		move.w	#$180,$18(a1)

loc_7A8E:
		dbf	d1,Obj15_MakeChain ; repeat d1 times (chain length)

loc_7A92:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.w	#$4080,$26(a0)
		move.w	#-$200,$3E(a0)
		move.w	(sp)+,d1
		btst	#4,d1		; is object type $8X ?
		beq.s	loc_7AD4	; if not, branch
		move.l	#Map_obj48,4(a0) ; use WOZ ball	mappings
		move.w	#$43AA,2(a0)
		move.b	#1,$1A(a0)
		move.w	#$100,$18(a0)
		move.b	#$81,$20(a0)	; make object hurt when	touched

loc_7AD4:
		cmpi.b	#5,($FFFFFE10).w ; is zone ABZ?
		beq.s	Obj15_Action	; if yes, branch

Obj15_SetSolid:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		moveq	#0,d3
		move.b	$16(a0),d3
		bsr.w	Obj15_Solid

Obj15_Action:				; XREF: Obj15_Index
		bsr.w	Obj15_Move
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel
; ===========================================================================

Obj15_Action2:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	ExitPlatform
		move.w	8(a0),-(sp)
		bsr.w	Obj15_Move
		move.w	(sp)+,d2
		moveq	#0,d3
		move.b	$16(a0),d3
		addq.b	#1,d3
		bsr.w	MvSonicOnPtfm
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel

		rts

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MvSonicOnPtfm:
		lea	($FFFFB000).w,a1
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.s	MvSonic2
; End of function MvSonicOnPtfm

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

loc2_19B92:				; CODE XREF: sub_12768+4Cp h+27FCp ...
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.s	MvSonic2

MvSonicOnPtfm2:
		lea	($FFFFB000).w,a1
		move.w	$C(a0),d0
		subi.w	#9,d0

MvSonic2:
		tst.b	($FFFFF7C8).w
		bmi.s	locret_7B62
		cmpi.b	#6,($FFFFB024).w
		bcc.s	locret_7B62
		tst.w	($FFFFFE08).w
		bne.s	locret_7B62
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d2
		sub.w	d2,8(a1)
		move.w   d0,($FFFFB18C).w   ; apply change to Shield's Y-Position
    	sub.w    d2,($FFFFB188).w   ; apply change to Shield's X-Position
		move.w   d0,($FFFFB3CC).w   ; apply change to Shield's Y-Position
    	sub.w    d2,($FFFFB3C8).w   ; apply change to Shield's X-Position
		move.w   d0,($FFFFB1CC).w   ; apply change to Shield's Y-Position
    	sub.w    d2,($FFFFB1C8).w   ; apply change to Shield's X-Position

locret_7B62:
		rts	
; End of function MvSonicOnPtfm2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move:				; XREF: Obj15_Action; Obj15_Action2
		move.b	($FFFFFE78).w,d0
		move.w	#$80,d1
		btst	#0,$22(a0)
		beq.s	loc_7B78
		neg.w	d0
		add.w	d1,d0

loc_7B78:
		bra.s	Obj15_Move2
; End of function Obj15_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj48_Move:				; XREF: Obj48_Display2
		tst.b	$3D(a0)
		bne.s	loc_7B9C
		move.w	$3E(a0),d0
		addq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,$26(a0)
		cmpi.w	#$200,d0
		bne.s	loc_7BB6
		move.b	#1,$3D(a0)
		bra.s	loc_7BB6
; ===========================================================================

loc_7B9C:
		move.w	$3E(a0),d0
		subq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,$26(a0)
		cmpi.w	#-$200,d0
		bne.s	loc_7BB6
		move.b	#0,$3D(a0)

loc_7BB6:
		move.b	$26(a0),d0
; End of function Obj48_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move2:				; XREF: Obj15_Move; Obj48_Display
		jsr	CalcSine
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	$28(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_7BCE:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFB000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,$C(a1)
		move.w	d5,8(a1)
		dbf	d6,loc_7BCE
		rts	
; End of function Obj15_Move2

; ===========================================================================

Obj15_ChkDel:				; XREF: Obj15_Action; Obj15_Action2
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj15_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj15_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj15_DelAll

Obj15_Done:
		rts	
; ===========================================================================

Obj15_DelAll:				; XREF: Obj15_ChkDel
		moveq	#0,d2
		lea	$28(a0),a2
		move.b	(a2)+,d2

Obj15_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,Obj15_DelLoop ; repeat for length of	chain
		rts	
; ===========================================================================

Obj15_Delete:				; XREF: Obj15_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj15_Display:				; XREF: Obj15_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - WOZ	and DDZ swinging	platforms
; ---------------------------------------------------------------------------
Map_obj15:
	include "_maps\obj15WOZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - KVZ	swinging platforms
; ---------------------------------------------------------------------------
Map_obj15a:
	include "_maps\obj15KVZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 17 - helix of spikes on a pole	(WOZ)
; ---------------------------------------------------------------------------

Obj17:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj17_Index(pc,d0.w),d1
		jmp	Obj17_Index(pc,d1.w)
; ===========================================================================
Obj17_Index:	dc.w Obj17_Main-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Delete-Obj17_Index
		dc.w Obj17_Display-Obj17_Index
; ===========================================================================

Obj17_Main:				; XREF: Obj17_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj17,4(a0)
		move.w	#$4500,2(a0)
		move.b	#7,$22(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		move.b	0(a0),d4
		lea	$28(a0),a2	; move helix length to a2
		moveq	#0,d1
		move.b	(a2),d1		; move a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	Obj17_Action
		moveq	#0,d6

Obj17_MakeHelix:
		bsr.w	SingleObjLoad
		bne.s	Obj17_Action
		addq.b	#1,$28(a0)
		move.w	a1,d5
		subi.w	#$D000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#8,$24(a1)
		move.b	d4,0(a1)
		move.w	d2,$C(a1)
		move.w	d3,8(a1)
		move.l	4(a0),4(a1)
		move.w	#$4500,2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#8,$14(a1)
		move.b	d6,$3E(a1)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		cmp.w	8(a0),d3
		bne.s	loc_7D78
		move.b	d6,$3E(a0)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		addq.b	#1,$28(a0)

loc_7D78:
		dbf	d1,Obj17_MakeHelix ; repeat d1 times (helix length)

Obj17_Action:				; XREF: Obj17_Index
		bsr.w	Obj17_RotateSpikes
		bsr.w	DisplaySprite
		bra.w	Obj17_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj17_RotateSpikes:			; XREF: Obj17_Action; Obj17_Display
		move.b	($FFFFFEC1).w,d0
		move.b	#0,$20(a0)	; make object harmless
		add.b	$3E(a0),d0
		andi.b	#7,d0
		move.b	d0,$1A(a0)	; change current frame
		bne.s	locret_7DA6
		move.b	#$84,$20(a0)	; make object harmful

locret_7DA6:
		rts	
; End of function Obj17_RotateSpikes

; ===========================================================================

Obj17_ChkDel:				; XREF: Obj17_Action
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj17_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj17_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj17_DelAll

Obj17_Done:
		rts	
; ===========================================================================

Obj17_DelAll:				; XREF: Obj17_ChkDel
		moveq	#0,d2
		lea	$28(a0),a2	; move helix length to a2
		move.b	(a2)+,d2	; move a2 to d2
		subq.b	#2,d2
		bcs.s	Obj17_Delete

Obj17_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2	; delete object
		dbf	d2,Obj17_DelLoop ; repeat d2 times (helix length)

Obj17_Delete:				; XREF: Obj17_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj17_Display:				; XREF: Obj17_Index
		bsr.w	Obj17_RotateSpikes
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - helix of spikes on a pole (WOZ)
; ---------------------------------------------------------------------------
Map_obj17:
	include "_maps\obj17.asm"



; ===========================================================================
; ---------------------------------------------------------------------------
; Object 18 - platforms	(WOZ, CCZ, KVZ)
; ---------------------------------------------------------------------------

Obj18:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj18_Index(pc,d0.w),d1
		jmp	Obj18_Index(pc,d1.w)
; ===========================================================================
Obj18_Index:	dc.w Obj18_Main-Obj18_Index
		dc.w Obj18_Solid-Obj18_Index
		dc.w Obj18_Action2-Obj18_Index
		dc.w Obj18_Delete-Obj18_Index
		dc.w Obj18_Action-Obj18_Index
; ===========================================================================

Obj18_Main:				; XREF: Obj18_Index
		addq.b	#2,$24(a0)
		move.w	#$4486,2(a0)
		move.l	#Map_obj18,4(a0)
		cmpi.b	#4,($FFFFFE10).w ; check if level is CCZ
		bne.s	Obj18_NotCCZ
		move.l	#Map_obj18a,4(a0) ; CCZ	specific code

Obj18_NotCCZ:
		cmpi.b	#3,($FFFFFE10).w ; check if level is KVZ
		bne.s	Obj18_NotKVZ
		move.l	#Map_obj18b,4(a0) ; KVZ	specific code
		move.w	#$4000,2(a0)

Obj18_NotKVZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj18_NotABZ
		move.l	#Map_obj18c,4(a0) ; KVZ	specific code
		move.w	#$2340,2(a0)

Obj18_NotABZ:
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.w	$C(a0),$2C(a0)
		move.w	$C(a0),$34(a0)
		move.w	8(a0),$32(a0)
		move.w	#$80,$26(a0)
		moveq	#0,d1
		move.b	$28(a0),d0
		btst	#5,d0
		beq.s	Obj18_SmallPlatforms
		btst	#4,d0
		beq.s	Obj18_Long
		bra.s	Obj18_Big

Obj18_SmallPlatforms:
		btst	#4,d0
		bne.s	Obj18_Medium

Obj18_Short:
		move.b	#$10,$14(a0)
		addq.b	#2,d1		; use frame #2
		bra.s	Obj18_SetFrame

Obj18_Medium:
		move.b	#$20,$14(a0)
		bra.s	Obj18_SetFrame

Obj18_Long:
		move.b	#$30,$14(a0)
		addq.b	#3,d1		; use frame #3
		bra.s	Obj18_SetFrame

Obj18_Big:
		move.b	#$20,$14(a0)
		addq.b	#1,d1		; use frame #1

Obj18_SetFrame:
		move.b	d1,$1A(a0)	; set frame to d1

Obj18_Solid:				; XREF: Obj18_Index
		tst.b	$38(a0)
		beq.s	loc_7EE0
		subq.b	#4,$38(a0)

loc_7EE0:
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	PlatformObject

Obj18_Action:				; XREF: Obj18_Index
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj18_Display
		lea	(Ani_obj18).l,a1
		jsr	AnimateSprite

Obj18_Display:
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel

; ===========================================================================

Obj18_Action2:				; XREF: Obj18_Index
		cmpi.b	#$40,$38(a0)
		beq.s	loc_7F06
		addq.b	#4,$38(a0)

loc_7F06:
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	ExitPlatform
		move.w	8(a0),-(sp)
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		move.w	(sp)+,d2
		bsr.w	MvSonicOnPtfm2
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj18_Display2
		lea	(Ani_obj18).l,a1
		jsr	AnimateSprite

Obj18_Display2:
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel
		rts

; ---------------------------------------------------------------------------
; Subroutine to	move platform slightly when you	stand on it
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Nudge:				; XREF: Obj18_Action; Obj18_Action2
		cmpi.b	#6,$28(a0)
		beq.s	Obj18_NudgeDone
		move.b	$38(a0),d0
		jsr	CalcSine
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$2C(a0),d0
		move.w	d0,$C(a0)

Obj18_NudgeDone:
		rts	
; End of function Obj18_Nudge

; ---------------------------------------------------------------------------
; Subroutine to	move platforms
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Move:				; XREF: Obj18_Action; Obj18_Action2
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj18_TypeIndex(pc,d0.w),d1
		jmp	Obj18_TypeIndex(pc,d1.w)
; End of function Obj18_Move

; ===========================================================================
Obj18_TypeIndex:dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type01-Obj18_TypeIndex
		dc.w Obj18_Type02-Obj18_TypeIndex, Obj18_Type03-Obj18_TypeIndex
		dc.w Obj18_Type04-Obj18_TypeIndex, Obj18_Type05-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type07-Obj18_TypeIndex
		dc.w Obj18_Type08-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex
; ===========================================================================

Obj18_Type00:
		rts			; platform 00 doesn't move
; ===========================================================================
Obj18_ChgMotion:
		move.b	($FFFFFE78).w,$26(a0) ;	update platform-movement variable
		rts	

Obj18_Type01:
		move.w	$32(a0),d0
		move.b	$26(a0),d1	; load platform-motion variable
		btst	#0,$22(a0)
		beq.s	Obj18_Type01_Normal
		neg.b	d1
		addi.b	#$40,d1
		bra.s	Obj18_01_Move

Obj18_Type01_Normal:
		subi.b	#$40,d1

Obj18_01_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,8(a0)	; change position on x-axis
		bra.s	Obj18_ChgMotion
; ===========================================================================

Obj18_Type02:
		move.w	$34(a0),d0
		move.b	$26(a0),d1	; load platform-motion variable
		btst	#1,$22(a0)
		beq.s	Obj18_Type02_Normal
		neg.b	d1
		addi.b	#$40,d1
		bra.s	Obj18_02_Move

Obj18_Type02_Normal:
		subi.b	#$40,d1

Obj18_02_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,$2C(a0)	; change position on y-axis
		bra.s	Obj18_ChgMotion
; ===========================================================================

Obj18_Type03:
		move.w	$32(a0),d0
		move.w	$34(a0),d1
		move.b	$26(a0),d2	; load platform-motion variable
		move.b	$26(a0),d3	; load platform-motion variable
		btst	#0,$22(a0)
		beq.s	Obj18_Type03_NoMirror
		neg.b	d2		; reverse platform-motion
		addi.b	#$40,d2
		bra.s	Obj18_Type03_Flip

Obj18_Type03_NoMirror:
		subi.b	#$40,d2

Obj18_Type03_Flip:
		btst	#1,$22(a0)
		beq.s	Obj18_Type03_Normal
		subi.b	#$40,d3
		bra.s	Obj18_03_Move

Obj18_Type03_Normal:
		neg.b	d3		; reverse platform-motion
		addi.b	#$40,d3

Obj18_03_Move:
		ext.w	d2
		ext.w	d3
		add.w	d2,d0
		add.w	d3,d1
		move.w	d0,8(a0)	; change position on x-axis
		move.w	d1,$2C(a0)	; change position on y-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type04:		
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_04_Wait	; if yes, branch
		btst	#3,$22(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_04_NoMove	; if not, branch
		move.w	#30,$3A(a0)	; set time delay to 0.5	seconds

Obj18_04_NoMove:
		rts	
; ===========================================================================

Obj18_04_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time
		bne.s	Obj18_04_NoMove	; if time is > 0, branch
		move.w	#32,$3A(a0)
		move.b	#8,$28(a0)	; change to type 04 (falling)
		rts	
; ===========================================================================

Obj18_Type08:
		tst.w	$3A(a0)
		beq.s	loc_8048
		subq.w	#1,$3A(a0)
		bne.s	loc_8048
		btst	#3,$22(a0)
		beq.s	loc_8042
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		move.w	$12(a0),$12(a1)

loc_8042:
		move.b	#8,$24(a0)

loc_8048:
		move.l	$2C(a0),d3
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,$2C(a0)
		addi.w	#$38,$12(a0)
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$2C(a0),d0
		bcc.s	locret_8074
		move.b	#6,$24(a0)

locret_8074:
		rts	
; ===========================================================================

Obj18_Type05:
		tst.b	$25(a0)
		bne.s	Obj18_Type05Rise
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_05_Wait	; if yes, branch
		btst	#3,$22(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_05_NoMove	; if not, branch
		move.w	#30,$3A(a0)	; set time delay to 0.5	seconds

Obj18_05_NoMove:
		rts	
; ===========================================================================

Obj18_05_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time
		bne.s	Obj18_05_NoMove	; if time is > 0, branch
		move.w	#32,$3A(a0)
		addq.b	#2,$25(a0)	; change to type 04 (falling)
		rts	
; ===========================================================================

Obj18_Type05Rise:
		subq.w	#2,$2C(a0)	; move platform	up
		move.w	$34(a0),d0
		subi.w	#$200,d0
		rts	
; ===========================================================================

Obj18_Type07:
		move.w	($FFFFFE04).w,d0	; load platform-motion variable
		move.w	$32(a0),d2
		move.w	$34(a0),d3
		add.w	d0,d0			; double the value (doubles the speed)
		jsr	CalcSine		; calc sine based on it
		asr.w	#2,d0			; shrink down the Sine output (shrink down the horizontal radius)
		asr.w	#2,d1			; shrink down the Cos output (shrink down the vertical radius)
		btst	#0,$22(a0)
		beq.s	Obj18_07_Move
		neg.w	d0		; reverse platform-motion

Obj18_07_Move:
		btst	#1,$22(a0)
		beq.s	Obj18_07_Move2
		neg.w	d1		; reverse platform-motion
		move.b	#1,$1C(a0)

Obj18_07_Move2:
		add.w	d0,d2
		add.w	d1,d3
		move.w	d2,8(a0)		; save result to new X-pos
		move.w	d3,$2C(a0)		; save result to new Y-pos
		rts
; ===========================================================================

Obj18_ChkDel:				; XREF: Obj18_Action; Obj18_Action2
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj18_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj18_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj18_Delete

Obj18_Done:
		rts	
; ===========================================================================

Obj18_Delete:				; XREF: Obj18_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - unused
; ---------------------------------------------------------------------------
Map_obj18x:
	include "_maps\obj18x.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - WOZ	platforms
; ---------------------------------------------------------------------------
Map_obj18:
	include "_maps\obj18WOZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - CCZ	platforms
; ---------------------------------------------------------------------------
Map_obj18a:
	include "_maps\obj18CCZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - KVZ	platforms
; ---------------------------------------------------------------------------
Map_obj18b:
	include "_maps\obj18KVZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - ABZ	platforms
; ---------------------------------------------------------------------------
Map_obj18c:
	include "_maps\obj18ABZ.asm"

; ---------------------------------------------------------------------------
Ani_obj18:
	include "_anim\obj18.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 19 - blank
; ---------------------------------------------------------------------------

Obj19:					; XREF: Obj_Index
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - swinging ball on a chain from WOZ boss
; ---------------------------------------------------------------------------
Map_obj48:
	include "_maps\obj48.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1A - WOZ collapsing ledge
; ---------------------------------------------------------------------------

Obj1A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1A_Index(pc,d0.w),d1
		jmp	Obj1A_Index(pc,d1.w)
; ===========================================================================
Obj1A_Index:	dc.w Obj1A_Main-Obj1A_Index, Obj1A_ChkTouch-Obj1A_Index
		dc.w Obj1A_Touch-Obj1A_Index, Obj1A_Display-Obj1A_Index
		dc.w Obj1A_Delete-Obj1A_Index, Obj1A_WalkOff-Obj1A_Index
; ===========================================================================

Obj1A_Main:				; XREF: Obj1A_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj1A,4(a0)
		move.w	#$4000,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#7,$38(a0)	; set time delay for collapse
		move.b	#$64,$14(a0)
		move.b	$28(a0),$1A(a0)
		move.b	#$38,$16(a0)
		bset	#4,1(a0)

Obj1A_ChkTouch:				; XREF: Obj1A_Index
		tst.b	$3A(a0)		; has Sonic touched the	platform?
		beq.s	Obj1A_Slope	; if not, branch
		tst.b	$38(a0)		; has time reached zero?
		beq.w	Obj1A_Collapse	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time

Obj1A_Slope:
		move.w	#$30,d1
		lea	(Obj1A_SlopeData).l,a2
		bsr.w	SlopeObject
		jmp	MarkObjGone
; ===========================================================================

Obj1A_Touch:				; XREF: Obj1A_Index
		tst.b	$38(a0)
		beq.w	loc_847A
		move.b	#1,$3A(a0)	; set object as	"touched"
		subq.b	#1,$38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1A_WalkOff:				; XREF: Obj1A_Index
		move.w	#$30,d1
		bsr.w	ExitPlatform
		move.w	#$30,d1
		lea	(Obj1A_SlopeData).l,a2
		move.w	8(a0),d2
		bsr.w	SlopeObject2
		jmp	MarkObjGone
; End of function Obj1A_WalkOff

; ===========================================================================

Obj1A_Display:				; XREF: Obj1A_Index
		tst.b	$38(a0)		; has time delay reached zero?
		beq.s	Obj1A_TimeZero	; if yes, branch
		tst.b	$3A(a0)		; has Sonic touched the	object?
		bne.w	loc_82D0	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

loc_82D0:				; XREF: Obj1A_Display
		subq.b	#1,$38(a0)
		bsr.w	Obj1A_WalkOff
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	loc_82FC
		tst.b	$38(a0)
		bne.s	locret_8308
		bclr	#3,$22(a1)
		bclr	#5,$22(a1)
		move.b	#1,$1D(a1)

loc_82FC:
		move.b	#0,$3A(a0)
		move.b	#6,$24(a0)	; run "Obj1A_Display" routine

locret_8308:
		rts	
; ===========================================================================

Obj1A_TimeZero:				; XREF: Obj1A_Display
		bsr.w	ObjectFall
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.s	Obj1A_Delete
		rts	
; ===========================================================================

Obj1A_Delete:				; XREF: Obj1A_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 53 - collapsing floors	(DDZ, KVZ, ABZ)
; ---------------------------------------------------------------------------

Obj53:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj53_Index(pc,d0.w),d1
		jmp	Obj53_Index(pc,d1.w)
; ===========================================================================
Obj53_Index:	dc.w Obj53_Main-Obj53_Index, Obj53_ChkTouch-Obj53_Index
		dc.w Obj53_Touch-Obj53_Index, Obj53_Display-Obj53_Index
		dc.w Obj53_Delete-Obj53_Index, Obj53_WalkOff-Obj53_Index
; ===========================================================================

Obj53_Main:				; XREF: Obj53_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj53,4(a0)
		move.w	#$42B8,2(a0)
		tst.b	($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj53_NotWOZ
		move.w	#$4000,2(a0)
		addq.b	#4,$1A(a0)

Obj53_NotWOZ:
		cmpi.b	#3,($FFFFFE10).w ; check if level is KVZ
		bne.s	Obj53_NotKVZ
		move.w	#$44E0,2(a0)	; KVZ specific code
		addq.b	#2,$1A(a0)

Obj53_NotKVZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	Obj53_NotABZ
		move.w	#$43F5,2(a0)	; ABZ specific code

Obj53_NotABZ:
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#7,$38(a0)
		move.b	#$44,$14(a0)

Obj53_ChkTouch:				; XREF: Obj53_Index
		tst.b	$3A(a0)		; has Sonic touched the	object?
		beq.s	Obj53_Solid	; if not, branch
		tst.b	$38(a0)		; has time delay reached zero?
		beq.w	Obj53_Collapse	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time

Obj53_Solid:
		move.w	#$20,d1
		bsr.w	PlatformObject
		tst.b	$28(a0)
		bpl.s	Obj53_MarkAsGone
		btst	#3,$22(a1)
		beq.s	Obj53_MarkAsGone
		bclr	#0,1(a0)
		move.w	8(a1),d0
		sub.w	8(a0),d0
		bcc.s	Obj53_MarkAsGone
		bset	#0,1(a0)

Obj53_MarkAsGone:
		jmp	MarkObjGone
; ===========================================================================

Obj53_Touch:				; XREF: Obj53_Index
		tst.b	$38(a0)
		beq.w	loc_8458
		move.b	#1,$3A(a0)	; set object as	"touched"
		subq.b	#1,$38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj53_WalkOff:				; XREF: Obj53_Index
		move.w	#$20,d1
		bsr.w	ExitPlatform
		move.w	8(a0),d2
		bsr.w	MvSonicOnPtfm2
		jmp	MarkObjGone
; End of function Obj53_WalkOff

; ===========================================================================

Obj53_Display:				; XREF: Obj53_Index
		tst.b	$38(a0)		; has time delay reached zero?
		beq.s	Obj53_TimeZero	; if yes, branch
		tst.b	$3A(a0)		; has Sonic touched the	object?
		bne.w	loc_8402	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

loc_8402:
		subq.b	#1,$38(a0)
		bsr.w	Obj53_WalkOff
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	loc_842E
		tst.b	$38(a0)
		bne.s	locret_843A
		bclr	#3,$22(a1)
		bclr	#5,$22(a1)
		move.b	#1,$1D(a1)

loc_842E:
		move.b	#0,$3A(a0)
		move.b	#6,$24(a0)	; run "Obj53_Display" routine

locret_843A:
		rts	
; ===========================================================================

Obj53_TimeZero:				; XREF: Obj53_Display
		bsr.w	ObjectFall
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.s	Obj53_Delete
		rts	
; ===========================================================================

Obj53_Delete:				; XREF: Obj53_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj53_Collapse:				; XREF: Obj53_ChkTouch
		move.b	#0,$3A(a0)

loc_8458:				; XREF: Obj53_Touch
		lea	(Obj53_Data2).l,a4
		btst	#0,$28(a0)
		beq.s	loc_846C
		lea	(Obj53_Data3).l,a4

loc_846C:
		moveq	#7,d1
		addq.b	#1,$1A(a0)
		bra.s	loc_8486
; ===========================================================================

Obj1A_Collapse:
		move.b	#0,$3A(a0)

loc_847A:
		lea	(Obj53_Data1).l,a4
		moveq	#$18,d1
		addq.b	#2,$1A(a0)

loc_8486:
		moveq	#0,d0
		move.b	$1A(a0),d0
		add.w	d0,d0
		movea.l	4(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,1(a0)
		move.b	0(a0),d4
		move.b	1(a0),d5
		movea.l	a0,a1
	;	bra.s	loc_84B2	; We have to remove this otherwise a1's value won't be right,
	; but since it's what creates the first object over the source object, we also have to create it now...
	; First object's creation begins here:
		move.b	#6,$24(a1)
		move.b	d4,0(a1)
		move.l	a3,4(a1)
		move.b	d5,1(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	2(a0),2(a1)
		move.w	$18(a0),$18(a1)
		move.b	$14(a0),$14(a1)
		move.b	(a4)+,$38(a1)
	; and ends here, it's a simple copy/paste from loc_84B2.
	; Now since we created one object already, we have to decrease the counter
		subq.w	#1,d1
	; We don't have to check whether it's the last one or not, it can't be unless there's not enough free ram to create more (and that's checked later).
	; Here we begin what's replacing SingleObjLoad, in order to avoid resetting its d0 every time an object is created.
		lea	($FFFFB800).w,a1
		move.w	#$5F,d0

loc_84AA:
	;	bsr.w	SingleObjLoad	; We remove this, it's the routine we want to avoid
	; So here goes what was originally happening in SingleObjLoad, excepted now d0 won't be reset every time an object has to be created.
	; We'll just copy/paste the content of loc_DA94 and correct the branches.
	@loop:
		tst.b	(a1)
		beq.s	@cont		; Let's correct the branches. Here we can also skip the bne that was originally after bsr.w SingleObjLoad because we already know there's a free object slot in memory.
		lea	$40(a1),a1
		dbf	d0,@loop	; Branch correction again.
		bne.s	loc_84F2	; We're moving this line here.
	@cont:
	; And that's it, copy/paste complete.
		addq.w	#5,a3

loc_84B2:
		move.b	#6,$24(a1)
		move.b	d4,0(a1)
		move.l	a3,4(a1)
		move.b	d5,1(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	2(a0),2(a1)
		move.w	$18(a0),$18(a1)
		move.b	$14(a0),$14(a1)
		move.b	(a4)+,$38(a1)
	;	cmpa.l	a0,a1		; Finally, this isn't necessary anymore, its only purpose was to skip DisplaySprite2 on the first object
	;	bcc.s	loc_84EE
		bsr.w	DisplaySprite2

loc_84EE:
		dbf	d1,loc_84AA

loc_84F2:
		bsr.w	DisplaySprite
		move.w	#$59,d0
		jmp	(PlaySound_Special).l ;	play collapsing	sound
; ===========================================================================
; ---------------------------------------------------------------------------
; Disintegration data for collapsing ledges (DDZ, KVZ, ABZ)
; ---------------------------------------------------------------------------
Obj53_Data1:	dc.b $1C, $18, $14, $10, $1A, $16, $12,	$E, $A,	6, $18,	$14, $10, $C, 8, 4
		dc.b $16, $12, $E, $A, 6, 2, $14, $10, $C, 0
Obj53_Data2:	dc.b $1E, $16, $E, 6, $1A, $12,	$A, 2
Obj53_Data3:	dc.b $16, $1E, $1A, $12, 6, $E,	$A, 2

; ---------------------------------------------------------------------------
; Sloped platform subroutine (WOZ collapsing ledges and	DDZ platforms)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject2:				; XREF: Obj1A_WalkOff; et al
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	locret_856E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		lsr.w	#1,d0
		btst	#0,1(a0)
		beq.s	loc_854E
		not.w	d0
		add.w	d1,d0

loc_854E:
		moveq	#0,d1
		move.b	(a2,d0.w),d1
		move.w	$C(a0),d0
		sub.w	d1,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d2
		sub.w	d2,8(a1)

locret_856E:
		rts	
; End of function SlopeObject2

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for WOZ collapsing ledge
; ---------------------------------------------------------------------------
Obj1A_SlopeData:
		incbin	misc\WOZledge.bin
		even

; ---------------------------------------------------------------------------
; Sprite mappings - WOZ	collapsing ledge
; ---------------------------------------------------------------------------
Map_obj1A:
	include "_maps\obj1A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - collapsing floors (DDZ, KVZ,	ABZ)
; ---------------------------------------------------------------------------
Map_obj53:
	include "_maps\obj53.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1C - scenery (WOZ bridge stump, KVZ lava thrower)
; ---------------------------------------------------------------------------

Obj1C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1C_Index(pc,d0.w),d1
		jmp	Obj1C_Index(pc,d1.w)
; ===========================================================================
Obj1C_Index:	dc.w Obj1C_Main-Obj1C_Index
		dc.w Obj1C_ChkDel-Obj1C_Index
; ===========================================================================

Obj1C_Main:				; XREF: Obj1C_Index
		addq.b	#2,$24(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; copy object type to d0
		mulu.w	#$A,d0		; multiply by $A
		lea	Obj1C_Var(pc,d0.w),a1
		move.l	(a1)+,4(a0)
		move.w	(a1)+,2(a0)
		ori.b	#4,1(a0)
		move.b	(a1)+,$1A(a0)
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$18(a0)
		move.w 	$18(a0),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a0)
		move.b	(a1)+,$20(a0)

Obj1C_ChkDel:				; XREF: Obj1C_Index
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj1C_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj1C_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		jmp		DeleteObject

Obj1C_Done:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Variables for	object $1C are stored in an array
; ---------------------------------------------------------------------------
Obj1C_Var:	dc.l Map_obj06		; mappings address
		dc.w $4384		; VRAM setting
		dc.b 3,	$10, 4, 0		; frame, width,	priority, collision response
		dc.l Map_obj06
		dc.w $4384
		dc.b 4,	$10, 4, 0
		dc.l Map_obj06
		dc.w $4384
		dc.b 1,	$38, 3, 0
		dc.l Map_obj11
		dc.w $437C
		dc.b 1,	$10, 1,	0
; ---------------------------------------------------------------------------
; Sprite mappings - KVZ	lava thrower
; ---------------------------------------------------------------------------
Map_obj1C:
	include "_maps\obj1C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1D - switch that activates when Sonic touches it
; (this	is not used anywhere in	the game)
; ---------------------------------------------------------------------------

Obj1D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1D_Index(pc,d0.w),d1
		jmp	Obj1D_Index(pc,d1.w)
; ===========================================================================
Obj1D_Index:	dc.w Obj1D_Main-Obj1D_Index
		dc.w Obj1D_Action-Obj1D_Index
		dc.w Obj1D_Delete-Obj1D_Index
; ===========================================================================

Obj1D_Main:				; XREF: Obj1D_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj1D,4(a0)
		move.w	#$4000,2(a0)
		move.b	#4,1(a0)
		move.w	$C(a0),$30(a0)	; save position	on y-axis
		move.b	#$10,$14(a0)
		move.w	#$280,$18(a0)

Obj1D_Action:				; XREF: Obj1D_Index
		move.w	$30(a0),$C(a0)	; restore position on y-axis
		move.w	#$10,d1
		bsr.w	Obj1D_ChkTouch
		beq.s	Obj1D_ChkDel
		addq.w	#2,$C(a0)	; move object 2	pixels
		moveq	#1,d0
		move.w	d0,($FFFFF7E0).w ; set switch 0	as "pressed"

Obj1D_ChkDel:
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj1D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj1D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj1D_Delete

Obj1D_Done:
		rts	
; ===========================================================================

Obj1D_Delete:				; XREF: Obj1D_Index
		bsr.w	DeleteObject
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	check if Sonic touches the object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1D_ChkTouch:				; XREF: Obj1D_Action
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_8918
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.s	loc_8918
		move.w	$C(a1),d2
		move.b	$16(a1),d1
		ext.w	d1
		add.w	d2,d1
		move.w	$C(a0),d0
		subi.w	#$10,d0
		sub.w	d1,d0
		bhi.s	loc_8918
		cmpi.w	#-$10,d0
		bcs.s	loc_8918
		moveq	#-1,d0
		rts	
; ===========================================================================

loc_8918:
		moveq	#0,d0
		rts	
; End of function Obj1D_ChkTouch

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - object 1D
; ---------------------------------------------------------------------------
Map_obj1D:
	include "_maps\obj1D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2A - doors (ABZ)
; ---------------------------------------------------------------------------

Obj2A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2A_Index(pc,d0.w),d1
		jmp	Obj2A_Index(pc,d1.w)
; ===========================================================================
Obj2A_Index:	dc.w Obj2A_Main-Obj2A_Index
		dc.w Obj2A_OpenShut-Obj2A_Index
; ===========================================================================

Obj2A_Main:				; XREF: Obj2A_Index
		addq.b	#2,$24(a0)
		tst.b 	($FFFFFE10).w
		beq.s 	Obj2A_WOZ
		move.l	#Map_obj2A,4(a0)
		bra.s 	Obj2A_Cont

Obj2A_WOZ:
		move.l	#Map_obj2AWOZ,4(a0)
		move.w	#$2408,2(a0)

Obj2A_Cont:
		move.w	#$4370,2(a0)
		ori.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$200,$18(a0)

Obj2A_OpenShut:				; XREF: Obj2A_Index
		move.w	#$40,d1
		clr.b	$1C(a0)		; use "closing"	animation
		move.w	($FFFFB008).w,d0
		add.w	d1,d0
		cmp.w	8(a0),d0
		bcs.s	Obj2A_Animate
		sub.w	d1,d0
		sub.w	d1,d0
		cmp.w	8(a0),d0
		bcc.s	Obj2A_Animate
		add.w	d1,d0
		cmp.w	8(a0),d0
		bcc.s	loc_899A
		btst	#0,$22(a0)
		bne.s	Obj2A_Animate
		bra.s	Obj2A_Open
; ===========================================================================

loc_899A:				; XREF: Obj2A_OpenShut
		btst	#0,$22(a0)
		beq.s	Obj2A_Animate

Obj2A_Open:				; XREF: Obj2A_OpenShut
		move.b	#1,$1C(a0)	; use "opening"	animation

Obj2A_Animate:				; XREF: Obj2A_OpenShut; loc_899A
		lea	(Ani_obj2A).l,a1
		bsr.w	AnimateSprite
		tst.b	$1A(a0)		; is the door open?
		bne.s	Obj2A_MarkAsUsed ; if yes, branch
		move.w	#$11,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		jsr	SolidObject

Obj2A_MarkAsUsed:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj2A:
	include "_anim\obj2A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - doors (ABZ)
; ---------------------------------------------------------------------------
Map_obj2A:
	include "_maps\obj2A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - doors (WOZ)
; ---------------------------------------------------------------------------
Map_obj2AWOZ:
	include "_maps\obj2AWOZ.asm"

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall:			; XREF: Obj44_Solid
		bsr.w	Obj44_SolidWall2
		beq.s	loc_8AA8
		bmi.w	loc_8AC4
		tst.w	d0
		beq.w	loc_8A92
		bmi.s	loc_8A7C
		tst.w	$10(a1)
		bmi.s	loc_8A92
		bra.s	loc_8A82
; ===========================================================================

loc_8A7C:
		tst.w	$10(a1)
		bpl.s	loc_8A92

loc_8A82:
		sub.w	d0,8(a1)
		move.w	#0,$20(a1)
		move.w	#0,$10(a1)

loc_8A92:
		btst	#1,$22(a1)
		bne.s	loc_8AB6
		bset	#5,$22(a1)
		bset	#5,$22(a0)
		rts	
; ===========================================================================

loc_8AA8:
		btst	#5,$22(a0)
		beq.s	locret_8AC2
		move.w	#1,$1C(a1)

loc_8AB6:
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)

locret_8AC2:
		rts	
; ===========================================================================

loc_8AC4:
		tst.w	$12(a1)
		bpl.s	locret_8AD8
		tst.w	d3
		bpl.s	locret_8AD8
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)

locret_8AD8:
		rts	
; End of function Obj44_SolidWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall2:			; XREF: Obj44_SolidWall
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_8B48
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_8B48
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		add.w	d2,d3
		bmi.s	loc_8B48
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.s	loc_8B48
		tst.b	($FFFFF7C8).w
		bmi.s	loc_8B48
		cmpi.b	#6,($FFFFB024).w
		bcc.s	loc_8B48
		tst.w	($FFFFFE08).w
		bne.s	loc_8B48
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_8B30
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_8B30:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_8B3C
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_8B3C:
		cmp.w	d1,d5
		bhi.s	loc_8B44
		moveq	#1,d4
		rts	
; ===========================================================================

loc_8B44:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_8B48:
		moveq	#0,d4
		rts	
; End of function Obj44_SolidWall2

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1E - Ball Hog enemy (ABZ)
; ---------------------------------------------------------------------------

Obj1E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1E_Index(pc,d0.w),d1
		jmp	Obj1E_Index(pc,d1.w)
; ===========================================================================
Obj1E_Index:	dc.w Obj1E_Main-Obj1E_Index
		dc.w Obj1E_Action-Obj1E_Index
; ===========================================================================

Obj1E_Main:				; XREF: Obj1E_Index
		move.b	#$13,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj1E,4(a0)
		move.w	#$2302,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#5,$20(a0)
		move.b	#$C,$14(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_8BAC
		add.w	d1,$C(a0)
		move.w	#0,$12(a0)
		addq.b	#2,$24(a0)

locret_8BAC:
		rts	
; ===========================================================================

Obj1E_Action:				; XREF: Obj1E_Index
		lea	(Ani_obj1E).l,a1
		bsr.w	AnimateSprite
		cmpi.b	#1,$1A(a0)	; is final frame (01) displayed?
		bne.s	Obj1E_SetBall	; if not, branch
		tst.b	$32(a0)		; is it	set to launch cannonball?
		beq.s	Obj1E_MakeBall	; if yes, branch
		bra.s	Obj1E_MarkAsGone
; ===========================================================================

Obj1E_SetBall:				; XREF: Obj1E_Action
		clr.b	$32(a0)		; set to launch	cannonball

Obj1E_MarkAsGone:			; XREF: Obj1E_Action
		jmp	MarkObjGone
; ===========================================================================

Obj1E_MakeBall:				; XREF: Obj1E_Action
		move.b	#1,$32(a0)
		bsr.w	SingleObjLoad
		bne.s	loc_8C1A
		move.b	#$20,0(a1)	; load cannonball object ($20)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	#-$100,$10(a1)	; cannonball bounces to	the left
		move.w	#0,$12(a1)
		moveq	#-4,d0
		btst	#0,$22(a0)	; is Ball Hog facing right?
		beq.s	loc_8C0A	; if not, branch
		neg.w	d0
		neg.w	$10(a1)		; cannonball bounces to	the right

loc_8C0A:
		add.w	d0,8(a1)
		addi.w	#$C,$C(a1)
		move.b	$28(a0),$28(a1)	; copy object type from	Ball Hog

loc_8C1A:
		bra.s	Obj1E_MarkAsGone
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 20 - cannonball that Ball Hog throws (ABZ)
; ---------------------------------------------------------------------------

Obj20:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj20_Index(pc,d0.w),d1
		jmp	Obj20_Index(pc,d1.w)
; ===========================================================================
Obj20_Index:	dc.w Obj20_Main-Obj20_Index
		dc.w Obj20_Bounce-Obj20_Index
; ===========================================================================

Obj20_Main:				; XREF: Obj20_Index
		addq.b	#2,$24(a0)
		move.b	#7,$16(a0)
		move.l	#Map_obj1E,4(a0)
		move.w	#$2302,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; move object type to d0
		mulu.w	#60,d0		; multiply by 60 frames	(1 second)
		move.w	d0,$30(a0)	; set explosion	time
		move.b	#4,$1A(a0)

Obj20_Bounce:				; XREF: Obj20_Index
		jsr	ObjectFall
		tst.w	$12(a0)
		bmi.s	Obj20_ChkExplode
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj20_ChkExplode
		add.w	d1,$C(a0)
		move.w	#-$300,$12(a0)
		tst.b	d3
		beq.s	Obj20_ChkExplode
		bmi.s	loc_8CA4
		tst.w	$10(a0)
		bpl.s	Obj20_ChkExplode
		neg.w	$10(a0)
		bra.s	Obj20_ChkExplode
; ===========================================================================

loc_8CA4:				; XREF: Obj20_Bounce
		tst.w	$10(a0)
		bmi.s	Obj20_ChkExplode
		neg.w	$10(a0)

Obj20_ChkExplode:			; XREF: Obj20_Bounce
		subq.w	#1,$30(a0)	; subtract 1 from explosion time
		bpl.s	Obj20_Animate	; if time is > 0, branch
		move.b	#$24,0(a0)
		move.b	#$3F,0(a0)	; change object	to an explosion	($3F)
		move.b	#0,$24(a0)	; reset	routine	counter
		bra.w	Obj3F		; jump to explosion code
; ===========================================================================

Obj20_Animate:				; XREF: Obj20_ChkExplode
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Obj20_Display
		move.b	#5,$23(a0)	; set frame duration to	5 frames
		bchg	#0,$1A(a0)	; change frame

Obj20_Display:
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object fallen off	the level?
		bcs.w	DeleteObject	; if yes, branch
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 24 - explosion	from a destroyed monitor
; ---------------------------------------------------------------------------

Obj24:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj24_Index(pc,d0.w),d1
		jmp	Obj24_Index(pc,d1.w)
; ===========================================================================
Obj24_Index:	dc.w Obj24_Main-Obj24_Index
		dc.w Obj24_Animate-Obj24_Index
; ===========================================================================

Obj24_Main:				; XREF: Obj24_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj24,4(a0)
		move.w	#$41C,2(a0)
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#0,$20(a0)
		move.b	#$C,$14(a0)
		move.b	#9,$23(a0)
		move.b	#0,$1A(a0)
		move.w	#$B4,d0
		jsr	(PlaySound_Special).l ;	play explosion sound

Obj24_Animate:				; XREF: Obj24_Index
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Obj24_Display
		move.b	#9,$23(a0)	; set frame duration to	9 frames
		addq.b	#1,$1A(a0)	; next frame
		cmpi.b	#4,$1A(a0)	; is the final frame (04) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj24_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 27 - explosion	from a destroyed enemy
; ---------------------------------------------------------------------------

Obj27:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj27_Index(pc,d0.w),d1
		jmp	Obj27_Index(pc,d1.w)
; ===========================================================================
Obj27_Index:	dc.w Obj27_LoadAnimal-Obj27_Index
		dc.w Obj27_Main-Obj27_Index
		dc.w Obj27_Animate-Obj27_Index
; ===========================================================================

Obj27_LoadAnimal:			; XREF: Obj27_Index
		addq.b	#2,$24(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj27_Main
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	$3E(a0),$3E(a1)

Obj27_Main:				; XREF: Obj27_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj27,4(a0)
		move.w	#$5A4,2(a0)
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#0,$20(a0)
		move.b	#$C,$14(a0)
		move.b	#7,$23(a0)	; set frame duration to	7 frames
		move.b	#0,$1A(a0)
		move.w	#$3D,d0
		jsr		PlaySound	;	play breaking enemy sound

Obj27_Animate:				; XREF: Obj27_Index
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Obj27_Display
		move.b	#7,$23(a0)	; set frame duration to	7 frames
		addq.b	#1,$1A(a0)	; next frame
		cmpi.b	#5,$1A(a0)	; is the final frame (05) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj27_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3F - explosion	from a destroyed boss, bomb or cannonball
; ---------------------------------------------------------------------------

Obj3F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3F_Index(pc,d0.w),d1
		jmp	Obj3F_Index(pc,d1.w)
; ===========================================================================
Obj3F_Index:	dc.w Obj3F_Main-Obj3F_Index
		dc.w Obj27_Animate-Obj3F_Index
; ===========================================================================

Obj3F_Main:				; XREF: Obj3F_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj3F,4(a0)
		move.w	#$5A4,2(a0)
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#0,$20(a0)
		move.b	#$C,$14(a0)
		move.b	#7,$23(a0)
		move.b	#0,$1A(a0)
		move.w	#$4E,d0
		jmp	(PlaySound_Special).l ;	play exploding bomb sound
; ===========================================================================
Ani_obj1E:
	include "_anim\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Ball Hog enemy (ABZ)
; ---------------------------------------------------------------------------
Map_obj1E:
	include "_maps\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj24:
	include "_maps\obj24.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj27:	
	include "_maps\obj27.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion from when	a boss is destroyed
; ---------------------------------------------------------------------------
Map_obj3F:	
	include "_maps\obj3F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 28 - animals
; ---------------------------------------------------------------------------

Obj28:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj28_Index(pc,d0.w),d1
		jmp	Obj28_Index(pc,d1.w)
; ===========================================================================
Obj28_Index:	dc.w Obj28_Ending-Obj28_Index, loc_912A-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9184-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9240-Obj28_Index
		dc.w loc_9260-Obj28_Index, loc_9260-Obj28_Index
		dc.w loc_9280-Obj28_Index, loc_92BA-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9370-Obj28_Index
		dc.w loc_92D6-Obj28_Index

Obj28_VarIndex:	dc.b 0,	5, 2, 3, 6, 3, 4, 5, 4,	1, 0, 1

Obj28_Variables:dc.w $FE00, $FC00
		dc.l Map_obj28
		dc.w $FE00, $FD00	; horizontal speed, vertical speed
		dc.l Map_obj28a		; mappings address
		dc.w $FE80, $FD00
		dc.l Map_obj28
		dc.w $FEC0, $FE80
		dc.l Map_obj28a
		dc.w $FE40, $FD00
		dc.l Map_obj28b
		dc.w $FD00, $FC00
		dc.l Map_obj28a
		dc.w $FD80, $FC80
		dc.l Map_obj28b

Obj28_EndSpeed:	dc.w $FBC0, $FC00, $FBC0, $FC00, $FBC0,	$FC00, $FD00, $FC00
		dc.w $FD00, $FC00, $FE80, $FD00, $FE80,	$FD00, $FEC0, $FE80
		dc.w $FE40, $FD00, $FE00, $FD00, $FD80,	$FC80

Obj28_EndMap:	dc.l Map_obj28a, Map_obj28a, Map_obj28a, Map_obj28, Map_obj28
		dc.l Map_obj28,	Map_obj28, Map_obj28a, Map_obj28b, Map_obj28a
		dc.l Map_obj28b

Obj28_EndVram:	dc.w $5A5, $5A5, $5A5, $553, $553, $573, $573, $585, $593
		dc.w $565, $5B3
; ===========================================================================

Obj28_Ending:				; XREF: Obj28_Index
		tst.b	$28(a0)		; did animal come from a destroyed enemy?
		beq.w	Obj28_FromEnemy	; if yes, branch
		moveq	#0,d0
		move.b	$28(a0),d0	; move object type to d0
		add.w	d0,d0		; multiply d0 by 2
		move.b	d0,$24(a0)	; move d0 to routine counter
		subi.w	#$14,d0
		move.w	Obj28_EndVram(pc,d0.w),2(a0)
		add.w	d0,d0
		move.l	Obj28_EndMap(pc,d0.w),4(a0)
		lea	Obj28_EndSpeed(pc),a1
		move.w	(a1,d0.w),$32(a0) ; load horizontal speed
		move.w	(a1,d0.w),$10(a0)
		move.w	2(a1,d0.w),$34(a0) ; load vertical speed
		move.w	2(a1,d0.w),$12(a0)
		move.b	#$C,$16(a0)
		move.b	#4,1(a0)
		bset	#0,1(a0)
		move.w	#$300,$18(a0)
		move.b	#8,$14(a0)
		move.b	#7,$23(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj28_FromEnemy:			; XREF: Obj28_Ending
		addq.b	#2,$24(a0)
		jsr	RandomNumber
		andi.w	#1,d0
		moveq	#0,d1
		move.b	($FFFFFE10).w,d1
		add.w	d1,d1
		add.w	d0,d1
		lea	Obj28_VarIndex(pc),a1
		move.b	(a1,d1.w),d0
		move.b	d0,$30(a0)
		lsl.w	#3,d0
		lea	Obj28_Variables(pc),a1
		adda.w	d0,a1
		move.w	(a1)+,$32(a0)	; load horizontal speed
		move.w	(a1)+,$34(a0)	; load vertical	speed
		move.l	(a1)+,4(a0)	; load mappings
		move.w	#$580,2(a0)	; VRAM setting for 1st animal
		btst	#0,$30(a0)	; is 1st animal	used?
		beq.s	loc_90C0	; if yes, branch
		move.w	#$594,2(a0)	; VRAM setting for 2nd animal

loc_90C0:
		move.b	#$C,$16(a0)
		move.b	#4,1(a0)
		bset	#0,1(a0)
		move.w	#$300,$18(a0)
		move.b	#8,$14(a0)
		move.b	#7,$23(a0)
		move.b	#2,$1A(a0)
		move.w	#-$400,$12(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_911C
		move.w	$3E(a0),d0
		lsr.w	#1,d0
		move.b	d0,$1A(a1)

Obj28_Display:
		bra.w	DisplaySprite
; ===========================================================================

loc_911C:
		move.b	#$12,$24(a0)
		clr.w	$10(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_912A:				; XREF: Obj28_Index
		tst.b	1(a0)
		bpl.w	DeleteObject
		bsr.w	ObjectFall
		tst.w	$12(a0)
		bmi.s	loc_9180
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9180
		add.w	d1,$C(a0)
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#1,$1A(a0)
		move.b	$30(a0),d0
		add.b	d0,d0
		addq.b	#4,d0
		move.b	d0,$24(a0)
		tst.b	($FFFFF7A7).w
		beq.s	loc_9180
		btst	#4,($FFFFFE0F).w
		beq.s	loc_9180
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_9180:
		bra.w	DisplaySprite
; ===========================================================================

loc_9184:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_91AE
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91AE
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_91AE:
		tst.b	$28(a0)
		bne.s	loc_9224
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_91C0:				; XREF: Obj28_Index
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		tst.w	$12(a0)
		bmi.s	loc_91FC
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91FC
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)
		tst.b	$28(a0)
		beq.s	loc_91FC
		cmpi.b	#$A,$28(a0)
		beq.s	loc_91FC
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_91FC:
		subq.b	#1,$23(a0)
		bpl.s	loc_9212
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_9212:
		tst.b	$28(a0)
		bne.s	loc_9224
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_9224:				; XREF: Obj28_Index
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		bcs.s	loc_923C
		subi.w	#$180,d0
		bpl.s	loc_923C
		tst.b	1(a0)
		bpl.w	DeleteObject

loc_923C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9240:				; XREF: Obj28_Index
		tst.b	1(a0)
		bpl.w	DeleteObject
		subq.w	#1,$36(a0)
		bne.w	loc_925C
		move.b	#2,$24(a0)
		move.w	#$180,$18(a0)

loc_925C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9260:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bcc.s	loc_927C
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#$E,$24(a0)
		bra.w	loc_91C0
; ===========================================================================

loc_927C:
		bra.w	loc_9224
; ===========================================================================

loc_9280:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_92B6
		clr.w	$10(a0)
		clr.w	$32(a0)
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		bsr.w	loc_93C4
		bsr.w	loc_93EC
		subq.b	#1,$23(a0)
		bpl.s	loc_92B6
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_92B6:
		bra.w	loc_9224
; ===========================================================================

loc_92BA:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_9310
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#4,$24(a0)
		bra.w	loc_9184
; ===========================================================================

loc_92D6:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_9310
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9310
		not.b	$29(a0)
		bne.s	loc_9306
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_9306:
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_9310:
		bra.w	loc_9224
; ===========================================================================

loc_9314:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_932E
		clr.w	$10(a0)
		clr.w	$32(a0)
		bsr.w	ObjectFall
		bsr.w	loc_93C4
		bsr.w	loc_93EC

loc_932E:
		bra.w	loc_9224
; ===========================================================================

loc_9332:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_936C
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_936C
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_936C
		neg.w	$10(a0)
		bchg	#0,1(a0)
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_936C:
		bra.w	loc_9224
; ===========================================================================

loc_9370:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_93C0
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		tst.w	$12(a0)
		bmi.s	loc_93AA
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_93AA
		not.b	$29(a0)
		bne.s	loc_93A0
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_93A0:
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_93AA:
		subq.b	#1,$23(a0)
		bpl.s	loc_93C0
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_93C0:
		bra.w	loc_9224
; ===========================================================================

loc_93C4:
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	locret_93EA
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_93EA
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

locret_93EA:
		rts	
; ===========================================================================

loc_93EC:
		bset	#0,1(a0)
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		bcc.s	locret_9402
		bclr	#0,1(a0)

locret_9402:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_9404:
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		subi.w	#$B8,d0
		rts	
; End of function sub_9404

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - animals
; ---------------------------------------------------------------------------
Map_obj28:
	include "_maps\obj28.asm"

Map_obj28a:
	include "_maps\obj28a.asm"

Map_obj28b:
	include "_maps\obj28b.asm"

Obj90:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj90_Off(pc,d0.w),d1
		jmp	Obj90_Off(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
Obj90_Off:	dc.w Obj90_Main-Obj90_Off; 0 ; DATA XREF: h+AE46o h+AE48o
		dc.w Obj90_Display-Obj90_Off; 1
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

Obj90_Main:				; DATA XREF: h+AE46o
		addq.b	#2,$24(a0)
		move.l	#Map_Obj90,4(a0)
		move.w	#$2500,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0) ; ' '
		move.w	#$100,$18(a0)
		move.b	$28(a0),$1A(a0)

Obj90_Display:
		jsr	RandomNumber
		and.b	#$F,d0
		move.w	d0,$10(a0)
		move.w	d0,$12(a0)
		bsr.w	SpeedtoPos
		bra.w	DisplaySprite

Map_obj90:
	include "_maps\obj90.asm"

Obj29: ; loc_1600C:   
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_21DBA(pc,d0.w),d1
		jmp	off_21DBA(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_21DBA:	dc.w loc_21DBE-off_21DBA; 0 ; DATA XREF: h+AE46o h+AE48o
		dc.w loc_21E10-off_21DBA; 1
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21DBE:				; DATA XREF: h+AE46o
		addq.b	#2,$24(a0)
		move.l	#Map_Obj29,4(a0)
		move.w	#$4500,2(a0)
		ori.b	#4,1(a0)
		move.b	#$20,$14(a0) ; ' '
		move.b	#0,$1A(a0)
		move.w	#$80,$18(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$32(a0)
		move.b	#$40,$16(a0) ; '@'
		bset	#4,1(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsl.w	#3,d0
		move.w	d0,$34(a0)

loc_21E10:				; DATA XREF: h+AE46o
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	PlatformObject
		bsr.s	loc_21E2C
		jmp	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21E2C:				; CODE XREF: h+AEA0p
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_21E3A(pc,d0.w),d1
		jmp	off_21E3A(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_21E3A:	dc.w loc_21E40-off_21E3A; 0 ; DATA XREF: h+AEC6o h+AEC8o ...
		dc.w loc_21E68-off_21E3A; 1
		dc.w loc_21EC2-off_21E3A; 2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21E40:				; DATA XREF: h+AEC6o
		btst	#3,$22(a0)
		beq.s	locret_21E66
		addq.b	#2,$25(a0)
		move.w	#$200,$10(a0)
		btst	#0,$22(a0)
		beq.s	loc_21E60
		neg.w	$10(a0)

loc_21E60:				; CODE XREF: h+AEE6j
		move.w	#$100,$12(a0)

locret_21E66:				; CODE XREF: h+AED4j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21E68:				; DATA XREF: h+AEC6o
		move.w	($FFFFFE04).w,d0
		andi.w	#$F,d0
		bne.s	loc_21E7C
		move.w	#$60,d0	; 'รค'
		jsr	PlaySound

loc_21E7C:				; CODE XREF: h+AEFCj
		bsr.w	SpeedtoPos
		subq.w	#1,$34(a0)
		bne.s	locret_21EC0
		addq.b	#2,$25(a0)
		move.b	#2,$1A(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)

locret_21EC0:
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_21EC2:
		bsr.w	SpeedtoPos
		addi.w	#$38,$12(a0)
		move.w	#$400,d0
		cmp.w	$C(a0),d0
		bcc.s	locret_21F12
		move.b	$22(a0),d0
		andi.b	#$18,d0
		beq.s	loc_21F0C
		bclr	#3,$22(a0)
		beq.s	loc_21F0C
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

loc_21F0C:
		move.w	#$4000,8(a0)

locret_21F12:
		rts	

Map_obj29:
	include "_maps\obj29.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1F - Crabmeat enemy (WOZ, CCZ)
; ---------------------------------------------------------------------------

Obj1F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1F_Index(pc,d0.w),d1
		jmp	Obj1F_Index(pc,d1.w)
; ===========================================================================
Obj1F_Index:	dc.w Obj1F_Main-Obj1F_Index
		dc.w Obj1F_Action-Obj1F_Index
		dc.w Obj1F_Delete-Obj1F_Index
		dc.w Obj1F_BallMain-Obj1F_Index
		dc.w Obj1F_BallMove-Obj1F_Index
; ===========================================================================

Obj1F_Main:				; XREF: Obj1F_Index
		move.b	#$10,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj1F,4(a0)
		move.w	#$3E4,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#6,$20(a0)
		move.b	#$15,$14(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_955A
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		addq.b	#2,$24(a0)

locret_955A:
		rts	
; ===========================================================================

Obj1F_Action:				; XREF: Obj1F_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj1F_Index2(pc,d0.w),d1
		jsr	Obj1F_Index2(pc,d1.w)
		lea	(Ani_obj1F).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj1F_Index2:	dc.w Obj1F_WaitFire-Obj1F_Index2
		dc.w Obj1F_WalkOnFloor-Obj1F_Index2
; ===========================================================================

Obj1F_WaitFire:				; XREF: Obj1F_Index2
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bpl.s	locret_95B6
		tst.b	1(a0)
		bpl.s	Obj1F_Move
		bchg	#1,$32(a0)
		bne.s	Obj1F_MakeFire

Obj1F_Move:
		addq.b	#2,$25(a0)
		move.w	#127,$30(a0)	; set time delay to approx 2 seconds
		move.w	#$80,$10(a0)	; move Crabmeat	to the right
		bsr.w	Obj1F_SetAni
		addq.b	#3,d0
		move.b	d0,$1C(a0)
		bchg	#0,$22(a0)
		bne.s	locret_95B6
		neg.w	$10(a0)		; change direction

locret_95B6:
		rts	
; ===========================================================================

Obj1F_MakeFire:				; XREF: Obj1F_WaitFire
		move.w	#$3B,$30(a0)
		move.b	#6,$1C(a0)	; use firing animation
		bsr.w	SingleObjLoad
		bne.s	Obj1F_MakeFire2
		move.b	#$1F,0(a1)	; load left fireball
		move.b	#6,$24(a1)
		move.w	8(a0),8(a1)
		subi.w	#$10,8(a1)
		move.w	$C(a0),$C(a1)
		move.w	#-$100,$10(a1)

Obj1F_MakeFire2:
		bsr.w	SingleObjLoad
		bne.s	locret_9618
		move.b	#$1F,0(a1)	; load right fireball
		move.b	#6,$24(a1)
		move.w	8(a0),8(a1)
		addi.w	#$10,8(a1)
		move.w	$C(a0),$C(a1)
		move.w	#$100,$10(a1)

locret_9618:
		move.b	#$4D,d0
		jmp	PlaySound_Special ;	play shooting sound sound
; ===========================================================================

Obj1F_WalkOnFloor:			; XREF: Obj1F_Index2
		subq.w	#1,$30(a0)
		bmi.s	loc_966E
		bsr.w	SpeedToPos
		bchg	#0,$32(a0)
		bne.s	loc_9654
		move.w	8(a0),d3
		addi.w	#$10,d3
		btst	#0,$22(a0)
		beq.s	loc_9640
		subi.w	#$20,d3

loc_9640:
		jsr	ObjHitFloor2
		cmpi.w	#-8,d1
		blt.s	loc_966E
		cmpi.w	#$C,d1
		bge.s	loc_966E
		rts	
; ===========================================================================

loc_9654:				; XREF: Obj1F_WalkOnFloor
		jsr	ObjHitFloor
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		bsr.w	Obj1F_SetAni
		addq.b	#3,d0
		move.b	d0,$1C(a0)
		rts	
; ===========================================================================

loc_966E:				; XREF: Obj1F_WalkOnFloor
		subq.b	#2,$25(a0)
		move.w	#59,$30(a0)
		move.w	#0,$10(a0)
		bsr.w	Obj1F_SetAni
		move.b	d0,$1C(a0)
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	set the	correct	animation for a	Crabmeat
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1F_SetAni:				; XREF: loc_966E
		moveq	#0,d0
		move.b	$26(a0),d3
		bmi.s	loc_96A4
		cmpi.b	#6,d3
		bcs.s	locret_96A2
		moveq	#1,d0
		btst	#0,$22(a0)
		bne.s	locret_96A2
		moveq	#2,d0

locret_96A2:
		rts	
; ===========================================================================

loc_96A4:				; XREF: Obj1F_SetAni
		cmpi.b	#-6,d3
		bhi.s	locret_96B6
		moveq	#2,d0
		btst	#0,$22(a0)
		bne.s	locret_96B6
		moveq	#1,d0

locret_96B6:
		rts	
; End of function Obj1F_SetAni

; ===========================================================================

Obj1F_Delete:				; XREF: Obj1F_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sub-object - missile that the	Crabmeat throws
; ---------------------------------------------------------------------------

Obj1F_BallMain:				; XREF: Obj1F_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj1F,4(a0)
		move.w	#$3E4,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		move.w	#-$400,$12(a0)
		move.b	#7,$1C(a0)
		bset	#3,$2B(a0)
		bset	#5,$2B(a0)

Obj1F_BallMove:				; XREF: Obj1F_Index
		lea	(Ani_obj1F).l,a1
		bsr.w	AnimateSprite
		bsr.w	ObjectFall
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below the level boundary?
		bcs.s	Obj1F_Delete2	; if yes, branch
		rts	
; ===========================================================================

Obj1F_Delete2:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj1F:
	include "_anim\obj1F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Crabmeat enemy (WOZ, CCZ)
; ---------------------------------------------------------------------------
Map_obj1F:
	include "_maps\obj1F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 22 - Buzz Bomber enemy	(WOZ, DDZ, CCZ)
; ---------------------------------------------------------------------------

Obj22:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj22_Index(pc,d0.w),d1
		jmp	Obj22_Index(pc,d1.w)
; ===========================================================================
Obj22_Index:	dc.w Obj22_Main-Obj22_Index
		dc.w Obj22_Action-Obj22_Index
		dc.w Obj22_Delete-Obj22_Index
; ===========================================================================

Obj22_Main:				; XREF: Obj22_Index
		addq.b	#2,$24(a0)
		cmpi.b 	#4,($FFFFFE10).w
		beq.s 	Obj22_CCZ
		move.l	#Map_obj22,4(a0)
		move.w	#$444,2(a0)
		bra.s 	Obj22_Cont

Obj22_CCZ:
		move.l	#Map_CCZobj22,4(a0)
		move.w	#$3AC,2(a0)

Obj22_Cont:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$20(a0)
		move.b	#$18,$14(a0)

Obj22_Action:				; XREF: Obj22_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj22_Index2(pc,d0.w),d1
		jsr	Obj22_Index2(pc,d1.w)
		lea	(Ani_obj22).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj22_Index2:	dc.w Obj22_Move-Obj22_Index2
		dc.w Obj22_ChkNrSonic-Obj22_Index2
; ===========================================================================

Obj22_Move:				; XREF: Obj22_Index2
		subq.w	#1,$32(a0)	; subtract 1 from time delay
		bpl.s	locret_986C	; if time remains, branch
		btst	#1,$34(a0)	; is Buzz Bomber near Sonic?
		bne.s	Obj22_Fire	; if yes, branch
		addq.b	#2,$25(a0)
		move.w	#127,$32(a0)	; set time delay to just over 2	seconds
		move.w	#$400,$10(a0)	; move Buzz Bomber to the right
		move.b	#1,$1C(a0)	; use "flying" animation
		btst	#0,$22(a0)	; is Buzz Bomber facing	left?
		bne.s	locret_986C	; if not, branch
		neg.w	$10(a0)		; move Buzz Bomber to the left

locret_986C:
		rts	
; ===========================================================================

Obj22_Fire:				; XREF: Obj22_Move
		bsr.w	SingleObjLoad
		bne.s	locret_98D0
		move.b	#$23,0(a1)	; load missile object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		move.w	#$200,$12(a1)	; move missile downwards
		move.w	#$200,$10(a1)	; move missile to the right
		move.w	#$18,d0
		btst	#0,$22(a0)	; is Buzz Bomber facing	left?
		bne.s	loc_98AA	; if not, branch
		neg.w	d0
		neg.w	$10(a1)		; move missile to the left

loc_98AA:
		add.w	d0,8(a1)
		move.b	$22(a0),$22(a1)
		move.w	#$E,$32(a1)
		move.l	a0,$3C(a1)
		move.b	#1,$34(a0)	; set to "already fired" to prevent refiring
		move.w	#$3B,$32(a0)
		move.b	#2,$1C(a0)	; use "firing" animation

locret_98D0:
		rts	
; ===========================================================================

Obj22_ChkNrSonic:			; XREF: Obj22_Index2
		subq.w	#1,$32(a0)	; subtract 1 from time delay
		bmi.s	Obj22_ChgDir
		bsr.w	SpeedToPos
		tst.b	$34(a0)
		bne.s	locret_992A
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bpl.s	Obj22_SetNrSonic
		neg.w	d0

Obj22_SetNrSonic:
		cmpi.w	#$60,d0		; is Buzz Bomber within	$60 pixels of Sonic?
		bcc.s	locret_992A	; if not, branch
		tst.b	1(a0)
		bpl.s	locret_992A
		move.b	#2,$34(a0)	; set Buzz Bomber to "near Sonic"
		move.w	#29,$32(a0)	; set time delay to half a second
		bra.s	Obj22_Stop
; ===========================================================================

Obj22_ChgDir:				; XREF: Obj22_ChkNrSonic
		move.b	#0,$34(a0)	; set Buzz Bomber to "normal"
		bchg	#0,$22(a0)	; change direction
		move.w	#59,$32(a0)

Obj22_Stop:				; XREF: Obj22_SetNrSonic
		subq.b	#2,$25(a0)	; run "Obj22_Fire" routine
		move.w	#0,$10(a0)	; stop Buzz Bomber moving
		move.b	#0,$1C(a0)	; use "hovering" animation

locret_992A:
		rts	
; ===========================================================================

Obj22_Delete:				; XREF: Obj22_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 23 - missile that Buzz	Bomber throws
; ---------------------------------------------------------------------------

Obj23:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj23_Index(pc,d0.w),d1
		jmp	Obj23_Index(pc,d1.w)
; ===========================================================================
Obj23_Index:	dc.w Obj23_Main-Obj23_Index
		dc.w Obj23_Animate-Obj23_Index
		dc.w Obj23_FromBuzz-Obj23_Index
		dc.w Obj23_Delete-Obj23_Index
		dc.w Obj23_FromNewt-Obj23_Index
		dc.w Obj23_CoconutFall-Obj23_Index
; ===========================================================================

Obj23_Main:				; XREF: Obj23_Index
		subq.w	#1,$32(a0)
		bpl.w	Obj23_ChkCancel
		addq.b	#2,$24(a0)
		move.l	#Map_obj23,4(a0)
		move.w	#$23AC,2(a0)
		cmpi.b	#2,$28(a0)
		bne.s	Obj23_Main2
		move.l	#Map_obj93,4(a0)
		move.w	#$23FB,2(a0)

Obj23_Main2:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		move.b	#$4D,d0
		jsr		PlaySound_Special ;	play shooting sound sound
		andi.b	#3,$22(a0)
		tst.b	$28(a0)		; was object created by	a Newtron?
		beq.s	Obj23_Animate	; if not, branch
		cmpi.b	#2,$28(a0)
		beq.s	Obj23_CoCo
		move.b	#8,$24(a0)	; run "Obj23_FromNewt" routine
		move.b	#1,$1C(a0)
		bra.w	Obj23_Animate2

Obj23_CoCo:
		move.b	#$87,$20(a0)
		bset	#6,$2B(a0)
		bset	#3,$2B(a0)
		move.b	#$A,$24(a0)
		bra.w	Obj23_CoconutFall
; ===========================================================================

Obj23_Animate:				; XREF: Obj23_Index
		bsr.s	Obj23_ChkCancel
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ---------------------------------------------------------------------------
; Subroutine to	check if the Buzz Bomber which fired the missile has been
; destroyed, and if it has, then cancel	the missile
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj23_ChkCancel:			; XREF: Obj23_Main
		movea.l	$3C(a0),a1
		cmpi.b	#$27,0(a1)	; has Buzz Bomber been destroyed?
		beq.s	Obj23_Delete	; if yes, branch
		rts	
; End of function Obj23_ChkCancel

; ===========================================================================

Obj23_FromBuzz:				; XREF: Obj23_Index
		btst	#7,$22(a0)
		bne.s	Obj23_Explode
		move.b	#$87,$20(a0)
		bset	#5,$2B(a0)
		bset	#3,$2B(a0)
		move.b	#1,$1C(a0)
		bsr.w	SpeedToPos
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below the level boundary?
		bcs.s	Obj23_Delete	; if yes, branch
		rts	
; ===========================================================================

Obj23_Explode:				; XREF: Obj23_FromBuzz
		move.b	#$27,0(a0)	; change object	to an explosion	(Obj24)
		move.b	#0,$24(a0)
		bra.w	Obj27
; ===========================================================================

Obj23_Delete:				; XREF: Obj23_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj23_FromNewt:				; XREF: Obj23_Index
		tst.b	1(a0)
		bpl.s	Obj23_Delete
		bsr.w	SpeedToPos

Obj23_Animate2:				; XREF: Obj23_Main
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite

Obj23_NewtronCont:
		rts	

; loc_37728:
Obj23_CoconutFall:
		addi.w	#$20,$12(a0) ; apply gravity (less than normal)
		jsr	(SpeedtoPos).l
		bsr.w	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below the level boundary?
		bcs.s	Obj23_Delete	; if yes, branch
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret2_F68A
		moveq	#4,d1
		movea.l	a0,a1
		lea	(Obj23_ShrSpeed).l,a2 ;	load shrapnel speed data
		bra.s	Obj23_MakeShrap
; ===========================================================================

Obj23_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc2_11BCE

Obj23_MakeShrap:			; XREF: loc_11B7C
		move.b	#$5F,0(a1)	; load shrapnel	object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	#6,$28(a1)
		move.b	#4,$1C(a1)
		move.w	(a2)+,$10(a1)
		move.w	(a2)+,$12(a1)
		bset	#7,1(a1)
		move.b	#$98,$20(a1)
		bset	#5,$2B(a1)
		bset	#3,$2B(a1)

loc2_11BCE:
		dbf	d1,Obj23_Loop	; repeat 3 more	times
		jmp	DeleteObject

locret2_F68A:
		rts	
; ===========================================================================
Obj23_ShrSpeed:	dc.w $FE80, $FD80, $FF80, $FE80, $180, $FD80, $80, $FE80
Ani_obj22:
	include "_anim\obj22.asm"

Ani_obj23:
	include "_anim\obj23.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Buzz Bomber	enemy
; ---------------------------------------------------------------------------
Map_obj22:
	include "_maps\obj22.asm"

Map_CCZobj22:
	include "_maps\obj22CCZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - missile that Buzz Bomber throws
; ---------------------------------------------------------------------------
Map_obj23:
	include "_maps\obj23.asm"

; ---------------------------------------------------------------------------
; Object 25 - rings
; ---------------------------------------------------------------------------

Obj25:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj25_Index(pc,d0.w),d1
		jmp	Obj25_Index(pc,d1.w)
; ===========================================================================
Obj25_Index:	dc.w Obj25_Main-Obj25_Index
		dc.w Obj25_Animate-Obj25_Index
		dc.w Obj25_Collect-Obj25_Index
		dc.w Obj25_Sparkle-Obj25_Index
		dc.w Obj25_Delete-Obj25_Index
; ===========================================================================

Obj25_Main:				; XREF: Obj25_Index
		addq.b	#2,$24(a0)
		move.w	8(a0),$32(a0)
		move.l	#Map_obj25,4(a0)
		move.w	#$26C0,2(a0)
		move.b	#4,1(a0)
		move.w	#$100,$18(a0)
		move.b	#$47,$20(a0)
		move.b	#8,$14(a0)

Obj25_Animate:				; XREF: Obj25_Index
		move.w	$32(a0),d0
		bra.w	MarkObjGone
; ===========================================================================

Obj25_Collect:				; XREF: Obj25_Index
		addq.b	#2,$24(a0)
		move.b	#0,$20(a0)
		move.w	#$80,$18(a0)
		bsr.w	CollectRing

Obj25_Sparkle:				; XREF: Obj25_Index
		lea	(Ani_obj25).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj25_Delete:				; XREF: Obj25_Index
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

CollectRing:				; XREF: Obj25_Collect
		addq.w	#1,($FFFFFE20).w ; add 1 to rings
		ori.b	#1,($FFFFFE1D).w ; update the rings counter
		move.w	#$33,d0		; play ring sound
		cmpi.w	#100,($FFFFFE20).w ; do	you have < 100 rings?
		bcs.s	Obj25_PlaySnd	; if yes, branch
		bset	#1,($FFFFFE1B).w ; update lives	counter
		beq.s	loc_9CA4
		cmpi.w	#200,($FFFFFE20).w ; do	you have < 200 rings?
		bcs.s	Obj25_PlaySnd	; if yes, branch
		bset	#2,($FFFFFE1B).w ; update lives	counter
		bne.s	Obj25_PlaySnd

loc_9CA4:
		addq.b	#1,($FFFFFE12).w ; add 1 to the	number of lives	you have
		addq.b	#1,($FFFFFE1C).w ; add 1 to the	lives counter
		move.b	#$2A,d0		; play extra life music

Obj25_PlaySnd:
		jmp	(PlaySound_Special).l
; End of function CollectRing

RingsManager:
	moveq	#0,d0
	move.b	($FFFFFE17).w,d0
	move.w	RingsManager_States(pc,d0.w),d0
	jmp	RingsManager_States(pc,d0.w)
; ===========================================================================
; off_16F96:
RingsManager_States:
	dc.w RingsManager_Init-RingsManager_States
	dc.w RingsManager_Main-RingsManager_States
; ===========================================================================
; loc_16F9A:
RingsManager_Init:
	addq.b	#2,($FFFFFE17).w ; => RingsManager_Main
	bsr.w	RingsManager_Setup
	movea.l	($FFFFE800+Rings_Space).w,a1
	lea	($FFFFE800).w,a2
	move.w	($FFFFF700).w,d4
	subq.w	#8,d4
	bhi.s	loc_16FB6
	moveq	#1,d4
	bra.s	loc_16FB6
; ===========================================================================

loc_16FB2:
	addq.w	#4,a1
	addq.w	#2,a2

loc_16FB6:
	cmp.w	(a1),d4
	bhi.s	loc_16FB2
	move.l	a1,($FFFFE800+Rings_Space).w
	move.w	a2,($FFFFF7A2).w
	addi.w	#$150,d4
	bra.s	loc_16FCE
; ===========================================================================

loc_16FCA:
	addq.w	#4,a1

loc_16FCE:
	cmp.w	(a1),d4
	bhi.s	loc_16FCA
	move.l	a1,($FFFFE800+Rings_Space+4).w
	rts
; ===========================================================================
; loc_16FDE:
RingsManager_Main:
	lea	($FFFFEF80).w,a2
	move.w	(a2)+,d1
	subq.w	#1,d1
	bcs.s	loc_17014

loc_16FE8:
	move.w	(a2)+,d0
	beq.s	loc_16FE8
	movea.w	d0,a1
	subq.b	#1,(a1)
	bne.s	loc_17010
	move.b	#6,(a1)
	addq.b	#1,1(a1)
	cmpi.b	#5,1(a1)
	bne.s	loc_17010
	move.w	#-1,(a1)
	move.w	#0,-2(a2)
	subq.w	#1,($FFFFEF80).w

loc_17010:
	dbf	d1,loc_16FE8

loc_17014:
	movea.l	($FFFFE800+Rings_Space).w,a1
	movea.w	($FFFFF7A2).w,a2
	move.w	($FFFFF700).w,d4
	subq.w	#8,d4
	bhi.s	loc_17028
	moveq	#1,d4
	bra.s	loc_17028
; ===========================================================================

loc_17024:
	addq.w	#4,a1
	addq.w	#2,a2

loc_17028:
	cmp.w	(a1),d4
	bhi.s	loc_17024
	bra.s	loc_17032
; ===========================================================================

loc_17030:
	subq.w	#4,a1
	subq.w	#2,a2

loc_17032:
	cmp.w	-4(a1),d4
	bls.s	loc_17030
	move.l	a1,($FFFFE800+Rings_Space).w
	move.w	a2,($FFFFF7A2).w
	movea.l	($FFFFE800+Rings_Space+4).w,a2
	addi.w	#$150,d4
	bra.s	loc_1704A
; ===========================================================================

loc_17046:
	addq.w	#4,a2

loc_1704A:
	cmp.w	(a2),d4
	bhi.s	loc_17046
	bra.s	loc_17054
; ===========================================================================

loc_17052:
	subq.w	#4,a2

loc_17054:
	cmp.w	-4(a2),d4
	bls.s	loc_17052
	move.l	a2,($FFFFE800+Rings_Space+4).w
	rts
; ===========================================================================

Touch_Rings:
	movea.l	($FFFFE800+Rings_Space).w,a1
	movea.l	($FFFFE800+Rings_Space+4).w,a2

loc_170D0:
	cmpa.l	a1,a2
	beq.w	return_17166
	movea.w	($FFFFF7A2).w,a4
	cmpi.w	#$5A,$30(a0)
	bcc.w	return_17166
	btst	#5,($FFFFFE2C).w	; does Sonic have a lightning shield?
	beq.s	Touch_Rings_NoAttraction	; if not, branch
	move.w	8(a0),d2
	move.w	$C(a0),d3
	subi.w	#$40,d2
	subi.w	#$40,d3
	move.w	#6,d1
	move.w	#$C,d6
	move.w	#$80,d4
	move.w	#$80,d5
	bra.s	loc_17112
; ===========================================================================
	
Touch_Rings_NoAttraction:
	move.w	8(a0),d2
	move.w	$C(a0),d3
	subi.w	#8,d2
	moveq	#0,d5
	move.b	$16(a0),d5
	subq.b	#3,d5
	sub.w	d5,d3
	cmpi.b	#$4D,4(a0)
	bne.s	loc_17111
	addi.w	#$C,d3
	moveq	#$A,d5

loc_17111:
	move.w	#6,d1
	move.w	#$C,d6
	move.w	#$10,d4
	add.w	d5,d5

loc_17112:
	tst.w	(a4)
	bne.w	loc_1715C
	move.w	(a1),d0
	sub.w	d1,d0
	sub.w	d2,d0
	bcc.s	loc_1712A
	add.w	d6,d0
	bcs.s	loc_17130
	bra.w	loc_1715C
; ===========================================================================

loc_1712A:
	cmp.w	d4,d0
	bhi.w	loc_1715C

loc_17130:
	move.w	2(a1),d0
	sub.w	d1,d0
	sub.w	d3,d0
	bcc.s	loc_17142
	add.w	d6,d0
	bcs.s	loc_17148
	bra.w	loc_1715C
; ===========================================================================

loc_17142:
	cmp.w	d5,d0
	bhi.w	loc_1715C

loc_17148:
	btst	#5,($FFFFFE2C).w	; does Sonic have a lightning shield?
	bne.s	AttractRing
	
loc_17148_cont:
	move.w	#$601,(a4)
	bsr.s	loc_17168
	lea	($FFFFEF82).w,a3

loc_17152:
	tst.w	(a3)+
	bne.s	loc_17152
	move.w	a4,-(a3)
	addq.w	#1,($FFFFEF80).w

loc_1715C:
	addq.w	#4,a1
	addq.w	#2,a4
	cmpa.l	a1,a2
	bne.w	loc_17112

return_17166:
	rts
; ===========================================================================

loc_17168:
	subq.w	#1,($FFFFF712).w
	bra.w	CollectRing
; ===========================================================================

AttractRing:
	movea.l	a1,a3
	jsr	SingleObjLoad
	bne.w	AttractRing_NoFreeSlot
	move.b	#$91,(a1)
	move.w	(a3),8(a1)
	move.w	2(a3),$C(a1)
	move.w	a0,$34(a1)
	move.w	#-1,(a4)
	rts	
; ===========================================================================
	
AttractRing_NoFreeSlot:
	movea.l	a3,a1
	bra.s	loc_17148_cont
; ===========================================================================

BuildRings:
	movea.l	($FFFFE800+Rings_Space).w,a0
	move.l	($FFFFE800+Rings_Space+4).w,d7
	sub.l	a0,d7
	bne.s	loc_17186
	rts
; ===========================================================================

loc_17186:
	movea.w	($FFFFF7A2).w,a4
	lea	($FFFFF700).w,a3

loc_1718A:
	tst.w	(a4)+
	bmi.w	loc_171EC
	move.w	(a0),d3
	sub.w	(a3),d3
	addi.w	#$80,d3
	move.w	2(a0),d2
	sub.w	4(a3),d2
	andi.w	#$7FF,d2
	addi.w	#8,d2
	bmi.s	loc_171EC
	cmpi.w	#$F0,d2
	bge.s	loc_171EC
	addi.w	#$78,d2
	lea	(Map_Obj25).l,a1
	moveq	#0,d1
	move.b	-1(a4),d1
	bne.s	loc_171C8
	moveq	#0,d1

loc_171C8:
	add.w	d1,d1
	adda.w	(a1,d1.w),a1
	moveq	#$00,d1					; MJ: clear d1 (because of our byte to word change)
	move.b	(a1)+,d1
	subq.b	#1,d1
	bmi.s	loc_171EC
	move.b	(a1)+,d0
	ext.w	d0
	add.w	d2,d0
	move.w	d0,(a2)+
	move.b	(a1)+,(a2)+
	addq.b	#1,d5
	move.b	d5,(a2)+
	move.b	(a1)+,d0
	lsl.w	#8,d0
	move.b	(a1)+,d0
	addi.w	#$26C0,d0
	move.w	d0,(a2)+
	move.b	(a1)+,d0
	ext.w	d0
	add.w	d3,d0
	move.w	d0,(a2)+

loc_171EC:
	addq.w	#4,a0
	subq.w	#4,d7
	bne.w	loc_1718A
	rts
; ===========================================================================

RingsManager_Setup:
	lea	($FFFFE800).w,a1
	moveq	#0,d0
	move.w	#Rings_Space/4-1,d1

loc_172AE:				; CODE XREF: h+33Cj
	move.l	d0,(a1)+
	dbf	d1,loc_172AE

	lea	($FFFFEF80).w,a1
	move.w	#$1F,d1

loc_172AF:
	move.l	d0,(a1)+
	dbf	d1,loc_172AF

	moveq	#0,d5
	moveq	#0,d0
	move.w	($FFFFFE10).w,d0
	lsl.b	#6,d0
	lsr.w	#4,d0
	lea	(RingPos_Index).l,a1
	move.w	(a1,d0.w),d0
	lea	(a1,d0.w),a1
	move.l	a1,($FFFFE800+Rings_Space).w
	addq.w	#4,a1
	moveq	#0,d5
	move.w	#(Max_Rings-1),d0

loc_172B0:
	tst.l	(a1)+
	bmi.s	loc_172B1
	addq.w	#1,d5
	dbf	d0,loc_172B0

loc_172B1:
	move.w	d5,($FFFFF712).w
	move.w	#0,($FFFFF716).w	; no idea what this is
	rts
	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 37 - rings flying out of Sonic	when he's hit
; ---------------------------------------------------------------------------

Obj37:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj37_Index(pc,d0.w),d1
		jmp	Obj37_Index(pc,d1.w)
; ===========================================================================
Obj37_Index:	dc.w Obj37_CountRings-Obj37_Index
		dc.w Obj37_Bounce-Obj37_Index
		dc.w Obj37_Collect-Obj37_Index
		dc.w Obj37_Sparkle-Obj37_Index
		dc.w Obj37_Delete-Obj37_Index
; ===========================================================================

Obj37_CountRings:			; XREF: Obj37_Index
		movea.l	a0,a1
		moveq	#0,d5
		move.w	($FFFFFE20).w,d5 ; check number	of rings you have
		moveq	#32,d0
		cmp.w	d0,d5		; do you have 32 or more?
		bcs.s	loc_9CDE	; if not, branch
		move.w	d0,d5		; if yes, set d5 to 32

loc_9CDE:
		subq.w	#1,d5
		move.w	#$288,d4
		bra.s	Obj37_MakeRings
; ===========================================================================

Obj37_Loop:
		bsr.w	SingleObjLoad
		bne.w	Obj37_ResetCounter

Obj37_MakeRings:			; XREF: Obj37_CountRings
		move.b	#$37,0(a1)	; load bouncing	ring object
		addq.b	#2,$24(a1)
		move.b	#8,$16(a1)
		move.b	#8,$17(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.l	#Map_obj25,4(a1)
		move.w	#$26C0,2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#$47,$20(a1)
		move.b	#8,$14(a1)
		move.b	#-1,($FFFFFEC6).w
		tst.w	d4
		bmi.s	loc_9D62
		move.w	d4,d0
		jsr 	CalcSine
		move.w	d4,d2
		lsr.w	#8,d2
		asl.w	d2,d0
		asl.w	d2,d1
		move.w	d0,d2
		move.w	d1,d3
		addi.b	#$10,d4
		bcc.s	loc_9D62
		subi.w	#$80,d4
		bcc.s	loc_9D62
		move.w	#$288,d4

loc_9D62:
		btst	#0,($FFFFB022).w
		beq.s	Obj37_Reverse
		neg.w	d2
		move.w	d2,$10(a1)
		move.w	d3,$12(a1)
		bra.s	Obj37_Done

Obj37_Reverse:
		move.w	d2,$10(a1)
		move.w	d3,$12(a1)
		neg.w	d2

Obj37_Done:
		neg.w	d4
		dbf	d5,Obj37_Loop	; repeat for number of rings (max 31)

Obj37_ResetCounter:			; XREF: Obj37_Loop
		move.w	#0,($FFFFFE20).w ; reset number	of rings to zero
		move.b	#$80,($FFFFFE1D).w ; update ring counter
		move.b	#0,($FFFFFE1B).w
		move.w	#$B9,d0
		jsr	(PlaySound_Special).l ;	play ring loss sound

Obj37_Bounce:				; XREF: Obj37_Index
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		bmi.s	Obj37_ChkDel
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#3,d0
		bne.s	Obj37_ChkDel
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		blt.s	Obj37_Bounce2		; if yes, branch
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj37_ChkDel
		add.w	d1,$C(a0)

Obj37_Bounce2:
		move.w	$12(a0),d0
		asr.w	#2,d0
		sub.w	d0,$12(a0)
		neg.w	$12(a0)

Obj37_ChkDel:				; XREF: Obj37_Bounce
		tst.b	($FFFFFEC6).w
		beq.s	Obj37_JMPDelete
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		bcs.s	Obj37_JMPDelete	; if yes, branch
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		bcs.s	Obj37_JMPDelete	; if yes, branch
		btst	#5,($FFFFFE2C).w
		beq.s	Obj37_skip
		tst.b	1(a0)
		bpl.s	Obj37_skip
		lea ($FFFFB000).w,a1
		move.w	8(a1),d0	; load Sonic's x-axis position
		sub.w	8(a0),d0
		bpl.s	Obj37_a1
		neg.w	d0
		bra.w 	Obj37_a1
		
Obj37_JMPDelete:
		bsr.w 	Obj37_Delete

	Obj37_a1:
		cmpi.w	#$A0,d0
		bhi.s	Obj37_skip
		
		move.w	$C(a1),d0	; load Sonic's y-axis position
		sub.w	$C(a0),d0
		bpl.s	Obj37_a2
		neg.w	d0
		
	Obj37_a2:
		cmpi.w	#$A0,d0
		bhi.s	Obj37_skip
		
		move.b	#$A,$24(a0)
		move.b	#$25,0(a0)
		
	Obj37_skip:
		move.b	($FFFFFEC6).w,d0
		btst	#0,d0
		beq.w	DisplaySprite
		cmpi.b	#$80,d0
		bhi.w	DisplaySprite
		rts
; ===========================================================================

Obj37_Collect:				; XREF: Obj37_Index
		addq.b	#2,$24(a0)
		move.b	#0,$20(a0)
		move.w	#$80,$18(a0)
		bsr.w	CollectRing

Obj37_Sparkle:				; XREF: Obj37_Index
		lea	(Ani_obj25).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj37_Delete:				; XREF: Obj37_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4B - giant ring for entry to special stage
; ---------------------------------------------------------------------------

Obj4B:					; XREF: Obj_Index
		move.b	$28(a0),d0
		move.l	($FFFFFFC4).w,d1
		btst	d0,d1
		bne.w	Obj4B_Delete				; only make the ring if it hasn't already been collected
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj4B_Index(pc,d0.w),d1
		jmp	Obj4B_Index(pc,d1.w)
; ===========================================================================
Obj4B_Index:	dc.w Obj4B_Main-Obj4B_Index
		dc.w Obj4B_Animate-Obj4B_Index
		dc.w Obj4B_Collect-Obj4B_Index
		dc.w Obj4B_Delete-Obj_Index
; ===========================================================================

Obj4B_Main:				; XREF: Obj4B_Index
		move.l	#Map_obj4B,4(a0)
		move.w	#$2680,2(a0)
		ori.b	#4,1(a0)
		move.b	#$40,$14(a0)
		tst.b	1(a0)
		bpl.s	Obj4B_Animate
; ===========================================================================

Obj4B_Okay:				; XREF: Obj4B_Main
		addq.b	#2,$24(a0)
		move.w	#$100,$18(a0)

Obj4B_Animate:				; XREF: Obj4B_Index
		cmpi.b	#8,$1A(a0)
		bcs.s	Obj4B_AnimateCont		; If ring hasn't finished forming, don't allow collision
		move.b	#$52,$20(a0)

Obj4B_AnimateCont:	
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj4B_Return
		move.w	$C(a0),d0
		move.w	($FFFFF704).w,d1
		sub.w	($FFFFF704).w,d0
		subi.w	#$80,d1
		cmpi.w	#$200,d0
		bhi.s	Obj4B_Return
		lea     (Ani_obj4B).l,a1  
		jsr     AnimateSprite

LoadSSRingDynPLC:
		movea.l	#SSRingDynPLC,a2	; get DPLC location
		move.w	#$D000,d4		; offset in VRAM to store art
		move.l	#Art_BigRing,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	Obj4B_Display	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC

Obj4B_Display:
		bra.w	DisplaySprite

Obj4B_Return:				; XREF: Obj4B_Index
		moveq	#1,d0
		jsr	LoadPLC		; load standard	patterns
		bra.w	Mark_ChkGone
; ===========================================================================

Obj4B_Collect:				; XREF: Obj4B_Index
		addq.b	#2,$24(a0)
		move.b	#1,$1C(a0)
		move.b	#0,$20(a0)
		move.b	#$FF,$23(a0)
		jsr	(SingleObjLoad).l
		bne.s	Obj4B_PlaySnd
		move.b	#$7C,(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.l	a0,$3C(a1)
		move.w	($FFFFB008).w,d0
		cmp.w	8(a0),d0	; has Sonic come from the left?
		bcs.s	Obj4B_PlaySnd	; if yes, branch
		bset	#0,1(a1)	; reverse flash	object


Obj4B_PlaySnd:
		move.w	#$B3,d0
		jsr	(PlaySound_Special).l ;	play giant ring	sound
		move.w 	($FFFFB008).w,($FFFFF608).w
		move.w 	($FFFFB00C).w,($FFFFF60A).w
		move.b	$28(a0),d0
		move.l	($FFFFFFC4).w,d1
		bset	d0,d1
		move.l	d1,($FFFFFFC4).w	; Set the special stage ring as collected
		rts

; ===========================================================================

Obj4B_Delete:
		bra.w	DeleteObject

Ani_obj4B:
	include "_anim\obj4B.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7C - flash effect when	you collect the	giant ring
; ---------------------------------------------------------------------------

Obj7C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7C_Index(pc,d0.w),d1
		jmp	Obj7C_Index(pc,d1.w)
; ===========================================================================
Obj7C_Index:	dc.w Obj7C_Main-Obj7C_Index
		dc.w Obj7C_ChkDel-Obj7C_Index
		dc.w Obj7C_Delete-Obj7C_Index
; ===========================================================================

Obj7C_Main:				; XREF: Obj7C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj4B,4(a0)
		move.w	#$2680,2(a0)
		ori.b	#4,1(a0)
		move.w	#0,$18(a0)
		move.b	#$20,$14(a0)
		move.b	#$B,$1A(a0)
		move.b	#6,$24(a1)	; delete giant ring object (Obj4B)

Obj7C_ChkDel:				; XREF: Obj7C_Index
		bsr.s	Obj7C_Collect
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w 	LoadSSRingDynPLC

Obj7C_Collect:				; XREF: Obj7C_ChkDel
		subq.b	#1,$23(a0)
		bpl.s	locret_9F76
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		cmpi.b	#$11,$1A(a0)	; has animation	finished?
		bcc.s	Obj7C_End	; if yes, branch
		cmpi.b	#$E,$1A(a0)	; is 3rd frame displayed?
		bne.s	locret_9F76	; if not, branch
		movea.l	$3C(a0),a1
		move.w	#0,($FFFFB000).w ; remove Sonic	object
		move.b	#1,($FFFFF7CD).w ; stop	Sonic getting bonuses
		bclr	#1,($FFFFFE2C).w	; remove invincibility

locret_9F76:
		rts	
; ===========================================================================

Obj7C_End:				; XREF: Obj7C_Collect
		addq.b	#2,$24(a0)
		move.b	#$10,($FFFFF600).w
		addq.l	#4,sp
	;	jsr	RandomNumber
	;	andi.b	#3,d0
		move.b	#0,($FFFFFE16).w
		rts	
; End of function Obj7C_Collect

; ===========================================================================

Obj7C_Delete:				; XREF: Obj7C_Index
		bra.w	DeleteObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 91 - Attracted ring (ported from Sonic and Knuckles)
; ----------------------------------------------------------------------------
Obj91:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj_91_subtbl(pc,d0.w),d1
	jmp	Obj_91_subtbl(pc,d1.w)
; ===========================================================================
Obj_91_subtbl:
	dc.w	Obj_91_sub_0-Obj_91_subtbl; 0
	dc.w	Obj_91_sub_2-Obj_91_subtbl; 2
	dc.w	Obj_91_sub_4-Obj_91_subtbl; 4
	dc.w	Obj_91_sub_6-Obj_91_subtbl; 6
	dc.w	Obj_91_sub_8-Obj_91_subtbl; 8
; ===========================================================================

Obj_91_sub_0:
	addq.b	#2,$24(a0)
	move.w	8(a0),$32(a0)
	move.l	#Map_obj25,4(a0)
	move.w	#$26C0,2(a0)
	move.b	#4,1(a0)
	move.w	#$100,$18(a0)
	move.b	#$47,$20(a0)
	move.b	#8,$14(a0)

Obj_91_sub_2:
	bsr.w	Obj_91_Move
	movea.w	$34(a0),a1
	btst	#5,($FFFFFE2C).w	; Change the #0 to #5 if you've ported the actual lightning shield
	bne.s	Obj_91_sub_3
	move.b	#$37,(a0)	; Load object 37 (scattered rings)
	move.b	#2,$24(a0)
	move.b	#-1,($FFFFFEC6).w

Obj_91_sub_3:
	move.w	$32(a0),d0
	bra.w	DisplaySprite
; ===========================================================================

Obj_91_sub_4:
	addq.b	#2,$24(a0)
	move.b	#0,$20(a0)
	move.w	#$80,$18(a0)
	subq.w	#1,($FFFFF712).w
	bsr.w	CollectRing

Obj_91_sub_6:
	lea	(Ani_obj25).l,a1
	bsr.w	AnimateSprite
	bra.w	DisplaySprite
; ===========================================================================

Obj_91_sub_8:
	bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj_91_Move:
	movea.w	$34(a0),a1
	move.w	#$30,d1
	move.w	8(a1),d0
	cmp.w	8(a0),d0
	bcc.s	loc2_1A954
	neg.w	d1
	tst.w	$10(a0)
	bmi.s	loc2_1A95E
	add.w	d1,d1
	add.w	d1,d1
	bra.s	loc2_1A95E
; ===========================================================================

loc2_1A954:
	tst.w	$10(a0)
	bpl.s	loc2_1A95E
	add.w	d1,d1
	add.w	d1,d1

loc2_1A95E:
	add.w	d1,$10(a0)
	move.w	#$30,d1
	move.w	$C(a1),d0
	cmp.w	$C(a0),d0
	bcc.s	loc2_1A97E
	neg.w	d1
	tst.w	$12(a0)
	bmi.s	loc2_1A988
	add.w	d1,d1
	add.w	d1,d1
	bra.s	loc2_1A988
; ===========================================================================

loc2_1A97E:
	tst.w	$12(a0)
	bpl.s	loc2_1A988
	add.w	d1,d1
	add.w	d1,d1

loc2_1A988:
	add.w	d1,$12(a0)
	jmp	(SpeedtoPos).l
; ===========================================================================
Ani_obj25:
	include "_anim\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25:
	include "_maps\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25RM:
	include "_maps\obj25rm.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - giant ring
; ---------------------------------------------------------------------------
Map_obj4B:
	include "_maps\obj4B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flash effect when you collect the giant ring
; ---------------------------------------------------------------------------
Map_obj7C:
	include "_maps\obj7C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 26 - monitors
; ---------------------------------------------------------------------------

Obj26:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj26_Index(pc,d0.w),d1
		jmp	Obj26_Index(pc,d1.w)
; ===========================================================================
Obj26_Index:	dc.w Obj26_Main-Obj26_Index
		dc.w Obj26_Solid-Obj26_Index
		dc.w Obj26_BreakOpen-Obj26_Index
		dc.w Obj26_Animate-Obj26_Index
		dc.w Obj26_Display-Obj26_Index
; ===========================================================================

Obj26_Main:				; XREF: Obj26_Index
		addq.b	#2,$24(a0)
		move.b	#$E,$16(a0)
		move.b	#$E,$17(a0)
		move.l	#Map_obj26,4(a0)
		move.w	#$680,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$F,$14(a0)
		move.w  $1E(a0),d0    ; get address in respawn table
    	movea.w d0,a2   ; load address into a2
    	bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
		btst	#0,(a2)	; has monitor been broken?
		beq.s	Obj26_NotBroken	; if not, branch
		move.b	#8,$24(a0)	; run "Obj26_Display" routine
		move.b	#$B,$1A(a0)	; use broken monitor frame
		rts	
; ===========================================================================

Obj26_NotBroken:			; XREF: Obj26_Main
		move.b	#$46,$20(a0)
		move.b	$28(a0),$1C(a0)

Obj26_Solid:				; XREF: Obj26_Index
		move.b	$25(a0),d0	; is monitor set to fall?
		beq.s	Obj26_Animate	; if not, branch
		subq.b	#2,d0
		bne.s	Obj26_Fall
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		bsr.w	ExitPlatform
		btst	#3,$22(a1)
		bne.w	loc_A1BC
		clr.b	$25(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A1BC:				; XREF: Obj26_Solid
		move.w	#$10,d3
		move.w	8(a0),d2
		bsr.w	MvSonicOnPtfm
		bra.w	Obj26_Animate
; ===========================================================================

Obj26_Fall:				; XREF: Obj26_Solid
		bclr	#1,$22(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	Obj26_Animate
		add.w	d1,$C(a0)
		clr.w	$12(a0)
		clr.b	$25(a0)
		bra.w	Obj26_Animate
; ===========================================================================

Obj26_Animate:				; XREF: Obj26_Index
		lea	(Ani_obj26).l,a1
		bsr.w	AnimateSprite

Obj26_Display:				; XREF: Obj26_Index
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj26_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj26_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj26_Done:
		rts	
; ===========================================================================

Obj26_BreakOpen:			; XREF: Obj26_Index
		addq.b	#2,$24(a0)
		move.b	#0,$20(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj26_Explode
		move.b	#$2E,0(a1)	; load monitor contents	object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$1C(a0),$1C(a1)

Obj26_Explode:
		bsr.w	SingleObjLoad
		bne.s	Obj26_SetBroken
		move.b	#$27,0(a1)	; load explosion object
		addq.b	#2,$24(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj26_SetBroken:
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		move.b	#9,$1C(a0)	; set monitor type to broken
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2E - contents of monitors
; ---------------------------------------------------------------------------

Obj2E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2E_Index(pc,d0.w),d1
		jsr	Obj2E_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj2E_Index:	dc.w Obj2E_Main-Obj2E_Index
		dc.w Obj2E_Move-Obj2E_Index
		dc.w Obj2E_Move2-Obj2E_Index
		dc.w Obj2E_Delete-Obj2E_Index
; ===========================================================================

Obj2E_Main:				; XREF: Obj2E_Index
		addq.b	#2,$24(a0)
		move.w	#$680,2(a0)
		move.b	#$4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		move.w	#-$300,$12(a0)
		moveq	#0,d0
		move.b	$1C(a0),d0
		addq.b	#2,d0
		move.b	d0,$1A(a0)
		move.l	#Map_obj2E,4(a0)

Obj2E_Move:				; XREF: Obj2E_Index
		tst.w	$12(a0)		; is object moving?
		bpl.w	Obj2E_Next; if not, branch
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; reduce object	speed
		rts	

Obj2E_Next:
		addq.b	#2,$24(a0)

Obj2E_Move2:
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		cmpi.w	#$10,d0
		bhi.s	Obj2E_Move3
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		cmpi.w	#$10,d0
		ble.w	Obj2E_ChkEggman

Obj2E_Move3:
		move.w	($FFFFB008).w,d1
		move.w	($FFFFB00C).w,d2
		sub.w	8(a0),d1
		sub.w	$C(a0),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		lsl.w	#4,d0
		lsl.w	#4,d1
		move.w	d0,$12(a0)
		move.w	d1,$10(a0)
		jsr	SpeedToPos

Obj2E_Done:
		rts	
; ===========================================================================

Obj2E_ChkEggman:			; XREF: Obj2E_Move
		addq.b	#2,$24(a0)
		move.b	$1C(a0),d0
		cmpi.b	#1,d0		; does monitor contain Eggman?
		bne.s	Obj2E_ChkSonic
		rts			; Eggman monitor does nothing
; ===========================================================================

Obj2E_ChkSonic:
		cmpi.b	#2,d0		; does monitor contain Sonic?
		bne.s	Obj2E_ChkShoes

ExtraLife:
		addq.b	#1,($FFFFFE12).w ; add 1 to the	number of lives	you have
		addq.b	#1,($FFFFFE1C).w ; add 1 to the	lives counter
		move.b	#$2A,d0
		jmp	(PlaySound).l	; play extra life music
; ===========================================================================

Obj2E_ChkShoes:
		cmpi.b	#3,d0		; does monitor contain speed shoes?
		bne.s	Obj2E_ChkShield
		move.b	#1,($FFFFFE2E).w ; speed up the	BG music
		move.w	#$4B0,($FFFFB034).w ; time limit for the power-up
		move.w	#$C00,($FFFFF760).w ; change Sonic"s top speed
		move.w	#$18,($FFFFF762).w
		move.w	#$80,($FFFFF764).w
		move.w	#8,d0
		jmp	(SetTempo).l	; Speed	up the music
; ===========================================================================

Obj2E_ChkShield:
		cmpi.b	#4,d0		; does monitor contain a shield?
		bne.s	Obj2E_ChkInvinc
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#5,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		move.w	#$41,d0
		jmp	(PlaySound).l	; play shield sound
; ===========================================================================

Obj2E_ChkInvinc:
		cmpi.b	#5,d0		; does monitor contain invincibility?
		bne.s	Obj2E_ChkRings
		bset	#1,($FFFFFE2C).w
		move.w  #$3B0,($FFFFB032).w	; Set Invisibility timer to 4B0
		move.b	#$4A,($FFFFB200).w ; load stars	object ($3801)
		move.b	#1,($FFFFB21C).w
		move.b	#$4A,($FFFFB240).w ; load stars	object ($3802)
		move.b	#2,($FFFFB25C).w
		move.b	#$4A,($FFFFB280).w ; load stars	object ($3803)
		move.b	#3,($FFFFB29C).w
		move.b	#$4A,($FFFFB2C0).w ; load stars	object ($3804)
		move.b	#4,($FFFFB2DC).w
		tst.b	($FFFFF7AA).w		; is boss mode on?
		bne.s   DontPlayMusic		; If so, don't play music
		cmpi.w  #$C,($FFFFFE14).w	; Check if Sonic has air left
		bls.s   DontPlayMusic		; If so, don't play music
		moveq  #$1B,d0			    ; Load Invincibility music
		jmp     (PlaySound).l        
DontPlayMusic:
		rts
; ===========================================================================

Obj2E_NoMusic:
		rts	
; ===========================================================================

Obj2E_ChkRings:
		cmpi.b	#6,d0		; does monitor contain 10 rings?
		bne.s	Obj2E_ChkS
		addi.w	#$A,($FFFFFE20).w ; add	10 rings to the	number of rings	you have
		ori.b	#1,($FFFFFE1D).w ; update the ring counter
		cmpi.w	#100,($FFFFFE20).w ; check if you have 100 rings
		bcs.s	Obj2E_RingSound
		bset	#1,($FFFFFE1B).w
		beq.w	ExtraLife
		cmpi.w	#200,($FFFFFE20).w ; check if you have 200 rings
		bcs.s	Obj2E_RingSound
		bset	#2,($FFFFFE1B).w
		beq.w	ExtraLife

Obj2E_RingSound:
		move.w	#$33,d0
		jmp	(PlaySound).l	; play ring sound
; ===========================================================================

Obj2E_ChkS:
		cmpi.b	#7,d0		; does monitor contain 'S'
        bne.s	Obj2E_ChkGoggles
		bset	#2,($FFFFFE2C).w
        move.b	#1,($FFFFFE2E).w ; speed up the	BG music
		move.w	#$4B0,($FFFFB034).w ; time limit for the power-up
		move.w	#$C00,($FFFFF760).w ; change Sonic's top speed
		move.w	#$4B0,($FFFFB034).w ; time limit for the power-up
		bset	#1,($FFFFFE2C).w ; make	Sonic invincible
		move.w	#$4B0,($FFFFB034).w ; time limit for the power-up 
		move.b	#$38,($FFFFB200).w ; load stars	object ($3801)
		move.b	#1,($FFFFB21C).w
		move.b	#$38,($FFFFB240).w ; load stars	object ($3802)
		move.b	#2,($FFFFB25C).w
		move.b	#$38,($FFFFB280).w ; load stars	object ($3803)
		move.b	#3,($FFFFB29C).w
		move.b	#$38,($FFFFB2C0).w ; load stars	object ($3804)
		move.b	#4,($FFFFB2DC).w
		addi.b 	#$32,($FFFFFE1D).w
		moveq	#$1B,d0
		jmp	(PlaySound).l	; play invincibility music 

Obj2E_ChkGoggles:	
		cmpi.b	#8,d0		; does monitor contain a shield?
		bne.w	Obj2E_ChkFlame
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#6,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		move.w	#$3F,d0
		jmp	(PlaySound).l	; play shield sound

Obj2E_ChkFlame:	
		cmpi.b	#$A,d0		; does monitor contain a flame shield?
		bne.w	Obj2E_ChkEnd
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#4,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		move.w	#$3E,d0
		jmp	(PlaySound).l	; play shield sound

Obj2E_ChkEnd:
		rts			; 'S' and goggles monitors do nothing
; ===========================================================================

Obj2E_Delete:				; XREF: Obj2E_Index
		bra.w	DeleteObject
; ---------------------------------------------------------------------------
; Subroutine to	make the sides of a monitor solid
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj26_SolidSides:			; XREF: loc_A1EC
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_A4E6
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_A4E6
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		add.w	d2,d3
		bmi.s	loc_A4E6
		add.w	d2,d2
		cmp.w	d2,d3
		bcc.s	loc_A4E6
		tst.b	($FFFFF7C8).w
		bmi.s	loc_A4E6
		cmpi.b	#6,($FFFFB024).w
		bcc.s	loc_A4E6
		tst.w	($FFFFFE08).w
		bne.s	loc_A4E6
		cmp.w	d0,d1
		bcc.s	loc_A4DC
		add.w	d1,d1
		sub.w	d1,d0

loc_A4DC:
		cmpi.w	#$10,d3
		bcs.s	loc_A4EA

loc_A4E2:
		moveq	#1,d1
		rts	
; ===========================================================================

loc_A4E6:
		moveq	#0,d1
		rts	
; ===========================================================================

loc_A4EA:
		moveq	#0,d1
		move.b	$14(a0),d1
		addq.w	#4,d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	8(a1),d1
		sub.w	8(a0),d1
		bmi.s	loc_A4E2
		cmp.w	d2,d1
		bcc.s	loc_A4E2
		moveq	#-1,d1
		rts	
; End of function Obj26_SolidSides

; ===========================================================================
Ani_obj26:
	include "_anim\obj26.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitors
; ---------------------------------------------------------------------------
Map_obj26:
	include "_maps\obj26.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitor contents
; ---------------------------------------------------------------------------
Map_obj2E:
	include "_maps\obj2E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0E - Sonic on the title screen
; ---------------------------------------------------------------------------

Obj0E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0E_Index(pc,d0.w),d1
		jmp	Obj0E_Index(pc,d1.w)
; ===========================================================================
Obj0E_Index:	dc.w Obj0E_Main-Obj0E_Index
		dc.w Obj0E_Move-Obj0E_Index
		dc.w Obj0E_Display-Obj0E_Index
; ===========================================================================

Obj0E_Main:				; XREF: Obj0E_Index
		addq.b	#2,$24(a0)
		move.w	#$E6,8(a0)
		move.w	#8,$A(a0)
		move.l	#Map_obj0E,4(a0)
		move.w	#$8300,2(a0)
		move.w	#$80,$18(a0)
		move.w	#$380,$12(a0)
		lea	(Obj0E_Positions).l,a2
		move.w	#3,d1
		move.b	#0,d2
		movea.l	a0,a1
		bra.s	Obj0E_MakeItem

Obj0E_Loop:
		jsr	SingleObjLoad
		bne.s	loc2_150FE
		move.b	#$E,0(a1)
		move.b	#2,$24(a1)
		move.w	(a2)+,8(a1)
		move.w	(a2)+,$A(a1)
		move.w	#$80,$18(a1)
		move.w	#$380,$12(a1)
		addq.b	#1,d2
		move.b	d2,$1A(a1)

Obj0E_MakeItem:				; XREF: Obj66_Main
		move.l	#Map_obj0E,4(a1)
		move.w	#$8300,2(a1)

loc2_150FE:
		dbf	d1,Obj0E_Loop			; XREF: Obj0E_Index

loc2_15100:
		bra.w	DisplaySprite

Obj0E_Positions:	dc.w $176,	8
		dc.w $D2,	$38
		dc.w $152,	$38
; ===========================================================================

Obj0E_Move:				; XREF: Obj0E_Index
		subq.w	#8,$12(a0)
		move.w	$12(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		add.l	d0,$A(a0)	; add to y-axis	position
		tst.w	$12(a0)
		bne.s	Obj0E_Display
		addq.b	#2,$24(a0)

Obj0E_Display:
		bra.w	DisplaySprite
; ===========================================================================

; ===========================================================================
; ----------------------------------------------------------------------------
; Sprite
;
; Unknown
; ----------------------------------------------------------------------------

Obj0F:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_13612(pc,d0.w),d1
		jsr	off_13612(pc,d1.w)
		bra.w	DisplaySprite
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_13612:	dc.w loc_13616-off_13612; 0 ; DATA XREF: ROM:00013612o
					; ROM:00013614o
		dc.w Obj0F_MoveIn-off_13612; 1
		dc.w loc_13644-off_13612; 1
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_13616:				; DATA XREF: ROM:00013612o
		addq.b	#2,$24(a0)
		move.w	#$128,8(a0)
		move.w	#$17C,$A(a0)
		move.l	#Map_Obj0F,4(a0)
		move.w	#$E680,2(a0)
		move.w	#$400,$12(a0)
		andi.b	#1,($FFFFF62B).w
		move.b	($FFFFF62B).w,$1A(a0)

Obj0F_MoveIn:
		tst.w		$12(a0)
		beq.s		Obj0F_WaitStart
		subi.w		#$20,$12(a0)
		move.w	$12(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		sub.l	d0,$A(a0)	; add to y-axis	position
		rts

Obj0F_WaitStart:
		addq.b		#2,$24(a0)
		move.b		#$40,$23(a0)

loc_13644:				; DATA XREF: ROM:00013612o
		moveq	#0,d2
		move.b	($FFFFF62B).w,d2
		move.b	($FFFFF605).w,d0
		btst	#0,d0
		beq.s	loc_13660
		subq.b	#1,d2
		bcc.s	loc_13660
		move.b	#2,d2

loc_13660:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#1,d0
		beq.s	loc_13671
		addq.b	#1,d2
		cmpi.b	#3,d2
		bcs.s	loc_13671
		moveq	#0,d2

loc_13671:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,$1A(a0)
		move.b	d2,($FFFFF62B).w
		andi.b	#3,d0
		beq.s	locret_13684
		moveq	#$5B,d0
		jmp	(PlaySound_Special).l

loc_36776:				; CODE XREF: h+2088Ap h+208CAp ...
		move.w	($FFFFF736).w,d0
		add.w	d0,8(a0)
		move.w	($FFFFF738).w,d0
		add.w	d0,$C(a0)

locret_13684:				; CODE XREF: ROM:0001367Cj
		rts	

; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj0F:
	include "_maps\obj0F.asm"

; ---------------------------------------------------------------------------
; Object 8F - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------

Obj8F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8F_Index(pc,d0.w),d1
		jsr	Obj8F_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj8F_Index:	dc.w Obj8F_Main-Obj8F_Index
		dc.w Obj8F_PrsStart-Obj8F_Index
		dc.w locret_A6F8-Obj8F_Index
		dc.w Obj8F_Delete-Obj8F_Index
; ===========================================================================

Obj8F_Main:				; XREF: Obj8F_Index
		addq.b	#2,$24(a0)
		move.w	#$D8,8(a0)
		move.w	#$130,$A(a0)
		move.l	#Map_Obj8F,4(a0)
		move.w	#$8200,2(a0)
		tst.b	$1A(a0)	; is object "PRESS START"?
		beq.s	Obj8F_PrsStart	; if yes, branch
		addq.b	#2,$24(a0)
	;	cmpi.b	#3,$1A(a0)	; is the object	"TM"?
	;	bne.s	locret_A6F8	; if not, branch
		move.w	#$8510,2(a0)	; "TM" specific	code
		move.w	#$1AC,8(a0)
		move.w	#$AC,$A(a0)

locret_A6F8:				; XREF: Obj8F_Index
		rts	
; ===========================================================================

Obj8F_PrsStart:				; XREF: Obj8F_Index
		andi.b	#$80,($FFFFF605).w ; check if Start is pressed
		bne.w	Obj8F_PrsStart2	; if not, branch

Obj8F_Display:
		lea	(Ani_Obj8F).l,a1
		bra.w	AnimateSprite
; ===========================================================================
Obj8F_PrsStart2:
		addq.b	#4,$24(a0)

Obj8F_Delete:				; XREF: Obj8F_Index
		tst.b	$1A(a0)
		bne.s	Obj8F_Display
		jsr	DeleteObject	; clear object RAM to make room for the "Press Start Button" object
		move.b	#$F,($FFFFB080).w
		rts

Ani_Obj8F:
	include "_anim\obj8F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj8F:
	include "_maps\obj8F.asm"

; ---------------------------------------------------------------------------
; Subroutine to	animate	a sprite using an animation script
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AnimateSprite:
		moveq	#0,d0
		move.b	$1C(a0),d0	; move animation number	to d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	Anim_Run	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

Anim_Run:
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Anim_Wait	; if time remains, branch
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),$23(a0)	; load frame duration
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FA,d0					; MJ: is it a flag from FA to FF?
		bhs	Anim_End_FF				; MJ: if so, branch to flag routines
 
Anim_Next:
		move.b	d0,d1
		andi.b	#$1F,d0
		move.b	d0,$1A(a0)	; load sprite number
		move.b	$22(a0),d0
		rol.b	#3,d1
		eor.b	d0,d1
		andi.b	#3,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		addq.b	#1,$1B(a0)	; next frame number

Anim_Wait:
		rts	
; ===========================================================================

Anim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	Anim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	Anim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	Anim_End_FC	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

Anim_End_FC:
		addq.b	#1,d0		; is the end flag = $FC	?
		bne.s	Anim_End_FB	; if not, branch
		addq.b	#2,$24(a0)	; jump to next routine

Anim_End_FB:
		addq.b	#1,d0		; is the end flag = $FB	?
		bne.s	Anim_End_FA	; if not, branch
		move.b	#0,$1B(a0)	; reset	animation
		clr.b	$25(a0)		; reset	2nd routine counter

Anim_End_FA:
		addq.b	#1,d0		; is the end flag = $FA	?
		bne.s	Anim_End	; if not, branch
		addq.b	#2,$25(a0)	; jump to next routine

Anim_End:
		rts	
; End of function AnimateSprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic on the title screen
; ---------------------------------------------------------------------------
Map_obj0E:
	include "_maps\obj0E.asm"

Ani_obj0E:
	include "_anim\obj0E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2B - Chopper enemy (WOZ)
; ---------------------------------------------------------------------------

Obj2B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2B_Index(pc,d0.w),d1
		jsr	Obj2B_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj2B_Index:	dc.w Obj2B_Main-Obj2B_Index	
		dc.w Obj2B_ChgSpeed-Obj2B_Index
; ===========================================================================

Obj2B_Main:				; XREF: Obj2B_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj2B,4(a0)
		move.w	#$23B4,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#9,$20(a0)
		move.b	#$10,$14(a0)
		move.w	#-$700,$12(a0)	; set vertical speed
		move.w	$C(a0),$30(a0)

Obj2B_ChgSpeed:				; XREF: Obj2B_Index
		lea	(Ani_obj2B).l,a1
		bsr.w	AnimateSprite
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; reduce speed
		move.w	$30(a0),d0
		cmp.w	$C(a0),d0
		bcc.s	Obj2B_ChgAni
		move.w	d0,$C(a0)
		move.w	#-$700,$12(a0)	; set vertical speed

Obj2B_ChgAni:
		move.b	#1,$1C(a0)	; use fast animation
		subi.w	#$C0,d0
		cmp.w	$C(a0),d0
		bcc.s	locret_ABB6
		move.b	#0,$1C(a0)	; use slow animation
		tst.w	$12(a0)		; is Chopper at	its highest point?
		bmi.s	locret_ABB6	; if not, branch
		move.b	#2,$1C(a0)	; use stationary animation

locret_ABB6:
		rts	
; ===========================================================================
Ani_obj2B:
	include "_anim\obj2B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Chopper enemy (WOZ)
; ---------------------------------------------------------------------------
Map_obj2B:
	include "_maps\obj2B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2C - Jaws enemy (TJZ)
; ---------------------------------------------------------------------------

Obj2C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2C_Index(pc,d0.w),d1
		jmp	Obj2C_Index(pc,d1.w)
; ===========================================================================
Obj2C_Index:	dc.w Obj2C_Main-Obj2C_Index
		dc.w Obj2C_Turn-Obj2C_Index
; ===========================================================================

Obj2C_Main:				; XREF: Obj2C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj2C,4(a0)
		move.w	#$2486,2(a0)
		ori.b	#4,1(a0)
		move.b	#$A,$20(a0)
		move.w	#$200,$18(a0)
		move.b	#$10,$14(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; load object subtype number
		lsl.w	#6,d0		; multiply d0 by 64
		subq.w	#1,d0
		move.w	d0,$30(a0)	; set turn delay time
		move.w	d0,$32(a0)
		move.w	#-$40,$10(a0)	; move Jaws to the left
		btst	#0,$22(a0)	; is Jaws facing left?
		beq.s	Obj2C_Turn	; if yes, branch
		neg.w	$10(a0)		; move Jaws to the right

Obj2C_Turn:				; XREF: Obj2C_Index
		subq.w	#1,$30(a0)	; subtract 1 from turn delay time
		bpl.s	Obj2C_Animate	; if time remains, branch
		move.w	$32(a0),$30(a0)	; reset	turn delay time
		neg.w	$10(a0)		; change speed direction
		bchg	#0,$22(a0)	; change Jaws facing direction
		move.b	#1,$1D(a0)	; reset	animation

Obj2C_Animate:
		lea	(Ani_obj2C).l,a1
		bsr.w	AnimateSprite
		bsr.w	SpeedToPos
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj2C:
	include "_anim\obj2C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Jaws enemy (TJZ)
; ---------------------------------------------------------------------------
Map_obj2C:
	include "_maps\obj2C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2D - Burrobot enemy (TJZ)
; ---------------------------------------------------------------------------

Obj2D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2D_Index(pc,d0.w),d1
		jmp	Obj2D_Index(pc,d1.w)
; ===========================================================================
Obj2D_Index:	dc.w Obj2D_Main-Obj2D_Index
		dc.w Obj2D_Action-Obj2D_Index
; ===========================================================================

Obj2D_Main:				; XREF: Obj2D_Index
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj2D,4(a0)
		move.w	#$51C,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#5,$20(a0)
		move.b	#$C,$14(a0)
		addq.b	#6,$25(a0)	; run "Obj2D_ChkSonic" routine
		move.b	#2,$1C(a0)

Obj2D_Action:				; XREF: Obj2D_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj2D_Index2(pc,d0.w),d1
		jsr	Obj2D_Index2(pc,d1.w)
		lea	(Ani_obj2D).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj2D_Index2:	dc.w Obj2D_ChgDir-Obj2D_Index2
		dc.w Obj2D_Move-Obj2D_Index2
		dc.w Obj2D_Jump-Obj2D_Index2
		dc.w Obj2D_ChkSonic-Obj2D_Index2
; ===========================================================================

Obj2D_ChgDir:				; XREF: Obj2D_Index2
		subq.w	#1,$30(a0)
		bpl.s	locret_AD42
		addq.b	#2,$25(a0)
		move.w	#$FF,$30(a0)
		move.w	#$80,$10(a0)
		move.b	#1,$1C(a0)
		bchg	#0,$22(a0)	; change direction the Burrobot	is facing
		beq.s	locret_AD42
		neg.w	$10(a0)		; change direction the Burrobot	is moving

locret_AD42:
		rts	
; ===========================================================================

Obj2D_Move:				; XREF: Obj2D_Index2
		subq.w	#1,$30(a0)
		bmi.s	loc_AD84
		bsr.w	SpeedToPos
		bchg	#0,$32(a0)
		bne.s	loc_AD78
		move.w	8(a0),d3
		addi.w	#$C,d3
		btst	#0,$22(a0)
		bne.s	loc_AD6A
		subi.w	#$18,d3

loc_AD6A:
		jsr	ObjHitFloor2
		cmpi.w	#$C,d1
		bge.s	loc_AD84
		rts	
; ===========================================================================

loc_AD78:				; XREF: Obj2D_Move
		jsr	ObjHitFloor
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_AD84:				; XREF: Obj2D_Move
		btst	#2,($FFFFFE0F).w
		beq.s	loc_ADA4
		subq.b	#2,$25(a0)
		move.w	#$3B,$30(a0)
		move.w	#0,$10(a0)
		move.b	#0,$1C(a0)
		rts	
; ===========================================================================

loc_ADA4:
		addq.b	#2,$25(a0)
		move.w	#-$400,$12(a0)
		move.b	#2,$1C(a0)
		rts	
; ===========================================================================

Obj2D_Jump:				; XREF: Obj2D_Index2
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		bmi.s	locret_ADF0
		move.b	#3,$1C(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_ADF0
		add.w	d1,$C(a0)
		move.w	#0,$12(a0)
		move.b	#1,$1C(a0)
		move.w	#$FF,$30(a0)
		subq.b	#2,$25(a0)
		bsr.w	Obj2D_ChkSonic2

locret_ADF0:
		rts	
; ===========================================================================

Obj2D_ChkSonic:				; XREF: Obj2D_Index2
		move.w	#$60,d2
		bsr.w	Obj2D_ChkSonic2
		bcc.s	locret_AE20
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		bcc.s	locret_AE20
		cmpi.w	#-$80,d0
		bcs.s	locret_AE20
		tst.w	($FFFFFE08).w
		bne.s	locret_AE20
		subq.b	#2,$25(a0)
		move.w	d1,$10(a0)
		move.w	#-$400,$12(a0)

locret_AE20:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2D_ChkSonic2:			; XREF: Obj2D_ChkSonic
		move.w	#$80,d1
		bset	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_AE40
		neg.w	d0
		neg.w	d1
		bclr	#0,$22(a0)

loc_AE40:
		cmp.w	d2,d0
		rts	
; End of function Obj2D_ChkSonic2

; ===========================================================================
Ani_obj2D:
	include "_anim\obj2D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Burrobot enemy (TJZ)
; ---------------------------------------------------------------------------
Map_obj2D:
	include "_maps\obj2D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2F - large moving platforms (DDZ)
; ---------------------------------------------------------------------------

Obj2F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2F_Index(pc,d0.w),d1
		jmp	Obj2F_Index(pc,d1.w)
; ===========================================================================
Obj2F_Index:	dc.w Obj2F_Main-Obj2F_Index
		dc.w Obj2F_Action-Obj2F_Index

Obj2F_Data:	dc.w Obj2F_Data1-Obj2F_Data 	; collision angle data
		dc.b 0,	$40			; frame	number,	platform width
		dc.w Obj2F_Data3-Obj2F_Data
		dc.b 1,	$40
		dc.w Obj2F_Data2-Obj2F_Data
		dc.b 2,	$20
; ===========================================================================

Obj2F_Main:				; XREF: Obj2F_Index
		addq.b	#2,$24(a0)
		cmpi.b	#4,($FFFFFE10).w
		bne.s	Obj2F_DDZ
		move.l	#Map_obj2FCCZ,4(a0)
		bra.s	Obj2F_MainCont

Obj2F_DDZ:
		move.l	#Map_obj2F,4(a0)

Obj2F_MainCont:
		move.w	#$C000,2(a0)
		move.b	#4,1(a0)
		move.w	#$280,$18(a0)
		move.w	$C(a0),$2C(a0)
		move.w	8(a0),$2A(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj2F_Data(pc,d0.w),a1
		move.w	(a1)+,d0
		lea	Obj2F_Data(pc,d0.w),a2
		move.l	a2,$30(a0)
		move.b	(a1)+,$1A(a0)
		move.b	(a1),$14(a0)
		andi.b	#$F,$28(a0)
		move.b	#$40,$16(a0)
		bset	#4,1(a0)

Obj2F_Action:				; XREF: Obj2F_Index
		bsr.w	Obj2F_Types
		tst.b	$25(a0)
		beq.s	Obj2F_Solid
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		bsr.w	ExitPlatform
		btst	#3,$22(a1)
		bne.w	Obj2F_Slope
		clr.b	$25(a0)
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Slope:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		movea.l	$30(a0),a2
		move.w	8(a0),d2
		bsr.w	SlopeObject2
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Solid:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$20,d2
		cmpi.b	#2,$1A(a0)
		bne.s	loc_AF8E
		move.w	#$30,d2

loc_AF8E:
		movea.l	$30(a0),a2
		bsr.w	SolidObject2F

Obj2F_Display:				; XREF: Obj2F_Action
		bsr.w	DisplaySprite
		bra.w	Obj2F_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2F_Types:				; XREF: Obj2F_Action
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj2F_TypeIndex(pc,d0.w),d1
		jmp	Obj2F_TypeIndex(pc,d1.w)
; End of function Obj2F_Types

; ===========================================================================
Obj2F_TypeIndex:dc.w Obj2F_Type00-Obj2F_TypeIndex
		dc.w Obj2F_Type01-Obj2F_TypeIndex
		dc.w Obj2F_Type02-Obj2F_TypeIndex
		dc.w Obj2F_Type03-Obj2F_TypeIndex
		dc.w Obj2F_Type04-Obj2F_TypeIndex
		dc.w Obj2F_Type05-Obj2F_TypeIndex
; ===========================================================================

Obj2F_Type00:				; XREF: Obj2F_TypeIndex
		rts			; type 00 platform doesn't move
; ===========================================================================

Obj2F_Type01:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE60).w,d0
		move.w	#$20,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type02:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE64).w,d0
		move.w	#$30,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type03:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE68).w,d0
		move.w	#$40,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type04:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1

Obj2F_Move:
		btst	#3,$28(a0)
		beq.s	loc_AFF2
		neg.w	d0
		add.w	d1,d0

loc_AFF2:
		move.w	$2C(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; update position on y-axis
		rts	
; ===========================================================================

Obj2F_Type05:				; XREF: Obj2F_TypeIndex
		move.b	$34(a0),d0
		tst.b	$25(a0)
		bne.s	loc_B010
		subq.b	#2,d0
		bcc.s	loc_B01C
		moveq	#0,d0
		bra.s	loc_B01C
; ===========================================================================

loc_B010:
		addq.b	#4,d0
		cmpi.b	#$40,d0
		bcs.s	loc_B01C
		move.b	#$40,d0

loc_B01C:
		move.b	d0,$34(a0)
		jsr	(CalcSine).l
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	$2C(a0),d0
		move.w	d0,$C(a0)
		cmpi.b	#$20,$34(a0)
		bne.s	loc_B07A
		tst.b	$35(a0)
		bne.s	loc_B07A
		move.b	#1,$35(a0)
		bsr.w	SingleObjLoad2
		bne.s	loc_B07A
		move.b	#$35,0(a1)	; load sitting flame object
		move.w	8(a0),8(a1)
		move.w	$2C(a0),$2C(a1)
		addq.w	#8,$2C(a1)
		subq.w	#3,$2C(a1)
		subi.w	#$40,8(a1)
		move.l	$30(a0),$30(a1)
		move.l	a0,$38(a1)
		movea.l	a0,a2
		bsr.s	sub_B09C

loc_B07A:
		moveq	#0,d2
		lea	$36(a0),a2
		move.b	(a2)+,d2
		subq.b	#1,d2
		bcs.s	locret_B09A

loc_B086:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		move.w	d1,$3C(a1)
		dbf	d2,loc_B086

locret_B09A:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_B09C:
		lea	$36(a2),a2
		moveq	#0,d0
		move.b	(a2),d0
		addq.b	#1,(a2)
		lea	1(a2,d0.w),a2
		move.w	a1,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,(a2)
		rts	
; End of function sub_B09C

; ===========================================================================

Obj2F_ChkDel:				; XREF: Obj2F_Display
		tst.b	$35(a0)
		beq.s	loc_B0C6
		tst.b	1(a0)
		bpl.s	Obj2F_DelFlames

loc_B0C6:
		move.w	$2A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj2F_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj2F_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj2F_Done:
		rts	
; ===========================================================================

Obj2F_DelFlames:			; XREF: Obj2F_ChkDel
		moveq	#0,d2

loc_B0E8:
		lea	$36(a0),a2
		move.b	(a2),d2
		clr.b	(a2)+
		subq.b	#1,d2
		bcs.s	locret_B116

loc_B0F4:
		moveq	#0,d0
		move.b	(a2),d0
		clr.b	(a2)+
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,loc_B0F4
		move.b	#0,$35(a0)
		move.b	#0,$34(a0)

locret_B116:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for large moving platforms (DDZ)
; ---------------------------------------------------------------------------
Obj2F_Data1:	incbin	misc\DDZ_pfm1.bin
		even
Obj2F_Data2:	incbin	misc\DDZ_pfm2.bin
		even
Obj2F_Data3:	incbin	misc\DDZ_pfm3.bin
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 35 - fireball that sits on the	floor (DDZ)
; (appears when	you walk on sinking platforms)
; ---------------------------------------------------------------------------

Obj35:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj35_Index(pc,d0.w),d1
		jmp	Obj35_Index(pc,d1.w)
; ===========================================================================
Obj35_Index:	dc.w Obj35_Main-Obj35_Index
		dc.w loc_B238-Obj35_Index
		dc.w Obj35_Move-Obj35_Index
; ===========================================================================

Obj35_Main:				; XREF: Obj35_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj14,4(a0)
		move.w	#$37C,2(a0)
		move.w	8(a0),$2A(a0)
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#8,$14(a0)
		move.w	#$D5,d0
		jsr	(PlaySound_Special).l ;	play flame sound
		tst.b	$28(a0)
		beq.s	loc_B238
		addq.b	#2,$24(a0)
		bra.w	Obj35_Move
; ===========================================================================

loc_B238:				; XREF: Obj35_Index
		movea.l	$30(a0),a1
		move.w	8(a0),d1
		sub.w	$2A(a0),d1
		addi.w	#$C,d1
		move.w	d1,d0
		lsr.w	#1,d0
		move.b	(a1,d0.w),d0
		neg.w	d0
		add.w	$2C(a0),d0
		move.w	d0,d2
		add.w	$3C(a0),d0
		move.w	d0,$C(a0)
		cmpi.w	#$84,d1
		bcc.s	loc_B2B0
		addi.l	#$10000,8(a0)
		cmpi.w	#$80,d1
		bcc.s	loc_B2B0
		move.l	8(a0),d0
		addi.l	#$80000,d0
		andi.l	#$FFFFF,d0
		bne.s	loc_B2B0
		bsr.w	SingleObjLoad2
		bne.s	loc_B2B0
		move.b	#$35,0(a1)
		move.w	8(a0),8(a1)
		move.w	d2,$2C(a1)
		move.w	$3C(a0),$3C(a1)
		move.b	#1,$28(a1)
		movea.l	$38(a0),a2
		bsr.w	sub_B09C

loc_B2B0:
		bra.s	Obj35_Animate
; ===========================================================================

Obj35_Move:				; XREF: Obj35_Index
		move.w	$2C(a0),d0
		add.w	$3C(a0),d0
		move.w	d0,$C(a0)
		move.b	#$8B,$20(a0)
		bset	#4,$2B(a0)

Obj35_Animate:				; XREF: loc_B238
		lea	(Ani_obj35).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj35:
	include "_anim\obj35.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - large moving platforms (DDZ)
; ---------------------------------------------------------------------------
Map_obj2F:
	include "_maps\obj2F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - large moving platforms (CCZ)
; ---------------------------------------------------------------------------
Map_obj2FCCZ:
	include "_maps\obj2FCCZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava balls (DDZ, KVZ)
; ---------------------------------------------------------------------------
Map_obj14:
	include "_maps\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 30 - large green glassy blocks	(DDZ)
; ---------------------------------------------------------------------------

Obj30:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj30_Index(pc,d0.w),d1
		jsr	Obj30_Index(pc,d1.w)
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj30_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj30_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj30_Delete

Obj30_Done:
		bra.w	DisplaySprite
; ===========================================================================

Obj30_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj30_Index:	dc.w Obj30_Main-Obj30_Index
		dc.w Obj30_Block012-Obj30_Index
		dc.w Obj30_Reflect012-Obj30_Index
		dc.w Obj30_Block34-Obj30_Index
		dc.w Obj30_Reflect34-Obj30_Index

Obj30_Vars1:	dc.b 2,	0, 0	; routine num, y-axis dist from	origin,	frame num
		dc.b 4,	0, 1
Obj30_Vars2:	dc.b 6,	0, 2
		dc.b 8,	0, 1
; ===========================================================================

Obj30_Main:				; XREF: Obj30_Index
		lea	(Obj30_Vars1).l,a2
		moveq	#1,d1
		move.b	#$48,$16(a0)
		cmpi.b	#3,$28(a0)	; is object type 0/1/2 ?
		bcs.s	loc_B40C	; if yes, branch
		lea	(Obj30_Vars2).l,a2
		moveq	#1,d1
		move.b	#$38,$16(a0)

loc_B40C:
		movea.l	a0,a1
		bra.s	Obj30_Load	; load main object
; ===========================================================================

Obj30_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_B480

Obj30_Load:				; XREF: Obj30_Main
		move.b	(a2)+,$24(a1)
		move.b	#$30,0(a1)
		move.w	8(a0),8(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	$C(a0),d0
		move.w	d0,$C(a1)
		tst.b 	($FFFFFE10).w
		beq.s 	Obj30_WOZ
		move.l	#Map_obj30,4(a1)
		move.w	#$C38E,2(a1)
		bra.s 	Obj30_Cont

Obj30_WOZ:
		move.l	#Map_obj30WOZ,4(a1)

Obj30_Cont:
		move.b	#4,1(a1)
		move.w	$C(a1),$30(a1)
		move.b	$28(a0),$28(a1)
		move.b	#$20,$14(a1)
		move.w	#$200,$18(a1)
		move.b	(a2)+,$1A(a1)
		move.l	a0,$3C(a1)
		dbf	d1,Obj30_Loop	; repeat once to load "reflection object"

		move.b	#$10,$14(a1)
		move.w	#$180,$18(a1)
		addq.b	#8,$28(a1)
		andi.b	#$F,$28(a1)

loc_B480:
		move.w	#$90,$32(a0)
		bset	#4,1(a0)

Obj30_Block012:				; XREF: Obj30_Index
		bsr.w	Obj30_Types
		move.w	#$2B,d1
		move.w	#$48,d2
		move.w	#$49,d3
		move.w	8(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect012:			; XREF: Obj30_Index
		movea.l	$3C(a0),a1
		move.w	$32(a1),$32(a0)
		bra.w	Obj30_Types
; ===========================================================================

Obj30_Block34:				; XREF: Obj30_Index
		bsr.w	Obj30_Types
		move.w	#$2B,d1
		move.w	#$38,d2
		move.w	#$39,d3
		move.w	8(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect34:			; XREF: Obj30_Index
		movea.l	$3C(a0),a1
		move.w	$32(a1),$32(a0)
		move.w	$C(a1),$30(a0)
		bra.w	*+4

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj30_Types:				; XREF: Obj30_Block012; et al
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj30_TypeIndex(pc,d0.w),d1
		jmp	Obj30_TypeIndex(pc,d1.w)
; End of function Obj30_Types

; ===========================================================================
Obj30_TypeIndex:dc.w Obj30_Type00-Obj30_TypeIndex
		dc.w Obj30_Type01-Obj30_TypeIndex
		dc.w Obj30_Type02-Obj30_TypeIndex
		dc.w Obj30_Type03-Obj30_TypeIndex
		dc.w Obj30_Type04-Obj30_TypeIndex
; ===========================================================================

Obj30_Type00:				; XREF: Obj30_TypeIndex
		rts	
; ===========================================================================

Obj30_Type01:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		bra.s	loc_B514
; ===========================================================================

Obj30_Type02:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		neg.w	d0
		add.w	d1,d0

loc_B514:				; XREF: Obj30_Type01
		btst	#3,$28(a0)
		beq.s	loc_B526
		neg.w	d0
		add.w	d1,d0
		lsr.b	#1,d0
		addi.w	#$20,d0

loc_B526:
		bra.w	loc_B5EE
; ===========================================================================

Obj30_Type03:				; XREF: Obj30_TypeIndex
		btst	#3,$28(a0)
		beq.s	loc_B53E
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.w	loc_B5EE
; ===========================================================================

loc_B53E:
		btst	#3,$22(a0)
		bne.s	loc_B54E
		bclr	#0,$34(a0)
		bra.s	loc_B582
; ===========================================================================

loc_B54E:
		tst.b	$34(a0)
		bne.s	loc_B582
		move.b	#1,$34(a0)
		bset	#0,$35(a0)
		beq.s	loc_B582
		bset	#7,$34(a0)
		move.w	#$10,$36(a0)
		move.b	#$A,$38(a0)
		cmpi.w	#$40,$32(a0)
		bne.s	loc_B582
		move.w	#$40,$36(a0)

loc_B582:
		tst.b	$34(a0)
		bpl.s	loc_B5AA
		tst.b	$38(a0)
		beq.s	loc_B594
		subq.b	#1,$38(a0)
		bne.s	loc_B5AA

loc_B594:
		tst.w	$32(a0)
		beq.s	loc_B5A4
		subq.w	#1,$32(a0)
		subq.w	#1,$36(a0)
		bne.s	loc_B5AA

loc_B5A4:
		bclr	#7,$34(a0)

loc_B5AA:
		move.w	$32(a0),d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_Type04:				; XREF: Obj30_TypeIndex
		btst	#3,$28(a0)
		beq.s	Obj30_ChkSwitch
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_ChkSwitch:			; XREF: Obj30_Type04
		tst.b	$34(a0)
		bne.s	loc_B5E0
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$28(a0),d0	; load object type number
		lsr.w	#4,d0		; read only the	first nybble
		tst.b	(a2,d0.w)	; has switch number d0 been pressed?
		beq.s	loc_B5EA	; if not, branch
		move.b	#1,$34(a0)

loc_B5E0:
		tst.w	$32(a0)
		beq.s	loc_B5EA
		subq.w	#2,$32(a0)

loc_B5EA:
		move.w	$32(a0),d0

loc_B5EE:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - large green	glassy blocks (DDZ)
; ---------------------------------------------------------------------------
Map_obj30:
	include "_maps\obj30.asm"

Map_obj30WOZ:
	include "_maps\obj30WOZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 31 - stomping metal blocks on chains (DDZ)
; ---------------------------------------------------------------------------

Obj31:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj31_Index(pc,d0.w),d1
		jmp	Obj31_Index(pc,d1.w)
; ===========================================================================
Obj31_Index:	dc.w Obj31_Main-Obj31_Index
		dc.w loc_B798-Obj31_Index
		dc.w loc_B7FE-Obj31_Index
		dc.w Obj31_Display2-Obj31_Index
		dc.w loc_B7E2-Obj31_Index

Obj31_SwchNums:	dc.b 0,	0		; switch number, obj number
		dc.b 1,	0

Obj31_Var:	dc.b 2,	0, 0		; XREF: ROM:0000B6E0o
		dc.b 4,	$1C, 1		; routine number, y-position, frame number
		dc.b 8,	$CC, 3
		dc.b 6,	$F0, 2

word_B6A4:	dc.w $7000, $A000
		dc.w $5000, $7800
		dc.w $3800, $5800
		dc.w $B800
; ===========================================================================

Obj31_Main:				; XREF: Obj31_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		bpl.s	loc_B6CE
		andi.w	#$7F,d0
		add.w	d0,d0
		lea	Obj31_SwchNums(pc,d0.w),a2
		move.b	(a2)+,$3A(a0)
		move.b	(a2)+,d0
		move.b	d0,$28(a0)

loc_B6CE:
		andi.b	#$F,d0
		add.w	d0,d0
		move.w	word_B6A4(pc,d0.w),d2
		tst.w	d0
		bne.s	loc_B6E0
		move.w	d2,$32(a0)

loc_B6E0:
		lea	(Obj31_Var).l,a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj31_MakeStomper
; ===========================================================================

Obj31_Loop:
		bsr.w	SingleObjLoad2
		bne.w	Obj31_SetSize

Obj31_MakeStomper:			; XREF: Obj31_Main
		move.b	(a2)+,$24(a1)
		move.b	#$31,0(a1)
		move.w	8(a0),8(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	$C(a0),d0
		move.w	d0,$C(a1)
		move.l	#Map_obj31,4(a1)
		move.w	#$2386,2(a1)
		move.b	#4,1(a1)
		move.w	$C(a1),$30(a1)
		move.b	$28(a0),$28(a1)
		move.b	#$10,$14(a1)
		move.w	d2,$34(a1)
		move.w	#$200,$18(a1)
		move.b	(a2)+,$1A(a1)
		cmpi.b	#1,$1A(a1)
		bne.s	loc_B76A
		subq.w	#1,d1
		move.b	$28(a0),d0
		andi.w	#$F0,d0
		cmpi.w	#$20,d0
		beq.s	Obj31_MakeStomper
		move.b	#$38,$14(a1)
		move.b	#$90,$20(a1)
		addq.w	#1,d1

loc_B76A:
		move.l	a0,$3C(a1)
		dbf	d1,Obj31_Loop

		move.w	#$180,$18(a1)

Obj31_SetSize:
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.b	#$E,d0
		lea	Obj31_Var2(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2)+,$1A(a0)
		bra.s	loc_B798
; ===========================================================================
Obj31_Var2:	dc.b $38, 0		; width, frame number
		dc.b $30, 9
		dc.b $10, $A
; ===========================================================================

loc_B798:				; XREF: Obj31_Index
		bsr.w	Obj31_Types
		move.w	$C(a0),($FFFFF7A4).w
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$C,d2
		move.w	#$D,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
	;	btst	#3,$22(a0)
	;	beq.s	Obj31_Display
	;	cmpi.b	#$10,$32(a0)
	;	bcc.s	Obj31_Display
	;	movea.l	a0,a2
	;	lea	($FFFFB000).w,a0
	;	jsr	KillSonic
	;	movea.l	a2,a0

Obj31_Display:
		bsr.w	DisplaySprite
		bra.w	Obj31_ChkDel
; ===========================================================================

loc_B7E2:				; XREF: Obj31_Index
		move.b	#$80,$16(a0)
		bset	#4,1(a0)
		movea.l	$3C(a0),a1
		move.b	$32(a1),d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,$1A(a0)

loc_B7FE:				; XREF: Obj31_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$32(a1),d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)

Obj31_Display2:				; XREF: Obj31_Index
		bsr.w	DisplaySprite

Obj31_ChkDel:				; XREF: Obj31_Display
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================

Obj31_Types:				; XREF: loc_B798
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj31_TypeIndex(pc,d0.w),d1
		jmp	Obj31_TypeIndex(pc,d1.w)
; ===========================================================================
Obj31_TypeIndex:dc.w Obj31_Type00-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
; ===========================================================================

Obj31_Type00:				; XREF: Obj31_TypeIndex
		lea	($FFFFF7E0).w,a2 ; load	switch statuses
		moveq	#0,d0
		move.b	$3A(a0),d0	; move number 0	or 1 to	d0
		tst.b	(a2,d0.w)	; has switch (d0) been pressed?
		beq.s	loc_B8A8	; if not, branch
		tst.w	($FFFFF7A4).w
		bpl.s	loc_B872
		cmpi.b	#$10,$32(a0)
		beq.s	loc_B8A0

loc_B872:
		tst.w	$32(a0)
		beq.s	loc_B8A0
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_B892
		tst.b	1(a0)
		bpl.s	loc_B892
		move.w	#$C7,d0
		jsr	(PlaySound_Special).l ;	play rising chain sound

loc_B892:
		subi.w	#$80,$32(a0)
		bcc.s	Obj31_Restart
		move.w	#0,$32(a0)

loc_B8A0:
		move.w	#0,$12(a0)
		bra.s	Obj31_Restart
; ===========================================================================

loc_B8A8:				; XREF: Obj31_Type00
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	Obj31_Restart
		move.w	$12(a0),d0
		addi.w	#$70,$12(a0)	; make object fall
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	Obj31_Restart
		move.w	d1,$32(a0)
		move.w	#0,$12(a0)	; stop object falling
		tst.b	1(a0)
		bpl.s	Obj31_Restart
		move.w	#$BD,d0
		jsr	(PlaySound_Special).l ;	play stomping sound

Obj31_Restart:
		moveq	#0,d0
		move.b	$32(a0),d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		rts	
; ===========================================================================

Obj31_Type01:				; XREF: Obj31_TypeIndex
		tst.w	$36(a0)
		beq.s	loc_B938
		tst.w	$38(a0)
		beq.s	loc_B902
		subq.w	#1,$38(a0)
		bra.s	loc_B97C
; ===========================================================================

loc_B902:
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_B91C
		tst.b	1(a0)
		bpl.s	loc_B91C
		move.w	#$C7,d0
		jsr	(PlaySound_Special).l ;	play rising chain sound

loc_B91C:
		subi.w	#$80,$32(a0)
		bcc.s	loc_B97C
		move.w	#0,$32(a0)
		move.w	#0,$12(a0)
		move.w	#0,$36(a0)
		bra.s	loc_B97C
; ===========================================================================

loc_B938:				; XREF: Obj31_Type01
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	loc_B97C
		move.w	$12(a0),d0
		addi.w	#$70,$12(a0)	; make object fall
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	loc_B97C
		move.w	d1,$32(a0)
		move.w	#0,$12(a0)	; stop object falling
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0)
		tst.b	1(a0)
		bpl.s	loc_B97C
		move.w	#$BD,d0
		jsr	(PlaySound_Special).l ;	play stomping sound

loc_B97C:
		bra.w	Obj31_Restart
; ===========================================================================

Obj31_Type03:				; XREF: Obj31_TypeIndex
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_B98C
		neg.w	d0

loc_B98C:
		cmpi.w	#$90,d0
		bcc.s	loc_B996
		addq.b	#1,$28(a0)

loc_B996:
		bra.w	Obj31_Restart
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 45 - spiked metal block from beta version (DDZ)
; ---------------------------------------------------------------------------

Obj45:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj45_Index(pc,d0.w),d1
		jmp	Obj45_Index(pc,d1.w)
; ===========================================================================
Obj45_Index:	dc.w Obj45_Main-Obj45_Index
		dc.w Obj45_Solid-Obj45_Index
		dc.w loc_BA8E-Obj45_Index
		dc.w Obj45_Display-Obj45_Index
		dc.w loc_BA7A-Obj45_Index

Obj45_Var:	dc.b	2,   4,	  0	; routine number, x-position, frame number
		dc.b	4, $E4,	  1
		dc.b	8, $54,	  3
		dc.b	6, $28,	  2

word_B9BE:	dc.w $3800
		dc.w -$6000
		dc.w $5000
; ===========================================================================

Obj45_Main:				; XREF: Obj45_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	word_B9BE(pc,d0.w),d2
		lea	(Obj45_Var).l,a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj45_Load
; ===========================================================================

Obj45_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_BA52

Obj45_Load:				; XREF: Obj45_Main
		move.b	(a2)+,$24(a1)
		move.b	#$45,0(a1)
		move.w	$C(a0),$C(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	8(a0),d0
		move.w	d0,8(a1)
		move.l	#Map_obj45,4(a1)
		move.w	#$300,2(a1)
		move.b	#4,1(a1)
		move.w	8(a1),$30(a1)
		move.w	8(a0),$3A(a1)
		move.b	$28(a0),$28(a1)
		move.b	#$20,$14(a1)
		move.w	d2,$34(a1)
		move.w	#$200,$18(a1)
		cmpi.b	#1,(a2)
		bne.s	loc_BA40
		move.b	#$91,$20(a1)

loc_BA40:
		move.b	(a2)+,$1A(a1)
		move.l	a0,$3C(a1)
		dbf	d1,Obj45_Loop	; repeat 3 times

		move.w	#$180,$18(a1)

loc_BA52:
		move.b	#$10,$14(a0)

Obj45_Solid:				; XREF: Obj45_Index
		move.w	8(a0),-(sp)
		bsr.w	Obj45_Move
		move.w	#$17,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	(sp)+,d4
		bsr.w	SolidObject
		bsr.w	DisplaySprite
		bra.w	Obj45_ChkDel
; ===========================================================================

loc_BA7A:				; XREF: Obj45_Index
		movea.l	$3C(a0),a1
		move.b	$32(a1),d0
		addi.b	#$10,d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,$1A(a0)

loc_BA8E:				; XREF: Obj45_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$32(a1),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)

Obj45_Display:				; XREF: Obj45_Index
		bsr.w	DisplaySprite

Obj45_ChkDel:				; XREF: Obj45_Solid
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj45_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj45_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj45_Done:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj45_Move:				; XREF: Obj45_Solid
		tst.w	$36(a0)
		beq.s	loc_BB08
		tst.w	$38(a0)
		beq.s	loc_BAEC
		subq.w	#1,$38(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BAEC:
		subi.w	#$80,$32(a0)
		bcc.s	loc_BB3C
		move.w	#0,$32(a0)
		move.w	#0,$10(a0)
		move.w	#0,$36(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BB08:				; XREF: loc_BADA
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	loc_BB3C
		move.w	$10(a0),d0
		addi.w	#$70,$10(a0)
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	loc_BB3C
		move.w	d1,$32(a0)
		move.w	#0,$10(a0)
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0)

loc_BB3C:
		moveq	#0,d0
		move.b	$32(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal stomping blocks on chains (DDZ)
; ---------------------------------------------------------------------------
Map_obj31:
	include "_maps\obj31.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked metal block from beta version (DDZ)
; ---------------------------------------------------------------------------
Map_obj45:
	include "_maps\obj45.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 32 - switches (DDZ, CCZ, TJZ, ABZ)
; ---------------------------------------------------------------------------

Obj32:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj32_Index(pc,d0.w),d1
		jmp	Obj32_Index(pc,d1.w)
; ===========================================================================
Obj32_Index:	dc.w Obj32_Main-Obj32_Index
		dc.w Obj32_Pressed-Obj32_Index
; ===========================================================================

Obj32_Main:				; XREF: Obj32_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj32,4(a0)
		move.w	#$2424,2(a0)	; CCZ, TJZ and ABZ specific code
		move.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		addq.w	#3,$C(a0)

Obj32_Pressed:				; XREF: Obj32_Index
		tst.b	1(a0)
		bpl.s	Obj32_Display
		move.w	#$1B,d1
		move.w	#5,d2
		move.w	#4,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		bclr	#0,$1A(a0)	; use "unpressed" frame
		move.b	$28(a0),d0
		andi.w	#$F,d0
		lea	($FFFFF7E0).w,a3
		lea	(a3,d0.w),a3
		moveq	#0,d3
		btst	#6,$28(a0)
		beq.s	loc_BDB2
		moveq	#7,d3

loc_BDB2:
		tst.b	$28(a0)
		bpl.s	loc_BDBE
		bsr.w	Obj32_DDZBlock
		bne.s	loc_BDC8

loc_BDBE:
		tst.b	$25(a0)
		bne.s	loc_BDC8
		bclr	d3,(a3)
		bra.s	loc_BDDE
; ===========================================================================

loc_BDC8:
		tst.b	(a3)
		bne.s	loc_BDD6
		move.w	#$5B,d0
		jsr	(PlaySound_Special).l ;	play switch sound

loc_BDD6:
		bset	d3,(a3)
		bset	#0,$1A(a0)	; use "pressed"	frame

loc_BDDE:
		btst	#5,$28(a0)
		beq.s	Obj32_Display
		subq.b	#1,$23(a0)
		bpl.s	Obj32_Display
		move.b	#7,$23(a0)
		bchg	#1,$1A(a0)

Obj32_Display:
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj32_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj32_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj32_Delete

Obj32_Done:
		rts	
; ===========================================================================

Obj32_Delete:
		bsr.w	DeleteObject
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj32_DDZBlock:				; XREF: Obj32_Pressed
		move.w	d3,-(sp)
		move.w	8(a0),d2
		move.w	$C(a0),d3
		subi.w	#$10,d2
		subq.w	#8,d3
		move.w	#$20,d4
		move.w	#$10,d5
		lea	($FFFFB800).w,a1 ; begin checking object RAM
		move.w	#$5F,d6

Obj32_DDZLoop:
		tst.b	1(a1)
		bpl.s	loc_BE4E
		cmpi.b	#$33,(a1)	; is the object	a green	DDZ block?
		beq.s	loc_BE5E	; if yes, branch

loc_BE4E:
		lea	$40(a1),a1	; check	next object
		dbf	d6,Obj32_DDZLoop	; repeat $5F times

		move.w	(sp)+,d3
		moveq	#0,d0

locret_BE5A:
		rts	
; ===========================================================================
Obj32_DDZData:	dc.b $10, $10
; ===========================================================================

loc_BE5E:				; XREF: Obj32_DDZBlock
		moveq	#1,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Obj32_DDZData-2(pc,d0.w),a2
		move.b	(a2)+,d1
		ext.w	d1
		move.w	8(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_BE80
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_BE84
		bra.s	loc_BE4E
; ===========================================================================

loc_BE80:
		cmp.w	d4,d0
		bhi.s	loc_BE4E

loc_BE84:
		move.b	(a2)+,d1
		ext.w	d1
		move.w	$C(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_BE9A
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_BE9E
		bra.s	loc_BE4E
; ===========================================================================

loc_BE9A:
		cmp.w	d5,d0
		bhi.s	loc_BE4E

loc_BE9E:
		move.w	(sp)+,d3
		moveq	#1,d0
		rts	
; End of function Obj32_DDZBlock

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - switches (DDZ, CCZ, TJZ, ABZ)
; ---------------------------------------------------------------------------
Map_obj32:
	include "_maps\obj32.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 33 - pushable blocks (DDZ, TJZ)
; ---------------------------------------------------------------------------

Obj33:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj33_Index(pc,d0.w),d1
		jmp	Obj33_Index(pc,d1.w)
; ===========================================================================
Obj33_Index:	dc.w Obj33_Main-Obj33_Index
		dc.w loc_BF6E-Obj33_Index
		dc.w loc_C02C-Obj33_Index

Obj33_Var:	dc.b $10, 0	; object width,	frame number
		dc.b $40, 1
; ===========================================================================

Obj33_Main:				; XREF: Obj33_Index
		addq.b	#2,$24(a0)
		move.b	#$F,$16(a0)
		move.b	#$F,$17(a0)
		move.l	#Map_obj33,4(a0)
		move.w	#$42B8,2(a0)	; DDZ specific code
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_BF16
		move.w	#$43DE,2(a0)	; TJZ specific code

loc_BF16:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.w	8(a0),$34(a0)
		move.w	$C(a0),$36(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		andi.w	#$E,d0
		lea	Obj33_Var(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2)+,$1A(a0)
		tst.b	$28(a0)
		beq.s	Obj33_ChkGone
		move.w	#$C2B8,2(a0)

Obj33_ChkGone:
		move.w  $1E(a0),d0    ; get address in respawn table
    	beq.s   loc_BF6E   ; if it's zero, object was placed in debug mode
    	movea.w d0,a2   ; load address into a2
    	bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
		bset	#0,(a2)
		bne.w	DeleteObject

loc_BF6E:				; XREF: Obj33_Index
		tst.b	$32(a0)
		bne.w	loc_C046
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		bsr.w	loc_C186
		cmpi.w	#$200,($FFFFFE10).w ; is the level DDZ act 1?
		bne.s	loc_BFC6	; if not, branch
		bclr	#7,$28(a0)
		move.w	8(a0),d0
		cmpi.w	#$A20,d0
		bcs.s	loc_BFC6
		cmpi.w	#$AA1,d0
		bcc.s	loc_BFC6
		move.w	($FFFFF7A4).w,d0
		subi.w	#$1C,d0
		move.w	d0,$C(a0)
		bset	#7,($FFFFF7A4).w
		bset	#7,$28(a0)

loc_BFC6:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj33_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj33_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj33_Done:
		bra.w	DisplaySprite
; ===========================================================================

loc_BFE6:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj33_Done2
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj33_Done2	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj33_Done2:
		move.w	$34(a0),8(a0)
		move.w	$36(a0),$C(a0)
		move.b	#4,$24(a0)
		bra.s	loc_C02C
; ===========================================================================

loc_C016:
		move.w	$1E(a0),d0
		beq.s	loc_C028
		movea.w	d0,a2	; load address into a2
		bclr	#0,(a2)

loc_C028:
		bra.w	DeleteObject
; ===========================================================================

loc_C02C:				; XREF: Obj33_Index
		bsr.w	ChkObjOnScreen2
		beq.s	locret_C044
		move.b	#2,$24(a0)
		clr.b	$32(a0)
		clr.w	$10(a0)
		clr.w	$12(a0)

locret_C044:
		rts	
; ===========================================================================

loc_C046:				; XREF: loc_BF6E
		move.w	8(a0),-(sp)
		cmpi.b	#4,$25(a0)
		bcc.s	loc_C056
		bsr.w	SpeedToPos

loc_C056:
		btst	#1,$22(a0)
		beq.s	loc_C0A0
		addi.w	#$18,$12(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	loc_C09E
		add.w	d1,$C(a0)
		clr.w	$12(a0)
		bclr	#1,$22(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		bcs.s	loc_C09E
		move.w	$30(a0),d0
		asr.w	#3,d0
		move.w	d0,$10(a0)
		move.b	#1,$32(a0)
		clr.w	$E(a0)

loc_C09E:
		bra.s	loc_C0E6
; ===========================================================================

loc_C0A0:
		tst.w	$10(a0)
		beq.w	loc_C0D6
		bmi.s	loc_C0BC
		moveq	#0,d3
		move.b	$14(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

loc_C0BC:
		moveq	#0,d3
		move.b	$14(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

Obj33_StopPush:
		clr.w	$10(a0)		; stop block moving
		bra.s	loc_C0E6
; ===========================================================================

loc_C0D6:
		addi.l	#$2001,$C(a0)
		cmpi.b	#-$60,$F(a0)
		bcc.s	loc_C104

loc_C0E6:
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	(sp)+,d4
		bsr.w	loc_C186
		bsr.s	Obj33_ChkLava
		bra.w	loc_BFC6
; ===========================================================================

loc_C104:
		move.w	(sp)+,d4
		lea	($FFFFB000).w,a1
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		bra.w	loc_BFE6
; ===========================================================================

Obj33_ChkLava:
		cmpi.w	#$201,($FFFFFE10).w ; is the level DDZ act 2?
		bne.s	Obj33_ChkLava2	; if not, branch
		move.w	#-$20,d2
		cmpi.w	#$DD0,8(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$CC0,8(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$BA0,8(a0)
		beq.s	Obj33_LoadLava
		rts	
; ===========================================================================

Obj33_ChkLava2:
		cmpi.w	#$202,($FFFFFE10).w ; is the level DDZ act 3?
		bne.s	Obj33_NoLava	; if not, branch
		move.w	#$20,d2
		cmpi.w	#$560,8(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$5C0,8(a0)
		beq.s	Obj33_LoadLava

Obj33_NoLava:
		rts	
; ===========================================================================

Obj33_LoadLava:
		bsr.w	SingleObjLoad
		bne.s	locret_C184
		move.b	#$4C,0(a1)	; load lava geyser object
		move.w	8(a0),8(a1)
		add.w	d2,8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$10,$C(a1)
		move.l	a0,$3C(a1)

locret_C184:
		rts	
; ===========================================================================

loc_C186:				; XREF: loc_BF6E
		move.b	$25(a0),d0
		beq.w	loc_C218
		subq.b	#2,d0
		bne.s	loc_C1AA
		bsr.w	ExitPlatform
		btst	#3,$22(a1)
		bne.s	loc_C1A4
		clr.b	$25(a0)
		rts	
; ===========================================================================

loc_C1A4:
		move.w	d4,d2
		bra.w	MvSonicOnPtfm
; ===========================================================================

loc_C1AA:
		subq.b	#2,d0
		bne.s	loc_C1F2
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_C1F0
		add.w	d1,$C(a0)
		clr.w	$12(a0)
		clr.b	$25(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		bcs.s	locret_C1F0
		move.w	$30(a0),d0
		asr.w	#3,d0
		move.w	d0,$10(a0)
		move.b	#1,$32(a0)
		clr.w	$E(a0)

locret_C1F0:
		rts	
; ===========================================================================

loc_C1F2:
		bsr.w	SpeedToPos
		move.w	8(a0),d0
		andi.w	#$C,d0
		bne.w	locret_C2E4
		andi.w	#-$10,8(a0)
		move.w	$10(a0),$30(a0)
		clr.w	$10(a0)
		subq.b	#2,$25(a0)
		rts	
; ===========================================================================

loc_C218:
		bsr.w	loc_FAC8
		tst.w	d4
		beq.w	locret_C2E4
		bmi.w	locret_C2E4
		tst.b	$32(a0)
		beq.s	loc_C230
		bra.w	locret_C2E4
; ===========================================================================

loc_C230:
		tst.w	d0
		beq.w	locret_C2E4
		bmi.s	loc_C268
		btst	#0,$22(a1)
		bne.w	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	$14(a0),d3
		jsr	ObjHitWallRight
		move.w	(sp)+,d0
		tst.w	d1
		bmi.w	locret_C2E4
		addi.l	#$10000,8(a0)
		moveq	#1,d0
		move.w	#$40,d1
		bra.s	loc_C294
; ===========================================================================

loc_C268:
		btst	#0,$22(a1)
		beq.s	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	$14(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		move.w	(sp)+,d0
		tst.w	d1
		bmi.s	locret_C2E4
		subi.l	#$10000,8(a0)
		moveq	#-1,d0
		move.w	#-$40,d1

loc_C294:
		lea	($FFFFB000).w,a1
		add.w	d0,8(a1)
		move.w	d1,$20(a1)
		move.w	#0,$10(a1)
		move.w	d0,-(sp)
		move.w	#$69,d0
		jsr	(PlaySound_Special).l ;	play pushing sound
		move.w	(sp)+,d0
		tst.b	$28(a0)
		bmi.s	locret_C2E4
		move.w	d0,-(sp)
		jsr	ObjHitFloor
		move.w	(sp)+,d0
		cmpi.w	#4,d1
		ble.s	loc_C2E0
		move.w	#$400,$10(a0)
		tst.w	d0
		bpl.s	loc_C2D8
		neg.w	$10(a0)

loc_C2D8:
		move.b	#6,$25(a0)
		bra.s	locret_C2E4
; ===========================================================================

loc_C2E0:
		add.w	d1,$C(a0)

locret_C2E4:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pushable blocks (DDZ, TJZ)
; ---------------------------------------------------------------------------
Map_obj33:
	include "_maps\obj33.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 34 - zone title cards
; ---------------------------------------------------------------------------

Obj34:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj34_Index(pc,d0.w),d1
		jsr	Obj34_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj34_Index:	dc.w Obj34_Main-Obj34_Index
		dc.w Obj34_MoveIn-Obj34_Index
		dc.w Obj34_Wait-Obj34_Index
		dc.w Obj34_MoveOut-Obj34_Index
; ===========================================================================

Obj34_Main:
		addq.b	#2,$24(a0)
		move.w	#$8580,2(a0)
		move.b	#0,1(a0)
		move.w	#0,$18(a0)
		move.w	#$78,8(a0)
		move.w	#$170,$A(a0)
		move.l	#Map_Obj34,4(a0)
		move.w	#$600,$10(a0)
		move	#$2700,sr
		lea	($C00000).l,a6
		move.l	#$70000002,4(a6)
		lea	(Art_MText).l,a5
		move.w	#$28F,d1

Obj34_LoadText:
		move.w	(a5)+,(a6)
		dbf	d1,Obj34_LoadText ; load uncompressed text patterns

Obj34_MoveIn:
		tst.w		$10(a0)
		beq.s		Obj34_WaitStart
		subi.w		#$20,$10(a0)
		bra.w	SpeedToPos

Obj34_WaitStart:
		addq.b		#2,$24(a0)
		move.b		#$40,$23(a0)

Obj34_Wait:
		tst.b		$23(a0)
		beq.s		Obj34_MoveStart
		subi.b		#1,$23(a0)
		rts

Obj34_MoveStart:
		addq.b		#2,$24(a0)

Obj34_MoveOut:
		cmpi.w		#-$600,$10(a0)
		beq.s		Obj34_LoadArt
		subi.w		#$20,$10(a0)
		bra.w	SpeedToPos

Obj34_LoadArt:
		moveq	#2,d0
		jsr	(LoadPLC).l	; load explosion patterns
		jsr	(LoadAnimalPLC).l	; load explosion patterns
		jmp	DeleteObject

Obj34_Done:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 39 - "GAME OVER" and "TIME OVER"
; ---------------------------------------------------------------------------

Obj39:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj39_Index(pc,d0.w),d1
		jmp	Obj39_Index(pc,d1.w)
; ===========================================================================
Obj39_Index:	dc.w Obj39_ChkPLC-Obj39_Index
		dc.w loc_C50C-Obj39_Index
		dc.w Obj39_Wait-Obj39_Index
; ===========================================================================

Obj39_ChkPLC:				; XREF: Obj39_Index
		tst.l	($FFFFF680).w	; are the pattern load cues empty?
		beq.s	Obj39_Main	; if yes, branch
		rts	
; ===========================================================================

Obj39_Main:
		addq.b	#2,$24(a0)
		move.w	#$50,8(a0)	; set x-position
		btst	#0,$1A(a0)	; is the object	"OVER"?
		beq.s	loc_C4EC	; if not, branch
		move.w	#$1F0,8(a0)	; set x-position for "OVER"

loc_C4EC:
		move.w	#$F0,$A(a0)
		move.l	#Map_obj39,4(a0)
		move.w	#$84DE,2(a0)
		move.b	#0,1(a0)
		move.w	#0,$18(a0)

loc_C50C:				; XREF: Obj39_Index
		moveq	#$10,d1		; set horizontal speed
		cmpi.w	#$120,8(a0)	; has item reached its target position?
		beq.s	Obj39_SetWait	; if yes, branch
		bcs.s	Obj39_Move
		neg.w	d1

Obj39_Move:
		add.w	d1,8(a0)	; change item's position
		bra.w	DisplaySprite
; ===========================================================================

Obj39_SetWait:				; XREF: Obj39_Main
		move.w	#720,$30(a0)	; set time delay to 12 seconds
		addq.b	#2,$24(a0)
		rts	
; ===========================================================================

Obj39_Wait:				; XREF: Obj39_Index
		move.b	($FFFFF605).w,d0
		andi.b	#$70,d0		; is button A, B or C pressed?
		bne.s	Obj39_ChgMode	; if yes, branch
		btst	#0,$1A(a0)
		bne.s	Obj39_Display
		tst.w	$30(a0)		; has time delay reached zero?
		beq.s	Obj39_ChgMode	; if yes, branch
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bra.w	DisplaySprite
; ===========================================================================

Obj39_ChgMode:				; XREF: Obj39_Wait
		tst.b	($FFFFFE1A).w	; is time over flag set?
		bne.s	Obj39_ResetLvl	; if yes, branch
		move.b	#$14,($FFFFF600).w ; set mode to $14 (continue screen)
		bra.s	Obj39_Display	; if yes, branch
; ===========================================================================

Obj39_ResetLvl:				; XREF: Obj39_ChgMode
		move.w	#1,($FFFFFE02).w ; restart level

Obj39_Display:				; XREF: Obj39_ChgMode
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3A - "SONIC GOT THROUGH" title	card
; ---------------------------------------------------------------------------

Obj3A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3A_Index(pc,d0.w),d1
		jmp	Obj3A_Index(pc,d1.w)
; ===========================================================================
Obj3A_Index:	dc.w Obj3A_ChkPLC-Obj3A_Index
		dc.w Obj3A_ChkPos-Obj3A_Index
		dc.w Obj3A_Wait-Obj3A_Index
		dc.w Obj3A_TimeBonus-Obj3A_Index
		dc.w Obj3A_Wait-Obj3A_Index
		dc.w Obj3A_NextLevel-Obj3A_Index
		dc.w Obj3A_Wait-Obj3A_Index
		dc.w Obj3A_ChkPos2-Obj3A_Index
		dc.w loc_C766-Obj3A_Index
; ===========================================================================

Obj3A_ChkPLC:				; XREF: Obj3A_Index
		tst.l	($FFFFF680).w	; are the pattern load cues empty?
		beq.s	Obj3A_Main	; if yes, branch
		rts	
; ===========================================================================

Obj3A_Main:
		movea.l	a0,a1
		lea	(Obj3A_Config).l,a2
		moveq	#4,d1

Obj3A_Loop:
		move.b	#$3A,0(a1)
		move.w	(a2),8(a1)	; load start x-position
		move.w	(a2)+,$32(a1)	; load finish x-position (same as start)
		move.w	(a2)+,$30(a1)	; load main x-position
		move.w	(a2)+,$A(a1)	; load y-position
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,d0

loc_C5CA:
		move.b	d0,$1A(a1)
		move.l	#Map_obj3A,4(a1)
		move.w	#$8580,2(a1)
		move.b	#0,1(a1)
		lea	$40(a1),a1
		dbf	d1,Obj3A_Loop	; repeat 6 times

Obj3A_ChkPos:				; XREF: Obj3A_Index
		moveq	#$10,d1		; set horizontal speed
		move.w	$30(a0),d0
		cmp.w	8(a0),d0	; has item reached its target position?
		beq.s	loc_C61A	; if yes, branch
		bge.s	Obj3A_Move
		neg.w	d1

Obj3A_Move:
		add.w	d1,8(a0)	; change item's position

loc_C5FE:				; XREF: loc_C61A
		move.w	8(a0),d0
		bmi.s	locret_C60E
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C60E	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C60E:
		rts	
; ===========================================================================

loc_C610:				; XREF: loc_C61A
		move.b	#$E,$24(a0)
		bra.w	Obj3A_ChkPos2
; ===========================================================================

loc_C61A:				; XREF: Obj3A_ChkPos
		cmpi.b	#$E,($FFFFB6A4).w
		beq.s	loc_C610
		cmpi.b	#3,$1A(a0)
		bne.s	loc_C5FE
		addq.b	#2,$24(a0)
		move.w	#180,$34(a0)	; set time delay to 3 seconds

Obj3A_Wait:				; XREF: Obj3A_Index
		subq.w	#1,$34(a0)	; subtract 1 from time delay
		bne.s	Obj3A_Display
		addq.b	#2,$24(a0)

Obj3A_Display:
		bra.w	DisplaySprite
; ===========================================================================

Obj3A_TimeBonus:			; XREF: Obj3A_Index
		bsr.w	DisplaySprite
		move.b	#10,d1	; set score decrement to 10
		move.b	($FFFFF604).w,d0
		andi.b	#%01110000,d0	; is A, B or C pressed?
		beq.w	@dontspeedup	; if not, branch
		move.b	#100,d1	; increase score decrement to 100
		
	@dontspeedup:
		move.b	#1,($FFFFF7D6).w ; set time/ring bonus update flag
		moveq	#0,d0
		tst.w	($FFFFF7D2).w	; is time bonus	= zero?
		beq.s	Obj3A_RingBonus	; if yes, branch
		cmp.w	($FFFFF7D2).w,d1	; compare time bonus to score decrement
		blt.s	Obj3A_TimeBonusSkip	; if it's greater or equal, branch
		move.w	($FFFFF7D2).w,d1	; else, set the decrement to the remaining bonus

Obj3A_TimeBonusSkip:
		add.w	d1,d0		; add decrement to score
		sub.w	d1,($FFFFF7D2).w ; subtract decrement from time bonus

Obj3A_RingBonus:
		tst.w	($FFFFF7D4).w	; is ring bonus	= zero?
		beq.s	Obj3A_ChkBonus	; if yes, branch
		cmp.w	($FFFFF7D4).w,d1	; compare ring bonus to score decrement
		blt.s	Obj3A_RingBonusSkip	; if it's greater or equal, branch
		move.w	($FFFFF7D4).w,d1	; else, set the decrement to the remaining bonus

Obj3A_RingBonusSkip:
		add.w	d1,d0		; add decrement to score
		sub.w	d1,($FFFFF7D4).w ; subtract decrement from ring bonus

Obj3A_ChkBonus:
		tst.w	d0		; is there any bonus?
		bne.s	Obj3A_AddBonus	; if yes, branch
		tst.b 	($FFFFFFBB).w
		bne.s 	Obj3A_Cont
		move.w	#$B0,d0
		jsr	(PlaySound_Special).l ;	play "ker-ching" sound
		move.w	#$1D,d0
		jsr		PlaySound	; play results music
		move.b 	#1,($FFFFFFBB).w
		move.b	#$F,0(a1)
		jsr	SingleObjLoad

Obj3A_Cont:
		andi.b	#$70,($FFFFF605).w ; is	A, B, C, or Start pressed?
		beq.s 	locret_C692
		addq.b	#2,$24(a0)
		move.b 	#$E1,d0
		jsr (PlaySound_Special).l 	; fade out music
		addq.b	#2,$24(a0)

Obj3A_SetDelay:
		move.w	#$30,$34(a0)	; set time delay to 3 seconds

locret_C692:
		rts

; ===========================================================================

Obj3A_AddBonus:				; XREF: Obj3A_ChkBonus
		jsr	AddPoints
		move.b	($FFFFFE0F).w,d0
		andi.b	#3,d0
		bne.s	locret_C692
		move.w	#$5B,d0
		jmp	(PlaySound_Special).l ;	play "blip" sound
; ===========================================================================

Obj3A_NextLevel:			; XREF: Obj3A_Index
		clr.l	($FFFFFFC4).w
		clr.l	($FFFFF608).w
		move.b	($FFFFFE10).w,d0
		andi.w	#$F,d0
		lsl.w	#3,d0
		move.b	($FFFFFE11).w,d1
		andi.w	#3,d1
		add.w	d1,d1
		add.w	d1,d0
		move.w	LevelOrder(pc,d0.w),d0 ; load level from level order array
		move.w	d0,($FFFFFE10).w ; set level number
		tst.w	d0
		bne.s	Obj3A_ChkSS
		move.b	#$18,($FFFFF600).w ; set game mode to ending (18)
		bra.s	Obj3A_Display2
; ===========================================================================

Obj3A_ChkSS:				; XREF: Obj3A_NextLevel
	 ;	move.b	#$28,($FFFFF600).w ; set	screen mode to $28 (Title Card)
		clr.b	($FFFFFE30).w	; clear	lamppost counter
		tst.b	($FFFFFE11).w
		beq.s	Obj3A_Display2
		addq.b	#2,$24(a0)
		rts

Obj3A_Display2:				; XREF: Obj3A_NextLevel, Obj3A_ChkSS
		move.w	#1,($FFFFFE02).w ; restart level
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Level	order array
; ---------------------------------------------------------------------------
LevelOrder:	
		dc.w	wave_ocean_act_3	; WOZ1
		dc.w	wave_ocean_act_4	; WOZ2
		dc.w	wave_ocean_act_4	; WOZ3
		dc.w	dusty_desert_act_1	; WOZ4
		
		dc.w	kingdom_valley_act_1	; TJZ1
		dc.w	lvlord_sega			; TJZ2
		dc.w	lvlord_sega			; TJZ3
		dc.w	lvlord_sega			; TJZ4
		
		dc.w	dusty_desert_act_2	; DDZ1
		dc.w	soleanna_act_1		; DDZ2
		dc.w	lvlord_sega			; DDZ3
		dc.w	lvlord_sega			; DDZ4
		
		dc.w	kingdom_valley_act_2	; KVZ1
		dc.w	kingdom_valley_act_3	; KVZ2
		dc.w	aquatic_base_act_1	; KVZ3
		dc.w	lvlord_sega			; KVZ4
		
		dc.w	crisis_city_act_2	; CCZ1
		dc.w	crisis_city_act_3	; CCZ2
		dc.w	crisis_city_act_4	; CCZ3
		dc.w	flame_core_act_1	; CCZ4
		
		dc.w	aquatic_base_act_2	; ABZ1
		dc.w	aquatic_base_act_3	; ABZ2
		dc.w	aquatic_base_act_4	; ABZ3
		dc.w	lvlord_sega			; ABZ4

		dc.w	lvlord_sega			; Ending
		dc.w	lvlord_sega			; Ending
		dc.w	lvlord_sega			; Ending
		dc.w	lvlord_sega			; Ending

		dc.w	lvlord_sega			; SSZ1
		dc.w	lvlord_sega			; SSZ2
		dc.w	lvlord_sega			; SSZ3
		dc.w	lvlord_sega			; SSZ4

		dc.w	white_acropolis_act_2	; WAZ1
		dc.w	white_acropolis_act_3	; WAZ2
		dc.w	crisis_city_act_1	; WAZ3
		dc.w	lvlord_sega			; WAZ4

		dc.w	flame_core_act_2	; FCZ1
		dc.w	flame_core_act_3	; FCZ2
		dc.w	radical_train_act_1	; FCZ3
		dc.w	lvlord_sega			; FCZ4

		dc.w	radical_train_act_2	; RTZ1
		dc.w	radical_train_act_3	; RTZ2
		dc.w	tropical_jungle_act_1	; RTZ3
		dc.w	lvlord_sega			; RTZ4

		dc.w	white_acropolis_act_1	; SZ1
		dc.w	lvlord_sega			; SZ2
		dc.w	lvlord_sega			; SZ3
		dc.w	lvlord_sega			; SZ4
		even

Obj3A_ChkPos2:				; XREF: Obj3A_Index
		moveq	#$20,d1		; set horizontal speed
		move.w	$32(a0),d0
		cmp.w	8(a0),d0	; has item reached its finish position?
		beq.s	Obj3A_ABZ2	; if yes, branch
		bge.s	Obj3A_Move2
		neg.w	d1

Obj3A_Move2:
		add.w	d1,8(a0)	; change item's position
		move.w	8(a0),d0
		bmi.s	locret_C748
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C748	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C748:
		rts	
; ===========================================================================

Obj3A_ABZ2:				; XREF: Obj3A_ChkPos2
		cmpi.b	#3,$1A(a0)
		bne.w	DeleteObject
		addq.b	#2,$24(a0)
		move.b	#1,($FFFFFE13).w
		rts
; ===========================================================================

loc_C766:				; XREF: Obj3A_Index
	;	addq.w	#2,($FFFFF72A).w
	;	move.w	($FFFFF72A).w,d0
	;	cmp.w	($FFFFF700).w,d0
	;	blt.w	locret_C748
		move.w	#$3E80,($FFFFF72A).w
		bra.w	DeleteObject
; ===========================================================================
Obj3A_Config:	dc.w 4,	$124, $BC	; x-start, x-main, y-main
		dc.b 2,	0		; routine number, frame	number (changes)
		dc.w $FEE0, $120, $D0
		dc.b 2,	1
	;	dc.w $40C, $14C, $D6
	;	dc.b 2,	6
		dc.w $520, $120, $EC
		dc.b 2,	2
		dc.w $540, $120, $FC
		dc.b 2,	3
		dc.w $560, $120, $10C
		dc.b 2,	4
	;	dc.w $20C, $14C, $CC
	;	dc.b 2,	5
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7E - special stage results screen
; ---------------------------------------------------------------------------

Obj7E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7E_Index(pc,d0.w),d1
		jmp	Obj7E_Index(pc,d1.w)
; ===========================================================================
Obj7E_Index:	dc.w Obj7E_ChkPLC-Obj7E_Index
		dc.w Obj7E_ChkPos-Obj7E_Index
		dc.w Obj7E_Wait-Obj7E_Index
		dc.w Obj7E_RingBonus-Obj7E_Index
		dc.w Obj7E_Wait-Obj7E_Index
		dc.w Obj7E_Exit-Obj7E_Index
		dc.w Obj7E_Wait-Obj7E_Index
		dc.w Obj7E_Continue-Obj7E_Index
		dc.w Obj7E_Wait-Obj7E_Index
		dc.w Obj7E_Exit-Obj7E_Index
		dc.w loc_C91A-Obj7E_Index
; ===========================================================================

Obj7E_ChkPLC:				; XREF: Obj7E_Index
		tst.l	($FFFFF680).w	; are the pattern load cues empty?
		beq.s	Obj7E_Main	; if yes, branch
		rts	
; ===========================================================================

Obj7E_Main:
		movea.l	a0,a1
		lea	(Obj7E_Config).l,a2
		moveq	#3,d1
		cmpi.w	#50,($FFFFFE20).w ; do you have	50 or more rings?
		bcs.s	Obj7E_Loop	; if no, branch
		addq.w	#1,d1		; if yes, add 1	to d1 (number of sprites)

Obj7E_Loop:
		move.b	#$7E,0(a1)
		move.w	(a2)+,8(a1)	; load start x-position
		move.w	(a2)+,$30(a1)	; load main x-position
		move.w	(a2)+,$A(a1)	; load y-position
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1A(a1)
		move.l	#Map_obj7E,4(a1)
		move.w	#$8580,2(a1)
		move.b	#0,1(a1)
		lea	$40(a1),a1
		dbf	d1,Obj7E_Loop	; repeat sequence 3 or 4 times

		moveq	#7,d0
		move.b	($FFFFFE57).w,d1
		beq.s	loc_C842
		moveq	#0,d0
		cmpi.b	#6,d1		; do you have all chaos	emeralds?
		bne.s	loc_C842	; if not, branch
		moveq	#8,d0		; load "Sonic got them all" text
		move.w	#$18,8(a0)
		move.w	#$118,$30(a0)	; change position of text

loc_C842:
		move.b	d0,$1A(a0)

Obj7E_ChkPos:				; XREF: Obj7E_Index
		moveq	#$10,d1		; set horizontal speed
		move.w	$30(a0),d0
		cmp.w	8(a0),d0	; has item reached its target position?
		beq.s	loc_C86C	; if yes, branch
		bge.s	Obj7E_Move
		neg.w	d1

Obj7E_Move:
		add.w	d1,8(a0)	; change item's position

loc_C85A:				; XREF: loc_C86C
		move.w	8(a0),d0
		bmi.s	locret_C86A
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C86A	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C86A:
		rts	
; ===========================================================================

loc_C86C:				; XREF: Obj7E_ChkPos
		cmpi.b	#2,$1A(a0)
		bne.s	loc_C85A
		addq.b	#2,$24(a0)
		move.w	#180,$30(a0)	; set time delay to 3 seconds
		move.b	#$7F,($FFFFB800).w ; load chaos	emerald	object

Obj7E_Wait:				; XREF: Obj7E_Index
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bne.s	Obj7E_Display
		addq.b	#2,$24(a0)

Obj7E_Display:
		bra.w	DisplaySprite
; ===========================================================================

Obj7E_RingBonus:			; XREF: Obj7E_Index
		bsr.w	DisplaySprite
		move.b	#1,($FFFFF7D6).w ; set ring bonus update flag
		tst.w	($FFFFF7D4).w	; is ring bonus	= zero?
		beq.s	loc_C8C4	; if yes, branch
		subi.w	#10,($FFFFF7D4).w ; subtract 10	from ring bonus
		moveq	#10,d0		; add 10 to score
		jsr	AddPoints
		move.b	($FFFFFE0F).w,d0
		andi.b	#3,d0
		bne.s	locret_C8EA
		move.w	#$5B,d0
		jmp	(PlaySound_Special).l ;	play "blip" sound
; ===========================================================================

loc_C8C4:				; XREF: Obj7E_RingBonus
		move.w	#$B0,d0
		jsr	(PlaySound_Special).l ;	play "ker-ching" sound
		addq.b	#2,$24(a0)
		move.w	#180,$30(a0)	; set time delay to 3 seconds
		cmpi.w	#50,($FFFFFE20).w ; do you have	at least 50 rings?
		bcs.s	locret_C8EA	; if not, branch
		move.w	#60,$30(a0)	; set time delay to 1 second
		addq.b	#4,$24(a0)	; goto "Obj7E_Continue"	routine

locret_C8EA:
		rts	
; ===========================================================================

Obj7E_Exit:				; XREF: Obj7E_Index
		move.w	#1,($FFFFFE02).w ; restart level
		bra.w	DisplaySprite
; ===========================================================================

Obj7E_Continue:				; XREF: Obj7E_Index
		move.b	#4,($FFFFB6DA).w
		move.b	#$14,($FFFFB6E4).w
		move.w	#$AC,d0
		jsr	(PlaySound_Special).l ;	play continues music
		addq.b	#2,$24(a0)
		move.w	#360,$30(a0)	; set time delay to 6 seconds
		bra.w	DisplaySprite
; ===========================================================================

loc_C91A:				; XREF: Obj7E_Index
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	Obj7E_Display2
		bchg	#0,$1A(a0)

Obj7E_Display2:
		bra.w	DisplaySprite
; ===========================================================================
Obj7E_Config:	dc.w $20, $120,	$C4	; start	x-pos, main x-pos, y-pos
		dc.b 2,	0		; rountine number, frame number
		dc.w $320, $120, $118
		dc.b 2,	1
		dc.w $360, $120, $128
		dc.b 2,	2
		dc.w $1EC, $11C, $C4
		dc.b 2,	3
		dc.w $3A0, $120, $138
		dc.b 2,	6
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7F - chaos emeralds from the special stage results screen
; ---------------------------------------------------------------------------

Obj7F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7F_Index(pc,d0.w),d1
		jmp	Obj7F_Index(pc,d1.w)
; ===========================================================================
Obj7F_Index:	dc.w Obj7F_Main-Obj7F_Index
		dc.w Obj7F_Flash-Obj7F_Index

; ---------------------------------------------------------------------------
; X-axis positions for chaos emeralds
; ---------------------------------------------------------------------------
Obj7F_PosData:	dc.w $110, $128, $F8, $140, $E0, $158
; ===========================================================================

Obj7F_Main:				; XREF: Obj7F_Index
		movea.l	a0,a1
		lea	(Obj7F_PosData).l,a2
		moveq	#0,d2
		moveq	#0,d1
		move.b	($FFFFFE57).w,d1 ; d1 is number	of emeralds
		subq.b	#1,d1		; subtract 1 from d1
		bcs.w	DeleteObject	; if you have 0	emeralds, branch

Obj7F_Loop:
		move.b	#$7F,0(a1)
		move.w	(a2)+,8(a1)	; set x-position
		move.w	#$F0,$A(a1)	; set y-position
		lea	($FFFFFE58).w,a3 ; check which emeralds	you have
		move.b	(a3,d2.w),d3
		move.b	d3,$1A(a1)
		move.b	d3,$1C(a1)
		addq.b	#1,d2
		addq.b	#2,$24(a1)
		move.l	#Map_obj7F,4(a1)
		move.w	#$8541,2(a1)
		move.b	#0,1(a1)
		lea	$40(a1),a1	; next object
		dbf	d1,Obj7F_Loop	; loop for d1 number of	emeralds

Obj7F_Flash:				; XREF: Obj7F_Index
		move.b	$1A(a0),d0
		move.b	#6,$1A(a0)	; load 6th frame (blank)
		cmpi.b	#6,d0
		bne.s	Obj7F_Display
		move.b	$1C(a0),$1A(a0)	; load visible frame

Obj7F_Display:
		bra.w	DisplaySprite
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - "GAME OVER"	and "TIME OVER"
; ---------------------------------------------------------------------------
Map_obj39:
	include "_maps\obj39.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - "SONIC HAS PASSED" title card
; ---------------------------------------------------------------------------
Map_obj3A:	
	include "_maps\obj3A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage results screen
; ---------------------------------------------------------------------------
Map_obj7E:
	include "_maps\obj7E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - chaos emeralds from	the special stage results screen
; ---------------------------------------------------------------------------
Map_obj7F:
	include "_maps\obj7F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 36 - spikes
; ---------------------------------------------------------------------------

Obj36:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_1590E(pc,d0.w),d1
		jmp	off_1590E(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_1590E:	dc.w loc_15926-off_1590E; 0 ; DATA XREF: ROM:0001590Eo
					; ROM:00015910o ...
		dc.w loc_15996-off_1590E; 1
		dc.w loc_159E6-off_1590E; 2
		dc.w loc_15A42-off_1590E; 3
byte_15916:	dc.b $10		; 0 ; DATA XREF: ROM:00015952t
		dc.b $10		; 1
		dc.b $20		; 2
		dc.b $10		; 3
		dc.b $30		; 4
		dc.b $10		; 5
		dc.b $40		; 6
		dc.b $10		; 7
		dc.b $10		; 8
		dc.b $10		; 9
		dc.b $10		; 10
		dc.b $20		; 11
		dc.b $10		; 12
		dc.b $30		; 13
		dc.b $10		; 14
		dc.b $40		; 15
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15926:				; DATA XREF: ROM:0001590Eo
		addq.b	#2,$24(a0)
		move.l	#Map_Obj36,4(a0)
		move.w	#$2434,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),d0
		andi.b	#$F,$28(a0)
		andi.w	#$F0,d0	; 'รฐ'
		lea	(byte_15916,pc),a1
		lsr.w	#3,d0
		adda.w	d0,a1
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$16(a0)
		lsr.w	#1,d0
		move.b	d0,$1A(a0)
		cmpi.b	#4,d0
		bcs.s	loc_15978
		addq.b	#2,$24(a0)

loc_15978:				; CODE XREF: ROM:0001596Cj
		btst	#1,$22(a0)
		beq.s	loc_15986
		move.b	#6,$24(a0)

loc_15986:				; CODE XREF: ROM:0001597Ej
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$32(a0)
		rts
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15996:				; DATA XREF: ROM:0001590Eo
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		move.b	$22(a0),d6
		andi.b	#$18,d6
		beq.s	loc_159DE
		move.b	d6,d0
		andi.b	#8,d0
		beq.s	loc_159DE
		lea	($FFFFB000).w,a1
		bsr.w	sub_15A90

loc_159DE:				; CODE XREF: ROM:000159BEj
					; ROM:000159D4j
		move.w	$30(a0),d0
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_159E6:				; DATA XREF: ROM:0001590Eo
		move.w	8(a0),-(sp)
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		bsr.w	SolidObject
		btst	#3,$22(a0)
		bne.s	loc_15A3A
		cmpi.w	#1,d4
		bne.s	loc_15A3A
		bsr.w	sub_15A90
		bclr	#5,$22(a0)

loc_15A3A:				; CODE XREF: ROM:00015A0Ej
					; ROM:00015A2Aj
		move.w	$30(a0),d0
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15A42:				; DATA XREF: ROM:0001590Eo
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		btst	#3,$22(a0)
		bne.s	loc_15A88
		tst.w	d4
		bpl.s	loc_15A88
		bsr.w	sub_15A90

loc_15A88:				; CODE XREF: ROM:00015A68j
					; ROM:00015A7Ej
		move.w	$30(a0),d0
		bra.w	MarkObjGone

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15A90:				; CODE XREF: ROM:0001293Aj
					; ROM:000159CCp ...
		btst	#1,($FFFFFE2C).w	; is Sonic invincible?
		bne.s	locret_15AC4
		tst.w	$30(a1)
		bne.s	locret_15AC4
		cmpi.b	#4,$24(a1)
		bcc.s	locret_15AC4
		move.l	$C(a1),d3
		move.w	$12(a1),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a1)
		movea.l	a0,a2
		movea.l	a1,a0
		jsr	HurtSonic
		movea.l	a2,a0

locret_15AC4:				; CODE XREF: sub_15A90+6j sub_15A90+Cj ...
		rts	
; End of function sub_15A90


; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15AC6:				; CODE XREF: ROM:00015996p
					; ROM:000159EAp ...
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	off_15AD6(pc,d0.w),d1
		jmp	off_15AD6(pc,d1.w)
; End of function sub_15AC6

; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_15AD6:	dc.w locret_15ADC-off_15AD6; 0 ; DATA XREF: ROM:00015AD6o
					; ROM:00015AD8o ...
		dc.w loc_15ADE-off_15AD6; 1
		dc.w loc_15AF2-off_15AD6; 2
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

locret_15ADC:				; DATA XREF: ROM:00015AD6o
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15ADE:				; DATA XREF: ROM:00015AD6o
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,$C(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15AF2:				; DATA XREF: ROM:00015AD6o
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)
		rts	

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15B06:				; CODE XREF: ROM:00015ADEp
					; ROM:00015AF2p
		tst.w	$38(a0)
		beq.s	loc_15B24
		subq.w	#1,$38(a0)
		bne.s	locret_15B66
		tst.b	1(a0)
		bpl.s	locret_15B66
		move.w	#$52,d0	; 'ยถ'
		jsr	(PlaySound).l
		bra.s	locret_15B66
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15B24:				; CODE XREF: sub_15B06+4j
		tst.w	$36(a0)
		beq.s	loc_15B46
		subi.w	#$800,$34(a0)
		bcc.s	locret_15B66
		move.w	#0,$34(a0)
		move.w	#0,$36(a0)
		move.w	#$3C,$38(a0) ; '<'
		bra.s	locret_15B66
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_15B46:				; CODE XREF: sub_15B06+22j
		addi.w	#$800,$34(a0)
		cmpi.w	#$2000,$34(a0)
		bcs.s	locret_15B66
		move.w	#$2000,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0) ; '<'

locret_15B66:				; CODE XREF: sub_15B06+Aj
					; sub_15B06+10j ...
		rts	
; End of function sub_15B06
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - spikes
; ---------------------------------------------------------------------------
Map_obj36:
	include "_maps\obj36.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3B - purple rock (WOZ)
; ---------------------------------------------------------------------------

Obj3B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3B_Index(pc,d0.w),d1
		jmp	Obj3B_Index(pc,d1.w)
; ===========================================================================
Obj3B_Index:	dc.w Obj3B_Main-Obj3B_Index
		dc.w Obj3B_Solid-Obj3B_Index
		dc.w loc_2366A-Obj3B_Index
; ===========================================================================

Obj3B_Main:				; XREF: Obj3B_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj3B,4(a0)
		move.w	#$6308,2(a0)
		move.b	#4,1(a0)
		move.b	#$13,$14(a0)
		move.w	#$180,$18(a0)
		move.b	#4,$1A(a0)

Obj3B_Solid:				; XREF: Obj3B_Index
		tst.b 	$28(a0)
		bne.s 	loc_23582
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$10,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj3B_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj3B_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj3B_Done:
		rts	

loc_23582:				; DATA XREF: h+C5B4o
		move.w	($FFFFF7D0).w,$38(a0)
		move.b	($FFFFB01C).w,$32(a0)
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		jsr	SolidObject
		move.b	$22(a0),d0
		andi.b	#$18,d0
		bne.s	loc_235BC

loc_235B8:				; CODE XREF: h+C65Cj h+C684j ...
		jmp	MarkObjGone
; ===========================================================================

loc_235BC:				; CODE XREF: h+C642j
		cmpi.b	#$18,d0
		bne.s	loc_235EA
		cmpi.b	#2,$32(a0)
		beq.s	loc_235D2
		cmpi.b	#$C,$32(a0)
		beq.s	loc_235D2
		cmpi.b	#2,$33(a0)
		bne.s	loc_235B8

loc_235D2:				; CODE XREF: h+C654j
		lea	($FFFFB000).w,a1
		move.b	$32(a0),d0
		bsr.s	loc_23602
		move.b	$33(a0),d0
		bsr.s	loc_23602
		bra.w	loc_23652
; ===========================================================================

loc_235EA:				; CODE XREF: h+C64Cj
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_23652
		cmpi.b	#2,$32(a0)
		beq.s	loc_235EA2
		cmpi.b	#$C,$32(a0)
		bne.s	loc_235B8

loc_235EA2:
		lea	($FFFFB000).w,a1
		bsr.s	loc_23608
		bra.s	loc_23652
; ===========================================================================

loc_23602:				; CODE XREF: h+C666p h+C670p
		cmpi.b	#2,d0
		beq.s	loc_23608
		cmpi.b	#$C,d0
		bne.s	loc_23626

loc_23608:				; CODE XREF: h+C68Ap h+C6DCp
		bset	#2,$22(a1)
		move.b	#$E,$16(a1)
		move.b	#7,$17(a1)
		move.b	#$C,$1C(a1)
		move.w	#-$300,$12(a1)

loc_23626:				; CODE XREF: h+C692j
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		rts	
; ===========================================================================

loc_23652:				; CODE XREF: h+C672j h+C68Cj
		move.w	$38(a0),($FFFFF7D0).w
		andi.b	#-$19,$22(a0)
		movea.l	$3C(a0),a4
		bsr.w	SmashObject
		bsr.w	loc_236A8

loc_2366A:				; DATA XREF: h+C5B4o
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
byte_23680:	dc.b $FE,  0,$FE,  0,  0,  0,$FD,$80,  2,  0,$FE,  0,$FE,$40,$FE,$40; 0
					; DATA XREF: h+C5D2o
		dc.b   0,  0,$FE,  0,  1,$C0,$FE,$40; 16
byte_23698:	dc.b $FF,  0,$FE,  0,  1,  0,$FE,  0,$FF,$40,$FE,$40,  0,$C0,$FE,$40; 0
					; DATA XREF: h+C5F6o
; ===========================================================================

loc_236A8:				; CODE XREF: h+C564p h+C6F2p
		moveq	#0,d0
		move.w	word_236F2(pc,d2.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; ' '
		bcs.s	loc_236E4
		move.w	#$3E8,d0
		moveq	#$A,d2

loc_236E4:				; CODE XREF: h+C768j
		jsr	AddPoints
		lsr.w	#1,d2
		move.b	d2,$1A(a1)

locret_236F0:				; CODE XREF: h+C738j
		rts	
; ===========================================================================
word_236F2:	dc.w	$A		; 0 ; DATA XREF: h+C780o h+C782o ...
		dc.w   $14		; 1
		dc.w   $32		; 2
		dc.w   $64		; 3
		dc.w	$A		; 5
		dc.w   $14		; 1
		dc.w   $32		; 2
		dc.w   $64		; 3
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 49 - waterfall	sound effect (WOZ)
; ---------------------------------------------------------------------------

Obj49:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj49_Index(pc,d0.w),d1
		jmp	Obj49_Index(pc,d1.w)
; ===========================================================================
Obj49_Index:	dc.w Obj49_Main-Obj49_Index
		dc.w Obj49_PlaySnd-Obj49_Index
; ===========================================================================

Obj49_Main:				; XREF: Obj49_Index
		addq.b	#2,$24(a0)
		move.b	#4,1(a0)

Obj49_PlaySnd:				; XREF: Obj49_Index
		move.b	($FFFFFE0F).w,d0
		andi.b	#$3F,d0
		bne.s	Obj49_ChkDel
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play waterfall sound

Obj49_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj49_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj49_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj49_Done:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - purple rock	(WOZ)
; ---------------------------------------------------------------------------
Map_obj3B:
	include "_maps\obj3B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3C - smashable	wall (WOZ, KVZ)
; ---------------------------------------------------------------------------

Obj3C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3C_Index(pc,d0.w),d1
		jsr	Obj3C_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj3C_Index:	dc.w Obj3C_Main-Obj3C_Index
		dc.w Obj3C_Solid-Obj3C_Index
		dc.w Obj3C_FragMove-Obj3C_Index
; ===========================================================================

Obj3C_Main:				; XREF: Obj3C_Index
		addq.b	#2,$24(a0)
		move.b	#4,1(a0)
		move.w	#$4C00,$18(a0)
		move.b	#0,$1A(a0)
		move.l	#Map_obj3B,4(a0)
		move.w	#$2308,2(a0)
		move.b	#$10,$14(a0)
		tst.b	($FFFFFE10).w
		beq.s	Obj3C_Solid
		move.l	#Map_obj3C,4(a0)
		move.w	#$4312,2(a0)
		move.b	#$10,$14(a0)

Obj3C_Solid
		tst.b	($FFFFFE10).w
		bne.s	Obj3C_Main2
		move.w	($FFFFB010).w,$30(a0) ;	load Sonic's horizontal speed
		move.w	#$20,d1
		move.w	#$30,d2
		move.w	#$30,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		bra.s	Obj3C_Main3

OBj3C_Main2:
		move.w	($FFFFB010).w,$30(a0) ;	load Sonic's horizontal speed
		move.w	#$20,d1
		move.w	#$38,d2
		move.w	#$38,d3
		move.w	8(a0),d4
		bsr.w	SolidObject

Obj3C_Main3:
		btst	#5,$22(a0)
		bne.s	Obj3C_ChkRoll
		cmpi.b	#2,0(a1)
		bne.s	locret_D180
		lea		($FFFFB1C0).w,a2
		move.w	8(a2),d0
		sub.w	8(a0),d0
		cmpi.w	#$10,d0
		bhi.s	locret_D180

Obj3C_ChkSpeed2:
		lea	(Obj3C_FragSpd1).l,a4 ;	use fragments that move	right
		btst	#0,$22(a2)
		beq.s	Obj3C_Smash	; if yes, branch
		lea	(Obj3C_FragSpd2).l,a4 ;	use fragments that move	left
		bra.s	Obj3C_Smash

locret_D180:
		rts	
; ===========================================================================

Obj3C_ChkRoll:				; XREF: Obj3C_Solid
		cmpi.b	#2,$1C(a1)	; is Sonic rolling?
		bne.s	locret_D180	; if not, branch
		move.b	#1,$1A(a0)
		move.w	$30(a0),d0
		bpl.s	Obj3C_ChkSpeed
		neg.w	d0

Obj3C_ChkSpeed:
		cmpi.w	#$480,d0	; is Sonic's speed $480 or higher?
		bcs.s	locret_D180	; if not, branch
		move.w	$30(a0),$10(a1)
		addq.w	#4,8(a1)
		lea	(Obj3C_FragSpd1).l,a4 ;	use fragments that move	right
		move.w	8(a0),d0
		cmp.w	8(a1),d0	; is Sonic to the right	of the block?
		bcs.s	Obj3C_Smash	; if yes, branch
		subq.w	#8,8(a1)
		lea	(Obj3C_FragSpd2).l,a4 ;	use fragments that move	left

Obj3C_Smash:
		move.w	$10(a1),$20(a1)
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)
		moveq	#7,d1		; load 8 fragments
		move.w	#$70,d2
		bsr.s	SmashObject

Obj3C_FragMove:				; XREF: Obj3C_Index
		bsr.w	SpeedToPos
		addi.w	#$70,$12(a0)	; make fragment	fall faster
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.w	DeleteObject
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	smash a	block (WOZ walls and DDZ	blocks)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SmashObject:				; XREF: Obj3C_Smash
		moveq	#0,d0
		move.b	$1A(a0),d0
		add.w	d0,d0
		movea.l	4(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,1(a0)
		move.b	0(a0),d4
		move.b	1(a0),d5
		movea.l	a0,a1
		bra.s	Smash_LoadFrag
; ===========================================================================

Smash_Loop:
		bsr.w	SingleObjLoad
		bne.s	Smash_PlaySnd
		addq.w	#5,a3

Smash_LoadFrag:				; XREF: SmashObject
		move.b	#4,$24(a1)
		move.b	d4,0(a1)
		move.l	a3,4(a1)
		move.b	d5,1(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	2(a0),2(a1)
		move.w	$18(a0),$18(a1)
		move.b	$14(a0),$14(a1)
		move.w	(a4)+,$10(a1)
		move.w	(a4)+,$12(a1)
		cmpa.l	a0,a1
		bcc.s	loc_D268
		move.l	a0,-(sp)
		movea.l	a1,a0
		bsr.w	SpeedToPos
		add.w	d2,$12(a0)
		movea.l	(sp)+,a0
		bsr.w	DisplaySprite2

loc_D268:
		dbf	d1,Smash_Loop

Smash_PlaySnd:
		move.w	#$59,d0
		jmp	(PlaySound_Special).l ;	play smashing sound
; End of function SmashObject

; ===========================================================================
; Smashed block	fragment speeds
;
Obj3C_FragSpd1:	dc.w $400, $FB00	; x-move speed,	y-move speed
		dc.w $600, $FF00
		dc.w $600, $100
		dc.w $400, $500
		dc.w $600, $FA00
		dc.w $800, $FE00
		dc.w $800, $200
		dc.w $600, $600

Obj3C_FragSpd2:	dc.w $FA00, $FA00
		dc.w $F800, $FE00
		dc.w $F800, $200
		dc.w $FA00, $600
		dc.w $FC00, $FB00
		dc.w $FA00, $FF00
		dc.w $FA00, $100
		dc.w $FC00, $500
; ---------------------------------------------------------------------------
; Sprite mappings - smashable walls (WOZ, KVZ)
; ---------------------------------------------------------------------------
Map_obj3C:
	include "_maps\obj3C.asm"

; ---------------------------------------------------------------------------
; Object code loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectsLoad:
	lea	($FFFFB000).w,a0 ; a0=object

	moveq	#$7F,d7 ; run the first $80 objects out of levels
	moveq	#0,d0
	cmpi.b	#8,($FFFFF600).w	; demo mode?
	beq.s	ObjectsLoad2	; if in a level in a demo, branch
	cmpi.b	#$C,($FFFFF600).w	; regular level mode?
	bne.s	RunObject ; if not in a level, branch to RunObject

ObjectsLoad2:
	move.w	#$8F,d7	; run the first $90 objects in levels
	
	cmpi.b	#6,($FFFFB024).w
	bhs.s	RunObjectsWhenPlayerIsDead ; if dead, branch
	; continue straight to RunObject
; ---------------------------------------------------------------------------

; -------------------------------------------------------------------------------
; This is THE place where each individual object's code gets called from
; -------------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_15FCC:
RunObject:
	move.b	(a0),d0	; get the object's ID
	beq.s	RunNextObject ; if it's obj00, skip it

	add.w	d0,d0
	add.w	d0,d0	; d0 = object ID * 4
	movea.l	Obj_Index-4(pc,d0.w),a1	; load the address of the object's code
	jsr	(a1)	; dynamic call! to one of the the entries in Obj_Index
	moveq	#0,d0

; loc_15FDC:
RunNextObject:
	lea	$40(a0),a0 ; load 0bj address
	dbf	d7,RunObject
; return_15FE4:
RunObjects_End:
	rts

; ---------------------------------------------------------------------------
; this skips certain objects to make enemies and things pause when Sonic dies
; loc_15FE6:
RunObjectsWhenPlayerIsDead:
	moveq	#$F,d7
	bsr.s	RunObject	; run the first $10 objects normally
	moveq	#$6F,d7
	bsr.s	RunObjectDisplayOnly ; all objects in this range are paused
	moveq	#$F,d7
	bra.s	RunObject	; run the last $10 objects normally

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_15FF2:
RunObjectDisplayOnly:
	moveq	#0,d0
	move.b	(a0),d0	; get the object's ID
	beq.s	RunObjectDisplayOnly2	; if it's obj00, skip it
	tst.b	1(a0)	; should we render it?
	bpl.s	RunObjectDisplayOnly2			; if not, skip it
	bsr.w	DisplaySprite

RunObjectDisplayOnly2:
	lea	$40(a0),a0 ; load 0bj address
	dbf	d7,RunObjectDisplayOnly
	rts
; End of function RunObjectDisplayOnly

; ===========================================================================
; ---------------------------------------------------------------------------
; Object pointers
; ---------------------------------------------------------------------------
Obj_Index:
	include "_inc\Object pointers.asm"

; ---------------------------------------------------------------------------
; Subroutine to	make an	object fall downwards, increasingly fast
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectFall:
		move.b	0(a0),d0
		move.b	($FFFFB000).w,d1
		cmp.b 	d0,d1 ; is Sonic object?
		bne.s   ObjectFall_NotSonic	 ; if is, branch
		cmpi.b 	#0,$1A(a0) ; is running/walking animation?
		bne.s   ObjectFall_NotSonic  ; if not, dont make rolling ani (to prevent from being in rolling ani when died, jumped from spring, etc.)
		move.b #$C,$1C(a0)  ; use falling animation
		bset #2,$22(a0)			  ; set in air flag, to enable in air moves

ObjectFall_NotSonic:			  
		move.w	$10(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,8(a0)
		move.w	$12(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,$C(a0)
		addi.w	#$38,$12(a0)	; increase vertical speed

ObjectFall_Done:
		rts	

ObjectFall2:
		move.w	$10(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,8(a0)
		move.w	$12(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,$C(a0)
		rts	


; End of function ObjectFall

; ---------------------------------------------------------------------------
; Subroutine translating object	speed to update	object position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SpeedToPos:
		move.w	$10(a0),d0	; load horizontal speed
		ext.l	d0
		lsl.l	#8,d0		; multiply speed by $100
		add.l	d0,8(a0)	; add to x-axis	position
		move.w	$12(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		add.l	d0,$C(a0)	; add to y-axis	position
		rts	s	
; End of function SpeedToPos

; ---------------------------------------------------------------------------
; Subroutine to	display	a sprite/object, when a0 is the	object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DisplaySprite:
		lea	($FFFFAC00).w,a1
		adda.w	$18(a0),a1
		cmpi.w	#$7E,(a1)
		bcc.s	locret_D620
		addq.w	#2,(a1)
		adda.w	(a1),a1
		move.w	a0,(a1)
		bset	#6,1(a0)	; ++ setup display flag

locret_D620:
		rts	
; End of function DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	display	a 2nd sprite/object, when a1 is	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DisplaySprite2:
		lea	($FFFFAC00).w,a2
		adda.w	$18(a1),a2
		cmpi.w	#$7E,(a2)
		bcc.s	locret_D63E
		addq.w	#2,(a2)
		adda.w	(a2),a2
		move.w	a1,(a2)
		bset	#6,1(a0)	; ++ setup display flag

locret_D63E:
		rts	
; End of function DisplaySprite2

DisplaySprite3:				; CODE XREF: ROM:0000F688j
					; ROM:0000FCB8j ...
		lea	($FFFFAC00).w,a1
		adda.w	d0,a1
		cmpi.w	#$7E,(a1) ; '~'
		bcc.s	locret_16542
		addq.w	#2,(a1)
		adda.w	(a1),a1
		move.w	a0,(a1)

locret_16542:				; CODE XREF: ROM:0001653Aj
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	delete an object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeleteObject:
		movea.l	a0,a1

DeleteObject2:
		moveq	#0,d1
		moveq	#$F,d0

loc_D646:
		move.l	d1,(a1)+	; clear	the object RAM
		dbf	d0,loc_D646	; repeat $F times (length of object RAM)
		rts	
; End of function DeleteObject

; ===========================================================================
BldSpr_ScrPos:	dc.l 0			; blank
		dc.l $FFF700		; main screen x-position
		dc.l $FFF708		; background x-position	1
		dc.l $FFF718		; background x-position	2
; ---------------------------------------------------------------------------
; Subroutine to	convert	mappings (etc) to proper Megadrive sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BuildSprites:				; XREF: TitleScreen; et al
		lea	($FFFFF800).w,a2 ; set address for sprite table
		moveq	#0,d5
		moveq	#0,d4
		tst.b	($FFFFF74F).w
		beq.s	BuildSpritesCont
		bsr.w	BuildRings

BuildSpritesCont:
		lea	($FFFFAC00).w,a4
		moveq	#7,d7

loc_D66A:
		tst.w	(a4)
		beq.w	loc_D72E
		moveq	#2,d6

loc_D672:
		movea.w	(a4,d6.w),a0
		tst.b	(a0)
		beq.w	loc_D726
		btst	#6,1(a0)	; ++ is object already processed?
		beq.w	loc_D726	; ++ if yes, branch
		bclr	#6,1(a0)	; ++ clear display flag
		bclr	#7,1(a0)
		move.b	1(a0),d0
		move.b	d0,d4
		andi.w	#$C,d0
		beq.s	loc_D6DE
		movea.l	BldSpr_ScrPos(pc,d0.w),a1
		moveq	#0,d0
		move.b	$14(a0),d0
		move.w	8(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1
		bmi.w	loc_D726
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#$140,d1
		bge.s	loc_D726
		addi.w	#$80,d3
		btst	#4,d4
		beq.s	loc_D6E8
		moveq	#0,d0
		move.b	$16(a0),d0
		move.w	$C(a0),d2
		sub.w	4(a1),d2
		move.w	d2,d1
		add.w	d0,d1
		bmi.s	loc_D726
		move.w	d2,d1
		sub.w	d0,d1
		cmpi.w	#$E0,d1
		bge.s	loc_D726
		addi.w	#$80,d2
		bra.s	loc_D700
; ===========================================================================

loc_D6DE:
		move.w	$A(a0),d2
		move.w	8(a0),d3
		bra.s	loc_D700
; ===========================================================================

loc_D6E8:
		move.w	$C(a0),d2
		sub.w	4(a1),d2
		addi.w	#$80,d2
		cmpi.w	#$60,d2
		bcs.s	loc_D726
		cmpi.w	#$180,d2
		bcc.s	loc_D726

loc_D700:
		movea.l	4(a0),a1
		moveq	#0,d1
		btst	#5,d4
		bne.s	loc_D71C
		move.b	$1A(a0),d1
		add.w	d1,d1					; MJ: changed from byte to word (we want more than 7F sprites)
		adda.w	(a1,d1.w),a1
		moveq	#$00,d1					; MJ: clear d1 (because of our byte to word change)
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_D720


loc_D71C:
		bsr.w	sub_D750

loc_D720:
		bset	#7,1(a0)

loc_D726:
		addq.w	#2,d6
		subq.w	#2,(a4)
		bne.w	loc_D672

loc_D72E:
		lea	$80(a4),a4
		dbf	d7,loc_D66A
		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_D748
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_D748:
		move.b	#0,-5(a2)
		rts	
; End of function BuildSprites


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D750:				; XREF: BuildSprites
		movea.w	2(a0),a3
		btst	#0,d4
		bne.s	loc_D796
		btst	#1,d4
		bne.w	loc_D7E4
; End of function sub_D750


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D762:				; XREF: sub_D762; SS_ShowLayout
		cmpi.b	#$50,d5
		beq.s	locret_D794
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D78E
		addq.w	#1,d0

loc_D78E:
		move.w	d0,(a2)+
		dbf	d1,sub_D762

locret_D794:
		rts	
; End of function sub_D762

; ===========================================================================

loc_D796:
		btst	#1,d4
		bne.w	loc_D82A

loc_D79E:
		cmpi.b	#$50,d5
		beq.s	locret_D7E2
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D7DC
		addq.w	#1,d0

loc_D7DC:
		move.w	d0,(a2)+
		dbf	d1,loc_D79E

locret_D7E2:
		rts	
; ===========================================================================

loc_D7E4:				; XREF: sub_D750
		cmpi.b	#$50,d5
		beq.s	locret_D828
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1000,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D822
		addq.w	#1,d0

loc_D822:
		move.w	d0,(a2)+
		dbf	d1,loc_D7E4

locret_D828:
		rts	
; ===========================================================================

loc_D82A:
		cmpi.b	#$50,d5
		beq.s	locret_D87C
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D876
		addq.w	#1,d0

loc_D876:
		move.w	d0,(a2)+
		dbf	d1,loc_D82A

locret_D87C:
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	check if an object is on the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen:
		move.w	8(a0),d0	; get object x-position
		sub.w	($FFFFF700).w,d0 ; subtract screen x-position
		bmi.s	NotOnScreen
		cmpi.w	#320,d0		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		move.w	$C(a0),d1	; get object y-position
		sub.w	($FFFFF704).w,d1 ; subtract screen y-position
		bmi.s	NotOnScreen
		cmpi.w	#224,d1		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		moveq	#0,d0		; set flag to 0
		rts	
; ===========================================================================

NotOnScreen:				; XREF: ChkObjOnScreen
		moveq	#1,d0		; set flag to 1
		rts	
; End of function ChkObjOnScreen


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen2:
		moveq	#0,d1
		move.b	$14(a0),d1
		move.w	8(a0),d0
		sub.w	($FFFFF700).w,d0
		add.w	d1,d0
		bmi.s	NotOnScreen2
		add.w	d1,d1
		sub.w	d1,d0
		cmpi.w	#320,d0
		bge.s	NotOnScreen2

		move.w	$C(a0),d1
		sub.w	($FFFFF704).w,d1
		bmi.s	NotOnScreen2
		cmpi.w	#224,d1
		bge.s	NotOnScreen2

		moveq	#0,d0
		rts	
; ===========================================================================

NotOnScreen2:				; XREF: ChkObjOnScreen2
		moveq	#1,d0
		rts	
; End of function ChkObjOnScreen2

; ---------------------------------------------------------------------------
; Objects Manager
; Subroutine to load objects whenever they are close to the screen. Unlike in
; normal s2, in this version every object gets an entry in the respawn table.
; This is necessary to get the additional y-range checks to work.
;
; input variables:
;  -none-
;
; writes:
;  d0, d1, d2
;  d3 = upper boundary to load object
;  d4 = lower boundary to load object
;  d5 = #$FFF, used to filter out object's y position
;  d6 = camera position
;
;  a0 = address in object placement list
;  a3 = address in object respawn table
;  a6 = object loading routine
; ---------------------------------------------------------------------------
; loc_17AA4
ObjPosLoad:
        moveq    #0,d0
        move.b   ($FFFFF76C).w,d0
        jmp    ObjPosLoad_States(pc,d0.w)
; ============== JUMP TABLE    =============================================
ObjPosLoad_States:
        bra.w    ObjPosLoad_Init        ; 0
        bra.w    ObjPosLoad_Main        ; 2
; ============== END JUMP TABLE    =============================================
ObjPosLoad_Init:
        addq.b    #4,($FFFFF76C).w

        lea     ($FFFFD600).w,a0
        moveq   #0,d0
        move.w  #$BF,d1 ; set loop counter
OPL1:
        move.l  d0,(a0)+
        dbf     d1,OPL1
        move.w    ($FFFFFE10).w,d0
		lsl.b	#6,d0			; then this yields $87...
		lsr.w	#4,d0			; and this yields $0002.
        lea    (ObjPos_Index).l,a0    ; load the first pointer in the object layout list pointer index,
        adda.w    (a0,d0.w),a0        ; load the pointer to the current object layout
        ; initialize each object load address with the first object in the layout
        move.l    a0,($FFFFF770).w
        move.l    a0,($FFFFF774).w
        lea    ($FFFFD600).w,a3
        move.w    ($FFFFF700).w,d6
        subi.w    #$80,d6    ; look one chunk to the left
        bcc.s    OPL2    ; if the result was negative,
        moveq    #0,d6    ; cap at zero
OPL2:    andi.w    #$FF80,d6    ; limit to increments of $80 (width of a chunk)
        movea.l    ($FFFFF770).w,a0    ; get first object in layout
OPL3:    ; at the beginning of a level this gives respawn table entries to any object that is one chunk
        ; behind the left edge of the screen that needs to remember its state (Monitors, Badniks, etc.)
        cmp.w    (a0),d6        ; is object's x position >= d6?
        bls.s    OPL4        ; if yes, branch
        addq.w    #6,a0    ; next object
        addq.w    #1,a3    ; respawn index of next object going right
        bra.s    OPL3
; ===========================================================================
OPL4:    move.l    a0,($FFFFF770).w    ; remember rightmost object that has been processed, so far (we still need to look forward)
        move.w    a3,($FFFFF778).w    ; and its respawn table index
        lea    ($FFFFD600).w,a3    ; reset a3
        movea.l    ($FFFFF774).w,a0    ; reset a0
        subi.w    #$80,d6        ; look even farther left (any object behind this is out of range)
        bcs.s    OPL6        ; branch, if camera position would be behind level's left boundary
OPL5:    ; count how many objects are behind the screen that are not in range and need to remember their state
        cmp.w    (a0),d6        ; is object's x position >= d6?
        bls.s    OPL6        ; if yes, branch
        addq.w    #6,a0
        addq.w    #1,a3    ; respawn index of next object going left
        bra.s    OPL5    ; continue with next object
; ===========================================================================
OPL6:    move.l    a0,($FFFFF774).w    ; remember current object from the left
        move.w    a3,($FFFFF77C).w    ; and its respawn table index
        move.w    #-1,($FFFFF76E).w    ; make sure ObjPosLoad_GoingForward is run
        move.w    ($FFFFF704).w,d0
        andi.w    #$FF80,d0
        move.w    d0,($FFFFFE2A).w    ; make sure the Y check isn't run unnecessarily during initialization
; ===========================================================================
ObjPosLoad_Main:
        ; get coarse camera position

        move.w    ($FFFFF700).w,d1
        subi.w    #$80,d1
        andi.w    #$FF80,d1
        move.w    d1,($FFFFFFEA).w
        tst.w    ($FFFFF72E).w    ; does this level y-wrap?
        bpl.s    ObjMan_Main_NoYWrap    ; if not, branch
        lea    (ChkLoadObj_YWrap).l,a6    ; set object loading routine
        move.w    ($FFFFF704).w,d3
        andi.w    #$FF80,d3    ; get coarse value
        move.w    d3,d4
        addi.w    #$200,d4    ; set lower boundary
        subi.w    #$80,d3        ; set upper boundary
        bpl.s    OPL7        ; branch, if upper boundary > 0
        andi.w    #$7FF,d3    ; wrap value
        bra.s    ObjMan_Main_Cont
; ===========================================================================
OPL7:    move.w    #$7FF,d0
        addq.w    #1,d0
        cmp.w    d0,d4
        bls.s    OPL8        ; branch, if lower boundary < $7FF
        andi.w    #$7FF,d4    ; wrap value
        bra.s    ObjMan_Main_Cont
; ===========================================================================
ObjMan_Main_NoYWrap:
        move.w    ($FFFFF704).w,d3
        andi.w    #$FF80,d3    ; get coarse value
        move.w    d3,d4
        addi.w    #$200,d4    ; set lower boundary
        subi.w    #$80,d3        ; set upper boundary
        bpl.s    OPL8
        moveq    #0,d3    ; no negative values allowed
OPL8:   lea    (ChkLoadObj).l,a6    ; set object loading routine
ObjMan_Main_Cont:
        move.w    #$FFF,d5    ; this will be used later when we load objects
        move.w    ($FFFFF700).w,d6
        andi.w    #$FF80,d6
        cmp.w    ($FFFFF76E).w,d6    ; is the X range the same as last time?
        beq.w    ObjPosLoad_SameXRange    ; if yes, branch
        bge.s    ObjPosLoad_GoingForward    ; if new pos is greater than old pos, branch
        ; if the player is moving back
        move.w    d6,($FFFFF76E).w    ; remember current position for next time
        movea.l    ($FFFFF774).w,a0    ; get current object going left
        movea.w    ($FFFFF77C).w,a3    ; and its respawn table index
        subi.w    #$80,d6            ; look one chunk to the left
        bcs.s    ObjMan_GoingBack_Part2    ; branch, if camera position would be behind level's left boundary
        jsr    (SingleObjLoad).l        ; find an empty object slot
        bne.s    ObjMan_GoingBack_Part2        ; branch, if there are none
OPL9:    ; load all objects left of the screen that are now in range
        cmp.w    -6(a0),d6        ; is the previous object's X pos less than d6?
        bge.s    ObjMan_GoingBack_Part2    ; if it is, branch
        subq.w    #6,a0        ; get object's address
        subq.w    #1,a3        ; and respawn table index
        jsr    (a6)        ; load object
        bne.s    OPL10        ; branch, if SST is full
        subq.w    #6,a0
        bra.s    OPL9    ; continue with previous object
; ===========================================================================
OPL10:    ; undo a few things, if the object couldn't load
        addq.w    #6,a0    ; go back to last object
        addq.w    #1,a3    ; since we didn't load the object, undo last change
ObjMan_GoingBack_Part2:
        move.l    a0,($FFFFF774).w    ; remember current object going left
        move.w    a3,($FFFFF77C).w    ; and its respawn table index
        movea.l    ($FFFFF770).w,a0    ; get next object going right
        movea.w    ($FFFFF778).w,a3    ; and its respawn table index
        addi.w    #$300,d6    ; look two chunks beyond the right edge of the screen
OPL11:    ; subtract number of objects that have been moved out of range (from the right side)
        cmp.w    -6(a0),d6    ; is the previous object's X pos less than d6?
        bgt.s    OPL12        ; if it is, branch
        subq.w    #6,a0        ; get object's address
        subq.w    #1,a3        ; and respawn table index
        bra.s    OPL11    ; continue with previous object
; ===========================================================================
OPL12:    move.l    a0,($FFFFF770).w    ; remember next object going right
        move.w    a3,($FFFFF778).w    ; and its respawn table index
        bra.s    ObjPosLoad_SameXRange
; ===========================================================================
ObjPosLoad_GoingForward:
        move.w    d6,($FFFFF76E).w
        movea.l    ($FFFFF770).w,a0    ; get next object from the right
        movea.w ($FFFFF778).w,a3    ; and its respawn table index
        addi.w    #$280,d6    ; look two chunks forward
        jsr    (SingleObjLoad).l        ; find an empty object slot
        bne.s    ObjMan_GoingForward_Part2    ; branch, if there are none
OPL13:    ; load all objects right of the screen that are now in range
        cmp.w    (a0),d6                ; is object's x position >= d6?
        bls.s    ObjMan_GoingForward_Part2    ; if yes, branch
        jsr    (a6)        ; load object (and get address of next object)
        addq.w    #1,a3        ; respawn index of next object to the right
        beq.s    OPL13    ; continue loading objects, if the SST isn't full
ObjMan_GoingForward_Part2:
        move.l    a0,($FFFFF770).w    ; remember next object from the right
        move.w    a3,($FFFFF778).w    ; and its respawn table index
        movea.l    ($FFFFF774).w,a0    ; get current object from the left
        movea.w    ($FFFFF77C).w,a3    ; and its respawn table index
        subi.w    #$300,d6        ; look one chunk behind the left edge of the screen
        bcs.s    ObjMan_GoingForward_End    ; branch, if camera position would be behind level's left boundary
OPL14:    ; subtract number of objects that have been moved out of range (from the left)
        cmp.w    (a0),d6            ; is object's x position >= d6?
        bls.s    ObjMan_GoingForward_End    ; if yes, branch
        addq.w    #6,a0    ; next object
        addq.w    #1,a3    ; respawn index of next object to the left
        bra.s    OPL14    ; continue with next object
; ===========================================================================

ObjMan_GoingForward_End:
        move.l    a0,($FFFFF774).w    ; remember current object from the left
        move.w    a3,($FFFFF77C).w    ; and its respawn table index
ObjPosLoad_SameXRange:
        move.w    ($FFFFF704).w,d6
        andi.w    #$FF80,d6
        move.w    d6,d3
        cmp.w    ($FFFFFE2A).w,d6    ; is the y range the same as last time?
        beq.w    ObjPosLoad_SameYRange    ; if yes, branch
        bge.s    ObjPosLoad_GoingDown    ; if the player is moving down
        ; if the player is moving up
        tst.w    ($FFFFF72E).w    ; does the level y-wrap?
        bpl.s    ObjMan_GoingUp_NoYWrap    ; if not, branch
        tst.w    d6
        bne.s    ObjMan_GoingUp_YWrap
        cmpi.w    #$80,($FFFFFE2A).w
        bne.s    ObjMan_GoingDown_YWrap
ObjMan_GoingUp_YWrap:
        subi.w    #$80,d3            ; look one chunk up
        bpl.s    ObjPosLoad_YCheck    ; go to y check, if camera y position >= $80
        andi.w    #$7FF,d3        ; else, wrap value
        bra.s    ObjPosLoad_YCheck
; ===========================================================================
ObjMan_GoingUp_NoYWrap:
        subi.w    #$80,d3                ; look one chunk up
        bmi.w    ObjPosLoad_SameYRange    ; don't do anything if camera y position is < $80
        bra.s    ObjPosLoad_YCheck
; ===========================================================================
ObjPosLoad_GoingDown:
        tst.w    ($FFFFF72E).w        ; does the level y-wrap?
        bpl.s    ObjMan_GoingDown_NoYWrap    ; if not, branch
        tst.w    ($FFFFFE2A).w
        bne.s    ObjMan_GoingDown_YWrap
        cmpi.w    #$80,d6
        bne.s    ObjMan_GoingUp_YWrap
ObjMan_GoingDown_YWrap:
        addi.w    #$180,d3        ; look one chunk down
        cmpi.w    #$7FF,d3
        bcs.s    ObjPosLoad_YCheck    ; go to  check, if camera y position < $7FF
        andi.w    #$7FF,d3        ; else, wrap value
        bra.s    ObjPosLoad_YCheck
; ===========================================================================
ObjMan_GoingDown_NoYWrap:
        addi.w    #$180,d3            ; look one chunk down
        cmpi.w    #$7FF,d3
        bhi.w    ObjPosLoad_SameYRange    ; don't do anything, if camera is too close to bottom
ObjPosLoad_YCheck:
        jsr    (SingleObjLoad).l        ; get an empty object slot
        bne.w    ObjPosLoad_SameYRange    ; branch, if there are none
        move.w    d3,d4
        addi.w    #$80,d4
        move.w    #$FFF,d5    ; this will be used later when we load objects
        movea.l    ($FFFFF774).w,a0    ; get next object going left
        movea.w    ($FFFFF77C).w,a3    ; and its respawn table index
        move.l    ($FFFFF770).w,d7    ; get next object going right
        sub.l    a0,d7    ; d7 = number of objects between the left and right boundaries * 6
        beq.s    ObjPosLoad_SameYRange    ; branch if there are no objects inbetween
        addq.w    #2,a0    ; align to object's y position
OPL15:    ; check, if current object needs to be loaded
        tst.b    (a3)    ; is object already loaded?
        bmi.s    OPL16    ; if yes, branch
        move.w    (a0),d1
        and.w    d5,d1    ; get object's y position
        cmp.w    d3,d1
        blo.s    OPL16    ; branch, if object is out of range from the top
        cmp.w    d4,d1
        bhi.s    OPL16    ; branch, if object is out of range from the bottom
        bset    #7,(a3)    ; mark object as loaded
        ; load object
        move.w    -2(a0),8(a1)
        move.w    (a0),d1
        move.w    d1,d2
        and.w    d5,d1    ; get object's y position
        move.w    d1,$C(a1)
        rol.w    #2,d2
        andi.w    #3,d2    ; get object's render flags and status
        move.b    d2,1(a1)
        move.b    d2,$22(a1)
        moveq	#0,d2
		move.b	2(a0),d2
		andi.b	#$7F,d2
		move.b	d2,0(a1)
        moveq	#0,d2
        move.b    3(a0),$28(a1)
        move.w    a3,$1E(a1)
        jsr    (SingleObjLoad).l    ; find new object slot
        bne.s    ObjPosLoad_SameYRange    ; brach, if there are none left
OPL16:
        addq.w    #6,a0    ; address of next object
        addq.w    #1,a3    ; and its respawn index
        subq.w    #6,d7    ; subtract from size of remaining objects
        bne.s    OPL15    ; branch, if there are more
ObjPosLoad_SameYRange:
        move.w    d6,($FFFFFE2A).w
        rts   
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutines to check if an object needs to be loaded,
; with and without y-wrapping enabled.
;
; input variables:
;  d3 = upper boundary to load object
;  d4 = lower boundary to load object
;  d5 = #$FFF, used to filter out object's y position
;
;  a0 = address in object placement list
;  a1 = object
;  a3 = address in object respawn table
;
; writes:
;  d1, d2, d7
; ---------------------------------------------------------------------------
ChkLoadObj_YWrap:
        tst.b    (a3)    ; is object already loaded?
        bpl.s    OPL17    ; if not, branch
        addq.w    #6,a0    ; address of next object
        moveq    #0,d1    ; let the objects manager know that it can keep going
        rts
; ===========================================================================
OPL17:    move.w    (a0)+,d7    ; x_pos
        move.w    (a0)+,d1    ; there are three things stored in this word
        move.w    d1,d2    ; does this object skip y-Checks?
        bmi.s    OPL18    ; if yes, branch
        and.w    d5,d1    ; y_pos
        cmp.w    d3,d1
        bcc.s    LoadObj_YWrap
        cmp.w    d4,d1
        bls.s    LoadObj_YWrap
        addq.w    #2,a0    ; address of next object
        moveq    #0,d1    ; let the objects manager know that it can keep going
        rts
; ===========================================================================
OPL18:    and.w    d5,d1    ; y_pos
LoadObj_YWrap:
        bset    #7,(a3)    ; mark object as loaded
        move.w    d7,8(a1)
        move.w    d1,$C(a1)
        rol.w    #2,d2    ; adjust bits
        andi.w    #3,d2    ; get render flags and status
        move.b    d2,1(a1)
        move.b    d2,$22(a1)
        moveq	#0,d0
		move.b	(a0)+,d0
		move.b	d0,0(a1)
        move.b    (a0)+,$28(a1)
        move.w    a3,$1E(a1)
        bra.s    SingleObjLoad    ; find new object slot
;loc_17F36
ChkLoadObj:
        tst.b    (a3)    ; is object already loaded?
        bpl.s    OPL19    ; if not, branch
        addq.w    #6,a0    ; address of next object
        moveq    #0,d1    ; let the objects manager know that it can keep going
        rts
; ===========================================================================
OPL19:    move.w    (a0)+,d7    ; x_pos
        move.w    (a0)+,d1    ; there are three things stored in this word
        move.w    d1,d2    ; does this object skip y-Checks?    ;*6
        bmi.s    OPL21    ; if yes, branch
        and.w    d5,d1    ; y_pos
        cmp.w    d3,d1
        bcs.s    OPL20    ; branch, if object is out of range from the top
        cmp.w    d4,d1
        bls.s    LoadObj    ; branch, if object is in range from the bottom
OPL20:
        addq.w    #2,a0    ; address of next object
        moveq    #0,d1
        rts   
; ===========================================================================
OPL21:    and.w    d5,d1    ; y_pos
LoadObj:
        bset    #7,(a3)    ; mark object as loaded
        move.w    d7,8(a1)
        move.w    d1,$C(a1)
        rol.w    #2,d2    ; adjust bits
        andi.w    #3,d2    ; get render flags and status
        move.b    d2,1(a1)
        move.b    d2,$22(a1)
        moveq	#0,d0
        move.b	(a0)+,d0
		move.b	d0,0(a1)
        move.b    (a0)+,d0
        move.b	d0,$28(a1)
        move.w    a3,$1E(a1)
        ; continue straight to SingleObjLoad
; End of function ChkLoadObj

; ===========================================================================
; ---------------------------------------------------------------------------
; Single object	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad:
		lea	($FFFFB800).w,a1 ; start address for object RAM
		move.w	#$5F,d0

loc_DA94:
		tst.b	(a1)		; is object RAM	slot empty?
		beq.s	locret_DAA0	; if yes, branch
		lea	$40(a1),a1	; goto next object RAM slot
		dbf	d0,loc_DA94	; repeat $5F times

locret_DAA0:
		rts	
; End of function SingleObjLoad


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad2:
		movea.l	a0,a1
		move.w	#-$1000,d0
		sub.w	a0,d0
		lsr.w	#6,d0
		subq.w	#1,d0
		bcs.s	locret_DABC

loc_DAB0:
		tst.b	(a1)
		beq.s	locret_DABC
		lea	$40(a1),a1
		dbf	d0,loc_DAB0

locret_DABC:
		rts	
; End of function SingleObjLoad2

LoadChildObject:
	jsr	(SingleObjLoad2).l
	bne.s	LoadChildObject2	; rts
	move.w	(a2)+,d0
	move.w	a1,(a0,d0.w) ; store pointer to child in parent's SST
	move.b	(a2)+,1(a1) ; load obj
	move.b	(a2)+,$28(a1)
	move.w	a0,$2C(a1) ; store pointer to parent in child's SST
	move.w	8(a0),8(a1)
	move.w	$C(a0),$C(a1)

LoadChildObject2:
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to destroy all enemies/monitors/etc on screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DestroyEnemiesUW:
		lea	($FFFFB800).w,a1			; load start of level object ram
		moveq	#$5F,d6					; set repeat times

DE_CheckNext:
		tst.b	(a1)					; is the object valid?
		beq	DE_NextObject				; if not, branch
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a1),d0	; is bubble maker underwater?
		bcc	DE_NextObject				; if not, branch
		lea	DE_BossList(pc),a2			; load start of boss ID list
		bra	DE_CheckBoss				; continue

DE_NoEndList:
		cmp.b	(a1),d0					; is it a boss?
		beq	DE_NextObject				; if so, branch

DE_CheckBoss:
		move.b	(a2)+,d0				; load boss ID
		bne	DE_NoEndList				; if it's not the end of the list, branch
		cmpi.b	#$5F,(a1)				; is it a bomb fuse?
		bne	DE_NoBombFuse				; if not, branch
		cmpi.b	#$04,$28(a1)				; is it a fuse and not the bomb?
		beq	DE_DestroyNoAnimal			; if so, branch

DE_NoBombFuse:
		tst.b	$01(a1)					; is the object displayed on screen?
		bpl	DE_NextObject				; if not, branch
		cmpi.b	#$20,(a1)				; is it the ball of a ball hog?
		beq	DE_DestroyNoAnimal			; if so, branch
		cmpi.b	#$5F,(a1)				; is it a bomb?
		bne	DE_NoBomb				; if not, branch

DE_DestroyNoAnimal:
		move.b	#$3F,(a1)				; change bomb into an explosion object
		sf.b	$24(a1)					; clear routine counter
		bra	DE_NextObject				; skip for next object

DE_NoBomb:
		cmpi.b	#$26,(a1)				; is it a monitor?
		bne	DE_NoMonitor				; if not, branch
		cmpi.b	#$04,$24(a1)				; is the monitor destroyed?
		bge	DE_NextObject				; if so, branch
		move.b	#$04,$24(a1)				; set to correct destory routine
		bra	DE_NextObject				; skip for next object

DE_NoMonitor:
		cmpi.b	#$50,(a1)				; is it a yadrin?
		beq	DE_Destory				; if so, branch
		move.b	$20(a1),d0				; load touch type
		beq	DE_NextObject				; if it's not valid, branch
		andi.b	#$C0,d0					; get only types
		bne	DE_NextObject				; if it's not an enemie, branch

DE_Destory:
		movem.l	d0-a6,-(sp)				; store register data
		move.w	$12(a0),-(sp)				; store Y speed
		clr.w	$12(a0)					; set no Y speed
		jsr	touch_killenemy				; run destroy code
		move.w	(sp)+,$12(a0)				; reload Y speed
		movem.l	(sp)+,d0-a6				; reload register data

DE_NextObject:
		lea	$40(a1),a1				; advance to next object slot
		dbf	d6,DE_CheckNext				; repeat til all object slots are done
		rts						; return
; ===========================================================================

; ---------------------------------------------------------------------------
; Boss ID's to check (00 means end of list)
; ---------------------------------------------------------------------------

DE_BossList:	dc.b	$3D,$73,$75,$77,$7A,$82,$85,$00
		even
; ----------------------------------------------------------------------------
; Object
;
; Spring
; ----------------------------------------------------------------------------

Obj41:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_1889C(pc,d0.w),d1
		jsr	off_1889C(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
off_1889C:	dc.w Obj41_loc_188A8-off_1889C; 0 ; DATA XREF: h+1928o h+192Ao ...
		dc.w Obj41_loc_18980-off_1889C; 1
		dc.w Obj41_loc_18A70-off_1889C; 2
		dc.w Obj41_loc_18C80-off_1889C; 3
		dc.w Obj41_loc_18D6A-off_1889C; 4
		dc.w Obj41_loc_18E9E-off_1889C; 5
; ===========================================================================

Obj41_loc_188A8:				; DATA XREF: h+1928o
		addq.b	#2,$24(a0)
		move.l	#MapUnc_1901C,4(a0)
		move.w	#$45C,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		move.w	off_188DE(pc,d0.w),d0
		jmp	off_188DE(pc,d0.w)
; ===========================================================================
off_188DE:	dc.w Obj41_loc_18954-off_188DE; 0 ; DATA XREF: h+196Ao h+196Co ...
		dc.w Obj41_loc_188E8-off_188DE; 1
		dc.w Obj41_loc_18908-off_188DE; 2
		dc.w Obj41_loc_1891C-off_188DE; 3
		dc.w Obj41_loc_18936-off_188DE; 4
; ===========================================================================

Obj41_loc_188E8:				; DATA XREF: h+196Ao
		move.b	#4,$24(a0)
		move.b	#2,$1C(a0)
		move.b	#3,$1A(a0)
		move.w	#$470,2(a0)
		move.b	#8,$14(a0)
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_18908:				; DATA XREF: h+196Ao
		move.b	#6,$24(a0)
		move.b	#6,$1A(a0)
		bset	#1,$22(a0)
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_1891C:				; DATA XREF: h+196Ao
		move.b	#8,$24(a0)
		move.b	#4,$1C(a0)
		move.b	#7,$1A(a0)
		move.w	#$444,2(a0)
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_18936:				; DATA XREF: h+196Ao
		move.b	#$A,$24(a0)
		move.b	#4,$1C(a0)
		move.b	#$A,$1A(a0)
		move.w	#$444,2(a0)
		bset	#1,$22(a0)

Obj41_loc_18954:				; CODE XREF: h+1992j h+19A6j ...
		move.b	$28(a0),d0
		andi.w	#2,d0
		move.w	word_1897C(pc,d0.w),$30(a0)
		btst	#1,d0
		beq.s	Obj41_loc_18976
		bset	#5,2(a0)
		move.l	#MapUnc_19032,4(a0)

Obj41_loc_18976:				; CODE XREF: h+19F2j
		rts	
; ===========================================================================
word_1897C:	dc.w $F000		; 0
		dc.w $F600		; 1
; ===========================================================================

Obj41_loc_18980:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	8(a0),d4
		lea	($FFFFB000).w,a1
		bsr.w	SolidObject
		btst	#3,$22(a0)
		beq.s	Obj41_loc_189A8
		bsr.s	Obj41_loc_189CA

Obj41_loc_189A8:				; CODE XREF: h+1A30j

Obj41_loc_189C0:				; CODE XREF: h+1A48j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_189CA:				; CODE XREF: h+1A32p h+1A4Ap
		move.w	#$100,$1C(a0)
		addq.w	#8,$C(a1)
		move.w	$30(a0),$12(a1)
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#$10,$1C(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_189FE
		move.w	#0,$10(a1)

Obj41_loc_189FE:				; CODE XREF: h+1A82j
		btst	#0,d0
		beq.s	Obj41_loc_18A3E
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#0,$2C(a1)
	;	move.b	#4,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18A2E
	;	move.b	#1,$2C(a1)

Obj41_loc_18A2E:				; CODE XREF: h+1AB2j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18A3E
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18A3E:				; CODE XREF: h+1A8Ej h+1AC0j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18A54
		move.b	#$C,($FFFFFFD8).w
		move.b	#$D,($FFFFFFD9).w

Obj41_loc_18A54:				; CODE XREF: h+1AD2j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18A66
		move.b	#$E,($FFFFFFD8).w
		move.b	#$F,($FFFFFFD9).w

Obj41_loc_18A66:				; CODE XREF: h+1AE4j
		move.w	#$B1,d0	; 'ร'
		jmp	(PlaySound).l
; ===========================================================================

Obj41_loc_18A70:				; DATA XREF: h+1928o
		move.w	#$13,d1
		move.w	#$E,d2
		move.w	#$F,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		btst	#5,$22(a0)
		beq.s	Obj41_loc_18AB0
		move.b	$22(a0),d1
		move.w	8(a0),d0
		sub.w	8(a1),d0
		bcs.s	Obj41_loc_18AA8
		eori.b	#1,d1

Obj41_loc_18AA8:				; CODE XREF: h+1B2Ej
		andi.b	#1,d1
		bne.s	Obj41_loc_18AB0
		bsr.s	Obj41_loc_18AEE

Obj41_loc_18AB0:				; CODE XREF: h+1B20j h+1B38j

Obj41_loc_18AE0:				; CODE XREF: h+1B50j h+1B68j
		bsr.w	Obj41_loc_18BC6
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18AEE:				; CODE XREF: h+1B3Ap h+1B6Ap ...
		move.w	#$300,$1C(a0)
		move.w	$30(a0),$10(a1)
		addq.w	#8,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18B1C
		bclr	#0,$22(a1)
		subi.w	#$10,8(a1)
		neg.w	$10(a1)

Obj41_loc_18B1C:				; CODE XREF: h+1B96j
	;	move.w	#$F,$2E(a1)
		move.w	$10(a1),$20(a1)
		btst	#2,$22(a1)
		bne.s	Obj41_loc_18B36
		move.b	#0,$1C(a1)
		cmpi.b	#1,($FFFFB000).w
		beq.s	Obj41_loc_18B36
		move.b	#3,$1C(a1)

Obj41_loc_18B36:				; CODE XREF: h+1BBAj
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_18B42
		move.w	#0,$12(a1)

Obj41_loc_18B42:				; CODE XREF: h+1BC6j
		btst	#0,d0
		beq.s	Obj41_loc_18B82
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18B72
	;	move.b	#3,$2C(a1)

Obj41_loc_18B72:				; CODE XREF: h+1BF6j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18B82
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18B82:				; CODE XREF: h+1BD2j h+1C04j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18B98
		move.b	#$C,($FFFFFFD8).w
		move.b	#$D,($FFFFFFD9).w

Obj41_loc_18B98:				; CODE XREF: h+1C16j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18BAA
		move.b	#$E,($FFFFFFD8).w
		move.b	#$F,($FFFFFFD9).w

Obj41_loc_18BAA:				; CODE XREF: h+1C28j
		bclr	#5,$22(a0)
		bclr	#6,$22(a0)
		bclr	#5,$22(a1)
		move.w	#$B1,d0	; 'ร'
		jmp	(PlaySound).l
; ===========================================================================

Obj41_loc_18BC6:				; CODE XREF: h+1B6Cp
		cmpi.b	#3,$1C(a0)
		beq.w	Obj41_locret_18C7E
		move.w	8(a0),d0
		move.w	d0,d1
		addi.w	#$28,d1	; '('
		btst	#0,$22(a0)
		beq.s	Obj41_loc_18BE8
		move.w	d0,d1
		subi.w	#$28,d0	; '('

Obj41_loc_18BE8:				; CODE XREF: h+1C6Cj
		move.w	$C(a0),d2
		move.w	d2,d3
		subi.w	#$18,d2
		addi.w	#$18,d3
		btst	#1,$22(a1)
		bne.s	Obj41_loc_18C3C
		move.w	$20(a1),d4
		btst	#0,$22(a0)
		beq.s	Obj41_loc_18C10
		neg.w	d4

Obj41_loc_18C10:				; CODE XREF: h+1C98j
		tst.w	d4
		bmi.s	Obj41_loc_18C3C
		move.w	8(a1),d4
		cmp.w	d0,d4
		bcs.w	Obj41_loc_18C3C
		cmp.w	d1,d4
		bcc.w	Obj41_loc_18C3C
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.w	Obj41_loc_18C3C
		cmp.w	d3,d4
		bcc.w	Obj41_loc_18C3C
		move.w	d0,-(sp)
		bsr.w	Obj41_loc_18AEE
		move.w	(sp)+,d0

Obj41_loc_18C3C:				; CODE XREF: h+1C8Cj h+1C9Ej ...

Obj41_locret_18C7E:				; CODE XREF: h+1C58j h+1CD2j ...
		rts	
; ===========================================================================

Obj41_loc_18C80:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	8(a0),d4
		bsr.w	SolidObject

loc_DCA4:
		tst.w	d4
		bmi.s	Obj41_loc_18CC6

Obj41_loc_18CBC:				; CODE XREF: h+1D44j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18CC6:				; CODE XREF: h+1D30p h+1D46p
		move.w	#$100,$1C(a0)
		subq.w	#8,$C(a1)
		move.w	$30(a0),$12(a1)
		neg.w	$12(a1)
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_18CE6
		move.w	#0,$10(a1)

Obj41_loc_18CE6:				; CODE XREF: h+1D6Aj
		btst	#0,d0
		beq.s	Obj41_loc_18D26
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#0,$2C(a1)
	;	move.b	#4,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18D16
	;	move.b	#1,$2C(a1)

Obj41_loc_18D16:				; CODE XREF: h+1D9Aj
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18D26
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18D26:				; CODE XREF: h+1D76j h+1DA8j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18D3C
		move.b	#$C,($FFFFFFD8).w
		move.b	#$D,($FFFFFFD9).w

Obj41_loc_18D3C:				; CODE XREF: h+1DBAj
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18D4E
		move.b	#$E,($FFFFFFD8).w
		move.b	#$F,($FFFFFFD9).w

Obj41_loc_18D4E:				; CODE XREF: h+1DCCj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		move.w	#$B1,d0	; 'ร'
		jmp	(PlaySound).l
; ===========================================================================

Obj41_loc_18D6A:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	8(a0),d4
		lea	(byte_18FAA,pc),a2
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		jsr	SlopedSolid_SingleCharacter
		btst	#3,$22(a0)
		beq.s	Obj41_loc_18D92
		bsr.s	Obj41_loc_18DB4

Obj41_loc_18D92:				; CODE XREF: h+1E1Aj

Obj41_loc_18DAA:				; CODE XREF: h+1E32j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18DB4:				; CODE XREF: h+1E1Cp h+1E34p
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18DCA
		move.w	8(a0),d0
		subq.w	#4,d0
		cmp.w	8(a1),d0
		bcs.s	Obj41_loc_18DD8
		rts	
; ===========================================================================

Obj41_loc_18DCA:				; CODE XREF: h+1E46j
		move.w	8(a0),d0
		addq.w	#4,d0
		cmp.w	8(a1),d0
		bcc.s	Obj41_loc_18DD8
		rts	
; ===========================================================================

Obj41_loc_18DD8:				; CODE XREF: h+1E52j h+1E60j
		move.w	#$500,$1C(a0)
		move.w	$30(a0),$12(a1)
		move.w	$30(a0),$10(a1)
		addq.w	#6,$C(a1)
		addq.w	#6,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18E10
		bclr	#0,$22(a1)
		subi.w	#$C,8(a1)
		neg.w	$10(a1)

Obj41_loc_18E10:				; CODE XREF: h+1E8Aj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#$10,$1C(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		btst	#0,d0
		beq.s	Obj41_loc_18E6C
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18E5C
	;	move.b	#3,$2C(a1)

Obj41_loc_18E5C:				; CODE XREF: h+1EE0j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18E6C
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18E6C:				; CODE XREF: h+1EBCj h+1EEEj
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18E82
		move.b	#$C,($FFFFFFD8).w
		move.b	#$D,($FFFFFFD9).w

Obj41_loc_18E82:				; CODE XREF: h+1F00j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18E94
		move.b	#$E,($FFFFFFD8).w
		move.b	#$F,($FFFFFFD9).w

Obj41_loc_18E94:				; CODE XREF: h+1F12j
		move.w	#$B1,d0	; 'ร'
		jmp	(PlaySound).l
; ===========================================================================

Obj41_loc_18E9E:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	8(a0),d4
		lea	(byte_18FC6,pc),a2
		moveq	#3,d6
		jsr	SlopedSolid_SingleCharacter

Obj41_loc_18EC4:				; CODE XREF: h+1F4Cj
		tst.w	d4
		bmi.s	Obj41_loc_18EE6

Obj41_loc_18EDA:				; CODE XREF: h+1F62j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18EE6:				; CODE XREF: h+1F4Ep h+1F64p
		move.w	#$500,$1C(a0)
		move.w	$30(a0),$12(a1)
		neg.w	$12(a1)
		move.w	$30(a0),$10(a1)
		subq.w	#6,$C(a1)
		addq.w	#6,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18F22
		bclr	#0,$22(a1)
		subi.w	#$C,8(a1)
		neg.w	$10(a1)

Obj41_loc_18F22:				; CODE XREF: h+1F9Cj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		btst	#0,d0
		beq.s	Obj41_loc_18F78
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18F68
	;	move.b	#3,$2C(a1)

Obj41_loc_18F68:				; CODE XREF: h+1FECj
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18F78
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18F78:				; CODE XREF: h+1FC8j h+1FFAj
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18F8E
		move.b	#$C,($FFFFFFD8).w
		move.b	#$D,($FFFFFFD9).w

Obj41_loc_18F8E:				; CODE XREF: h+200Cj
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18FA0
		move.b	#$E,($FFFFFFD8).w
		move.b	#$F,($FFFFFFD9).w

Obj41_loc_18FA0:				; CODE XREF: h+201Ej
		move.w	#$B1,d0	; 'ร'
		jmp	(PlaySound).l
; ===========================================================================
byte_18FAA:	dc.b $10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10, $E, $C, $A,  8; 0
					; DATA XREF: h+1E02t
		dc.b   6,  4,  2,  0,$FE,$FC,$FC,$FC,$FC,$FC,$FC,$FC; 16
byte_18FC6:	dc.b $F4,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F2,$F4,$F6,$F8; 0
					; DATA XREF: h+1F36t
		dc.b $FA,$FC,$FE,  0,  2,  4,  4,  4,  4,  4,  4,  4; 16
off_18FE2:	dc.w byte_18FEE-off_18FE2; 0 ; DATA XREF: h+1A4Co h+1B70o ...
		dc.w byte_18FF1-off_18FE2; 1
		dc.w byte_18FFD-off_18FE2; 2
		dc.w byte_19000-off_18FE2; 3
		dc.w byte_1900C-off_18FE2; 4
		dc.w byte_1900F-off_18FE2; 5
byte_18FEE:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   0		; 1
		dc.b $FF		; 2
byte_18FF1:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   1		; 1
		dc.b   0		; 2
		dc.b   0		; 3
		dc.b   2		; 4
		dc.b   2		; 5
		dc.b   2		; 6
		dc.b   2		; 7
		dc.b   2		; 8
		dc.b   2		; 9
		dc.b $FD		; 10
		dc.b   0		; 11
byte_18FFD:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   3		; 1
		dc.b $FF		; 2
byte_19000:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   4		; 1
		dc.b   3		; 2
		dc.b   3		; 3
		dc.b   5		; 4
		dc.b   5		; 5
		dc.b   5		; 6
		dc.b   5		; 7
		dc.b   5		; 8
		dc.b   5		; 9
		dc.b $FD		; 10
		dc.b   2		; 11
byte_1900C:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   7		; 1
		dc.b $FF		; 2
byte_1900F:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   8		; 1
		dc.b   7		; 2
		dc.b   7		; 3
		dc.b   9		; 4
		dc.b   9		; 5
		dc.b   9		; 6
		dc.b   9		; 7
		dc.b   9		; 8
		dc.b   9		; 9
		dc.b $FD		; 10
		dc.b   4		; 11
		dc.b   0		; 12
; ----------------------------------------------------------------------------
; Unknown sprite mappings
; ----------------------------------------------------------------------------
Map_Obj41:
MapUnc_1901C:				; DATA XREF: h+1938o h+20A8o ...
		include 	"_maps\obj41r.asm"

; -------------------------------------------------------------------------------
; Unknown Sprite Mappings
; -------------------------------------------------------------------------------
MapUnc_19032:				; DATA XREF: h+19FAo h+20BEo ...
		include 	"_maps\obj41y.asm"

; ===========================================================================
		nop	
; ===========================================================================
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 42 - Newtron enemy (WOZ)
; ---------------------------------------------------------------------------

Obj42:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj42_Index(pc,d0.w),d1
		jmp	Obj42_Index(pc,d1.w)
; ===========================================================================
Obj42_Index:	dc.w Obj42_Main-Obj42_Index
		dc.w Obj42_Action-Obj42_Index
		dc.w Obj42_Delete-Obj42_Index
; ===========================================================================

Obj42_Main:				; XREF: Obj42_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj42,4(a0)
		move.w	#$49B,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$14,$14(a0)
		move.b	#$10,$16(a0)
		move.b	#8,$17(a0)

Obj42_Action:				; XREF: Obj42_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj42_Index2(pc,d0.w),d1
		jsr	Obj42_Index2(pc,d1.w)
		lea	(Ani_obj42).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj42_Index2:	dc.w Obj42_ChkDist-Obj42_Index2
		dc.w Obj42_Type00-Obj42_Index2
		dc.w Obj42_MatchFloor-Obj42_Index2
		dc.w Obj42_Speed-Obj42_Index2
		dc.w Obj42_Type01-Obj42_Index2
; ===========================================================================

Obj42_ChkDist:				; XREF: Obj42_Index2
		bset	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_DDEA
		neg.w	d0
		bclr	#0,$22(a0)

loc_DDEA:
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	the newtron?
		bcc.s	locret_DE12	; if not, branch
		addq.b	#2,$25(a0)
		move.b	#1,$1C(a0)
		tst.b	$28(a0)		; check	object type
		beq.s	locret_DE12	; if type is 00, branch
		move.w	#$249B,2(a0)
		move.b	#8,$25(a0)	; run type 01 newtron subroutine
		move.b	#4,$1C(a0)	; use different	animation

locret_DE12:
		rts	
; ===========================================================================

Obj42_Type00:				; XREF: Obj42_Index2
		cmpi.b	#4,$1A(a0)	; has "appearing" animation finished?
		bcc.s	Obj42_Fall	; is yes, branch
		bset	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	locret_DE32
		bclr	#0,$22(a0)

locret_DE32:
		rts	
; ===========================================================================

Obj42_Fall:				; XREF: Obj42_Type00
		cmpi.b	#1,$1A(a0)
		bne.s	loc_DE42
		move.b	#$C,$20(a0)

loc_DE42:
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1		; has newtron hit the floor?
		bpl.s	locret_DE86	; if not, branch
		add.w	d1,$C(a0)
		move.w	#0,$12(a0)	; stop newtron falling
		addq.b	#2,$25(a0)
		move.b	#2,$1C(a0)
		btst	#5,2(a0)
		beq.s	Obj42_Move
		addq.b	#1,$1C(a0)

Obj42_Move:
		move.b	#$D,$20(a0)
		move.w	#$200,$10(a0)	; move newtron horizontally
		btst	#0,$22(a0)
		bne.s	locret_DE86
		neg.w	$10(a0)

locret_DE86:
		rts	
; ===========================================================================

Obj42_MatchFloor:			; XREF: Obj42_Index2
		bsr.w	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	loc_DEA2
		cmpi.w	#$C,d1
		bge.s	loc_DEA2
		add.w	d1,$C(a0)	; match	newtron's position with floor
		rts	
; ===========================================================================

loc_DEA2:
		addq.b	#2,$25(a0)
		rts	
; ===========================================================================

Obj42_Speed:				; XREF: Obj42_Index2
		bsr.w	SpeedToPos
		rts	
; ===========================================================================

Obj42_Type01:				; XREF: Obj42_Index2
		cmpi.b	#1,$1A(a0)
		bne.s	Obj42_FireMissile
		move.b	#$C,$20(a0)

Obj42_FireMissile:
		cmpi.b	#2,$1A(a0)
		bne.s	locret_DF14
		tst.b	$32(a0)
		bne.s	locret_DF14
		move.b	#1,$32(a0)
		bsr.w	SingleObjLoad
		bne.s	locret_DF14
		move.b	#$23,0(a1)	; load missile object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		subq.w	#8,$C(a1)
		move.w	#$200,$10(a1)
		move.w	#$14,d0
		btst	#0,$22(a0)
		bne.s	loc_DF04
		neg.w	d0
		neg.w	$10(a1)

loc_DF04:
		add.w	d0,8(a1)
		move.b	$22(a0),$22(a1)
		move.b	#1,$28(a1)

locret_DF14:
		rts	
; ===========================================================================

Obj42_Delete:				; XREF: Obj42_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj42:
	include "_anim\obj42.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Newtron enemy (WOZ)
; ---------------------------------------------------------------------------
Map_obj42:
	include "_maps\obj42.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 43 - Roller enemy (CCZ)
; ---------------------------------------------------------------------------

Obj43:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj43_Index(pc,d0.w),d1
		jmp	Obj43_Index(pc,d1.w)
; ===========================================================================
Obj43_Index:	dc.w Obj43_Main-Obj43_Index
		dc.w Obj43_Action-Obj43_Index
; ===========================================================================

Obj43_Main:				; XREF: Obj43_Index
		move.b	#$E,$16(a0)
		move.b	#8,$17(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		move.b	#$E,$20(a0)
		tst.w	d1
		bpl.s	locret_E052
		add.w	d1,$C(a0)	; match	roller's position with the floor
		move.w	#0,$12(a0)
		addq.b	#2,$24(a0)
		move.l	#Map_obj43,4(a0)
		move.w	#$2390,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$10,$14(a0)

locret_E052:
		rts	
; ===========================================================================

Obj43_Action:				; XREF: Obj43_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj43_Index2(pc,d0.w),d1
		jsr	Obj43_Index2(pc,d1.w)
		lea	(Ani_obj43).l,a1
		bsr.w	AnimateSprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bgt.w	Obj43_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj43_ChkGone:				; XREF: Obj43_Action
    	move.w  $1E(a0),d0    ; get address in respawn table
    	beq.s   Obj43_Delete   ; if it's zero, object was placed in debug mode
    	movea.w d0,a2   ; load address into a2
    	bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

Obj43_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj43_Index2:	dc.w Obj43_RollChk-Obj43_Index2
		dc.w Obj43_RollNoChk-Obj43_Index2
		dc.w Obj43_ChkJump-Obj43_Index2
		dc.w Obj43_MatchFloor-Obj43_Index2
; ===========================================================================

Obj43_RollChk:				; XREF: Obj43_Index2
		move.w	($FFFFB008).w,d0
		subi.w	#$100,d0
		bcs.s	loc_E0D2
		sub.w	8(a0),d0	; check	distance between Roller	and Sonic
		bcs.s	loc_E0D2
		addq.b	#4,$25(a0)
		move.b	#2,$1C(a0)
		move.w	#$700,$10(a0)	; move Roller horizontally

loc_E0D2:
		addq.l	#4,sp
		rts	
; ===========================================================================

Obj43_RollNoChk:			; XREF: Obj43_Index2
		cmpi.b	#2,$1C(a0)
		beq.s	loc_E0F8
		subq.w	#1,$30(a0)
		bpl.s	locret_E0F6
		move.b	#1,$1C(a0)
		move.w	#$700,$10(a0)

locret_E0F6:
		rts	
; ===========================================================================

loc_E0F8:
		addq.b	#2,$25(a0)
		rts	
; ===========================================================================

Obj43_ChkJump:				; XREF: Obj43_Index2
		bsr.w	Obj43_Stop
		bsr.w	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj43_Jump
		cmpi.w	#$C,d1
		bge.s	Obj43_Jump
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

Obj43_Jump:
		addq.b	#2,$25(a0)
		bset	#0,$32(a0)
		beq.s	locret_E12E
		move.w	#-$600,$12(a0)	; move Roller vertically

locret_E12E:
		rts	
; ===========================================================================

Obj43_MatchFloor:			; XREF: Obj43_Index2
		bsr.w	ObjectFall
		tst.w	$12(a0)
		bmi.s	locret_E150
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E150
		add.w	d1,$C(a0)	; match	Roller's position with the floor
		subq.b	#2,$25(a0)
		move.w	#0,$12(a0)

locret_E150:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj43_Stop:				; XREF: Obj43_ChkJump
		tst.b	$32(a0)
		bmi.s	locret_E188
		move.w	($FFFFB008).w,d0
		subi.w	#$30,d0
		sub.w	8(a0),d0
		bcc.s	locret_E188
		move.b	#0,$1C(a0)
		clr.w	$10(a0)
		move.w	#120,$30(a0)	; set waiting time to 2	seconds
		move.b	#2,$25(a0)
		bset	#7,$32(a0)

locret_E188:
		rts	
; End of function Obj43_Stop

; ===========================================================================
Ani_obj43:
	include "_anim\obj43.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Roller enemy (CCZ)
; ---------------------------------------------------------------------------
Map_obj43:
	include "_maps\obj43.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 44 - walls (WOZ)
; ---------------------------------------------------------------------------

Obj44:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj44_Index(pc,d0.w),d1
		jmp	Obj44_Index(pc,d1.w)
; ===========================================================================
Obj44_Index:	dc.w Obj44_Main-Obj44_Index
		dc.w Obj44_Solid-Obj44_Index
		dc.w Obj44_Display-Obj44_Index
; ===========================================================================

Obj44_Main:				; XREF: Obj44_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj44,4(a0)
		move.w	#0,2(a0)
		ori.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$300,$18(a0)
		move.b	$28(a0),$1A(a0)	; copy object type number to frame number
		bclr	#4,$1A(a0)	; clear	4th bit	(deduct	$10)
		beq.s	Obj44_Solid	; make object solid if 4th bit = 0
		addq.b	#2,$24(a0)
		bra.s	Obj44_Display	; don't make it solid if 4th bit = 1
; ===========================================================================

Obj44_Solid:				; XREF: Obj44_Index
		move.w	#$13,d1
		move.w	#$28,d2
		bsr.w	Obj44_SolidWall

Obj44_Display:				; XREF: Obj44_Index
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj44_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj44_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj44_Done:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - walls (WOZ)
; ---------------------------------------------------------------------------
Map_obj44:
	include "_maps\obj44.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 13 - lava ball	producer (DDZ, KVZ)
; ---------------------------------------------------------------------------

Obj13:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj13_Index(pc,d0.w),d1
		jsr	Obj13_Index(pc,d1.w)
		bra.w	Obj14_ChkDel
; ===========================================================================
Obj13_Index:	dc.w Obj13_Main-Obj13_Index
		dc.w Obj13_MakeLava-Obj13_Index
; ---------------------------------------------------------------------------
;
; Lava ball production rates
;
Obj13_Rates:	dc.b 30, 60, 90, 120, 150, 180
; ===========================================================================

Obj13_Main:				; XREF: Obj13_Index
		addq.b	#2,$24(a0)
		move.b	$28(a0),d0
		lsr.w	#4,d0
		andi.w	#$F,d0
		move.b	Obj13_Rates(pc,d0.w),$29(a0)
		move.b	$29(a0),$23(a0)	; set time delay for lava balls
		andi.b	#$F,$28(a0)

Obj13_MakeLava:				; XREF: Obj13_Index
		subq.b	#1,$23(a0)	; subtract 1 from time delay
		bne.s	locret_E302	; if time still	remains, branch
		move.b	$29(a0),$23(a0)	; reset	time delay
		bsr.w	ChkObjOnScreen
		bne.s	locret_E302
		bsr.w	SingleObjLoad
		bne.s	locret_E302
		move.b	#$14,0(a1)	; load lava ball object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$28(a0),$28(a1)

locret_E302:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 14 - lava balls (DDZ, KVZ)
; ---------------------------------------------------------------------------

Obj14:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj14_Index(pc,d0.w),d1
		jsr	Obj14_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj14_Index:	dc.w Obj14_Main-Obj14_Index
		dc.w Obj14_Action-Obj14_Index
		dc.w Obj14_Delete-Obj14_Index

Obj14_Speeds:	dc.w $FC00, $FB00, $FA00, $F900, $FE00
		dc.w $200, $FE00, $200,	0
; ===========================================================================

Obj14_Main:				; XREF: Obj14_Index
		addq.b	#2,$24(a0)
		move.b	#8,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj14,4(a0)
		move.w	#$4AC,2(a0)
		cmpi.b	#2,($FFFFFE10).w
		bne.s	loc_E35A
		move.w	#$37C,2(a0)

loc_E35A:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.w	$C(a0),$30(a0)
		tst.b	$29(a0)
		beq.s	Obj14_SetSpeed
		addi.w	#$100,$18(a0)

Obj14_SetSpeed:
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	Obj14_Speeds(pc,d0.w),$12(a0) ;	load object speed (vertical)
		move.b	#8,$14(a0)
		cmpi.b	#6,$28(a0)	; is object type below $6 ?
		bcs.s	Obj14_PlaySnd	; if yes, branch
		move.b	#$10,$14(a0)
		move.b	#2,$1C(a0)	; use horizontal animation
		move.w	$12(a0),$10(a0)	; set horizontal speed
		move.w	#0,$12(a0)	; delete vertical speed

Obj14_PlaySnd:
		move.w	#$70,d0
		jsr	(PlaySound_Special).l ;	play lava ball sound

Obj14_Action:				; XREF: Obj14_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	Obj14_TypeIndex(pc,d0.w),d1
		jsr	Obj14_TypeIndex(pc,d1.w)
		bsr.w	SpeedToPos
		lea	(Ani_obj14).l,a1
		bsr.w	AnimateSprite
		move.b	#$8B,$20(a0)
		bset	#4,$2B(a0)

Obj14_ChkDel:				; XREF: Obj13
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj14_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj14_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj14_Done:
		rts	
; ===========================================================================
Obj14_TypeIndex:dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type04-Obj14_TypeIndex, Obj14_Type05-Obj14_TypeIndex
		dc.w Obj14_Type06-Obj14_TypeIndex, Obj14_Type07-Obj14_TypeIndex
		dc.w Obj14_Type08-Obj14_TypeIndex
; ===========================================================================
; lavaball types 00-03 fly up and fall back down

Obj14_Type00:				; XREF: Obj14_TypeIndex
		addi.w	#$18,$12(a0)	; increase object's downward speed
		move.w	$30(a0),d0
		cmp.w	$C(a0),d0	; has object fallen back to its	original position?
		bcc.s	loc_E41E	; if not, branch
		addq.b	#2,$24(a0)	; goto "Obj14_Delete" routine

loc_E41E:
		bclr	#1,$22(a0)
		tst.w	$12(a0)
		bpl.s	locret_E430
		bset	#1,$22(a0)

locret_E430:
		rts	
; ===========================================================================
; lavaball type	04 flies up until it hits the ceiling

Obj14_Type04:				; XREF: Obj14_TypeIndex
		bset	#1,$22(a0)
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.s	locret_E452
		move.b	#8,$28(a0)
		move.b	#1,$1C(a0)
		move.w	#0,$12(a0)	; stop the object when it touches the ceiling

locret_E452:
		rts	
; ===========================================================================
; lavaball type	05 falls down until it hits the	floor

Obj14_Type05:				; XREF: Obj14_TypeIndex
		bclr	#1,$22(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E474
		move.b	#8,$28(a0)
		move.b	#1,$1C(a0)
		move.w	#0,$12(a0)	; stop the object when it touches the floor

locret_E474:
		rts	
; ===========================================================================
; lavaball types 06-07 move sideways

Obj14_Type06:				; XREF: Obj14_TypeIndex
		bset	#0,$22(a0)
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bpl.s	locret_E498
		move.b	#8,$28(a0)
		move.b	#3,$1C(a0)
		move.w	#0,$10(a0)	; stop object when it touches a	wall

locret_E498:
		rts	
; ===========================================================================

Obj14_Type07:				; XREF: Obj14_TypeIndex
		bclr	#0,$22(a0)
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	locret_E4BC
		move.b	#8,$28(a0)
		move.b	#3,$1C(a0)
		move.w	#0,$10(a0)	; stop object when it touches a	wall

locret_E4BC:
		rts	
; ===========================================================================

Obj14_Type08:				; XREF: Obj14_TypeIndex
		rts	
; ===========================================================================

Obj14_Delete:				; XREF: Obj14_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj14:
	include "_anim\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6D - flame thrower (ABZ)
; ---------------------------------------------------------------------------

Obj6D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6D_Index(pc,d0.w),d1
		jmp	Obj6D_Index(pc,d1.w)
; ===========================================================================
Obj6D_Index:	dc.w Obj6D_Main-Obj6D_Index
		dc.w Obj6D_Action-Obj6D_Index
; ===========================================================================

Obj6D_Main:				; XREF: Obj6D_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj6D,4(a0)
		move.w	#$83D9,2(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.w	$C(a0),$30(a0)
		move.b	#$C,$14(a0)
		move.b	$28(a0),d0
		andi.w	#$F0,d0		; read 1st digit of object type
		add.w	d0,d0		; multiply by 2
		move.w	d0,$30(a0)
		move.w	d0,$32(a0)	; set flaming time
		move.b	$28(a0),d0
		andi.w	#$F,d0		; read 2nd digit of object type
		lsl.w	#5,d0		; multiply by $20
		move.w	d0,$34(a0)	; set pause time
		move.b	#$A,$36(a0)
		btst	#1,$22(a0)
		beq.s	Obj6D_Action
		move.b	#2,$1C(a0)
		move.b	#$15,$36(a0)

Obj6D_Action:				; XREF: Obj6D_Index
		subq.w	#1,$30(a0)	; subtract 1 from time
		bpl.s	loc_E57A	; if time remains, branch
		move.w	$34(a0),$30(a0)	; begin	pause time
		bchg	#0,$1C(a0)
		beq.s	loc_E57A
		move.w	$32(a0),$30(a0)	; begin	flaming	time
		move.w	#$48,d0
		jsr	(PlaySound_Special).l ;	play flame sound

loc_E57A:
		lea	(Ani_obj6D).l,a1
		bsr.w	AnimateSprite
		move.b	#0,$20(a0)
		move.b	$36(a0),d0
		cmp.b	$1A(a0),d0
		bne.s	Obj6D_ChkDel
		move.b	#$A3,$20(a0)
		bset	#4,$2B(a0)

Obj6D_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj6D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj6D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj6D_Done:
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj6D:
	include "_anim\obj6D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flame thrower (ABZ)
; ---------------------------------------------------------------------------
Map_obj6D:
	include "_maps\obj6D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 46 - solid blocks and blocks that fall	from the ceiling (DDZ)
; ---------------------------------------------------------------------------

Obj46:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj46_Index(pc,d0.w),d1
		jmp	Obj46_Index(pc,d1.w)
; ===========================================================================
Obj46_Index:	dc.w Obj46_Main-Obj46_Index
		dc.w Obj46_Action-Obj46_Index
; ===========================================================================

Obj46_Main:				; XREF: Obj46_Index
		addq.b	#2,$24(a0)
		move.b	#$F,$16(a0)
		move.b	#$F,$17(a0)
		tst.b 	($FFFFFE10).w
		beq.s 	Obj46_WOZ
		move.l	#Map_obj46,4(a0)
		move.w	#$4000,2(a0)
		bra.s 	Obj46_Cont

Obj46_WOZ:
		move.l	#Map_obj46WOZ,4(a0)
	;	move.w	#0,2(a0)	

Obj46_Cont:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$10,$14(a0)
		move.w	$C(a0),$30(a0)
		move.w	#$5C0,$32(a0)

Obj46_Action:				; XREF: Obj46_Index
		tst.b	1(a0)
		bpl.s	Obj46_ChkDel
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		andi.w	#7,d0		; read only the	1st digit
		add.w	d0,d0
		move.w	Obj46_TypeIndex(pc,d0.w),d1
		jsr	Obj46_TypeIndex(pc,d1.w)
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		bsr.w	SolidObject

Obj46_ChkDel:
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj46_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj46_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj46_Done:
		rts	
; ===========================================================================
Obj46_TypeIndex:dc.w Obj46_Type00-Obj46_TypeIndex
		dc.w Obj46_Type01-Obj46_TypeIndex
		dc.w Obj46_Type02-Obj46_TypeIndex
		dc.w Obj46_Type03-Obj46_TypeIndex
		dc.w Obj46_Type04-Obj46_TypeIndex
; ===========================================================================

Obj46_Type00:				; XREF: Obj46_TypeIndex
		rts	
; ===========================================================================

Obj46_Type02:				; XREF: Obj46_TypeIndex
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_E888
		neg.w	d0

loc_E888:
		cmpi.w	#$90,d0		; is Sonic within $90 pixels of	the block?
		bcc.s	Obj46_Type01	; if not, resume wobbling
		move.b	#3,$28(a0)	; if yes, make the block fall

Obj46_Type01:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE74).w,d0
		btst	#3,$28(a0)
		beq.s	loc_E8A8
		neg.w	d0
		addi.w	#$10,d0

loc_E8A8:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; update the block's position to make it wobble
		rts	
; ===========================================================================

Obj46_Type03:				; XREF: Obj46_TypeIndex
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; increase falling speed
		jsr	ObjHitFloor
		tst.w	d1		; has the block	hit the	floor?
		bpl.w	locret_E8EE	; if not, branch
		add.w	d1,$C(a0)
		clr.w	$12(a0)		; stop the block falling
		move.w	$C(a0),$30(a0)
		move.b	#4,$28(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$2E8,d0
		bcc.s	locret_E8EE
		move.b	#0,$28(a0)

locret_E8EE:
		rts	
; ===========================================================================

Obj46_Type04:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE70).w,d0
		lsr.w	#3,d0
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; make the block wobble
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - solid blocks and blocks that fall from the ceiling (DDZ)
; ---------------------------------------------------------------------------
Map_obj46:
	include "_maps\obj46.asm"

Map_obj46WOZ:
	include "_maps\obj46WOZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 12 - lamp (CCZ)
; ---------------------------------------------------------------------------

Obj12:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj12_Index(pc,d0.w),d1
		jmp	Obj12_Index(pc,d1.w)
; ===========================================================================
Obj12_Index:	dc.w Obj12_Main-Obj12_Index
		dc.w Obj12_ChkDel-Obj12_Index
; ===========================================================================

Obj12_Main:				; XREF: Obj12_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj12,4(a0)
		move.w	#$2000,2(a0)
		move.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#0,$18(a0)

Obj12_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj12_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj12_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj12_Done:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamp (CCZ)
; ---------------------------------------------------------------------------
Map_obj12:
	include "_maps\obj12.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 47 - pinball bumper (CCZ)
; ---------------------------------------------------------------------------

Obj47:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj47_Index(pc,d0.w),d1
		jmp	Obj47_Index(pc,d1.w)
; ===========================================================================
Obj47_Index:	dc.w Obj47_Main-Obj47_Index
		dc.w Obj47_Hit-Obj47_Index
; ===========================================================================

Obj47_Main:				; XREF: Obj47_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj47,4(a0)
		move.w	#$380,2(a0)
		move.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$80,$18(a0)
		move.b	#$D7,$20(a0)

Obj47_Hit:				; XREF: Obj47_Index
		tst.b	$21(a0)		; has Sonic touched the	bumper?
		beq.w	Obj47_Display	; if not, branch
		clr.b	$21(a0)
		lea	($FFFFB000).w,a1
		move.w	8(a0),d1
		move.w	$C(a0),d2
		sub.w	8(a1),d1
		sub.w	$C(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,$10(a1)	; bounce Sonic away
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,$12(a1)	; bounce Sonic away
		bset	#1,$22(a1)
		bclr	#4,$22(a1)
		bclr	#5,$22(a1)
		clr.b	$3C(a1)
		move.b	#1,$1C(a0)
		move.w	#$AA,d0
		jsr	(PlaySound_Special).l ;	play bumper sound
		move.w	$1E(a0),d0
		beq.s	Obj47_Score
		movea.w	d0,a2	; load address into a2
		cmpi.b	#$8A,(a2)	; has bumper been hit $8A times?
		bcc.s	Obj47_Display	; if yes, Sonic	gets no	points
		addq.b	#1,(a2)

Obj47_Score:
		moveq	#1,d0
		jsr	AddPoints	; add 10 to score

Obj47_Display:
		lea	(Ani_obj47).l,a1
		bsr.w	AnimateSprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj47_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj47_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj47_ChkHit

Obj47_Done:
		bra.w	DisplaySprite
; ===========================================================================

Obj47_ChkHit:				; XREF: Obj47_Display
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   Obj47_Delete   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
Obj47_Delete:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj47:
	include "_anim\obj47.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - pinball bumper (CCZ)
; ---------------------------------------------------------------------------
Map_obj47:
	include "_maps\obj47.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0D - signpost at the end of a level
; ---------------------------------------------------------------------------

Obj0D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0D_Index(pc,d0.w),d1
		jsr	Obj0D_Index(pc,d1.w)
		lea	(Ani_obj0D).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj0D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj0D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj0D_Done:
		rts	
; ===========================================================================
Obj0D_Index:	dc.w Obj0D_Main-Obj0D_Index
		dc.w Obj0D_Touch-Obj0D_Index
		dc.w Obj0D_Spin-Obj0D_Index
		dc.w Obj0D_SonicRun-Obj0D_Index
		dc.w locret_ED1A-Obj0D_Index
; ===========================================================================

Obj0D_Main:				; XREF: Obj0D_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj0D,4(a0)
		move.w	#$680,2(a0)
		move.b	#4,1(a0)
		move.b	#$18,$14(a0)
		move.w	#$200,$18(a0)
		move.b	#$1F,$16(a0)

Obj0D_Touch:				; XREF: Obj0D_Index
		move.b	#$E1,d0
		jsr	PlaySound_Special ; stop music
		move.w	#$B8,d0
		jsr	(PlaySound).l	; play signpost	sound
		clr.b	($FFFFFE1E).w	; stop time counter
		move.w	($FFFFF72A).w,($FFFFF728).w ; lock screen position
		addq.b	#2,$24(a0)

locret_EBBA:
		rts	
; ===========================================================================

Obj0D_Spin:				; XREF: Obj0D_Index
		move.b	#1,$1C(a0)	; next spin cycle

Obj0D_Sparkle:
		move.w	#$B,$32(a0)	; set time between sparkles to $B frames
		moveq	#0,d0
		move.b	$34(a0),d0
		addq.b	#2,$34(a0)
		andi.b	#$E,$34(a0)
		lea	Obj0D_SparkPos(pc,d0.w),a2 ; load sparkle position data
		bsr.w	SingleObjLoad
		bne.s	Obj0D_Fall
		move.b	#$25,0(a1)	; load rings object
		move.b	#6,$24(a1)	; jump to ring sparkle subroutine
		move.b	(a2)+,d0
		ext.w	d0
		add.w	8(a0),d0
		move.w	d0,8(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	$C(a0),d0
		move.w	d0,$C(a1)
		move.l	#Map_obj25,4(a1)
		move.w	#$26C0,2(a1)
		move.b	#4,1(a1)
		move.w	#$100,$18(a1)
		move.b	#8,$14(a1)
		bra.s	Obj0D_Fall

; ===========================================================================
Obj0D_SparkPos:	dc.b -$18,-$10		; x-position, y-position
		dc.b	8,   8
		dc.b -$10,   0
		dc.b  $18,  -8
		dc.b	0,  -8
		dc.b  $10,   0
		dc.b -$18,   8
		dc.b  $18, $10
; ===========================================================================

Obj0D_Fall:
		bsr.w	SpeedToPos
		move.w	#$100,$12(a0)	; increase falling speed
		jsr	ObjHitFloor
		tst.w	d1		; has the block	hit the	floor?
		bpl.w	locret_EC42	; if not, branch
		add.w	d1,$C(a0)
		clr.w	$12(a0)		; stop the block falling
		move.w	$C(a0),$30(a0)
		move.b	#4,$28(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$2E8,d0
		bcc.s	locret_EC42
		addq.b	#2,$24(a0)
		move.b	#2,$1C(a0)

locret_EC42:
		rts	

Obj0D_SonicRun:				; XREF: Obj0D_Index
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.w	locret_EC42	; if yes, branch
		btst	#1,($FFFFB022).w	; is Sonic's in-air flag set?
		bne.s 	locret_EC42
; ---------------------------------------------------------------------------
; Subroutine to	set up bonuses at the end of an	act
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GotThroughAct:				; XREF: Obj3E_EndAct
		st.b	($FFFFF7C8).w 		; fully lock the controls
		move.b	#$A,($FFFFB01C).w	; set animation
		tst.b	($FFFFB5C0).w
		bne.s	locret_ECEE
		addq.b	#2,$24(a0)
		move.w	($FFFFF72A).w,($FFFFF728).w
		bclr	#1,($FFFFFE2C).w	; disable invincibility
		clr.b	($FFFFFE1E).w	; stop time counter
		move.b	#$3A,($FFFFB5C0).w
		moveq	#$10,d0
		jsr	(LoadPLC2).l	; load title card patterns
		move.b	#1,($FFFFF7D6).w
		moveq	#0,d0
		move.b	($FFFFFE23).w,d0
		mulu.w	#60,d0		; convert minutes to seconds
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1
		add.w	d1,d0		; add up your time
		divu.w	#15,d0		; divide by 15
		moveq	#$14,d1
		cmp.w	d1,d0		; is time 5 minutes or higher?
		bcs.s	loc_ECD0	; if not, branch
		move.w	d1,d0		; use minimum time bonus (0)

loc_ECD0:
		add.w	d0,d0
		move.w	TimeBonuses(pc,d0.w),($FFFFF7D2).w ; set time bonus
		move.w	($FFFFFE20).w,d0 ; load	number of rings
		mulu.w	#10,d0		; multiply by 10
		move.w	d0,($FFFFF7D4).w ; set ring bonus
		moveq	#$1C,d0
		jsr	(PlaySound).l ;	play "Sonic got	through" music
		move.w	#0,d0
		jsr	(SetTempo).l ;	use normal speed
		move.b 	#0,($FFFFFFBB).w

locret_ECEE:
		rts	
; End of function GotThroughAct

; ===========================================================================
TimeBonuses:	dc.w 5000, 5000, 1000, 500, 400, 400, 300, 300,	200, 200
		dc.w 200, 200, 100, 100, 100, 100, 50, 50, 50, 50, 0
; ===========================================================================

locret_ED1A:				; XREF: Obj0D_Index
	;	clr.b	($FFFFF7C8).w ; unlock controls
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj0D:
	include "_anim\obj0D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - signpost
; ---------------------------------------------------------------------------
Map_obj0D:
	include "_maps\obj0D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4C - lava geyser / lavafall producer (DDZ)
; ---------------------------------------------------------------------------

Obj4C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj4C_Index(pc,d0.w),d1
		jsr	Obj4C_Index(pc,d1.w)
		bra.w	Obj4D_ChkDel
; ===========================================================================
Obj4C_Index:	dc.w Obj4C_Main-Obj4C_Index
		dc.w loc_EDCC-Obj4C_Index
		dc.w loc_EE3E-Obj4C_Index
		dc.w Obj4C_MakeLava-Obj4C_Index
		dc.w Obj4C_Display-Obj4C_Index
		dc.w Obj4C_Delete-Obj4C_Index
; ===========================================================================

Obj4C_Main:				; XREF: Obj4C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj4C,4(a0)
		move.w	#$E3A8,2(a0)
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$38,$14(a0)
		move.w	#120,$34(a0)	; set time delay to 2 seconds

loc_EDCC:				; XREF: Obj4C_Index
		subq.w	#1,$32(a0)
		bpl.s	locret_EDF0
		move.w	$34(a0),$32(a0)
		move.w	($FFFFB00C).w,d0
		move.w	$C(a0),d1
		cmp.w	d1,d0
		bcc.s	locret_EDF0
		subi.w	#$170,d1
		cmp.w	d1,d0
		bcs.s	locret_EDF0
		addq.b	#2,$24(a0)

locret_EDF0:
		rts	
; ===========================================================================

Obj4C_MakeLava:				; XREF: Obj4C_Index
		addq.b	#2,$24(a0)
		bsr.w	SingleObjLoad2
		bne.s	loc_EE18
		move.b	#$4D,0(a1)	; load lavafall	object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$28(a0),$28(a1)
		move.l	a0,$3C(a1)

loc_EE18:
		move.b	#1,$1C(a0)
		tst.b	$28(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Type00	; if yes, branch
		move.b	#4,$1C(a0)
		bra.s	Obj4C_Display
; ===========================================================================

Obj4C_Type00:				; XREF: Obj4C_MakeLava
		movea.l	$3C(a0),a1	; load geyser object
		bset	#1,$22(a1)
		move.w	#-$580,$12(a1)
		bra.s	Obj4C_Display
; ===========================================================================

loc_EE3E:				; XREF: Obj4C_Index
		tst.b	$28(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Display	; if yes, branch
		addq.b	#2,$24(a0)
		rts	
; ===========================================================================

Obj4C_Display:				; XREF: Obj4C_Index
		lea	(Ani_obj4C).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		rts	
; ===========================================================================

Obj4C_Delete:				; XREF: Obj4C_Index
		move.b	#0,$1C(a0)
		move.b	#2,$24(a0)
		tst.b	$28(a0)
		beq.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4D - lava geyser / lavafall (DDZ)
; ---------------------------------------------------------------------------

Obj4D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj4D_Index(pc,d0.w),d1
		jsr	Obj4D_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj4D_Index:	dc.w Obj4D_Main-Obj4D_Index
		dc.w Obj4D_Action-Obj4D_Index
		dc.w loc_EFFC-Obj4D_Index
		dc.w Obj4D_Delete-Obj4D_Index

Obj4D_Speeds:	dc.w $FB00, 0
; ===========================================================================

Obj4D_Main:				; XREF: Obj4D_Index
		addq.b	#2,$24(a0)
		move.w	$C(a0),$30(a0)
		tst.b	$28(a0)
		beq.s	loc_EEA4
		subi.w	#$250,$C(a0)

loc_EEA4:
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	Obj4D_Speeds(pc,d0.w),$12(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bsr.s	Obj4D_MakeLava
		bra.s	loc_EF10
; ===========================================================================

Obj4D_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_EF0A

Obj4D_MakeLava:				; XREF: Obj4D_Main
		move.b	#$4D,0(a1)
		move.l	#Map_obj4C,4(a1)
		move.w	#$63A8,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$28(a0),$28(a1)
		move.w	#$80,$18(a1)
		move.b	#5,$1C(a1)
		tst.b	$28(a0)
		beq.s	loc_EF0A
		move.b	#2,$1C(a1)

loc_EF0A:
		dbf	d1,Obj4D_Loop
		rts	
; ===========================================================================

loc_EF10:				; XREF: Obj4D_Main
		addi.w	#$60,$C(a1)
		move.w	$30(a0),$30(a1)
		addi.w	#$60,$30(a1)
		move.b	#$80,$16(a1)
		bset	#4,1(a1)
		addq.b	#4,$24(a1)
		move.l	a0,$3C(a1)
		tst.b	$28(a0)
		beq.s	Obj4D_PlaySnd
		moveq	#0,d1
		bsr.w	Obj4D_Loop
		addq.b	#2,$24(a1)
		bset	#4,2(a1)
		addi.w	#$100,$C(a1)
		move.w	#0,$18(a1)
		move.w	$30(a0),$30(a1)
		move.l	$3C(a0),$3C(a1)
		move.b	#0,$28(a0)

Obj4D_PlaySnd:
		move.w	#$D5,d0
		jsr	(PlaySound_Special).l ;	play flame sound

Obj4D_Action:				; XREF: Obj4D_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	Obj4D_TypeIndex(pc,d0.w),d1
		jsr	Obj4D_TypeIndex(pc,d1.w)
		bsr.w	SpeedToPos
		lea	(Ani_obj4C).l,a1
		bsr.w	AnimateSprite
		move.b	#$93,$20(a1)
		bset	#4,$2B(a1)

Obj4D_ChkDel:				; XREF: Obj4C
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj4D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj4D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj4D_Done:
		rts	
; ===========================================================================
Obj4D_TypeIndex:dc.w Obj4D_Type00-Obj4D_TypeIndex
		dc.w Obj4D_Type01-Obj4D_TypeIndex
; ===========================================================================

Obj4D_Type00:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,$12(a0)	; increase object's falling speed
		move.w	$30(a0),d0
		cmp.w	$C(a0),d0
		bcc.s	locret_EFDA
		addq.b	#4,$24(a0)
		movea.l	$3C(a0),a1
		move.b	#3,$1C(a1)

locret_EFDA:
		rts	
; ===========================================================================

Obj4D_Type01:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,$12(a0)	; increase object's falling speed
		move.w	$30(a0),d0
		cmp.w	$C(a0),d0
		bcc.s	locret_EFFA
		addq.b	#4,$24(a0)
		movea.l	$3C(a0),a1
		move.b	#1,$1C(a1)

locret_EFFA:
		rts	
; ===========================================================================

loc_EFFC:				; XREF: Obj4D_Index
		movea.l	$3C(a0),a1
		cmpi.b	#6,$24(a1)
		beq.w	Obj4D_Delete
		move.w	$C(a1),d0
		addi.w	#$60,d0
		move.w	d0,$C(a0)
		sub.w	$30(a0),d0
		neg.w	d0
		moveq	#8,d1
		cmpi.w	#$40,d0
		bge.s	loc_F026
		moveq	#$B,d1

loc_F026:
		cmpi.w	#$80,d0
		ble.s	loc_F02E
		moveq	#$E,d1

loc_F02E:
		subq.b	#1,$23(a0)
		bpl.s	loc_F04C
		move.b	#7,$23(a0)
		addq.b	#1,$1B(a0)
		cmpi.b	#2,$1B(a0)
		bcs.s	loc_F04C
		move.b	#0,$1B(a0)

loc_F04C:
		move.b	$1B(a0),d0
		add.b	d1,d0
		move.b	d0,$1A(a0)
		bra.w	Obj4D_ChkDel
; ===========================================================================

Obj4D_Delete:				; XREF: Obj4D_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4E - advancing	wall of	lava (DDZ)
; ---------------------------------------------------------------------------

Obj4E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj4E_Index(pc,d0.w),d1
		jmp	Obj4E_Index(pc,d1.w)
; ===========================================================================
Obj4E_Index:	dc.w Obj4E_Main-Obj4E_Index
		dc.w Obj4E_Solid-Obj4E_Index
		dc.w Obj4E_Action-Obj4E_Index
		dc.w Obj4E_Move2-Obj4E_Index
		dc.w Obj4E_Delete-Obj4E_Index
; ===========================================================================

Obj4E_Main:				; XREF: Obj4E_Index
		addq.b	#4,$24(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bra.s	Obj4E_Main2
; ===========================================================================

Obj4E_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_F0C8

Obj4E_Main2:				; XREF: Obj4E_Main
		move.b	#$4E,0(a1)	; load object
		move.l	#Map_obj4E,4(a1)
		move.w	#$63A8,2(a1)
		move.b	#4,1(a1)
		move.b	#$50,$14(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	#$80,$18(a1)
		move.b	#0,$1C(a1)
		move.l	a0,$3C(a1)

loc_F0C8:
		dbf	d1,Obj4E_Loop	; repeat sequence once

		addq.b	#6,$24(a1)
		move.b	#4,$1A(a1)

Obj4E_Action:				; XREF: Obj4E_Index
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	Obj4E_ChkSonic
		neg.w	d0
		move.b	#$94,$20(a1)
		bset	#4,$2B(a1)

Obj4E_ChkSonic:
		cmpi.w	#$C0,d0		; is Sonic within $C0 pixels (x-axis)?
		bcc.s	Obj4E_Move	; if not, branch
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		bcc.s	loc_F0F4
		neg.w	d0

loc_F0F4:
		cmpi.w	#$60,d0		; is Sonic within $60 pixels (y-axis)?
		bcc.s	Obj4E_Move	; if not, branch
		move.b	#1,$36(a0)	; set object to	move
		bra.s	Obj4E_Solid
; ===========================================================================

Obj4E_Move:				; XREF: Obj4E_ChkSonic
		tst.b	$36(a0)		; is object set	to move?
		beq.s	Obj4E_Solid	; if not, branch
		move.w	#$180,$10(a0)	; set object speed
		subq.b	#2,$24(a0)

Obj4E_Solid:				; XREF: Obj4E_Index
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		move.b	$24(a0),d0
		move.w	d0,-(sp)
		bsr.w	SolidObject
		move.w	(sp)+,d0
		move.b	d0,$24(a0)
		cmpi.w	#$6A0,8(a0)	; has object reached $6A0 on the x-axis?
		bne.s	Obj4E_Animate	; if not, branch
		clr.w	$10(a0)		; stop object moving
		clr.b	$36(a0)

Obj4E_Animate:
		lea	(Ani_obj4E).l,a1
		bsr.w	AnimateSprite
		cmpi.b	#4,($FFFFB024).w
		bcc.s	Obj4E_ChkDel
		bsr.w	SpeedToPos

Obj4E_ChkDel:
		bsr.w	DisplaySprite
		tst.b	$36(a0)
		bne.s	Obj4E_Done
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj4E_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj4E_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj4E_Done:
		rts	
; ===========================================================================

Obj4E_ChkGone:				; XREF: Obj4E_ChkDel
        move.w  $1E(a0),d0    ; get address in respawn table
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
		move.b	#8,$24(a0)
		rts	
; ===========================================================================

Obj4E_Move2:				; XREF: Obj4E_Index
		movea.l	$3C(a0),a1
		cmpi.b	#8,$24(a1)
		beq.s	Obj4E_Delete
		move.w	8(a1),8(a0)	; move rest of lava wall
		subi.w	#$80,8(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj4E_Delete:				; XREF: Obj4E_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 54 - Quicksand (DDZ)
; ---------------------------------------------------------------------------
; Sprite_24020:
Obj54:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj54_Index(pc,d0.w),d1
	jmp	Obj54_Index(pc,d1.w)
; ===========================================================================
; off_2402E: Obj07_States:
Obj54_Index:
		dc.w Obj54_Init-Obj54_Index	; 0
		dc.w Obj54_Main-Obj54_Index	; 2
; ===========================================================================
; loc_24032:
Obj54_Init:
	addq.b	#2,$24(a0) ; => Obj07_Main
	move.b	$28(a0),d0
	lsl.w	#3,d0
	move.b	d0,$14(a0)
	move.w	$C(a0),$30(a0)
	move.b	#$30,$38(a0)

; loc_24054:
Obj54_Main:
	tst.w	($FFFFFE08).w
	bne.w	Obj54_End
	lea	($FFFFB000).w,a1 ; a1=character
	btst	#3,$22(a0)
	bne.s	Obj54_CheckKillChar1
	cmpi.b	#$30,$38(a0)
	bcc.s	Obj54_CheckSupportChar1
	addq.b	#2,$38(a0)
	bra.s	Obj54_CheckSupportChar1
; ---------------------------------------------------------------------------
; loc_24078:
Obj54_CheckKillChar1:
	tst.b	$38(a0)
	beq.s	Obj54_SuffocateCharacter
	subq.b	#1,$38(a0)

; loc_24082:
Obj54_CheckSupportChar1:
	moveq	#0,d1
	move.b	$14(a0),d1
	moveq	#0,d3
	move.b	$38(a0),d3
	lsr.w	#1,d3
	moveq	#3,d6
	move.w	8(a0),d4
	jmp	(PlatformObject_SingleCharacter).l ; stop the character from falling past the oil
; ---------------------------------------------------------------------------
; loc_240D6:
Obj54_SuffocateCharacter:
	move.b	#$30,$38(a0)
	not.b	d1
	and.b	d1,$22(a0)
	move.l	a0,-(sp)
	movea.l	a0,a2
	movea.l	a1,a0
	jsr	(KillSonic).l
	movea.l	(sp)+,a0 ; load 0bj address

Obj54_End:
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible lava tag (DDZ)
; ---------------------------------------------------------------------------
Map_obj54:
	include "_maps\obj54.asm"

Ani_obj4C:
	include "_anim\obj4C.asm"

Ani_obj4E:
	include "_anim\obj4E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava geyser / lava that falls from the ceiling (DDZ)
; ---------------------------------------------------------------------------
Map_obj4C:
	include "_maps\obj4C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - advancing wall of lava (DDZ)
; ---------------------------------------------------------------------------
Map_obj4E:
	include "_maps\obj4E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 40 - Moto Bug enemy (WOZ)
; ---------------------------------------------------------------------------

Obj40:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj40_Index(pc,d0.w),d1
		jmp	Obj40_Index(pc,d1.w)
; ===========================================================================
Obj40_Index:	dc.w Obj40_Main-Obj40_Index
		dc.w Obj40_Action-Obj40_Index
		dc.w Obj40_Animate-Obj40_Index
		dc.w Obj40_Delete-Obj40_Index
; ===========================================================================

Obj40_Main:				; XREF: Obj40_Index
		move.l	#Map_obj40,4(a0)
		move.w	#$23D4,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$14,$14(a0)
	;	tst.b	$1C(a0)		; is object a smoke trail?
	;	bne.s	Obj40_SetSmoke	; if yes, branch
		move.b	#$10,$16(a0)
		move.b	#8,$17(a0)
		move.b	#$C,$20(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F68A
		add.w	d1,$C(a0)	; match	object's position with the floor
		move.w	#0,$12(a0)
		addq.b	#2,$24(a0)
		bchg	#0,$22(a0)

locret_F68A:
		rts	
; ===========================================================================

Obj40_SetSmoke:				; XREF: Obj40_Main
		addq.b	#4,$24(a0)
		bra.w	Obj40_Animate
; ===========================================================================

Obj40_Action:				; XREF: Obj40_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj40_Index2(pc,d0.w),d1
		jsr	Obj40_Index2(pc,d1.w)
		lea	(Ani_obj40).l,a1
		bsr.w	AnimateSprite

; ---------------------------------------------------------------------------
; Routine to mark an enemy/monitor/ring	as destroyed
; ---------------------------------------------------------------------------

MarkObjGone:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Mark_ChkGone:
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   Mark_Delete   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

Mark_Delete:
		bra.w	DeleteObject

MarkObjGone3:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

; ===========================================================================
Obj40_Index2:	dc.w Obj40_Move-Obj40_Index2
		dc.w Obj40_FixToFloor-Obj40_Index2
		dc.w	Obj40_Fall-Obj40_Index2
; ===========================================================================

Obj40_Move:				; XREF: Obj40_Index2
		subq.w	#1,$30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F70A	; if time remains, branch
		addq.b	#2,$25(a0)
		move.w	#-$180,$10(a0)	; move object to the left
		move.b	#1,$1C(a0)
		bchg	#0,$22(a0)
		bne.s	locret_F70A
		neg.w	$10(a0)		; change direction

locret_F70A:
		rts	
; ===========================================================================

Obj40_FixToFloor:			; XREF: Obj40_Index2
		bsr.w	SpeedToPos
		btst	#0,$22(a0)
		bne.s	Obj40_FTF2
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.s	Obj40_Pause	; delete if the	fireball hits a	wall
		bra.s	Obj40_FTF3
; ===========================================================================

Obj40_FTF2:
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bmi.s	Obj40_Pause	; delete if the	fireball hits a	wall

Obj40_FTF3:
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj40_Pause2
		cmpi.w	#$C,d1
		bge.s	Obj40_Pause2
		add.w	d1,$C(a0)	; match	object's position with the floor
	;	subq.b	#1,$33(a0)
	;	bpl.s	locret_F756
	;	move.b	#$F,$33(a0)
	;	bsr.w	SingleObjLoad
	;	bne.s	locret_F756
	;	move.b	#$40,0(a1)	; load exhaust smoke object
	;	move.w	8(a0),8(a1)
	;	move.w	$C(a0),$C(a1)
	;	move.b	$22(a0),$22(a1)
	;	move.b	#2,$1C(a1)

locret_F756:
		rts	
; ===========================================================================

Obj40_Pause:				; XREF: Obj40_FixToFloor
		subq.b	#2,$25(a0)
		move.w	#59,$30(a0)	; set pause time to 1 second
		move.w	#0,$10(a0)	; stop the object moving
		move.b	#0,$1C(a0)
		rts

Obj40_Pause2:				; XREF: Obj40_FixToFloor
		addq.b	#2,$25(a0)
	;	move.w	#59,$30(a0)	; set pause time to 1 second
	;	move.w	#0,$10(a0)	; stop the object moving
	;	move.b	#0,$1C(a0)

Obj40_Fall:
		bsr.w	ObjectFall
		bsr.w	SpeedToPos
		cmpi.w	#-8,d1
		blt.s	Obj40_Fall2
		cmpi.w	#$C,d1
		bge.s	Obj40_Fall2
		subq.b	#2,$25(a0)

Obj40_Fall2:
		rts
; ===========================================================================

Obj40_Animate:				; XREF: Obj40_Index
		lea	(Ani_obj40).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj40_Delete:				; XREF: Obj40_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj40:
	include "_anim\obj40.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Moto Bug enemy (WOZ)
; ---------------------------------------------------------------------------
Map_obj40:
	include "_maps\obj40.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4F - blank
; ---------------------------------------------------------------------------

Obj4F:					; XREF: Obj_Index
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj50_ChkWall:				; XREF: Obj50_FixToFloor
		move.w	($FFFFFE04).w,d0
		add.w	d7,d0
		andi.w	#3,d0
		bne.s	loc_F836
		moveq	#0,d3
		move.b	$14(a0),d3
		tst.w	$10(a0)
		bmi.s	loc_F82C
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	loc_F836

loc_F828:
		moveq	#1,d0
		rts	
; ===========================================================================

loc_F82C:
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.s	loc_F828

loc_F836:
		moveq	#0,d0
		rts	
; End of function Obj50_ChkWall

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 50 - Yadrin enemy (CCZ)
; ---------------------------------------------------------------------------

Obj50:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj50_Index(pc,d0.w),d1
		jmp	Obj50_Index(pc,d1.w)
; ===========================================================================
Obj50_Index:	dc.w Obj50_Main-Obj50_Index
		dc.w Obj50_Action-Obj50_Index
; ===========================================================================

Obj50_Main:				; XREF: Obj50_Index
		move.l	#Map_obj50,4(a0)
		move.w	#$2349,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$14,$14(a0)
		move.b	#$11,$16(a0)
		move.b	#8,$17(a0)
		move.b	#$CC,$20(a0)
		bsr.w	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F89E
		add.w	d1,$C(a0)	; match	object's position with the floor
		move.w	#0,$12(a0)
		addq.b	#2,$24(a0)
		bchg	#0,$22(a0)

locret_F89E:
		rts	
; ===========================================================================

Obj50_Action:				; XREF: Obj50_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj50_Index2(pc,d0.w),d1
		jsr	Obj50_Index2(pc,d1.w)
		lea	(Ani_obj50).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj50_Index2:	dc.w Obj50_Move-Obj50_Index2
		dc.w Obj50_FixToFloor-Obj50_Index2
; ===========================================================================

Obj50_Move:				; XREF: Obj50_Index2
		subq.w	#1,$30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F8E2	; if time remains, branch
		addq.b	#2,$25(a0)
		move.w	#-$100,$10(a0)	; move object
		move.b	#1,$1C(a0)
		bchg	#0,$22(a0)
		bne.s	locret_F8E2
		neg.w	$10(a0)		; change direction

locret_F8E2:
		rts	
; ===========================================================================

Obj50_FixToFloor:			; XREF: Obj50_Index2
		bsr.w	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj50_Pause
		cmpi.w	#$C,d1
		bge.s	Obj50_Pause
		add.w	d1,$C(a0)	; match	object's position to the floor
		bsr.w	Obj50_ChkWall
		bne.s	Obj50_Pause
		rts	
; ===========================================================================

Obj50_Pause:				; XREF: Obj50_FixToFloor
		subq.b	#2,$25(a0)
		move.w	#59,$30(a0)	; set pause time to 1 second
		move.w	#0,$10(a0)
		move.b	#0,$1C(a0)
		rts	
; ===========================================================================
Ani_obj50:
	include "_anim\obj50.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Yadrin enemy (CCZ)
; ---------------------------------------------------------------------------
Map_obj50:
	include "_maps\obj50.asm"

; ----------------------------------------------------------------------------
; Sprite
;
; Coconuts badnick from	EHZ
; ----------------------------------------------------------------------------

Obj93:				; DATA XREF: ROM:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_37C08(pc,d0.w),d1
		jmp	off_37C08(pc,d1.w)
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_37C08:	dc.w loc_37C10-off_37C08; 0 ; DATA XREF: h+20C94o h+20C96o ...
		dc.w loc_37C1C-off_37C08; 1
		dc.w loc_37CAE-off_37C08; 2
		dc.w loc_37CD4-off_37C08; 3
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37C10:				; DATA XREF: h+20C94o
		move.l	#Map_obj93,4(a0)
		move.w	#$23FB,2(a0)
		or.b	#4,1(a0)
		move.w	#0,$18(a0)
		move.b	#$C,$14(a0)
		move.b	#9,$20(a0)
		addq.b	#2,$24(a0)
		move.b	#$10,$2A(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37C1C:				; DATA XREF: h+20C94o
Obj_GetOrientationToPlayer:
		moveq	#0,d0
		moveq	#0,d1
		lea	($FFFFB000).w,a1 ; a1=character
		move.w	8(a0),d2
		sub.w	8(a1),d2
		move.w	d2,d4
		bpl.s	loc_366EC
		neg.w	d4

loc_366EC:				; CODE XREF: h+1F774j
		lea	($FFFFB380).w,a2 ; a2=character
		move.w	8(a0),d3
		sub.w	8(a2),d3
		move.w	d3,d5
		bpl.s	loc_366FE
		neg.w	d5

loc_366FE:				; CODE XREF: h+1F786j
		cmp.w	d5,d4	; get shorter distance
		bls.s	@jump1	; branch, if main character is closer
		; if sidekick is closer
		movea.l	a2,a1
		move.w	d3,d2
	@jump1:
		tst.w	d2	; is player to enemy's left?
		bpl.s	@jump2	; if not, branch
		addq.w	#2,d0
	@jump2:
		move.w	$C(a0),d3
		sub.w	$C(a1),d3	; vertical distance to closest character
		bhs.s	@jump3	; branch, if enemy is under
		addq.w	#2,d1
	@jump3:
		bclr	#0,1(a0)
		bclr	#0,$22(a0)
		tst.w	d0
		beq.s	loc_37C3C
		bset	#0,1(a0)
		bset	#0,$22(a0)

loc_37C3C:				; CODE XREF: h+20CBAj
		addi.w	#$60,d2	; '`'
		cmpi.w	#$C0,d2	; 'ร'
		bcc.s	loc_37C50
		tst.b	$2E(a0)
		beq.s	loc_37C66
		subq.b	#1,$2E(a0)

loc_37C50:				; CODE XREF: h+20CD0j
		subq.b	#1,$2A(a0)
		bmi.s	loc_37C5A
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37C5A:				; CODE XREF: h+20CE0j
		addq.b	#2,$24(a0)
		bsr.w	loc_37C82
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37C66:				; CODE XREF: h+20CD6j
		move.b	#6,$24(a0)
		move.b	#1,$1A(a0)
		move.b	#8,$2A(a0)
		move.b	#$20,$2E(a0) ; ' '
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37C82:				; CODE XREF: h+20CEAp h+20DAAj
		move.w	$2C(a0),d0
		cmpi.w	#$C,d0
		bcs.s	loc_37C8E
		moveq	#0,d0

loc_37C8E:				; CODE XREF: h+20D16j
		lea	byte_37CA2(pc,d0.w),a1
		addq.w	#2,d0
		move.w	d0,$2C(a0)
		move.b	(a1)+,$12(a0)
		move.b	(a1)+,$2A(a0)
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
byte_37CA2:	dc.b $FF,$20		; 0
		dc.b   1,$18		; 2
		dc.b $FF,$10		; 4
		dc.b   1,$28		; 6
		dc.b $FF,$20		; 8
		dc.b   1,$10		; 10
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37CAE:				; DATA XREF: h+20C94o
		subq.b	#1,$2A(a0)
		beq.s	loc_37CC6
		bsr.w	SpeedtoPos
		lea	(off_37D88).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37CC6:				; CODE XREF: h+20D3Ej
		subq.b	#2,$24(a0)
		move.b	#$10,$2A(a0)
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37CD4:				; DATA XREF: h+20C94o
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	off_37CE6(pc,d0.w),d1
		jsr	off_37CE6(pc,d1.w)
		bra.w	MarkObjGone
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
off_37CE6:	dc.w loc_37CEA-off_37CE6; 0 ; DATA XREF: h+20D72o h+20D74o
		dc.w loc_37D06-off_37CE6; 1
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37CEA:				; DATA XREF: h+20D72o
		subq.b	#1,$2A(a0)
		bmi.s	loc_37CF2
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37CF2:				; CODE XREF: h+20D7Aj
		addq.b	#2,$25(a0)
		move.b	#8,$2A(a0)
		move.b	#2,$1A(a0)
		bra.w	loc_37D22
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37D06:				; DATA XREF: h+20D72o
		subq.b	#1,$2A(a0)
		bmi.s	loc_37D0E
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37D0E:				; CODE XREF: h+20D96j
		clr.b	$25(a0)
		move.b	#4,$24(a0)
		move.b	#8,$2A(a0)
		bra.w	loc_37C82
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

loc_37D22:				; CODE XREF: h+20D8Ej
		bsr.w	SingleObjLoad
		bne.s	locret_37D74
		move.b	#$23,0(a1)
		move.b	#3,$1A(a1)
		move.b	#2,$28(a1) ; ' '
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#-$D,$C(a1)
		moveq	#0,d0
		btst	#0,1(a0)
		bne.s	loc_37D58
		moveq	#4,d0

loc_37D58:				; CODE XREF: h+20DE0j
		lea	word_37D76(pc,d0.w),a2
		move.w	(a2)+,d0
		add.w	d0,8(a1)
		move.w	(a2)+,$10(a1)
		move.w	#-$100,$12(a1)
		lea	(Obj23_CoconutFall,pc),a2
		move.l	a2,$2A(a1)

locret_37D74:				; CODE XREF: h+20DB2j
		rts	
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร
word_37D76:	dc.w $FFF5		; 0
		dc.w  $100		; 1
		dc.w	$B		; 2
		dc.w $FF00		; 3
off_37D88:	dc.w byte_37D8C-off_37D88; 0 ; DATA XREF: h+20D44o h+20E14o ...
		dc.w MapUnc_37D90-off_37D88; 1
byte_37D8C:	dc.b   5,  0,  1,$FF	; 0 ; DATA XREF: h+20E14o
MapUnc_37D90:				; DATA XREF: h+20E14o
		dc.b   9,  1,  2,  1,$FF,  0; 0
; ------------------------------------------------------------------------
; Unknown sprite mappings
; ------------------------------------------------------------------------
Map_obj93:
	include "_maps\obj93.asm"
; รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร

Obj94:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj94_Index(pc,d0.w),d1
		jmp	Obj94_Index(pc,d1.w)
; ===========================================================================
Obj94_Index:	dc.w Obj94_Init-Obj94_Index
		dc.w Obj94_Passive-Obj94_Index
		dc.w Obj94_Active-Obj94_Index
; ===========================================================================
Obj94_Init:	
		addq.b	#2,$24(a0)
		move.b	$28(a0),d0
		andi.b	#$F,d0
		lsl.b	#2,d0
		move.b	d0,$14(a0)
		move.b	$28(a0),d0
		lsr.b	#3,d0
		lsl.b	#2,d0
		move.b	d0,$30(a0)

Obj94_Passive:
		lea	($FFFFB000),a1
		move.w	8(a0),d0
		move.w	8(a1),d1
		sub.w	d0,d1
		cmpi.w	#$40,d1
		bcs.s	Obj94_Switch
		cmpi.w	#-$40,d1
		bcc.s	Obj94_Switch

Obj94_Return:
		rts

Obj94_Switch:
		addq.b	#2,$24(a0)

Obj94_Active:
		lea	($FFFFB000),a1
		move.b	#$1D,$1C(a1)
		move.b	$C(a0),$C(a1)
		move.w	8(a0),d0
		move.w	8(a1),d1
		sub.w	d0,d1
		cmpi.w	#$40,d1
		bcc.s	Obj94_Switch2
		cmpi.w	#-$40,d1
		bcs.s	Obj94_Switch2
		rts

Obj94_Switch2:
		subq.b	#2,$24(a0)
		rts


; ---------------------------------------------------------------------------
; Solid	object subroutine (includes spikes, blocks, rocks etc)
;
; variables:
; d1 = width
; d2 = height /	2 (when	jumping)
; d3 = height /	2 (when	walking)
; d4 = x-axis position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SolidObject:
		tst.b	$25(a0)
		beq.w	loc_FAC8
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_F9FE
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_F9FE
		cmp.w	d2,d0
		bcs.s	loc_FA12

loc_F9FE:
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA12:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SolidObject71:				; XREF: Obj71_Solid
		tst.b	$25(a0)
		beq.w	loc_FAD0
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_FA44
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_FA44
		cmp.w	d2,d0
		bcs.s	loc_FA58

loc_FA44:
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA58:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SolidObject2F:				; XREF: Obj2F_Solid
		lea	($FFFFB000).w,a1
		tst.b	1(a0)
		bpl.w	loc_FB92
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.w	d0,d5
		btst	#0,1(a0)
		beq.s	loc_FA94
		not.w	d5
		add.w	d3,d5

loc_FA94:
		lsr.w	#1,d5
		moveq	#0,d3
		move.b	(a2,d5.w),d3
		sub.b	(a2),d3
		move.w	$C(a0),d5
		sub.w	d3,d5
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	loc_FB92
		bra.w	loc_FB0E
; ===========================================================================

loc_FAC8:
		tst.b	1(a0)
		bpl.w	loc_FB92

loc_FAD0:
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	loc_FB92

loc_FB0E:
		tst.b	($FFFFF7C8).w
		bmi.w	loc_FB92
		cmpi.b	#6,($FFFFB024).w
		bcc.w	loc_FB92
		tst.w	($FFFFFE08).w
		bne.w	loc_FBAC
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_FB36
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_FB36:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_FB44
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_FB44:
		cmp.w	d1,d5
		bhi.w	loc_FBB0
		cmpi.w	#4,d1
		bls.s	loc_FB8C
		tst.w	d0
		beq.s	loc_FB70
		bmi.s	loc_FB5E
		tst.w	$10(a1)
		bmi.s	loc_FB70
		bra.s	loc_FB64
; ===========================================================================

loc_FB5E:
		tst.w	$10(a1)
		bpl.s	loc_FB70

loc_FB64:
		move.w	#0,$20(a1)	; stop Sonic moving
		move.w	#0,$10(a1)

loc_FB70:
		sub.w	d0,8(a1)
		btst	#1,$22(a1)
		bne.s	loc_FB8C
		bset	#5,$22(a1)
		bset	#5,$22(a0)
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB8C:
		bsr.s	loc_FBA0
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB92:
		btst	#5,$22(a0)
		beq.s	loc_FBAC
		cmp.b	#2,$1C(a1)	; check if in jumping/rolling animation
		beq.s	loc_FBA0
		cmp.b	#$17,$1C(a1)	; check if in drowning animation
		beq.s	loc_FBA0
		cmp.b	#$1A,$1C(a1)	; check if in hurt animation
		beq.s	loc_FBA0
		move.w	#1,$1C(a1)	; use walking animation

loc_FBA0:
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)

loc_FBAC:
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FBB0:
		tst.w	d3
		bmi.s	loc_FBBC
		cmpi.w	#$10,d3
		bcs.s	loc_FBEE
		bra.s	loc_FB92
; ===========================================================================

loc_FBBC:
		tst.w	$12(a1)
		beq.s	loc_FBD6
		bpl.s	loc_FBD2
		tst.w	d3
		bpl.s	loc_FBD2
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)	; stop Sonic moving

loc_FBD2:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBD6:
		btst	#1,$22(a1)
		bne.s	loc_FBD2
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	KillSonic
		movea.l	(sp)+,a0
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBEE:
		subq.w	#4,d3
		moveq	#0,d1
		move.b	$14(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	8(a1),d1
		sub.w	8(a0),d1
		bmi.s	loc_FC28
		cmp.w	d2,d1
		bcc.s	loc_FC28
		tst.w	$12(a1)
		bmi.s	loc_FC28
		sub.w	d3,$C(a1)
		subq.w	#1,$C(a1)
		bsr.s	sub_FC2C
		move.b	#2,$25(a0)
		bset	#3,$22(a0)
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FC28:
		moveq	#0,d4
		rts	
; End of function SolidObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_FC2C:				; XREF: SolidObject
		btst	#3,$22(a1)
		beq.s	loc_FC4E
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)
		clr.b	$25(a2)

loc_FC4E:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,$26(a1)
		move.w	#0,$12(a1)
		move.w	$10(a1),$20(a1)
		btst	#1,$22(a1)
		beq.s	loc_FC84
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Player_ResetOnFloor
		movea.l	(sp)+,a0

loc_FC84:
		bset	#3,$22(a1)
		bset	#3,$22(a0)
		rts	
; End of function sub_FC2C

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 51 - smashable	green block (DDZ)
; ---------------------------------------------------------------------------

Obj51:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj51_Index(pc,d0.w),d1
		jsr	Obj51_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj51_Index:	dc.w Obj51_Main-Obj51_Index
		dc.w Obj51_Solid-Obj51_Index
		dc.w Obj51_Display-Obj51_Index
; ===========================================================================

Obj51_Main:				; XREF: Obj51_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj51,4(a0)
		move.w	#$42B8,2(a0)
		move.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),$1A(a0)

Obj51_Solid:				; XREF: Obj51_Index
		move.w	($FFFFF7D0).w,$34(a0)
		move.b	($FFFFB01C).w,$32(a0) ;	load Sonic's animation number
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		btst	#3,$22(a0)
		bne.s	Obj51_Smash

locret_FCFC:
		rts	
; ===========================================================================

Obj51_Smash:				; XREF: Obj51_Solid
		cmpi.b	#2,$32(a0)	; is Sonic rolling/jumping?
		bne.s	locret_FCFC	; if not, branch
		move.w	$34(a0),($FFFFF7D0).w
		bset	#2,$22(a1)
		move.b	#$E,$16(a1)
		move.b	#7,$17(a1)
		move.b	#2,$1C(a1)
		move.w	#-$300,$12(a1)	; bounce Sonic upwards
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		move.b	#1,$1A(a0)
		lea	(Obj51_Speeds).l,a4 ; load broken	fragment speed data
		moveq	#3,d1		; set number of	fragments to 4
		move.w	#$38,d2
		bsr.w	SmashObject
		bsr.w	SingleObjLoad
		bne.s	Obj51_Display
		move.w	($FFFFF7D0).w,d2
		addq.w	#2,($FFFFF7D0).w
		cmpi.w	#6,d2
		bcs.s	Obj51_Bonus
		moveq	#6,d2

Obj51_Bonus:
		moveq	#0,d0
		move.w	Obj51_Points(pc,d2.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 blocks been smashed?
		bcs.s	loc_FD98	; if not, branch
		move.w	#1000,d0	; give higher points for 16th block
		moveq	#10,d2

loc_FD98:
		jsr	AddPoints
		lsr.w	#1,d2
		move.b	d2,$1A(a1)

Obj51_Display:				; XREF: Obj51_Index
		bsr.w	SpeedToPos
		addi.w	#$38,$12(a0)
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================
Obj51_Speeds:	dc.w $FE00, $FE00	; x-speed, y-speed
		dc.w $FF00, $FF00
		dc.w $200, $FE00
		dc.w $100, $FF00

Obj51_Points:	dc.w 10, 20, 50, 100
; ---------------------------------------------------------------------------
; Sprite mappings - smashable green block (DDZ)
; ---------------------------------------------------------------------------
Map_obj51:
	include "_maps\obj51.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 52 - moving platform blocks (DDZ, TJZ, ABZ)
; ---------------------------------------------------------------------------

Obj52:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj52_Index(pc,d0.w),d1
		jmp	Obj52_Index(pc,d1.w)
; ===========================================================================
Obj52_Index:	dc.w Obj52_Main-Obj52_Index
		dc.w Obj52_Platform-Obj52_Index
		dc.w Obj52_StandOn-Obj52_Index

Obj52_Var:	dc.b $10, 0		; object width,	frame number
		dc.b $20, 1
		dc.b $20, 2
		dc.b $40, 3
		dc.b $30, 4
; ===========================================================================

Obj52_Main:				; XREF: Obj52_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj52,4(a0)
		move.w	#$2B8,2(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is TJZ
		bne.s	loc_FE44
		move.l	#Map_obj52a,4(a0) ; TJZ specific	code
		move.w	#$43BC,2(a0)
		move.b	#7,$16(a0)

loc_FE44:
		cmpi.b	#5,($FFFFFE10).w ; check if level is ABZ
		bne.s	loc_FE60
		move.w	#$22C0,2(a0)	; ABZ specific code (object 5228)
		cmpi.b	#$28,$28(a0)	; is object 5228 ?
		beq.s	loc_FE60	; if yes, branch
		move.w	#$4460,2(a0)	; ABZ specific code (object 523x)

loc_FE60:
		move.b	#4,1(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj52_Var(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2)+,$1A(a0)
		move.w	#$200,$18(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$32(a0)
		andi.b	#$F,$28(a0)

Obj52_Platform:				; XREF: Obj52_Index
		bsr.w	Obj52_Move
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(PlatformObject).l
		bra.s	Obj52_ChkDel
; ===========================================================================

Obj52_StandOn:				; XREF: Obj52_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(ExitPlatform).l
		move.w	8(a0),-(sp)
		bsr.w	Obj52_Move
		move.w	(sp)+,d2
		jsr	(MvSonicOnPtfm2).l

Obj52_ChkDel:				; XREF: Obj52_Platform
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj52_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj52_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj52_Done:
		bra.w	DisplaySprite
; ===========================================================================

Obj52_Move:				; XREF: Obj52_Platform; Obj52_StandOn
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj52_TypeIndex(pc,d0.w),d1
		jmp	Obj52_TypeIndex(pc,d1.w)
; ===========================================================================
Obj52_TypeIndex:dc.w Obj52_Type00-Obj52_TypeIndex, Obj52_Type01-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type03-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type05-Obj52_TypeIndex
		dc.w Obj52_Type06-Obj52_TypeIndex, Obj52_Type07-Obj52_TypeIndex
		dc.w Obj52_Type08-Obj52_TypeIndex, Obj52_Type02-Obj52_TypeIndex
		dc.w Obj52_Type0A-Obj52_TypeIndex
; ===========================================================================

Obj52_Type00:				; XREF: Obj52_TypeIndex
		rts	
; ===========================================================================

Obj52_Type01:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1
		btst	#0,$22(a0)
		beq.s	loc_FF26
		neg.w	d0
		add.w	d1,d0

loc_FF26:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

Obj52_Type02:				; XREF: Obj52_TypeIndex
		cmpi.b	#4,$24(a0)	; is Sonic standing on the platform?
		bne.s	Obj52_02_Wait
		addq.b	#1,$28(a0)	; if yes, add 1	to type

Obj52_02_Wait:
		rts	
; ===========================================================================

Obj52_Type03:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	$14(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_03_End	; if yes, branch
		addq.w	#1,8(a0)	; move platform	to the right
		move.w	8(a0),$30(a0)
		rts	
; ===========================================================================

Obj52_03_End:
		clr.b	$28(a0)		; change to type 00 (non-moving	type)
		rts	
; ===========================================================================

Obj52_Type05:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	$14(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_05_End	; if yes, branch
		addq.w	#1,8(a0)	; move platform	to the right
		move.w	8(a0),$30(a0)
		rts	
; ===========================================================================

Obj52_05_End:
		addq.b	#1,$28(a0)	; change to type 06 (falling)
		rts	
; ===========================================================================

Obj52_Type06:				; XREF: Obj52_TypeIndex
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; make the platform fall
		jsr	ObjHitFloor
		tst.w	d1		; has platform hit the floor?
		bpl.w	locret_FFA0	; if not, branch
		add.w	d1,$C(a0)
		clr.w	$12(a0)		; stop platform	falling
		clr.b	$28(a0)		; change to type 00 (non-moving)

locret_FFA0:
		rts	
; ===========================================================================

Obj52_Type07:				; XREF: Obj52_TypeIndex
		tst.b	($FFFFF7E2).w	; has switch number 02 been pressed?
		beq.s	Obj52_07_ChkDel
		subq.b	#3,$28(a0)	; if yes, change object	type to	04

Obj52_07_ChkDel:
		addq.l	#4,sp
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj52_Done2
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj52_Done2	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj52_Done2:
		rts	
; ===========================================================================

Obj52_Type08:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE7C).w,d0
		move.w	#$80,d1
		btst	#0,$22(a0)
		beq.s	loc_FFE2
		neg.w	d0
		add.w	d1,d0

loc_FFE2:
		move.w	$32(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

Obj52_Type0A:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	$14(a0),d3
		add.w	d3,d3
		moveq	#8,d1
		btst	#0,$22(a0)
		beq.s	loc_10004
		neg.w	d1
		neg.w	d3

loc_10004:
		tst.w	$36(a0)		; is platform set to move back?
		bne.s	Obj52_0A_Back	; if yes, branch
		move.w	8(a0),d0
		sub.w	$30(a0),d0
		cmp.w	d3,d0
		beq.s	Obj52_0A_Wait
		add.w	d1,8(a0)	; move platform
		move.w	#300,$34(a0)	; set time delay to 5 seconds
		rts	
; ===========================================================================

Obj52_0A_Wait:
		subq.w	#1,$34(a0)	; subtract 1 from time delay
		bne.s	locret_1002E	; if time remains, branch
		move.w	#1,$36(a0)	; set platform to move back to its original position

locret_1002E:
		rts	
; ===========================================================================

Obj52_0A_Back:
		move.w	8(a0),d0
		sub.w	$30(a0),d0
		beq.s	Obj52_0A_Reset
		sub.w	d1,8(a0)	; return platform to its original position
		rts	
; ===========================================================================

Obj52_0A_Reset:
		clr.w	$36(a0)
		subq.b	#1,$28(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (DDZ, ABZ)
; ---------------------------------------------------------------------------
Map_obj52:
	include "_maps\obj52DDZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - moving block (TJZ)
; ---------------------------------------------------------------------------
Map_obj52a:
	include "_maps\obj52TJZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 55 - Basaran enemy (DDZ)
; ---------------------------------------------------------------------------

Obj55:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj55_Index(pc,d0.w),d1
		jmp	Obj55_Index(pc,d1.w)
; ===========================================================================
Obj55_Index:	dc.w Obj55_Main-Obj55_Index
		dc.w Obj55_Action-Obj55_Index
; ===========================================================================

Obj55_Main:				; XREF: Obj55_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj55,4(a0)
		move.w	#$A322,2(a0)
		move.b	#4,1(a0)
		move.b	#$C,$16(a0)
		move.w	#$100,$18(a0)
		move.b	#$B,$20(a0)
		move.b	#$10,$14(a0)

Obj55_Action:				; XREF: Obj55_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj55_Index2(pc,d0.w),d1
		jsr	Obj55_Index2(pc,d1.w)
		lea	(Ani_obj55).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj55_Index2:	dc.w Obj55_ChkDrop-Obj55_Index2
		dc.w Obj55_DropFly-Obj55_Index2
		dc.w Obj55_PlaySnd-Obj55_Index2
		dc.w Obj55_FlyUp-Obj55_Index2
; ===========================================================================

Obj55_ChkDrop:				; XREF: Obj55_Index2
		move.w	#$80,d2
		bsr.w	Obj55_ChkSonic
		bcc.s	Obj55_NoDrop
		move.w	($FFFFB00C).w,d0
		move.w	d0,$36(a0)
		sub.w	$C(a0),d0
		bcs.s	Obj55_NoDrop
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	basaran?
		bcc.s	Obj55_NoDrop	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	Obj55_NoDrop	; if yes, branch
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	Obj55_NoDrop
		move.b	#1,$1C(a0)
		addq.b	#2,$25(a0)

Obj55_NoDrop:
		rts	
; ===========================================================================

Obj55_DropFly:				; XREF: Obj55_Index2
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; make basaran fall
		move.w	#$80,d2
		bsr.w	Obj55_ChkSonic
		move.w	$36(a0),d0
		sub.w	$C(a0),d0
		bcs.s	Obj55_ChkDel
		cmpi.w	#$10,d0
		bcc.s	locret_10180
		move.w	d1,$10(a0)	; make basaran fly horizontally
		move.w	#0,$12(a0)	; stop basaran falling
		move.b	#2,$1C(a0)
		addq.b	#2,$25(a0)

locret_10180:
		rts	
; ===========================================================================

Obj55_ChkDel:				; XREF: Obj55_DropFly
		tst.b	1(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================

Obj55_PlaySnd:				; XREF: Obj55_Index2
		move.b	($FFFFFE0F).w,d0
		andi.b	#$F,d0
		bne.s	loc_101A0
		move.w	#$47,d0
		jsr	(PlaySound_Special).l ;	play flapping sound

loc_101A0:
		bsr.w	SpeedToPos
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_101B0
		neg.w	d0

loc_101B0:
		cmpi.w	#$80,d0
		bcs.s	locret_101C6
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	locret_101C6
		addq.b	#2,$25(a0)

locret_101C6:
		rts	
; ===========================================================================

Obj55_FlyUp:				; XREF: Obj55_Index2
		bsr.w	SpeedToPos
		subi.w	#$18,$12(a0)	; make basaran fly upwards
		jsr	ObjHitCeiling
		tst.w	d1		; has basaran hit the ceiling?
		bpl.s	locret_101F4	; if not, branch
		sub.w	d1,$C(a0)
		andi.w	#$FFF8,8(a0)
		clr.w	$10(a0)		; stop basaran moving
		clr.w	$12(a0)
		clr.b	$1C(a0)
		clr.b	$25(a0)

locret_101F4:
		rts	
; ===========================================================================

Obj55_ChkSonic:				; XREF: Obj55_ChkDrop
		move.w	#$100,d1
		bset	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_10214
		neg.w	d0
		neg.w	d1
		bclr	#0,$22(a0)

loc_10214:
		cmp.w	d2,d0
		rts	
; ===========================================================================
		bsr.w	SpeedToPos
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================
Ani_obj55:
	include "_anim\obj55.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Basaran enemy (DDZ)
; ---------------------------------------------------------------------------
Map_obj55:
	include "_maps\obj55.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 56 - moving blocks (CCZ/KVZ), large doors (TJZ)
; ---------------------------------------------------------------------------

Obj56:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj56_Index(pc,d0.w),d1
		jmp	Obj56_Index(pc,d1.w)
; ===========================================================================
Obj56_Index:	dc.w Obj56_Main-Obj56_Index
		dc.w Obj56_Action-Obj56_Index

Obj56_Var:	dc.b  $10, $10		; width, height
		dc.b  $20, $20
		dc.b  $10, $20
		dc.b  $20, $1A
		dc.b  $10, $27
		dc.b  $10, $10
		dc.b	8, $20
		dc.b  $40, $10
; ===========================================================================

Obj56_Main:				; XREF: Obj56_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj56,4(a0)
		move.w	#$4000,2(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is TJZ
		bne.s	loc_102C8
		move.w	#$43C4,2(a0)	; TJZ specific code

loc_102C8:
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj56_Var(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2),$16(a0)
		lsr.w	#1,d0
		move.b	d0,$1A(a0)
		move.w	8(a0),$34(a0)
		move.w	$C(a0),$30(a0)
		moveq	#0,d0
		move.b	(a2),d0
		add.w	d0,d0
		move.w	d0,$3A(a0)
		moveq	#0,d0
		cmpi.b	#1,($FFFFFE10).w ; check if level is TJZ
		beq.s	loc_10332
		move.b	$28(a0),d0	; CCZ/KVZ specific code
		andi.w	#$F,d0
		subq.w	#8,d0
		bcs.s	loc_10332
		lsl.w	#2,d0
		lea	($FFFFFE8A).w,a2
		lea	(a2,d0.w),a2
		tst.w	(a2)
		bpl.s	loc_10332
		bchg	#0,$22(a0)

loc_10332:
		move.b	$28(a0),d0
		bpl.s	Obj56_Action
		andi.b	#$F,d0
		move.b	d0,$3C(a0)
		move.b	#5,$28(a0)
		cmpi.b	#7,$1A(a0)
		bne.s	Obj56_ChkGone
		move.b	#$C,$28(a0)
		move.w	#$80,$3A(a0)

Obj56_ChkGone:
        move.w  $1E(a0),d0    ; get address in respawn table
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
		btst	#0,(a2)
		beq.s	Obj56_Action
		addq.b	#1,$28(a0)
		clr.w	$3A(a0)

Obj56_Action:				; XREF: Obj56_Index
		move.w	8(a0),-(sp)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj56_TypeIndex(pc,d0.w),d1
		jsr	Obj56_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	1(a0)
		bpl.s	Obj56_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr.w	SolidObject

Obj56_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj56_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj56_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj56_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj56_TypeIndex:dc.w Obj56_Type00-Obj56_TypeIndex, Obj56_Type01-Obj56_TypeIndex
		dc.w Obj56_Type02-Obj56_TypeIndex, Obj56_Type03-Obj56_TypeIndex
		dc.w Obj56_Type04-Obj56_TypeIndex, Obj56_Type05-Obj56_TypeIndex
		dc.w Obj56_Type06-Obj56_TypeIndex, Obj56_Type07-Obj56_TypeIndex
		dc.w Obj56_Type08-Obj56_TypeIndex, Obj56_Type09-Obj56_TypeIndex
		dc.w Obj56_Type0A-Obj56_TypeIndex, Obj56_Type0B-Obj56_TypeIndex
		dc.w Obj56_Type0C-Obj56_TypeIndex, Obj56_Type0D-Obj56_TypeIndex
; ===========================================================================

Obj56_Type00:				; XREF: Obj56_TypeIndex
		rts	
; ===========================================================================

Obj56_Type01:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_LR
; ===========================================================================

Obj56_Type02:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_LR:
		btst	#0,$22(a0)
		beq.s	loc_10416
		neg.w	d0
		add.w	d1,d0

loc_10416:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)	; move object horizontally
		rts	
; ===========================================================================

Obj56_Type03:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_UD
; ===========================================================================

Obj56_Type04:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_UD:
		btst	#0,$22(a0)
		beq.s	loc_10444
		neg.w	d0
		add.w	d1,d0

loc_10444:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; move object vertically
		rts	
; ===========================================================================

Obj56_Type05:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_104A4
		cmpi.w	#$100,($FFFFFE10).w ; is level TJZ1 ?
		bne.s	loc_1047A	; if not, branch
		cmpi.b	#3,$3C(a0)
		bne.s	loc_1047A
		clr.b	($FFFFF7C9).w
		move.w	($FFFFB008).w,d0
		cmp.w	8(a0),d0
		bcc.s	loc_1047A
		move.b	#1,($FFFFF7C9).w

loc_1047A:
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_104AE
		cmpi.w	#$100,($FFFFFE10).w ; is level TJZ1 ?
		bne.s	loc_1049E	; if not, branch
		cmpi.b	#3,d0
		bne.s	loc_1049E
		clr.b	($FFFFF7C9).w

loc_1049E:
		move.b	#1,$38(a0)

loc_104A4:
		tst.w	$3A(a0)
		beq.s	loc_104C8
		subq.w	#2,$3A(a0)

loc_104AE:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_104BC
		neg.w	d0

loc_104BC:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_104C8:
		addq.b	#1,$28(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_104AE
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		bra.s	loc_104AE
; ===========================================================================

Obj56_Type06:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_10500
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10512
		move.b	#1,$38(a0)

loc_10500:
		moveq	#0,d0
		move.b	$16(a0),d0
		add.w	d0,d0
		cmp.w	$3A(a0),d0
		beq.s	loc_1052C
		addq.w	#2,$3A(a0)

loc_10512:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_10520
		neg.w	d0

loc_10520:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_1052C:
		subq.b	#1,$28(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_10512
		movea.w	d0,a2	; load address into a2
		bclr	#0,(a2)
		bra.s	loc_10512
; ===========================================================================

Obj56_Type07:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_1055E
		tst.b	($FFFFF7EF).w	; has switch number $F been pressed?
		beq.s	locret_10578
		move.b	#1,$38(a0)
		clr.w	$3A(a0)

loc_1055E:
		addq.w	#1,8(a0)
		move.w	8(a0),$34(a0)
		addq.w	#1,$3A(a0)
		cmpi.w	#$380,$3A(a0)
		bne.s	locret_10578
		clr.b	$28(a0)

locret_10578:
		rts	
; ===========================================================================

Obj56_Type0C:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_10598
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_105A2
		move.b	#1,$38(a0)

loc_10598:
		tst.w	$3A(a0)
		beq.s	loc_105C0
		subq.w	#2,$3A(a0)

loc_105A2:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_105B4
		neg.w	d0
		addi.w	#$80,d0

loc_105B4:
		move.w	$34(a0),d1
		add.w	d0,d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

loc_105C0:
		addq.b	#1,$28(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_105A2
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		bra.s	loc_105A2
; ===========================================================================

Obj56_Type0D:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_105F8
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10606
		move.b	#1,$38(a0)

loc_105F8:
		move.w	#$80,d0
		cmp.w	$3A(a0),d0
		beq.s	loc_10624
		addq.w	#2,$3A(a0)

loc_10606:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_10618
		neg.w	d0
		addi.w	#$80,d0

loc_10618:
		move.w	$34(a0),d1
		add.w	d0,d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

loc_10624:
		subq.b	#1,$28(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_10606
		movea.w	d0,a2	; load address into a2
		bclr	#0,(a2)
		bra.s	loc_10606
; ===========================================================================

Obj56_Type08:				; XREF: Obj56_TypeIndex
		move.w	#$10,d1
		moveq	#0,d0
		move.b	($FFFFFE88).w,d0
		lsr.w	#1,d0
		move.w	($FFFFFE8A).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type09:				; XREF: Obj56_TypeIndex
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE8C).w,d0
		move.w	($FFFFFE8E).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0A:				; XREF: Obj56_TypeIndex
		move.w	#$50,d1
		moveq	#0,d0
		move.b	($FFFFFE90).w,d0
		move.w	($FFFFFE92).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0B:				; XREF: Obj56_TypeIndex
		move.w	#$70,d1
		moveq	#0,d0
		move.b	($FFFFFE94).w,d0
		move.w	($FFFFFE96).w,d3

Obj56_Move_Sqr:
		tst.w	d3
		bne.s	loc_1068E
		addq.b	#1,$22(a0)
		andi.b	#3,$22(a0)

loc_1068E:
		move.b	$22(a0),d2
		andi.b	#3,d2
		bne.s	loc_106AE
		sub.w	d1,d0
		add.w	$34(a0),d0
		move.w	d0,8(a0)
		neg.w	d1
		add.w	$30(a0),d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_106AE:
		subq.b	#1,d2
		bne.s	loc_106CC
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		addq.w	#1,d1
		add.w	$34(a0),d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

loc_106CC:
		subq.b	#1,d2
		bne.s	loc_106EA
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$34(a0),d0
		move.w	d0,8(a0)
		addq.w	#1,d1
		add.w	$30(a0),d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_106EA:
		sub.w	d1,d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		neg.w	d1
		add.w	$34(a0),d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (CCZ/KVZ/TJZ)
; ---------------------------------------------------------------------------
Map_obj56:
	include "_maps\obj56.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 57 - spiked balls (CCZ, TJZ)
; ---------------------------------------------------------------------------

Obj57:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj57_Index(pc,d0.w),d1
		jmp	Obj57_Index(pc,d1.w)
; ===========================================================================
Obj57_Index:	dc.w Obj57_Main-Obj57_Index
		dc.w Obj57_Move-Obj57_Index
		dc.w Obj57_Display-Obj57_Index
; ===========================================================================

Obj57_Main:				; XREF: Obj57_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj57,4(a0)
		move.w	#$3A8,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#8,$14(a0)
		move.w	8(a0),$3A(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$98,$20(a0)	; CCZ specific code (chain hurts Sonic)
		cmpi.b	#3,($FFFFFE10).w ; check if level is TJZ
		bne.s	loc_107E8
		move.b	#0,$20(a0)	; TJZ specific code (chain doesn't hurt)
		move.w	#$240C,2(a0)
		move.l	#Map_obj57a,4(a0)

loc_107E8:
		move.b	$28(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,$3E(a0)	; set object twirl speed
		move.b	$22(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,$26(a0)
		lea	$29(a0),a2
		move.b	$28(a0),d1	; get object type
		andi.w	#7,d1		; read only the	2nd digit
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		move.b	d3,$3C(a0)
		subq.w	#1,d1		; set chain length (type-1)
		bcs.s	loc_10894
		btst	#3,$28(a0)
		beq.s	Obj57_MakeChain
		subq.w	#1,d1
		bcs.s	loc_10894

Obj57_MakeChain:
		bsr.w	SingleObjLoad
		bne.s	loc_10894
		addq.b	#1,$29(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,$24(a1)
		move.b	0(a0),0(a1)
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		move.b	1(a0),1(a1)
		move.w	$18(a0),$18(a1)
		move.b	$14(a0),$14(a1)
		move.b	$20(a0),$20(a1)
		subi.b	#$10,d3
		move.b	d3,$3C(a1)
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_10890
		tst.b	d3
		bne.s	loc_10890
		move.b	#2,$1A(a1)

loc_10890:
		dbf	d1,Obj57_MakeChain ; repeat for	length of chain

loc_10894:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$8B,$20(a0)	; if yes, make last spikeball larger
		move.b	#1,$1A(a0)	; use different	frame

Obj57_Move:				; XREF: Obj57_Index
		bsr.w	Obj57_MoveSub
		bra.w	Obj57_ChkDel
; ===========================================================================

Obj57_MoveSub:				; XREF: Obj57_Move
		move.w	$3E(a0),d0
		add.w	d0,$26(a0)
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	$29(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

Obj57_MoveLoop:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFB000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,$C(a1)
		move.w	d5,8(a1)
		dbf	d6,Obj57_MoveLoop
		rts	
; ===========================================================================

Obj57_ChkDel:				; XREF: Obj57_Move
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj57_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj57_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj57_Delete

Obj57_Done:
		bra.w	DisplaySprite
; ===========================================================================

Obj57_Delete:				; XREF: Obj57_ChkDel
		moveq	#0,d2
		lea	$29(a0),a2
		move.b	(a2)+,d2

Obj57_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,Obj57_DelLoop ; delete all pieces of	chain

		rts	
; ===========================================================================

Obj57_Display:				; XREF: Obj57_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - chain of spiked balls (CCZ)
; ---------------------------------------------------------------------------
Map_obj57:
	include "_maps\obj57CCZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked ball	on a chain (TJZ)
; ---------------------------------------------------------------------------
Map_obj57a:
	include "_maps\obj57TJZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 58 - giant spiked balls (CCZ)
; ---------------------------------------------------------------------------

Obj58:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj58_Index(pc,d0.w),d1
		jmp	Obj58_Index(pc,d1.w)
; ===========================================================================
Obj58_Index:	dc.w Obj58_Main-Obj58_Index
		dc.w Obj58_Move-Obj58_Index
; ===========================================================================

Obj58_Main:				; XREF: Obj58_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj15b,4(a0)
		move.w	#$396,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$18,$14(a0)
		move.w	8(a0),$3A(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$86,$20(a0)
		move.b	$28(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,$3E(a0)	; set object speed
		move.b	$22(a0),d0
		ror.b	#2,d0
		andi.b	#$C0,d0
		move.b	d0,$26(a0)
		move.b	#$50,$3C(a0)	; set diameter of circle of rotation

Obj58_Move:				; XREF: Obj58_Index
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		andi.w	#7,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj58_TypeIndex(pc,d0.w),d1
		jsr	Obj58_TypeIndex(pc,d1.w)
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj58_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj58_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj58_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj58_TypeIndex:dc.w Obj58_Type00-Obj58_TypeIndex
		dc.w Obj58_Type01-Obj58_TypeIndex
		dc.w Obj58_Type02-Obj58_TypeIndex
		dc.w Obj58_Type03-Obj58_TypeIndex
; ===========================================================================

Obj58_Type00:				; XREF: Obj58_TypeIndex
		rts	
; ===========================================================================

Obj58_Type01:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,$22(a0)
		beq.s	loc_10A38
		neg.w	d0
		add.w	d1,d0

loc_10A38:
		move.w	$3A(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)	; move object horizontally
		rts	
; ===========================================================================

Obj58_Type02:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,$22(a0)
		beq.s	loc_10A5C
		neg.w	d0
		addi.w	#$80,d0

loc_10A5C:
		move.w	$38(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; move object vertically
		rts	
; ===========================================================================

Obj58_Type03:				; XREF: Obj58_TypeIndex
		move.w	$3E(a0),d0
		add.w	d0,$26(a0)
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		moveq	#0,d4
		move.b	$3C(a0),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,$C(a0)
		move.w	d5,8(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - ABZ	spiked ball on a chain
; ---------------------------------------------------------------------------
Map_obj15b:
	include "_maps\obj15ABZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 59 - platforms	that move when you stand on them (KVZ)
; ---------------------------------------------------------------------------

Obj59:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj59_Index(pc,d0.w),d1
		jsr	Obj59_Index(pc,d1.w)
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj59_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj59_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj59_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj59_Index:	dc.w Obj59_Main-Obj59_Index
		dc.w Obj59_Platform-Obj59_Index
		dc.w Obj59_Action-Obj59_Index
		dc.w Obj59_MakeMulti-Obj59_Index

Obj59_Var1:	dc.b $28, 0		; width, frame number

Obj59_Var2:	dc.b $10, 1		; width, action	type
		dc.b $20, 1
		dc.b $34, 1
		dc.b $10, 3
		dc.b $20, 3
		dc.b $34, 3
		dc.b $14, 1
		dc.b $24, 1
		dc.b $2C, 1
		dc.b $14, 3
		dc.b $24, 3
		dc.b $2C, 3
		dc.b $20, 5
		dc.b $20, 7
		dc.b $30, 9
; ===========================================================================

Obj59_Main:				; XREF: Obj59_Index
		addq.b	#2,$24(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		bpl.s	Obj59_Main2
		addq.b	#4,$24(a0)
		andi.w	#$7F,d0
		mulu.w	#6,d0
		move.w	d0,$3C(a0)
		move.w	d0,$3E(a0)
		addq.l	#4,sp
		rts	
; ===========================================================================

Obj59_Main2:
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj59_Var1(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2)+,$1A(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj59_Var2(pc,d0.w),a2
		move.b	(a2)+,d0
		lsl.w	#2,d0
		move.w	d0,$3C(a0)
		move.b	(a2)+,$28(a0)
		move.l	#Map_obj59,4(a0)
		move.w	#$4000,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.w	8(a0),$32(a0)
		move.w	$C(a0),$30(a0)

Obj59_Platform:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj59_Types
; ===========================================================================

Obj59_Action:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(ExitPlatform).l
		move.w	8(a0),-(sp)
		bsr.w	Obj59_Types
		move.w	(sp)+,d2
		tst.b	0(a0)
		beq.s	locret_10BD4
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

locret_10BD4:
		rts	
; ===========================================================================

Obj59_Types:
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj59_TypeIndex(pc,d0.w),d1
		jmp	Obj59_TypeIndex(pc,d1.w)
; ===========================================================================
Obj59_TypeIndex:dc.w Obj59_Type00-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type02-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type04-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type06-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type08-Obj59_TypeIndex, Obj59_Type09-Obj59_TypeIndex
; ===========================================================================

Obj59_Type00:				; XREF: Obj59_TypeIndex
		rts	
; ===========================================================================

Obj59_Type01:				; XREF: Obj59_TypeIndex
		cmpi.b	#4,$24(a0)	; check	if Sonic is standing on	the object
		bne.s	locret_10C0C
		addq.b	#1,$28(a0)	; if yes, add 1	to type

locret_10C0C:
		rts	
; ===========================================================================

Obj59_Type02:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		rts	
; ===========================================================================

Obj59_Type04:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		rts	
; ===========================================================================

Obj59_Type06:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	$34(a0),d0
		asr.w	#1,d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		move.w	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,8(a0)
		rts	
; ===========================================================================

Obj59_Type08:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	$34(a0),d0
		asr.w	#1,d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$32(a0),d0
		move.w	d0,8(a0)
		rts	
; ===========================================================================

Obj59_Type09:				; XREF: Obj59_TypeIndex
		bsr.w	Obj59_Move
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)
		tst.b	$28(a0)
		beq.w	loc_10C94
		rts	
; ===========================================================================

loc_10C94:
		btst	#3,$22(a0)
		beq.s	Obj59_Delete
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)

Obj59_Delete:
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj59_Move:				; XREF: Obj59_Type02; et al
		move.w	$38(a0),d0
		tst.b	$3A(a0)
		bne.s	loc_10CC8
		cmpi.w	#$800,d0
		bcc.s	loc_10CD0
		addi.w	#$10,d0
		bra.s	loc_10CD0
; ===========================================================================

loc_10CC8:
		tst.w	d0
		beq.s	loc_10CD0
		subi.w	#$10,d0

loc_10CD0:
		move.w	d0,$38(a0)
		ext.l	d0
		asl.l	#8,d0
		add.l	$34(a0),d0
		move.l	d0,$34(a0)
		swap	d0
		move.w	$3C(a0),d2
		cmp.w	d2,d0
		bls.s	loc_10CF0
		move.b	#1,$3A(a0)

loc_10CF0:
		add.w	d2,d2
		cmp.w	d2,d0
		bne.s	locret_10CFA
		clr.b	$28(a0)

locret_10CFA:
		rts	
; End of function Obj59_Move

; ===========================================================================

Obj59_MakeMulti:			; XREF: Obj59_Index
		subq.w	#1,$3C(a0)
		bne.s	Obj59_ChkDel
		move.w	$3E(a0),$3C(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj59_ChkDel
		move.b	#$59,0(a1)	; duplicate the	object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	#$E,$28(a1)

Obj59_ChkDel:
		addq.l	#4,sp
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj59_Done2
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj59_Done2	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj59_Done2:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	when you stand on them (KVZ)
; ---------------------------------------------------------------------------
Map_obj59:
	include "_maps\obj59.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5A - platforms	moving in circles (KVZ)
; ---------------------------------------------------------------------------

Obj5A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5A_Index(pc,d0.w),d1
		jsr	Obj5A_Index(pc,d1.w)
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj5A_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj5A_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj5A_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj5A_Index:	dc.w Obj5A_Main-Obj5A_Index
		dc.w Obj5A_Platform-Obj5A_Index
		dc.w Obj5A_Action-Obj5A_Index
; ===========================================================================

Obj5A_Main:				; XREF: Obj5A_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5A,4(a0)
		move.w	#$4000,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$18,$14(a0)
		move.w	8(a0),$32(a0)
		move.w	$C(a0),$30(a0)

Obj5A_Platform:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj5A_Types
; ===========================================================================

Obj5A_Action:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(ExitPlatform).l
		move.w	8(a0),-(sp)
		bsr.w	Obj5A_Types
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

Obj5A_Types:
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$C,d0
		lsr.w	#1,d0
		move.w	Obj5A_TypeIndex(pc,d0.w),d1
		jmp	Obj5A_TypeIndex(pc,d1.w)
; ===========================================================================
Obj5A_TypeIndex:dc.w Obj5A_Type00-Obj5A_TypeIndex
		dc.w Obj5A_Type04-Obj5A_TypeIndex
; ===========================================================================

Obj5A_Type00:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,$28(a0)
		beq.s	loc_10E24
		neg.w	d1
		neg.w	d2

loc_10E24:
		btst	#1,$28(a0)
		beq.s	loc_10E30
		neg.w	d1
		exg	d1,d2

loc_10E30:
		add.w	$32(a0),d1
		move.w	d1,8(a0)
		add.w	$30(a0),d2
		move.w	d2,$C(a0)
		rts	
; ===========================================================================

Obj5A_Type04:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,$28(a0)
		beq.s	loc_10E62
		neg.w	d1
		neg.w	d2

loc_10E62:
		btst	#1,$28(a0)
		beq.s	loc_10E6E
		neg.w	d1
		exg	d1,d2

loc_10E6E:
		neg.w	d1
		add.w	$32(a0),d1
		move.w	d1,8(a0)
		add.w	$30(a0),d2
		move.w	d2,$C(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	in circles (KVZ)
; ---------------------------------------------------------------------------
Map_obj5A:
	include "_maps\obj5A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5B - blocks that form a staircase (KVZ)
; ---------------------------------------------------------------------------

Obj5B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5B_Index(pc,d0.w),d1
		jsr	Obj5B_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj5B_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj5B_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj5B_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj5B_Index:	dc.w Obj5B_Main-Obj5B_Index
		dc.w Obj5B_Move-Obj5B_Index
		dc.w Obj5B_Solid-Obj5B_Index
; ===========================================================================

Obj5B_Main:				; XREF: Obj5B_Index
		addq.b	#2,$24(a0)
		moveq	#$38,d3
		moveq	#1,d4
		btst	#0,$22(a0)
		beq.s	loc_10EDA
		moveq	#$3B,d3
		moveq	#-1,d4

loc_10EDA:
		move.w	8(a0),d2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj5B_MakeBlocks
; ===========================================================================

Obj5B_Loop:
		bsr.w	SingleObjLoad2
		bne.w	Obj5B_Move
		move.b	#4,$24(a1)

Obj5B_MakeBlocks:			; XREF: Obj5B_Main
		move.b	#$5B,0(a1)	; load another block object
		move.l	#Map_obj5B,4(a1)
		move.w	#$4000,2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#$10,$14(a1)
		move.b	$28(a0),$28(a1)
		move.w	d2,8(a1)
		move.w	$C(a0),$C(a1)
		move.w	8(a0),$30(a1)
		move.w	$C(a1),$32(a1)
		addi.w	#$20,d2
		move.b	d3,$37(a1)
		move.l	a0,$3C(a1)
		add.b	d4,d3
		dbf	d1,Obj5B_Loop	; repeat sequence 3 times

Obj5B_Move:				; XREF: Obj5B_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj5B_TypeIndex(pc,d0.w),d1
		jsr	Obj5B_TypeIndex(pc,d1.w)

Obj5B_Solid:				; XREF: Obj5B_Index
		movea.l	$3C(a0),a2
		moveq	#0,d0
		move.b	$37(a0),d0
		move.b	(a2,d0.w),d0
		add.w	$32(a0),d0
		move.w	d0,$C(a0)
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		tst.b	d4
		bpl.s	loc_10F92
		move.b	d4,$36(a2)

loc_10F92:
		btst	#3,$22(a0)
		beq.s	locret_10FA0
		move.b	#1,$36(a2)

locret_10FA0:
		rts	
; ===========================================================================
Obj5B_TypeIndex:dc.w Obj5B_Type00-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
		dc.w Obj5B_Type02-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
; ===========================================================================

Obj5B_Type00:				; XREF: Obj5B_TypeIndex
		tst.w	$34(a0)
		bne.s	loc_10FC0
		cmpi.b	#1,$36(a0)
		bne.s	locret_10FBE
		move.w	#$1E,$34(a0)

locret_10FBE:
		rts	
; ===========================================================================

loc_10FC0:
		subq.w	#1,$34(a0)
		bne.s	locret_10FBE
		addq.b	#1,$28(a0)	; add 1	to type
		rts	
; ===========================================================================

Obj5B_Type02:				; XREF: Obj5B_TypeIndex
		tst.w	$34(a0)
		bne.s	loc_10FE0
		tst.b	$36(a0)
		bpl.s	locret_10FDE
		move.w	#$3C,$34(a0)

locret_10FDE:
		rts	
; ===========================================================================

loc_10FE0:
		subq.w	#1,$34(a0)
		bne.s	loc_10FEC
		addq.b	#1,$28(a0)	; add 1	to type
		rts	
; ===========================================================================

loc_10FEC:
		lea	$38(a0),a1
		move.w	$34(a0),d0
		lsr.b	#2,d0
		andi.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		rts	
; ===========================================================================

Obj5B_Type01:				; XREF: Obj5B_TypeIndex
		lea	$38(a0),a1
		cmpi.b	#$80,(a1)
		beq.s	locret_11038
		addq.b	#1,(a1)
		moveq	#0,d1
		move.b	(a1)+,d1
		swap	d1
		lsr.l	#1,d1
		move.l	d1,d2
		lsr.l	#1,d1
		move.l	d1,d3
		add.l	d2,d3
		swap	d1
		swap	d2
		swap	d3
		move.b	d3,(a1)+
		move.b	d2,(a1)+
		move.b	d1,(a1)+

locret_11038:
		rts	
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	form a staircase (KVZ)
; ---------------------------------------------------------------------------
Map_obj5B:
	include "_maps\obj5B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5C - metal girders in foreground (KVZ)
; ---------------------------------------------------------------------------

Obj5C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5C_Index(pc,d0.w),d1
		jmp	Obj5C_Index(pc,d1.w)
; ===========================================================================
Obj5C_Index:	dc.w Obj5C_Main-Obj5C_Index
		dc.w Obj5C_Display-Obj5C_Index
; ===========================================================================

Obj5C_Main:				; XREF: Obj5C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5C,4(a0)
		move.w	#$83CC,2(a0)
		move.b	#$10,$14(a0)

Obj5C_Display:				; XREF: Obj5C_Index
		move.l	($FFFFF700).w,d1
		add.l	d1,d1
		swap	d1
		neg.w	d1
		move.w	d1,8(a0)
		move.l	($FFFFF704).w,d1
		add.l	d1,d1
		swap	d1
		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,$A(a0)
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal girders in foreground	(KVZ)
; ---------------------------------------------------------------------------
Map_obj5C:
	include "_maps\obj5C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1B - water surface (TJZ)
; ---------------------------------------------------------------------------

Obj1B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1B_Index(pc,d0.w),d1
		jmp	Obj1B_Index(pc,d1.w)
; ===========================================================================
Obj1B_Index:	dc.w Obj1B_Main-Obj1B_Index
		dc.w Obj1B_Action-Obj1B_Index
; ===========================================================================

Obj1B_Main:				; XREF: Obj1B_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj1B,4(a0)
		move.w	#$A380,2(a0)
		move.b	#4,1(a0)
		move.b	#$80,$14(a0)
		move.w	8(a0),$30(a0)

Obj1B_Action:				; XREF: Obj1B_Index
		move.w	($FFFFF700).w,d1
		andi.w	#$FFE0,d1
		add.w	$30(a0),d1
		btst	#0,($FFFFFE05).w
		beq.s	loc_11114
		addi.w	#$20,d1

loc_11114:
		move.w	d1,8(a0)	; match	obj x-position to screen position
		move.w	($FFFFF646).w,d1
		move.w	d1,$C(a0)	; match	obj y-position to water	height
		tst.b	$32(a0)
		bne.s	Obj1B_Animate
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq.s	loc_1114A	; if not, branch
		addq.b	#3,$1A(a0)	; use different	frames
		move.b	#1,$32(a0)	; stop animation
		bra.s	Obj1B_Display
; ===========================================================================

Obj1B_Animate:				; XREF: loc_11114
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	Obj1B_Display	; if yes, branch
		move.b	#0,$32(a0)	; resume animation
		subq.b	#3,$1A(a0)	; use normal frames

loc_1114A:				; XREF: loc_11114
		subq.b	#1,$23(a0)
		bpl.s	Obj1B_Display
		move.b	#7,$23(a0)
		addq.b	#1,$1A(a0)
		cmpi.b	#3,$1A(a0)
		bcs.s	Obj1B_Display
		move.b	#0,$1A(a0)

Obj1B_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - water surface (TJZ)
; ---------------------------------------------------------------------------
Map_obj1B:
	include "_maps\obj1B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0B - pole that	breaks (TJZ)
; ---------------------------------------------------------------------------

Obj0B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0B_Index(pc,d0.w),d1
		jsr	Obj0B_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj0B_Index:	dc.w Obj0B_Main-Obj0B_Index
		dc.w Obj0B_Action-Obj0B_Index
		dc.w Obj0B_FragMove-Obj0B_Index
; ===========================================================================

Obj0B_Main:				; XREF: Obj0B_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj0B,4(a0)
		move.w	#$43DE,2(a0)
		move.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$200,$18(a0)
		move.b	#$E1,$20(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		mulu.w	#60,d0		; multiply by 60 (1 second)
		move.w	d0,$30(a0)	; set breakage time

Obj0B_Action:				; XREF: Obj0B_Index
		tst.b	$32(a0)
		beq.w	Obj0B_Grab
		tst.w	$30(a0)
		beq.w	Obj0B_MoveUp
		subq.w	#1,$30(a0)
		bne.w	Obj0B_MoveUp
		bra.s	Obj0B_Release

Obj0B_MoveUp:				; XREF: Obj0B_Action
		lea	($FFFFB000).w,a1
		move.w	$C(a0),d0
		subi.w	#$18,d0
		btst	#0,($FFFFF604).w ; check if "up" is pressed
		beq.s	Obj0B_MoveDown
		subq.w	#1,$C(a1)	; move Sonic up
		cmp.w	$C(a1),d0
		bcs.s	Obj0B_MoveDown
		move.w	d0,$C(a1)

Obj0B_MoveDown:
		addi.w	#$24,d0
		btst	#1,($FFFFF604).w ; check if "down" is pressed
		beq.s	Obj0B_LetGo
		addq.w	#1,$C(a1)	; move Sonic down
		cmp.w	$C(a1),d0
		bcc.s	Obj0B_LetGo
		move.w	d0,$C(a1)

Obj0B_LetGo:
		move.b	($FFFFF603).w,d0
		andi.w	#$70,d0
		beq.s	Obj0B_Done

Obj0B_Release:				; XREF: Obj0B_Action
		move.b	#1,$1A(a0)	; break	the pole
		lea	(Obj0B_Speeds).l,a4 ; load broken	fragment speed data
		moveq	#7,d1		; set number of	fragments to 4
		move.w	#$38,d2
		bsr.w	SmashObject
		clr.b	$20(a0)
	;	addq.b	#2,$24(a0)
		clr.b	($FFFFF7C8).w
		clr.b	($FFFFF7C9).w
		clr.b	$32(a0)
		bra.s	Obj0B_FragMove

Obj0B_Done:
		rts
; ===========================================================================
Obj0B_Speeds:	dc.w	  $FFF0, $FF90
		dc.w	  $FFF0, $FFB0
		dc.w	  $FFF0, $FFD0
		dc.w	  $FFF0, $FFF0
		dc.w	  $FFF0,   $10
		dc.w	  $FFF0,   $30
		dc.w	  $FFF0,   $50
		dc.w	  $FFF0,   $70
; ===========================================================================

Obj0B_Grab:				; XREF: Obj0B_Action
		tst.b	$21(a0)		; has Sonic touched the	pole?
		beq.s	Obj0B_Done	; if not, branch
		lea	($FFFFB000).w,a1
		move.w	8(a0),d0
		addi.w	#$14,d0
		cmp.w	8(a1),d0
		bcc.s	Obj0B_Done
		clr.b	$21(a0)
		cmpi.b	#4,$24(a1)
		bcc.s	Obj0B_Done
		clr.w	$10(a1)		; stop Sonic moving
		clr.w	$12(a1)		; stop Sonic moving
		move.w	8(a0),d0
		addi.w	#$14,d0
		move.w	d0,8(a1)
		bclr	#0,$22(a1)
		move.b	#$11,$1C(a1)	; set Sonic's animation to "hanging" ($11)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#1,($FFFFF7C9).w ; disable wind	tunnel
		move.b	#1,$32(a0)	; begin	countdown to breakage
		rts

Obj0B_FragMove:				; XREF: Obj0B_Index
		bsr.w	SpeedToPos
		subi.w	#$40,$10(a0)
		bsr.w	DisplaySprite
		tst.b	1(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pole that breaks (TJZ)
; ---------------------------------------------------------------------------
Map_obj0B:
	include "_maps\obj0B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0C - flapping door (TJZ)
; ---------------------------------------------------------------------------

Obj0C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0C_Index(pc,d0.w),d1
		jmp	Obj0C_Index(pc,d1.w)
; ===========================================================================
Obj0C_Index:	dc.w Obj0C_Main-Obj0C_Index
		dc.w Obj0C_OpenClose-Obj0C_Index
; ===========================================================================

Obj0C_Main:				; XREF: Obj0C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj0C,4(a0)
		move.w	#$4328,2(a0)
		ori.b	#4,1(a0)
		move.b	#$28,$14(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		mulu.w	#60,d0		; multiply by 60 (1 second)
		move.w	d0,$32(a0)	; set flap delay time

Obj0C_OpenClose:			; XREF: Obj0C_Index
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bpl.s	Obj0C_Solid	; if time remains, branch
		move.w	$32(a0),$30(a0)	; reset	time delay
		bchg	#0,$1C(a0)	; open/close door
		tst.b	1(a0)
		bpl.s	Obj0C_Solid
		move.w	#$58,d0
		jsr	(PlaySound_Special).l ;	play door sound

Obj0C_Solid:
		lea	(Ani_obj0C).l,a1
		jsr	AnimateSprite
		clr.b	($FFFFF7C9).w	; enable wind tunnel
		tst.b	$1A(a0)		; is the door open?
		bne.s	Obj0C_Display	; if yes, branch
		move.w	($FFFFB008).w,d0
		cmp.w	8(a0),d0	; is Sonic in front of the door?
		bcc.s	Obj0C_Display	; if yes, branch
		move.b	#1,($FFFFF7C9).w ; disable wind	tunnel
		move.w	#$13,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject	; make the door	solid

Obj0C_Display:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj0C:
	include "_anim\obj0C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flapping door (TJZ)
; ---------------------------------------------------------------------------
Map_obj0C:
	include "_maps\obj0C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 71 - invisible	solid blocks
; ---------------------------------------------------------------------------

Obj71:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj71_Index(pc,d0.w),d1
		jmp	Obj71_Index(pc,d1.w)
; ===========================================================================
Obj71_Index:	dc.w Obj71_Main-Obj71_Index
		dc.w Obj71_Solid-Obj71_Index
; ===========================================================================

Obj71_Main:				; XREF: Obj71_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj71,4(a0)
		move.w	#$8680,2(a0)
		ori.b	#4,1(a0)
		move.b	$28(a0),d0	; get object type
		move.b	d0,d1
		andi.w	#$F0,d0		; read only the	1st byte
		addi.w	#$10,d0
		lsr.w	#1,d0
		move.b	d0,$14(a0)	; set object width
		andi.w	#$F,d1		; read only the	2nd byte
		addq.w	#1,d1
		lsl.w	#3,d1
		move.b	d1,$16(a0)	; set object height

Obj71_Solid:				; XREF: Obj71_Index
		bsr.w	ChkObjOnScreen
		bne.s	Obj71_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject71

Obj71_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj71_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj71_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	Obj71_Delete

Obj71_Done:
		tst.w	($FFFFFE08).w	; are you using	debug mode?
		beq.s	Obj71_NoDisplay	; if not, branch
		jmp	DisplaySprite	; if yes, display the object
; ===========================================================================

Obj71_NoDisplay:
		rts	
; ===========================================================================

Obj71_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible solid blocks
; ---------------------------------------------------------------------------
Map_obj71:
	include "_maps\obj71.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5D - fans (KVZ)
; ---------------------------------------------------------------------------

Obj5D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5D_Index(pc,d0.w),d1
		jmp	Obj5D_Index(pc,d1.w)
; ===========================================================================
Obj5D_Index:	dc.w Obj5D_Main-Obj5D_Index
		dc.w Obj5D_Delay-Obj5D_Index
; ===========================================================================

Obj5D_Main:				; XREF: Obj5D_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5D,4(a0)
		move.w	#$43A0,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)

Obj5D_Delay:				; XREF: Obj5D_Index
		btst	#1,$28(a0)	; is object type 02/03?
		bne.s	Obj5D_Blow	; if yes, branch
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bpl.s	Obj5D_Blow	; if time remains, branch
		move.w	#120,$30(a0)	; set delay to 2 seconds
		bchg	#0,$32(a0)	; switch fan on/off
		beq.s	Obj5D_Blow	; if fan is off, branch
		move.w	#180,$30(a0)	; set delay to 3 seconds

Obj5D_Blow:
		tst.b	$32(a0)		; is fan switched on?
		bne.w	Obj5D_ChkDel	; if not, branch
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		btst	#0,$22(a0)
		bne.s	Obj5D_ChkSonic
		neg.w	d0

Obj5D_ChkSonic:
		addi.w	#$50,d0
		cmpi.w	#$F0,d0		; is Sonic more	than $A0 pixels	from the fan?
		bcc.s	Obj5D_Animate	; if yes, branch
		move.w	$C(a1),d1
		addi.w	#$60,d1
		sub.w	$C(a0),d1
		bcs.s	Obj5D_Animate
		cmpi.w	#$70,d1
		bcc.s	Obj5D_Animate
		subi.w	#$50,d0
		bcc.s	loc_1159A
		not.w	d0
		add.w	d0,d0

loc_1159A:
		addi.w	#$60,d0
		btst	#0,$22(a0)
		bne.s	loc_115A8
		neg.w	d0

loc_115A8:
		neg.b	d0
		asr.w	#4,d0
		btst	#0,$28(a0)
		beq.s	Obj5D_MoveSonic
		neg.w	d0

Obj5D_MoveSonic:
		btst 	#6,($FFFFFE2C).w
		bne.s	Obj5D_Animate
		add.w	d0,8(a1)	; push Sonic away from the fan

Obj5D_Animate:				; XREF: Obj5D_ChkSonic
		subq.b	#1,$23(a0)
		bpl.s	Obj5D_ChkDel
		move.b	#0,$23(a0)
		addq.b	#1,$1B(a0)
		cmpi.b	#3,$1B(a0)
		bcs.s	loc_115D8
		move.b	#0,$1B(a0)

loc_115D8:
		moveq	#0,d0
		btst	#0,$28(a0)
		beq.s	loc_115E4
		moveq	#2,d0

loc_115E4:
		add.b	$1B(a0),d0
		move.b	d0,$1A(a0)

Obj5D_ChkDel:				; XREF: Obj5D_Animate
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj5D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj5D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj5D_Done:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - fans (KVZ)
; ---------------------------------------------------------------------------
Map_obj5D:
	include "_maps\obj5D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5E - seesaws (KVZ)
; ---------------------------------------------------------------------------

Obj5E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5E_Index(pc,d0.w),d1
		jsr	Obj5E_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	DeleteObject
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5E_Index:	dc.w Obj5E_Main-Obj5E_Index
		dc.w Obj5E_Slope-Obj5E_Index
		dc.w Obj5E_Slope2-Obj5E_Index
		dc.w Obj5E_Spikeball-Obj5E_Index
		dc.w Obj5E_MoveSpike-Obj5E_Index
		dc.w Obj5E_SpikeFall-Obj5E_Index
; ===========================================================================

Obj5E_Main:				; XREF: Obj5E_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5E,4(a0)
		move.w	#$23DC,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$30,$14(a0)
		move.w	8(a0),$30(a0)
		tst.b	$28(a0)		; is object type 00 ?
		bne.s	loc_116D2	; if not, branch
		bsr.w	SingleObjLoad2
		bne.s	loc_116D2
		move.b	#$5E,0(a1)	; load spikeball object
		addq.b	#6,$24(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$22(a0),$22(a1)
		move.l	a0,$3C(a1)

loc_116D2:
		btst	#0,$22(a0)
		beq.s	loc_116E0
		move.b	#2,$1A(a0)

loc_116E0:
		move.b	$1A(a0),$3A(a0)

Obj5E_Slope:				; XREF: Obj5E_Index
		move.b	$3A(a0),d1
		bsr.w	loc_11766
		lea	(Obj5E_Data1).l,a2
		btst	#0,$1A(a0)
		beq.s	loc_11702
		lea	(Obj5E_Data2).l,a2

loc_11702:
		lea	($FFFFB000).w,a1
		move.w	$12(a1),$38(a0)
		move.w	#$30,d1
		jsr	(SlopeObject).l
		rts	
; ===========================================================================

Obj5E_Slope2:				; XREF: Obj5E_Index
		bsr.w	loc_1174A
		lea	(Obj5E_Data1).l,a2
		btst	#0,$1A(a0)
		beq.s	loc_11730
		lea	(Obj5E_Data2).l,a2

loc_11730:
		move.w	#$30,d1
		jsr	(ExitPlatform).l
		move.w	#$30,d1
		move.w	8(a0),d2
		jsr	SlopeObject2
		rts	
; ===========================================================================

loc_1174A:				; XREF: Obj5E_Slope2
		moveq	#2,d1
		lea	($FFFFB000).w,a1
		move.w	8(a0),d0
		sub.w	8(a1),d0
		bcc.s	loc_1175E
		neg.w	d0
		moveq	#0,d1

loc_1175E:
		cmpi.w	#8,d0
		bcc.s	loc_11766
		moveq	#1,d1

loc_11766:
		move.b	$1A(a0),d0
		cmp.b	d1,d0
		beq.s	locret_11790
		bcc.s	loc_11772
		addq.b	#2,d0

loc_11772:
		subq.b	#1,d0
		move.b	d0,$1A(a0)
		move.b	d1,$3A(a0)
		bclr	#0,1(a0)
		btst	#1,$1A(a0)
		beq.s	locret_11790
		bset	#0,1(a0)

locret_11790:
		rts	
; ===========================================================================

Obj5E_Spikeball:			; XREF: Obj5E_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5Ea,4(a0)
		move.w	#$2309,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$8B,$20(a0)
		move.b	#$C,$14(a0)
		move.w	8(a0),$30(a0)
		addi.w	#$28,8(a0)
		move.w	$C(a0),$34(a0)
		btst	#0,$22(a0)
		beq.s	Obj5E_MoveSpike
		subi.w	#$50,8(a0)
		move.b	#2,$3A(a0)

Obj5E_MoveSpike:			; XREF: Obj5E_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$3A(a0),d0
		sub.b	$3A(a1),d0
		beq.s	loc_1183E
		bcc.s	loc_117FC
		neg.b	d0

loc_117FC:
		move.w	#-$818,d1
		move.w	#-$114,d2
		cmpi.b	#1,d0
		beq.s	loc_11822
		move.w	#-$AF0,d1
		move.w	#-$CC,d2
		cmpi.w	#$A00,$38(a1)
		blt.s	loc_11822
		move.w	#-$E00,d1
		move.w	#-$A0,d2

loc_11822:
		move.w	d1,$12(a0)
		move.w	d2,$10(a0)
		move.w	8(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_11838
		neg.w	$10(a0)

loc_11838:
		addq.b	#2,$24(a0)
		bra.s	Obj5E_SpikeFall
; ===========================================================================

loc_1183E:				; XREF: Obj5E_MoveSpike
		lea	(Obj5E_Speeds).l,a2
		moveq	#0,d0
		move.b	$1A(a1),d0
		move.w	#$28,d2
		move.w	8(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_1185C
		neg.w	d2
		addq.w	#2,d0

loc_1185C:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		move.w	d1,$C(a0)
		add.w	$30(a0),d2
		move.w	d2,8(a0)
		clr.w	$E(a0)
		clr.w	$A(a0)
		rts	
; ===========================================================================

Obj5E_SpikeFall:			; XREF: Obj5E_Index
		tst.w	$12(a0)
		bpl.s	loc_1189A
		bsr.w	ObjectFall
		move.w	$34(a0),d0
		subi.w	#$2F,d0
		cmp.w	$C(a0),d0
		bgt.s	locret_11898
		bsr.w	ObjectFall

locret_11898:
		rts	
; ===========================================================================

loc_1189A:				; XREF: Obj5E_SpikeFall
		bsr.w	ObjectFall
		movea.l	$3C(a0),a1
		lea	(Obj5E_Speeds).l,a2
		moveq	#0,d0
		move.b	$1A(a1),d0
		move.w	8(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_118BA
		addq.w	#2,d0

loc_118BA:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	$C(a0),d1
		bgt.s	locret_11938
		movea.l	$3C(a0),a1
		moveq	#2,d1
		tst.w	$10(a0)
		bmi.s	Obj5E_Spring
		moveq	#0,d1

Obj5E_Spring:
		move.b	d1,$3A(a1)
		move.b	d1,$3A(a0)
		cmp.b	$1A(a1),d1
		beq.s	loc_1192C
		bclr	#3,$22(a1)
		beq.s	loc_1192C
		clr.b	$25(a1)
		move.b	#2,$24(a1)
		lea	($FFFFB000).w,a2
		move.w	$12(a0),$12(a2)
		neg.w	$12(a2)
		bset	#1,$22(a2)
		bclr	#3,$22(a2)
		clr.b	$3C(a2)
		move.b	#$10,$1C(a2)	; change Sonic's animation to "spring" ($10)
		move.b	#2,$24(a2)
		move.w	#$B1,d0
		jsr	(PlaySound_Special).l ;	play spring sound

loc_1192C:
		clr.w	$10(a0)
		clr.w	$12(a0)
		subq.b	#2,$24(a0)

locret_11938:
		rts	
; ===========================================================================
Obj5E_Speeds:	dc.w $FFF8, $FFE4, $FFD1, $FFE4, $FFF8

Obj5E_Data1:	incbin	misc\KVZssaw1.bin
		even
Obj5E_Data2:	incbin	misc\KVZssaw2.bin
		even
; ---------------------------------------------------------------------------
; Sprite mappings - seesaws (KVZ)
; ---------------------------------------------------------------------------
Map_obj5E:
	include "_maps\obj5E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked balls on the	seesaws	(KVZ)
; ---------------------------------------------------------------------------
Map_obj5Ea:
	include "_maps\obj5Eballs.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5F - walking bomb enemy (KVZ, ABZ)
; ---------------------------------------------------------------------------

Obj5F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5F_Index(pc,d0.w),d1
		jmp	Obj5F_Index(pc,d1.w)
; ===========================================================================
Obj5F_Index:	dc.w Obj5F_Main-Obj5F_Index
		dc.w Obj5F_Action-Obj5F_Index
		dc.w Obj5F_Display-Obj5F_Index
		dc.w Obj5F_End-Obj5F_Index
; ===========================================================================

Obj5F_Main:				; XREF: Obj5F_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5F,4(a0)
		move.w	#$400,2(a0)
		ori.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$C,$14(a0)
		move.b	$28(a0),d0
		beq.s	loc_11A3C
		move.b	d0,$24(a0)
		rts	
; ===========================================================================

loc_11A3C:
		move.b	#$9A,$20(a0)
		bchg	#0,$22(a0)

Obj5F_Action:				; XREF: Obj5F_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj5F_Index2(pc,d0.w),d1
		jsr	Obj5F_Index2(pc,d1.w)
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj5F_Index2:	dc.w Obj5F_Walk-Obj5F_Index2
		dc.w Obj5F_Wait-Obj5F_Index2
		dc.w Obj5F_Explode-Obj5F_Index2
; ===========================================================================

Obj5F_Walk:				; XREF: Obj5F_Index2
		bsr.w	Obj5F_ChkSonic
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bpl.s	locret_11A96	; if time remains, branch
		addq.b	#2,$25(a0)
		move.w	#1535,$30(a0)	; set time delay to 25 seconds
		move.w	#$10,$10(a0)
		move.b	#1,$1C(a0)
		bchg	#0,$22(a0)
		beq.s	locret_11A96
		neg.w	$10(a0)		; change direction

locret_11A96:
		rts	
; ===========================================================================

Obj5F_Wait:				; XREF: Obj5F_Index2
		bsr.w	Obj5F_ChkSonic
		subq.w	#1,$30(a0)	; subtract 1 from time delay
		bmi.s	loc_11AA8
		bsr.w	SpeedToPos
		rts	
; ===========================================================================

loc_11AA8:
		subq.b	#2,$25(a0)
		move.w	#179,$30(a0)	; set time delay to 3 seconds
		clr.w	$10(a0)		; stop walking
		move.b	#0,$1C(a0)	; stop animation
		rts	
; ===========================================================================

Obj5F_Explode:				; XREF: Obj5F_Index2
		subq.w	#1,$30(a0)
		bpl.s	locret_11AD0
		move.b	#$3F,0(a0)	; change bomb into an explosion
		move.b	#0,$24(a0)

locret_11AD0:
		rts	
; ===========================================================================

Obj5F_ChkSonic:				; XREF: Obj5F_Walk; Obj5F_Wait
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_11ADE
		neg.w	d0

loc_11ADE:
		cmpi.w	#$60,d0
		bcc.s	locret_11B5E
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		bcc.s	Obj5F_MakeFuse
		neg.w	d0

Obj5F_MakeFuse:
		cmpi.w	#$60,d0
		bcc.s	locret_11B5E
		tst.w	($FFFFFE08).w
		bne.s	locret_11B5E
		move.b	#4,$25(a0)
		move.w	#143,$30(a0)	; set fuse time
		clr.w	$10(a0)
		move.b	#2,$1C(a0)
		bsr.w	SingleObjLoad2
		bne.s	locret_11B5E
		move.b	#$5F,0(a1)	; load fuse object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	$C(a0),$34(a1)
		move.b	$22(a0),$22(a1)
		move.b	#4,$28(a1)
		move.b	#3,$1C(a1)
		move.w	#$10,$12(a1)
		btst	#1,$22(a0)
		beq.s	loc_11B54
		neg.w	$12(a1)

loc_11B54:
		move.w	#143,$30(a1)	; set fuse time
		move.l	a0,$3C(a1)

locret_11B5E:
		rts	
; ===========================================================================

Obj5F_Display:				; XREF: Obj5F_Index
		bsr.s	loc_11B70
		lea	(Ani_obj5F).l,a1
		jmp	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================

loc_11B70:
		subq.w	#1,$30(a0)
		bmi.s	loc_11B7C
		bsr.w	SpeedToPos
		rts	
; ===========================================================================

loc_11B7C:
		clr.w	$30(a0)
		clr.b	$24(a0)
		move.w	$34(a0),$C(a0)
		moveq	#3,d1
		movea.l	a0,a1
		lea	(Obj5F_ShrSpeed).l,a2 ;	load shrapnel speed data
		bra.s	Obj5F_MakeShrap
; ===========================================================================

Obj5F_Loop:
		bsr.w	SingleObjLoad2
		bne.s	loc_11BCE

Obj5F_MakeShrap:			; XREF: loc_11B7C
		move.b	#$5F,0(a1)	; load shrapnel	object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	#6,$28(a1)
		move.b	#4,$1C(a1)
		move.w	(a2)+,$10(a1)
		move.w	(a2)+,$12(a1)
		bset	#7,1(a1)
		move.b	#$98,$20(a1)
		bset	#5,$2B(a1)
		bset	#3,$2B(a1)

loc_11BCE:
		dbf	d1,Obj5F_Loop	; repeat 3 more	times

		move.b	#6,$24(a0)

Obj5F_End:				; XREF: Obj5F_Index
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5F_ShrSpeed:	dc.w $FE00, $FD00, $FF00, $FE00, $200, $FD00, $100, $FE00

Ani_obj5F:
	include "_anim\obj5F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - walking bomb enemy (KVZ, ABZ)
; ---------------------------------------------------------------------------
Map_obj5F:
	include "_maps\obj5F.asm"

; ---------------------------------------------------------------------------
; Object 60 - Orbinaut enemy (TJZ, KVZ, ABZ)
; ---------------------------------------------------------------------------

Obj60:				; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Orb_Index(pc,d0.w),d1
		jmp	Orb_Index(pc,d1.w)
; ===========================================================================
Orb_Index:	dc.w Orb_Main-Orb_Index
		dc.w Orb_ChkSonic-Orb_Index
		dc.w Orb_Display-Orb_Index
		dc.w Orb_MoveOrb-Orb_Index
		dc.w Orb_ChkDel2-Orb_Index
		dc.w Orb_Pause-Orb_Index
		dc.w Orb_MoveOut-Orb_Index
; ===========================================================================

Orb_Main:	; Routine 0
		move.l	#Map_obj60,4(a0)
		move.w	#$2428,2(a0)	; ABZ specific code
		move.b	#4,$2A(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$B,$20(a0)
		move.b	#$C,$14(a0)
		moveq	#0,d2
		lea	$37(a0),a2
		movea.l	a2,a3
		addq.w	#1,a2
		moveq	#3,d1
		move.b	#1,$3A(a0)

@makesatellites:
		bsr.w	SingleObjLoad2
		bne.s	@fail
		addq.b	#1,(a3)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	0(a0),0(a1)	; load spiked orb object
		move.b	#6,$24(a1)
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		ori.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#8,$14(a1)
		move.b	#2,$1C(a1)
		move.b	#$98,$20(a1)
		bset	#3,$2B(a1)
		bset	#4,$2B(a1)
		move.b	d2,$26(a1)
		addi.b	#$40,d2
		move.l	a0,$3C(a1)
		move.b	#$24,$29(a1)
		move.b	#$24,$3B(a1)
		move.b	#0,$3E(a1)

		dbf	d1,@makesatellites ; repeat sequence 3 more times

	@fail:
		moveq	#1,d0
		cmpi.b	#2,$28(a0)
		bne.s	@add
		neg.w	d0

	@add:
		btst	#0,$22(a0)	; is orbinaut facing left?
		beq.s	@noflip		; if not, branch
		neg.w	d0

	@noflip:
		move.b	d0,$36(a0)
		addq.b	#2,$24(a0)
		move.w	#-$40,$10(a0) ; move orbinaut to the left
		btst	#0,$22(a0)	; is orbinaut facing left??
		beq.s	@noflip2	; if not, branch
		neg.w	$10(a0)	; move orbinaut	to the right

	@noflip2:
		rts	
; ===========================================================================

Orb_ChkSonic:	; Routine 2
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0	; is Sonic to the right of the orbinaut?
		bcc.s	@isright	; if yes, branch
		neg.w	d0

	@isright:
		cmpi.w	#$A0,d0		; is Sonic within $A0 pixels of	orbinaut?
		bcc.s	@animate	; if not, branch
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0	; is Sonic above the orbinaut?
		bcc.s	@isabove	; if yes, branch
		neg.w	d0

	@isabove:
		cmpi.w	#$50,d0		; is Sonic within $50 pixels of	orbinaut?
		bcc.s	@animate	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	@animate	; if yes, branch
		move.b	#1,$1C(a0)	; use "angry" animation

@animate:
		lea	(Ani_obj60).l,a1
		jsr	AnimateSprite
		bra.w	Orb_ChkDel
; ===========================================================================

Orb_Display:	; Routine 4
		bsr.w	SpeedToPos

Orb_ChkDel:
		obRange	@chkgone
		bra.w	DisplaySprite

@chkgone:
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   loc_11E34   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

loc_11E34:
		lea	$37(a0),a2
		moveq	#0,d2
		move.b	(a2)+,d2
		subq.w	#1,d2
		bcs.s	Orb_Delete

loc_11E40:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFFFD000&$FFFFFF,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,loc_11E40

Orb_Delete:
		bra.w	DeleteObject
; ===========================================================================

Orb_MoveOrb:	; Routine 6
		move.b	#$98,$20(a1)

Orb_OrbCont:
		movea.l	$3C(a0),a1
		cmpi.b	#$60,0(a1) ; does parent object still exist?
		bne.w	DeleteObject	; if not, delete
		cmpi.b	#2,$1A(a1)	; is orbinaut angry?
		bne.w	@circle		; if not, branch ;Mercury KVZ Orbinaut Behaviour Mod bne.s => bne.w
		cmpi.b	#2,$28(a1)
		beq.s	@fire2
		cmpi.b	#$40,$26(a0) ; is spikeorb directly under the orbinaut?
		bne.w	@circle		; if not, branch
		addq.b	#2,$24(a0)
		subq.b	#1,$37(a1)
		bne.s	@fire
		addq.b	#2,$24(a1)

	@fire:
		move.w	#-$200,$10(a0) ; move orb to the left (quickly)
		btst	#0,$22(a1)
		beq.s	@noflip
		neg.w	$10(a0)
		bra.s	@noflip

	@fire2:
		cmpi.b	#3,$2A(a1)	; is the orb distance high enough?
		beq.s	@circle			; if so, branch to the code that makes them circle
		move.b	#12,$24(a0)	; change orb to the routine that moves it outward
		move.b	#30,$2E(a0)		; set the orb timer to 30 steps
		subq.b	#1,$37(a1)		; decrease the number of orbs left to be fired off
		bne.s	@skip			; if there are still orbs, branch
		move.b	#10,$24(a1)	; change to the routine that pauses movement
		move.b	#3,$2A(a1)	; set orb distance
		move.b	$36(a1),d0		; double orbit speed
		asl.b	#1,d0
		move.b	d0,$36(a1)
		move.b	#30,$2E(a1)		; set a timer to 30 steps
	
	@skip:
		move.w	8(a0),d2		; set the velocity of the orb based on its position
		sub.w	8(a1),d2		; relative to the Orbinaut
		asl.w	#3,d2
		move.w	d2,$10(a0)
		move.w	$C(a0),d2
		sub.w	$C(a1),d2
		asl.w	#3,d2
		move.w	d2,$12(a0)

	@noflip:
		bra.w	DisplaySprite
; ===========================================================================

@circle:
	move.b	$26(a0),d0
	jsr	(CalcSine).l
	move.w	d0,d3
	moveq	#0,d1
	move.b	#$27,d1
	muls.w	d1,d0
	move.w	d0,d5
	move.w	d0,d4
	move.b	$27,d2
	tst.b	$3A(a1)
	beq.s	@circle1
	move.w	#$10,d2
@circle1:
	muls.w	d3,d2
	move.w	8(a1),d6
	move.b	$29(a0),d0
	jsr	(CalcSine).l
	muls.w	d0,d5
	swap	d5
	add.w	d6,d5
	move.w	d5,8(a0)
	muls.w	d1,d4
	swap	d4
	move.w	d4,$30(a0)
	move.w	$C(a1),d6
	move.b	$3B(a0),d0
	tst.b	$3A(a1)
	beq.s	@circle2
	move.b	$3E(a0),d0
@circle2:
	jsr	(CalcSine).l
	muls.w	d0,d2
	swap	d2
	add.w	d6,d2
	move.w	d2,$C(a0)
	addq.b	#4,$29(a0)
	tst.b	$3A(a1)
	bne.s	@circle3
	addq.b	#8,$3B(a0)
	bra.s	return_32B18
; ===========================================================================
@circle3:
	cmpi.b	#-1,$3A(a1)
	beq.s	@circle5
	cmpi.b	#$80,$3A(a1)
	bne.s	@circle4
	subq.b	#2,$3E(a0)
	bpl.s	return_32B18
	clr.b	$3E(a0)
@circle4:
	move.b	#0,$3A(a1)
	bra.s	return_32B18
; ===========================================================================
@circle5:
	cmpi.b	#$40,$3E(a0)
	bhs.s	return_32B18
	addq.b	#2,$3E(a0)

return_32B18:
		lea	(Ani_obj60).l,a1
		jsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Orb_Pause:	; Routine 10
		subq.b	#1,$2E(a0)		; decrease timer
		bne.s	Orb_ChkDel2Skip		; if it hasn't run out, branch
		move.b	#4,$24(a0)	; go back to the normal routine
		bra.s	Orb_ChkDel2Skip

Orb_MoveOut:	; Routine 12
		subq.b	#1,$2E(a0)		; decrease timer
		bne.s	Orb_ChkDel2		; if it hasn't run out, branch
		move.b	#6,$24(a0)	; go back to the normal routine

Orb_ChkDel2:	; Routine 8
		bsr.w	SpeedToPos

Orb_ChkDel2Skip:
		tst.b	1(a0)
		bpl.w	DeleteObject
		lea	(Ani_obj60).l,a1
		jsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj60:
	include "_anim\obj60.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Orbinaut enemy (TJZ,	KVZ, ABZ)
; ---------------------------------------------------------------------------
Map_obj60:
	include "_maps\obj60.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 16 - harpoon (TJZ)
; ---------------------------------------------------------------------------

Obj16:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj16_Index(pc,d0.w),d1
		jmp	Obj16_Index(pc,d1.w)
; ===========================================================================
Obj16_Index:	dc.w Obj16_Main-Obj16_Index
		dc.w Obj16_Move-Obj16_Index
		dc.w Obj16_Wait-Obj16_Index
; ===========================================================================

Obj16_Main:				; XREF: Obj16_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj16,4(a0)
		move.w	#$3CC,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),$1C(a0)
		move.b	#$14,$14(a0)
		move.w	#60,$30(a0)

Obj16_Move:				; XREF: Obj16_Index
		lea	(Ani_obj16).l,a1
		jsr	AnimateSprite
		moveq	#0,d0
		move.b	$1A(a0),d0	; move frame number to d0
		move.b	Obj16_Data(pc,d0.w),$20(a0) ; load collision response (based on	d0)
		bra.w	MarkObjGone
; ===========================================================================
Obj16_Data:	dc.b $9B, $9C, $9D, $9E, $9F, $A0
; ===========================================================================

Obj16_Wait:				; XREF: Obj16_Index
		subq.w	#1,$30(a0)
		bpl.s	Obj16_ChkDel
		move.w	#60,$30(a0)
		subq.b	#2,$24(a0)	; run "Obj16_Move" subroutine
		bchg	#0,$1C(a0)	; reverse animation

Obj16_ChkDel:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj16:
	include "_anim\obj16.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - harpoon (TJZ)
; ---------------------------------------------------------------------------
Map_obj16:
	include "_maps\obj16.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 61 - blocks (TJZ)
; ---------------------------------------------------------------------------

Obj61:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj61_Index(pc,d0.w),d1
		jmp	Obj61_Index(pc,d1.w)
; ===========================================================================
Obj61_Index:	dc.w Obj61_Main-Obj61_Index
		dc.w Obj61_Action-Obj61_Index

Obj61_Var:	dc.b $10, $10		; width, height
		dc.b $20, $C
		dc.b $10, $10
		dc.b $10, $10
; ===========================================================================

Obj61_Main:				; XREF: Obj61_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj61,4(a0)
		move.w	#$43E6,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj61_Var(pc,d0.w),a2
		move.b	(a2)+,$14(a0)
		move.b	(a2),$16(a0)
		lsr.w	#1,d0
		move.b	d0,$1A(a0)
		move.w	8(a0),$34(a0)
		move.w	$C(a0),$30(a0)
		move.b	$28(a0),d0
		andi.b	#$F,d0
		beq.s	Obj61_Action
		cmpi.b	#7,d0
		beq.s	Obj61_Action
		move.b	#1,$38(a0)

Obj61_Action:				; XREF: Obj61_Index
		move.w	8(a0),-(sp)
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj61_TypeIndex(pc,d0.w),d1
		jsr	Obj61_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	1(a0)
		bpl.s	Obj61_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr.w	SolidObject
		move.b	d4,$3F(a0)
		bsr.w	loc_12180

Obj61_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj61_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj61_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj61_Done:
		bra.w	DisplaySprite
; ===========================================================================
Obj61_TypeIndex:dc.w Obj61_Type00-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type04-Obj61_TypeIndex, Obj61_Type05-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type07-Obj61_TypeIndex
; ===========================================================================

Obj61_Type00:				; XREF: Obj61_TypeIndex
		rts	
; ===========================================================================

Obj61_Type01:				; XREF: Obj61_TypeIndex
		tst.w	$36(a0)		; is Sonic standing on the object?
		bne.s	loc_120D6	; if yes, branch
		btst	#3,$22(a0)
		beq.s	locret_120D4
		move.w	#30,$36(a0)	; wait for ยซ second

locret_120D4:
		rts	
; ===========================================================================

loc_120D6:
		subq.w	#1,$36(a0)	; subtract 1 from waiting time
		bne.s	locret_120D4	; if time remains, branch
		addq.b	#1,$28(a0)	; add 1	to type
		clr.b	$38(a0)
		rts	
; ===========================================================================

Obj61_Type02:				; XREF: Obj61_TypeIndex
		bsr.w	SpeedToPos
		addq.w	#8,$12(a0)	; make object fall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_12106
		addq.w	#1,d1
		add.w	d1,$C(a0)
		clr.w	$12(a0)		; stop when it touches the floor
		clr.b	$28(a0)		; set type to 00 (non-moving type)

locret_12106:
		rts	
; ===========================================================================

Obj61_Type04:				; XREF: Obj61_TypeIndex
		bsr.w	SpeedToPos
		subq.w	#8,$12(a0)	; make object rise
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12126
		sub.w	d1,$C(a0)
		clr.w	$12(a0)		; stop when it touches the ceiling
		clr.b	$28(a0)		; set type to 00 (non-moving type)

locret_12126:
		rts	
; ===========================================================================

Obj61_Type05:				; XREF: Obj61_TypeIndex
		cmpi.b	#1,$3F(a0)	; is Sonic touching the	object?
		bne.s	locret_12138	; if not, branch
		addq.b	#1,$28(a0)	; if yes, add 1	to type
		clr.b	$38(a0)

locret_12138:
		rts	
; ===========================================================================

Obj61_Type07:				; XREF: Obj61_TypeIndex
		move.w	($FFFFF646).w,d0
		sub.w	$C(a0),d0
		beq.s	locret_1217E
		bcc.s	loc_12162
		cmpi.w	#-2,d0
		bge.s	loc_1214E
		moveq	#-2,d0

loc_1214E:
		add.w	d0,$C(a0)	; make the block rise with water level
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12160
		sub.w	d1,$C(a0)

locret_12160:
		rts	
; ===========================================================================

loc_12162:				; XREF: Obj61_Type07
		cmpi.w	#2,d0
		ble.s	loc_1216A
		moveq	#2,d0

loc_1216A:
		add.w	d0,$C(a0)	; make the block sink with water level
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_1217E
		addq.w	#1,d1
		add.w	d1,$C(a0)

locret_1217E:
		rts	
; ===========================================================================

loc_12180:				; XREF: Obj61_Action
		tst.b	$38(a0)
		beq.s	locret_121C0
		btst	#3,$22(a0)
		bne.s	loc_1219A
		tst.b	$3E(a0)
		beq.s	locret_121C0
		subq.b	#4,$3E(a0)
		bra.s	loc_121A6
; ===========================================================================

loc_1219A:
		cmpi.b	#$40,$3E(a0)
		beq.s	locret_121C0
		addq.b	#4,$3E(a0)

loc_121A6:
		move.b	$3E(a0),d0
		jsr	(CalcSine).l
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$30(a0),d0
		move.w	d0,$C(a0)

locret_121C0:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks (TJZ)
; ---------------------------------------------------------------------------
Map_obj61:
	include "_maps\obj61.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 62 - gargoyle head (TJZ)
; ---------------------------------------------------------------------------

Obj62:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj62_Index(pc,d0.w),d1
		jsr	Obj62_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj62_Index:	dc.w Obj62_Main-Obj62_Index
		dc.w Obj62_MakeFire-Obj62_Index
		dc.w Obj62_FireBall-Obj62_Index
		dc.w Obj62_AniFire-Obj62_Index

Obj62_SpitRate:	dc.b 30, 60, 90, 120, 150, 180,	210, 240
; ===========================================================================

Obj62_Main:				; XREF: Obj62_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj62,4(a0)
		move.w	#$43CB,2(a0)
		ori.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$10,$14(a0)
		move.b	$28(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		move.b	Obj62_SpitRate(pc,d0.w),$29(a0)	; set fireball spit rate
		move.b	$29(a0),$23(a0)
		andi.b	#$F,$28(a0)

Obj62_MakeFire:				; XREF: Obj62_Index
		subq.b	#1,$23(a0)
		bne.s	Obj62_NoFire
		move.b	$29(a0),$23(a0)
		bsr.w	ChkObjOnScreen
		bne.s	Obj62_NoFire
		bsr.w	SingleObjLoad
		bne.s	Obj62_NoFire
		move.b	#$62,0(a1)	; load fireball	object
		addq.b	#4,$24(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	1(a0),1(a1)
		move.b	$22(a0),$22(a1)

Obj62_NoFire:
		rts	
; ===========================================================================

Obj62_FireBall:				; XREF: Obj62_Index
		addq.b	#2,$24(a0)
		move.b	#8,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj62,4(a0)
		move.w	#$3CB,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#8,$14(a0)
		move.b	#2,$1A(a0)
		addq.w	#8,$C(a0)
		move.w	#$200,$10(a0)
		btst	#0,$22(a0)
		bne.s	Obj62_Sound
		neg.w	$10(a0)

Obj62_Sound:
		move.w	#$70,d0
		jsr	(PlaySound_Special).l ;	play lava ball sound
		move.b	#$98,$20(a0)
		bset	#4,$2B(a0)

Obj62_AniFire:				; XREF: Obj62_Index
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	Obj62_StopFire
		bchg	#0,$1A(a0)	; switch between frame 01 and 02

Obj62_StopFire:
		bsr.w	SpeedToPos
		btst	#0,$22(a0)
		bne.s	Obj62_StopFire2
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.w	DeleteObject	; delete if the	fireball hits a	wall
		rts	
; ===========================================================================

Obj62_StopFire2:
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bmi.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - gargoyle head (TJZ)
; ---------------------------------------------------------------------------
Map_obj62:
	include "_maps\obj62.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 63 - platforms	on a conveyor belt (TJZ)
; ---------------------------------------------------------------------------

Obj63:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj63_Index(pc,d0.w),d1
		jsr	Obj63_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj63_Display
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj63_Display	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	loc_1236A

Obj63_Display:				; XREF: loc_1236A
		bra.w	DisplaySprite
; ===========================================================================

loc_1236A:				; XREF: Obj63
		cmpi.b	#2,($FFFFFE11).w
		bne.s	loc_12378
		cmpi.w	#-$80,d0
		bcc.s	Obj63_Display

loc_12378:
		move.b	$2F(a0),d0
		bpl.w	DeleteObject
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)
		bra.w	DeleteObject
; ===========================================================================
Obj63_Index:	dc.w Obj63_Main-Obj63_Index
		dc.w loc_124B2-Obj63_Index
		dc.w loc_124C2-Obj63_Index
		dc.w loc_124DE-Obj63_Index
; ===========================================================================

Obj63_Main:				; XREF: Obj63_Index
		move.b	$28(a0),d0
		bmi.w	loc_12460
		addq.b	#2,$24(a0)
		move.l	#Map_obj63,4(a0)
		move.w	#$43F6,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		cmpi.b	#$7F,$28(a0)
		bne.s	loc_123E2
		addq.b	#4,$24(a0)
		move.w	#$3F6,2(a0)
		move.w	#$80,$18(a0)
		bra.w	loc_124DE
; ===========================================================================

loc_123E2:
		move.b	#4,$1A(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj63_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$38(a0)
		move.w	(a2)+,$30(a0)
		move.l	a2,$3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,$38(a0)
		move.b	#4,$3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_1244C
		move.b	#1,$3B(a0)
		neg.b	$3A(a0)
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_12448
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12448
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_12448:
		move.b	d1,$38(a0)

loc_1244C:
		move.w	(a2,d1.w),$34(a0)
		move.w	2(a2,d1.w),$36(a0)
		bsr.w	Obj63_ChangeDir
		bra.w	loc_124B2
; ===========================================================================

loc_12460:				; XREF: Obj63_Main
		move.b	d0,$2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		bne.w	DeleteObject
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	(ObjPos_TJZxpf_Index).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj63_MakePtfms
; ===========================================================================

Obj63_Loop:
		bsr.w	SingleObjLoad
		bne.s	loc_124AA

Obj63_MakePtfms:			; XREF: loc_12460
		move.b	#$63,0(a1)
		move.w	(a2)+,8(a1)
		move.w	(a2)+,$C(a1)
		move.w	(a2)+,d0
		move.b	d0,$28(a1)

loc_124AA:
		dbf	d1,Obj63_Loop

		addq.l	#4,sp
		rts	
; ===========================================================================

loc_124B2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(PlatformObject).l
		bra.w	sub_12502
; ===========================================================================

loc_124C2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(ExitPlatform).l
		move.w	8(a0),-(sp)
		bsr.w	sub_12502
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

loc_124DE:				; XREF: Obj63_Index
		move.w	($FFFFFE04).w,d0
		andi.w	#3,d0
		bne.s	loc_124FC
		moveq	#1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_124F2
		neg.b	d1

loc_124F2:
		add.b	d1,$1A(a0)
		andi.b	#3,$1A(a0)

loc_124FC:
		addq.l	#4,sp
		bra.w	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_12502:				; XREF: loc_124B2; loc_124C2
		tst.b	($FFFFF7EE).w
		beq.s	loc_12520
		tst.b	$3B(a0)
		bne.s	loc_12520
		move.b	#1,$3B(a0)
		move.b	#1,($FFFFF7C0).w
		neg.b	$3A(a0)
		bra.s	loc_12534
; ===========================================================================

loc_12520:
		move.w	8(a0),d0
		cmp.w	$34(a0),d0
		bne.s	loc_1256A
		move.w	$C(a0),d0
		cmp.w	$36(a0),d0
		bne.s	loc_1256A

loc_12534:
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_12552
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12552
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_12552:
		move.b	d1,$38(a0)
		movea.l	$3C(a0),a1
		move.w	(a1,d1.w),$34(a0)
		move.w	2(a1,d1.w),$36(a0)
		bsr.w	Obj63_ChangeDir

loc_1256A:
		bsr.w	SpeedToPos
		rts	
; End of function sub_12502


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj63_ChangeDir:			; XREF: loc_123E2; sub_12502
		moveq	#0,d0
		move.w	#-$100,d2
		move.w	8(a0),d0
		sub.w	$34(a0),d0
		bcc.s	loc_12584
		neg.w	d0
		neg.w	d2

loc_12584:
		moveq	#0,d1
		move.w	#-$100,d3
		move.w	$C(a0),d1
		sub.w	$36(a0),d1
		bcc.s	loc_12598
		neg.w	d1
		neg.w	d3

loc_12598:
		cmp.w	d0,d1
		bcs.s	loc_125C2
		move.w	8(a0),d0
		sub.w	$34(a0),d0
		beq.s	loc_125AE
		ext.l	d0
		asl.l	#8,d0
		divs.w	d1,d0
		neg.w	d0

loc_125AE:
		move.w	d0,$10(a0)
		move.w	d3,$12(a0)
		swap	d0
		move.w	d0,$A(a0)
		clr.w	$E(a0)
		rts	
; ===========================================================================

loc_125C2:				; XREF: Obj63_ChangeDir
		move.w	$C(a0),d1
		sub.w	$36(a0),d1
		beq.s	loc_125D4
		ext.l	d1
		asl.l	#8,d1
		divs.w	d0,d1
		neg.w	d1

loc_125D4:
		move.w	d1,$12(a0)
		move.w	d2,$10(a0)
		swap	d1
		move.w	d1,$E(a0)
		clr.w	$A(a0)
		rts	
; End of function Obj63_ChangeDir

; ===========================================================================
Obj63_Data:	dc.w word_125F4-Obj63_Data
		dc.w word_12610-Obj63_Data
		dc.w word_12628-Obj63_Data
		dc.w word_1263C-Obj63_Data
		dc.w word_12650-Obj63_Data
		dc.w word_12668-Obj63_Data
word_125F4:	dc.w $18, $1070, $1078,	$21A, $10BE, $260, $10BE, $393
		dc.w $108C, $3C5, $1022, $390, $1022, $244
word_12610:	dc.w $14, $1280, $127E,	$280, $12CE, $2D0, $12CE, $46E
		dc.w $1232, $420, $1232, $2CC
word_12628:	dc.w $10, $D68,	$D22, $482, $D22, $5DE,	$DAE, $5DE, $DAE, $482
word_1263C:	dc.w $10, $DA0,	$D62, $3A2, $DEE, $3A2,	$DEE, $4DE, $D62, $4DE
word_12650:	dc.w $14, $D00,	$CAC, $242, $DDE, $242,	$DDE, $3DE, $C52, $3DE,	$C52, $29C
word_12668:	dc.w $10, $1300, $1252,	$20A, $13DE, $20A, $13DE, $2BE,	$1252, $2BE

; ---------------------------------------------------------------------------
; Sprite mappings - platforms on a conveyor belt (TJZ)
; ---------------------------------------------------------------------------
Map_obj63:
	include "_maps\obj63.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 64 - bubbles (TJZ)
; ---------------------------------------------------------------------------

Obj64:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj64_Index(pc,d0.w),d1
		jmp	Obj64_Index(pc,d1.w)
; ===========================================================================
Obj64_Index:	dc.w Obj64_Main-Obj64_Index
		dc.w Obj64_Animate-Obj64_Index
		dc.w Obj64_ChkWater-Obj64_Index
		dc.w Obj64_Display2-Obj64_Index
		dc.w Obj64_Delete3-Obj64_Index
		dc.w Obj64_BblMaker-Obj64_Index
; ===========================================================================

Obj64_Main:				; XREF: Obj64_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj64,4(a0)
		move.w	#$A390,2(a0)
		move.b	#$84,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$80,$18(a0)
		move.b	$28(a0),d0	; get object type
		bpl.s	Obj64_Bubble	; if type is $0-$7F, branch
		addq.b	#8,$24(a0)
		andi.w	#$7F,d0		; read only last 7 bits	(deduct	$80)
		move.b	d0,$32(a0)
		move.b	d0,$33(a0)
		move.b	#6,$1C(a0)
		bra.w	Obj64_BblMaker
; ===========================================================================

Obj64_Bubble:				; XREF: Obj64_Main
		move.b	d0,$1C(a0)
		move.w	8(a0),$30(a0)
		move.w	#-$88,$12(a0)	; float	bubble upwards
		jsr	(RandomNumber).l
		move.b	d0,$26(a0)

Obj64_Animate:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		cmpi.b	#6,$1A(a0)
		bne.s	Obj64_ChkWater
		move.b	#1,$2E(a0)

Obj64_ChkWater:				; XREF: Obj64_Index
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is bubble underwater?
		bcs.s	Obj64_Wobble	; if yes, branch

Obj64_Burst:				; XREF: Obj64_Wobble
		move.b	#6,$24(a0)
		addq.b	#3,$1C(a0)	; run "bursting" animation
		bra.w	Obj64_Display2
; ===========================================================================

Obj64_Wobble:				; XREF: Obj64_ChkWater
		move.b	$26(a0),d0
		addq.b	#1,$26(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)	; change bubble's horizontal position
		tst.b	$2E(a0)
		beq.s	Obj64_Display
		bsr.w	Obj64_ChkSonic	; has Sonic touched the	bubble?
		beq.s	Obj64_Display	; if not, branch
		btst	#6,($FFFFFE2C).w	; does Sonic have a bubble shield?
		bne.s	locret_2FC7C	; if so, branch

		bsr.w	ResumeMusic	; cancel countdown music
		move.w	#$38,d0
		jsr	(PlaySound_Special).l ;	play collecting	bubble sound
		lea	($FFFFB000).w,a1
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$20(a1)
		move.b	#$15,$1C(a1)
		move.w	#$23,$3E(a1)
		move.b	#0,$3C(a1)
		bclr	#5,$22(a1)
		bclr	#4,$22(a1)
		btst	#2,$22(a1)
		beq.w	Obj64_Burst
		bclr	#2,$22(a1)
		move.b	#$13,$16(a1)
		move.b	#9,$17(a1)
		subq.w	#5,$C(a1)
		bra.w	Obj64_Burst

locret_2FC7C:
		rts
; ===========================================================================

Obj64_Display:				; XREF: Obj64_Wobble
		bsr.w	SpeedToPos
		tst.b	1(a0)
		bpl.s	Obj64_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj64_Display2:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		tst.b	1(a0)
		bpl.s	Obj64_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete2:
		jmp	DeleteObject
; ===========================================================================

Obj64_Delete3:				; XREF: Obj64_Index
		bra.w	DeleteObject
; ===========================================================================

Obj64_BblMaker:				; XREF: Obj64_Index
		tst.w	$36(a0)
		bne.s	loc_12874
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is bubble maker underwater?
		bcc.w	Obj64_ChkDel	; if not, branch
		tst.b	1(a0)
		bpl.w	Obj64_ChkDel
		subq.w	#1,$38(a0)
		bpl.w	loc_12914
		move.w	#1,$36(a0)

loc_1283A:
		jsr	(RandomNumber).l
		move.w	d0,d1
		andi.w	#7,d0
		cmpi.w	#6,d0
		bcc.s	loc_1283A

		move.b	d0,$34(a0)
		andi.w	#$C,d1
		lea	(Obj64_BblTypes).l,a1
		adda.w	d1,a1
		move.l	a1,$3C(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_12872
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)

loc_12872:
		bra.s	loc_1287C
; ===========================================================================

loc_12874:				; XREF: Obj64_BblMaker
		subq.w	#1,$38(a0)
		bpl.w	loc_12914

loc_1287C:
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		move.w	d0,$38(a0)
		bsr.w	SingleObjLoad
		bne.s	loc_128F8
		move.b	#$64,0(a1)	; load bubble object
		move.w	8(a0),8(a1)
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,8(a1)
		move.w	$C(a0),$C(a1)
		moveq	#0,d0
		move.b	$34(a0),d0
		movea.l	$3C(a0),a2
		move.b	(a2,d0.w),$28(a1)
		btst	#7,$36(a0)
		beq.s	loc_128F8
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_128E4
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,$28(a1)

loc_128E4:
		tst.b	$34(a0)
		bne.s	loc_128F8
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,$28(a1)

loc_128F8:
		subq.b	#1,$34(a0)
		bpl.s	loc_12914
		jsr	(RandomNumber).l
		andi.w	#$7F,d0
		addi.w	#$80,d0
		add.w	d0,$38(a0)
		clr.w	$36(a0)

loc_12914:
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite

Obj64_ChkDel:				; XREF: Obj64_BblMaker
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj64_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj64_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj64_Done:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0
		bcs.w	DisplaySprite
		rts	
; ===========================================================================
; bubble production sequence

; 0 = small bubble, 1 =	large bubble

Obj64_BblTypes:	dc.b 0,	1, 0, 0, 0, 0, 1, 0, 0,	0, 0, 1, 0, 1, 0, 0, 1,	0

; ===========================================================================

Obj64_ChkSonic:				; XREF: Obj64_Wobble
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12998
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		move.w	8(a0),d1
		subi.w	#$10,d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$20,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		move.w	$C(a1),d0
		move.w	$C(a0),d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$10,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		moveq	#1,d0
		rts	
; ===========================================================================

loc_12998:
		moveq	#0,d0
		rts	
; ===========================================================================
Ani_obj64:
	include "_anim\obj64.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - bubbles (TJZ)
; ---------------------------------------------------------------------------
Map_obj64:
	include "_maps\obj64.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 65 - waterfalls (TJZ)
; ---------------------------------------------------------------------------

Obj65:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj65_Index(pc,d0.w),d1
		jmp	Obj65_Index(pc,d1.w)
; ===========================================================================
Obj65_Index:	dc.w Obj65_Main-Obj65_Index
		dc.w Obj65_Animate-Obj65_Index
		dc.w Obj65_ChkDel-Obj65_Index
		dc.w Obj65_FixHeight-Obj65_Index
		dc.w loc_12B36-Obj65_Index
; ===========================================================================

Obj65_Main:				; XREF: Obj65_Index
		addq.b	#4,$24(a0)
		move.l	#Map_obj65,4(a0)
		move.w	#$4259,2(a0)
		ori.b	#4,1(a0)
		move.b	#$18,$14(a0)
		move.w	#$80,$18(a0)
		move.b	$28(a0),d0	; get object type
		bpl.s	loc_12AE6
		bset	#7,2(a0)

loc_12AE6:
		andi.b	#$F,d0		; read only the	2nd byte
		move.b	d0,$1A(a0)	; set frame number
		cmpi.b	#9,d0		; is object type $x9 ?
		bne.s	Obj65_ChkDel	; if not, branch
		clr.w	$18(a0)
		subq.b	#2,$24(a0)
		btst	#6,$28(a0)	; is object type $4x ?
		beq.s	loc_12B0A	; if not, branch
		move.b	#6,$24(a0)

loc_12B0A:
		btst	#5,$28(a0)	; is object type $Ax ?
		beq.s	Obj65_Animate	; if not, branch
		move.b	#8,$24(a0)

Obj65_Animate:				; XREF: Obj65_Index
		lea	(Ani_obj65).l,a1
		jsr	AnimateSprite

Obj65_ChkDel:				; XREF: Obj65_Index
		bra.w	MarkObjGone
; ===========================================================================

Obj65_FixHeight:			; XREF: Obj65_Index
		move.w	($FFFFF646).w,d0
		subi.w	#$10,d0
		move.w	d0,$C(a0)	; match	object position	to water height
		bra.s	Obj65_Animate
; ===========================================================================

loc_12B36:				; XREF: Obj65_Index
		bclr	#7,2(a0)
		cmpi.b	#7,($FFFFA506).w
		bne.s	Obj65_Animate2
		bset	#7,2(a0)

Obj65_Animate2:
		bra.s	Obj65_Animate
; ===========================================================================
Ani_obj65:
	include "_anim\obj65.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - waterfalls (TJZ)
; ---------------------------------------------------------------------------
Map_obj65:
	include "_maps\obj65.asm"

; ---------------------------------------------------------------------------
; Spin Dash Dust
; ---------------------------------------------------------------------------
SpinDash_dust:
		moveq	#0,d0
		move.b	$24(a0),d0 
		move.w	Obj05_Index(pc,d0.w),d1
		jmp	Obj05_Index(pc,d1.w)
; ===========================================================================
Obj05_Index:
		dc.w Obj05_Init-Obj05_Index
		dc.w Obj05_Main-Obj05_Index
		dc.w DeleteObject-Obj05_Index
		dc.w Obj05_CheckSkid-Obj05_Index
; ===========================================================================
Obj05_Init:
		addq.b	#2,$24(a0)
		move.l	#Map_Dust,4(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		move.w	#$49C,2(a0)
		move.w	#$9380,$3C(a0)
; ===========================================================================
Obj05_Main:
	lea	($FFFFB000).w,a2 ; a2=character
	moveq	#0,d0
	move.b	$1C(a0),d0	; use current animation as a secondary routine counter
	add.w	d0,d0
	move.w	Obj05_DisplayModes(pc,d0.w),d1
	jmp	Obj05_DisplayModes(pc,d1.w)
; ===========================================================================
; off_1DDA4:
Obj05_DisplayModes:
		dc.w Obj05_Display-Obj05_DisplayModes	; 0
		dc.w Obj05_MdSplash-Obj05_DisplayModes	; 2
		dc.w Obj05_MdSpindashDust-Obj05_DisplayModes	; 4
		dc.w Obj05_Display-Obj05_DisplayModes	; 6
; ===========================================================================
; loc_1DDAC:
Obj05_MdSplash:
	move.w	($FFFFF646).w,$C(a0)
	tst.b	$1D(a0)
	bne.s	Obj05_Display
	move.w	8(a2),8(a0)
	move.b	#0,$22(a0)
	andi.w	#$7FFF,2(a0)
	bra.s	Obj05_Display
; ===========================================================================
; loc_1DDCC:
Obj05_MdSpindashDust:
	tst.b	$39(a2)
	beq.s	Obj05_ResetDisplayMode
	move.w	8(a2),8(a0)
	move.w	$C(a2),$C(a0)
	move.b	$22(a2),$22(a0)
	andi.b	#1,$22(a0)
	tst.b	$1D(a0)
	bne.s	Obj05_Display
	andi.w	#$7FFF,2(a0)
	tst.w	2(a2)
	bpl.s	Obj05_Display
	ori.w	#-$8000,2(a0)
; ===========================================================================

Obj05_Display:
		lea	(Ani_Dust).l,a1
		jsr	AnimateSprite
		bsr.w	Obj05_LoadArt
		jmp	DisplaySprite
		rts

Obj05_ResetDisplayMode:
	move.b	#0,$1C(a0)
	rts
; ===========================================================================
; loc_1DE4A:
Obj05_CheckSkid:
	lea	($FFFFB000).w,a2 ; a2=character
	cmpi.b	#$D,$1C(a2)	; SonAni_Stop
	beq.s	Obj05_SkidDust
	move.b	#2,$24(a0)
	move.b	#0,$32(a0)
	rts
; ===========================================================================
; loc_1DE64:
Obj05_SkidDust:
	subq.b	#1,$32(a0)
	bpl.w	return_1DF36
	move.b	#3,$32(a0)
	bsr.w	SingleObjLoad
	bne.w	return_1DF36
	move.b	0(a0),0(a1) ; load obj05
	move.w	8(a2),8(a1)
	move.w	$C(a2),$C(a1)
	addi.w	#$10,$C(a1)
	move.b	#0,$22(a1)
	move.b	#3,$1C(a1)
	addq.b	#2,$24(a1)
	move.l	4(a0),4(a1)
	move.b	1(a0),1(a1)
	move.w	#$80,$18(a1)
	move.b	#4,$14(a1)
	move.w	2(a0),2(a1)
	andi.w	#$7FFF,2(a1)
	tst.w	2(a2)
	bpl.s	Obj05_LoadArt
	ori.w	#-$8000,2(a1)
; ===========================================================================
Obj05_LoadArt:
		moveq	#0,d0
		move.b	$1A(a0),d0
		cmp.b	$30(a0),d0
		beq.s	return_1DF36
		move.b	d0,$30(a0)
		lea	(DynPLC_Dust).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	return_1DF36
		move.w	$3C(a0),d4

	@loop:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_Dust,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(QueueDMATransfer).l
		dbf	d5,@loop

	return_1DF36:
		rts

Ani_Dust:
	include	"_anim\obj05.asm"

Map_Dust:
	include	"_maps\obj05.asm"

DynPLC_Dust:
	include	"_inc\Spindash Dust DPLC.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 01 - Sonic
; ---------------------------------------------------------------------------

Obj01:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj01_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj01_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj01_Index(pc,d0.w),d1
		jmp	Obj01_Index(pc,d1.w)
; ===========================================================================
Obj01_Index:	dc.w Obj01_Main-Obj01_Index
		dc.w Obj01_Control-Obj01_Index
		dc.w Obj01_Hurt-Obj01_Index
		dc.w Obj01_Death-Obj01_Index
		dc.w Obj01_ResetLevel-Obj01_Index
; ===========================================================================

Obj01_Main:				; XREF: Obj01_Index
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Sonic,4(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_Sec
		move.w	#$780,2(a0)
		bra.s	Obj01_Cont

Obj01_Sec:
		move.w	#$7A0,2(a0)

Obj01_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_Control
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w

Obj01_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.s	loc_12C58
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc_12C58:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc_12C62	; if yes, branch
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control

loc_12C62:
		bsr.w	CPU_Control
		bra.s	loc_12C64

loc_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne.s	loc_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj01_Modes(pc,d0.w),d1
		jsr	Obj01_Modes(pc,d1.w)

loc_12C7E:
		bsr.s	Sonic_Display
		bsr.w	Main_RecordPos
		bsr.w	Sonic_Water
		btst	#7,$22(a0)
		bne.s	loc_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc_12C7E2

loc_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc_12C7E2
		add.w	#2,($FFFFF75E).w

loc_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc_12CA6
		tst.b	$1C(a0)
		bne.s	loc_12CA6
		move.b	$1D(a0),$1C(a0)

loc_12CA6:
		bsr.w	Sonic_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12CB6
		jsr	TouchResponse

loc_12CB6:
		bsr.w	LoadSonicDynPLC
		rts
; ===========================================================================
Obj01_Modes:	dc.w Obj01_MdNormal-Obj01_Modes
		dc.w Obj01_MdJump-Obj01_Modes
		dc.w Obj01_MdRoll-Obj01_Modes
		dc.w Obj01_MdJump2-Obj01_Modes

Sonic_Display:				; XREF: loc_12C7E
		move.w	$30(a0),d0
		beq.s	Obj01_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_Display
		lsr.w	#3,d0
		bcc.s	Obj01_ChkInvin

Obj01_Display:
		jsr	DisplaySprite

Obj01_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Sonic have invincibility?
		beq.w	Obj01_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj01_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj01_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj01_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj01_RmvInvin	; change to bcs.w
		moveq	#0,d0
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play normal music

Obj01_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj01_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Sonic have speed	shoes?
		beq.s	Obj01_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj01_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj01_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Sonic"s speed
		move.w	#$C,($FFFFF762).w ; restore Sonic"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Sonic"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		move.w	#$0,d0
		jmp	(SetTempo).l	; run music at normal speed
; ===========================================================================

Obj01_ExitChk:
		rts	

; ---------------------------------------------------------------------------
; AI Code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; loc_1BAD4:
CPU_Control: ; a0=Tails
	move.b	($FFFFF606).w,d0	; did the real player 2 hit something?
	andi.b	#$7F,d0
	beq.s	CPU1			; if not, branch
	move.w	#600,($FFFFF672).w ; give player 2 control for 10 seconds (minimum)
CPU1:
	lea	($FFFFB000).w,a1 ; a1=character ; a1=Sonic
	move.w	($FFFFF678).w,d0
	move.w	CPU_States(pc,d0.w),d0
	jmp	CPU_States(pc,d0.w)
; ===========================================================================
; off_1BAF4:
CPU_States:
	dc.w CPU_Init-CPU_States	; 0
	dc.w CPU_Spawning-CPU_States	; 2
	dc.w CPU_Flying-CPU_States	; 4
	dc.w CPU_Normal-CPU_States	; 6
	dc.w CPU_Panic-CPU_States	; 8

; ===========================================================================
; initial AI State
; ---------------------------------------------------------------------------
; loc_1BAFE:
CPU_Init:
	move.w	#6,($FFFFF678).w	; => CPU_Normal
;	move.b	#0,$2A(a0)
	move.b	#0,$1C(a0)
	move.w	#0,$10(a0)
	move.w	#0,$12(a0)
	move.w	#0,$20(a0)
	move.b	#$80,$22(a0)
	move.w	#0,($FFFFF674).w
	rts

; ===========================================================================
; AI State where Tails is waiting to respawn
; ---------------------------------------------------------------------------
; loc_1BB30:
CPU_Spawning:
	move.b	($FFFFF670).w,d0
	andi.b	#-$10,d0
	bne.s	CPU_Respawn
	move.w	($FFFFFE04).w,d0
	andi.w	#$3F,d0
	bne.s	return_1BB88
;	tst.b	$2A(a1)
;	bne.s	return_1BB88
	move.b	$22(a1),d0
	andi.b	#$D2,d0
	bne.s	return_1BB88
; loc_1BB54:
CPU_Respawn:
	move.w	#4,($FFFFF678).w	; => CPU_Flying
	move.w	8(a1),d0
	move.w	d0,8(a0)
	move.w	d0,($FFFFF67A).w
	move.w	$C(a1),d0
	move.w	d0,($FFFFF67C).w
	subi.w	#$C0,d0
	move.w	d0,$C(a0)
	ori.w	#(1<<15),2(a0)
	move.b	#0,$39(a0)
	move.w	#0,$3A(a0)

return_1BB88:
	rts

; ===========================================================================
; AI State where Tails pretends to be a helicopter
; ---------------------------------------------------------------------------
; loc_1BB8A:
CPU_Flying:
	tst.b	1(a0)
	bmi.s	CPU_FlyingOnscreen
	addq.w	#1,($FFFFF674).w
	cmpi.w	#$12C,($FFFFF674).w
	blo.s	CPU_Flying_Part2
	move.w	#0,($FFFFF674).w
	move.w	#2,($FFFFF678).w	; => CPU_Spawning
;	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.w	#0,8(a0)
	move.w	#0,$C(a0)
	move.b	#2,$1C(a0)
	rts
; ---------------------------------------------------------------------------
; loc_1BBC8:
CPU_FlyingOnscreen:
	move.w	#0,($FFFFF674).w
; loc_1BBCE:
CPU_Flying_Part2:
	lea	($FFFFE500).w,a2
	move.w	#$10,d2
	lsl.b	#2,d2
	addq.b	#4,d2
	move.w	($FFFFF7A8).w,d3
	sub.b	d2,d3
	move.w	(a2,d3.w),($FFFFF67A).w
	move.w	2(a2,d3.w),($FFFFF67C).w
	tst.b	(Water_flag).w
	beq.s	CPU2
	move.w	($FFFFF646).w,d0
	subi.w	#$10,d0
	cmp.w	($FFFFF67C).w,d0
	bge.s	CPU2
	move.w	d0,($FFFFF67C).w
CPU2:
	move.w	8(a0),d0
	sub.w	($FFFFF67A).w,d0
	beq.s	loc_1BC54
	move.w	d0,d2
	bpl.s	loc_1BC14
	neg.w	d2

loc_1BC14:				; CODE XREF: h+4C9Cj
	lsr.w	#4,d2
	cmpi.w	#$C,d2
	blo.s	CPU3
	moveq	#$C,d2
CPU3:
	move.b	$10(a1),d1
	bpl.s	loc_1BC26
	neg.b	d1

loc_1BC26:				; CODE XREF: h+4CAEj
	add.b	d1,d2
	addq.w	#1,d2
	tst.w	d0
	bmi.s	loc_1BC42
	bset	#0,$22(a0)
	cmp.w	d0,d2
	blo.s	CPU4
	move.w	d0,d2
	moveq	#0,d0
CPU4:
	neg.w	d2
	bra.s	loc_1BC50
; ---------------------------------------------------------------------------

loc_1BC42:
	bclr	#0,$22(a0)
	neg.w	d0
	cmp.w	d0,d2
	blo.s	loc_1BC50
	move.b	d0,d2
	moveq	#0,d0

loc_1BC50:
	add.w	d2,8(a0)

loc_1BC54:
	moveq	#1,d2
	move.w	$C(a0),d1
	sub.w	($FFFFF67C).w,d1
	beq.s	loc_1BC68
	bmi.s	loc_1BC64
	neg.w	d2

loc_1BC64:
	add.w	d2,$C(a0)

loc_1BC68:
	lea	($FFFFE400).w,a2
	move.b	2(a2,d3.w),d2
	andi.b	#$52,d2
	bne.s	return_1BCDE
	or.w	d0,d1
	bne.s	return_1BCDE
	move.w	#6,($FFFFF678).w	; => CPU_Normal
;	move.b	#0,$2A(a0)
	move.b	#0,$1C(a0)
	move.w	#0,$10(a0)
	move.w	#0,$12(a0)
	move.w	#0,$20(a0)
	move.b	#$82,$22(a0)
;	move.w	#0,$2E(a0)
	andi.w	#$7FFF,2(a0)
	tst.b	2(a1)
	bpl.s	CPU5
	ori.w	#-$8000,2(a0)
CPU5:
;	move.b	top_solid_bit(a1),top_solid_bit(a0)
;	move.b	lrb_solid_bit(a1),lrb_solid_bit(a0)
	cmpi.b	#9,$1C(a1)
	beq.s	return_1BCDE
	move.b	$39(a0),d0
	beq.s	return_1BCDE
	move.b	d0,$39(a1)
	jmp	loc_212C4

return_1BCDE:
	rts

; ===========================================================================
; AI State where Tails follows the player normally
; ---------------------------------------------------------------------------
; loc_1BCE0:
CPU_Normal:
	cmpi.b	#6,($FFFFB024).w	; is Sonic dead?
	blo.s	CPU_Normal_SonicOK		; if not, branch
	; Sonic's dead; fly down to his corpse
	move.w	#4,($FFFFF678).w	; => CPU_Flying
	move.b	#0,$39(a0)
	move.w	#0,$3A(a0)
;	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.b	#2,$1C(a0)
	rts
; ---------------------------------------------------------------------------
; loc_1BD0E:
CPU_Normal_SonicOK:
	bsr.w	CPU_CheckDespawn
	tst.w	($FFFFF672).w	; if CPU has control
	bne.w	CPU_Normal_HumanControl		; (if not, branch)
;	tst.b	$2A(a0)			; and Tails isn't fully object controlled (&$80)
;	bmi.w	CPU_Normal_HumanControl		; (if not, branch)
	tst.w	$3E(a0)			; and Tails' movement is locked (usually because he just fell down a slope)
	beq.s	CPU6					; (if not, branch)
	tst.w	$20(a0)			; and Tails is stopped, then...
	bne.s	CPU6					; (if not, branch)
	move.w	#8,($FFFFF678).w	; => CPU_Panic
CPU6:
	lea	($FFFFE500).w,a1
	move.w	#$10,d1
	lsl.b	#2,d1
	addq.b	#4,d1
	move.w	($FFFFF7A8).w,d0
	sub.b	d1,d0
	move.w	(a1,d0.w),d2	; d2 = earlier x position of Sonic
	move.w	2(a1,d0.w),d3	; d3 = earlier y position of Sonic
	lea	($FFFFE400).w,a1
	move.w	(a1,d0.w),d1	; d1 = earlier input of Sonic
	move.b	2(a1,d0.w),d4	; d4 = earlier status of Sonic
	move.w	d1,d0
	btst	#5,$22(a0)	; is Tails pushing against something?
	beq.s	CPU7		; if not, branch
	btst	#5,d4		; was Sonic pushing against something?
	beq.w	CPU_Normal_FilterAction_Part2 ; if not, branch elsewhere

; either Tails isn't pushing, or Tails and Sonic are both pushing
CPU7:
	sub.w	8(a0),d2
	beq.s	CPU_Normal_Stand ; branch if Tails is already lined up horizontally with Sonic
	bpl.s	CPU_Normal_FollowRight
	neg.w	d2

; Tails wants to go left because that's where Sonic is
; loc_1BD76: CPU_Normal_FollowLeft:
	cmpi.w	#$10,d2
	blo.s	CPU8
	andi.w	#$F3F3,d1 ; %1111001111110011
	ori.w	#$0404,d1 ; %0000010000000100
CPU8:
	tst.w	$20(a0)
	beq.s	CPU_Normal_FilterAction
	btst	#0,$22(a0)
	beq.s	CPU_Normal_FilterAction
	subq.w	#1,8(a0)
	bra.s	CPU_Normal_FilterAction
; ===========================================================================
; Tails wants to go right because that's where Sonic is
; loc_1BD98:
CPU_Normal_FollowRight:
	cmpi.w	#$10,d2
	blo.s	CPU9
	andi.w	#$F3F3,d1 ; %1111001111110011
	ori.w	#$0808,d1 ; %0000100000001000
CPU9:
	tst.w	$20(a0)
	beq.s	CPU_Normal_FilterAction
	btst	#0,$22(a0)
	bne.s	CPU_Normal_FilterAction
	addq.w	#1,8(a0)
	bra.s	CPU_Normal_FilterAction
; ===========================================================================
; Tails is happy where he is
; loc_1BDBA:
CPU_Normal_Stand:
	bclr	#0,$22(a0)
	move.b	d4,d0
	andi.b	#1,d0
	beq.s	CPU_Normal_FilterAction
	bset	#0,$22(a0)

; Filter the action we chose depending on a few things
; loc_1BDCE:
CPU_Normal_FilterAction:
	tst.b	($FFFFF67F).w
	beq.s	CPU10
	ori.w	#$7000,d1
	btst	#1,$22(a0)
	bne.s	CPU_Normal_SendAction
	move.b	#0,($FFFFF67F).w
CPU10:
	move.w	($FFFFFE04).w,d0
	andi.w	#$FF,d0
	beq.s	CPU11
	cmpi.w	#$40,d2
	bhs.s	CPU_Normal_SendAction
CPU11:
	sub.w	$C(a0),d3
	beq.s	CPU_Normal_SendAction
	bpl.s	CPU_Normal_SendAction
	neg.w	d3
	cmpi.w	#$20,d3
	blo.s	CPU_Normal_SendAction
; loc_1BE06:
CPU_Normal_FilterAction_Part2:
	move.b	($FFFFFE05).w,d0
	andi.b	#$3F,d0
	bne.s	CPU_Normal_SendAction
	cmpi.b	#8,$1C(a0)
	beq.s	CPU_Normal_SendAction
	ori.w	#$7070,d1
	move.b	#1,($FFFFF67F).w

; Send the action we chose by storing it into player 2's input
; loc_1BE22:
CPU_Normal_SendAction:
	move.w	d1,($FFFFF670).w
	rts

; ===========================================================================
; Follow orders from controller 2
; and decrease the counter to when the CPU will regain control
; loc_1BE28:
CPU_Normal_HumanControl:
	tst.w	($FFFFF672).w
	beq.s	CPU12	; don't decrease if it's already 0
	subq.w	#1,($FFFFF672).w
CPU12:
	rts

; ===========================================================================
; loc_1BE34:
CPU_Despawn:
	move.w	#0,($FFFFF672).w
	move.w	#0,($FFFFF674).w
	move.w	#2,($FFFFF678).w	; => CPU_Spawning
;	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.w	#$4000,8(a0)
	move.w	#0,$C(a0)
	move.b	#2,$1C(a0)
	rts
; ===========================================================================
; sub_1BE66:
CPU_CheckDespawn:
	tst.b	1(a0)
	bmi.s	CPU_ResetRespawnTimer
	btst	#3,$22(a0)
	beq.s	CPU_TickRespawnTimer

	moveq	#0,d0
	move.b	$3D(a0),d0
	lsl.w	#6,d0
	addi.l	#$FFFFB000,d0
	movea.l	d0,a3	; a3=object
	move.b	($FFFFF67E).w,d0
	cmp.b	(a3),d0
	bne.s	BranchTo_CPU_Despawn

; loc_1BE8C:
CPU_TickRespawnTimer:
	addq.w	#1,($FFFFF674).w
	cmpi.w	#$12C,($FFFFF674).w
	blo.s	CPU_UpdateObjInteract

BranchTo_CPU_Despawn 
	bra.w	CPU_Despawn
; ===========================================================================
; loc_1BE9C:
CPU_ResetRespawnTimer:
	move.w	#0,($FFFFF674).w
; loc_1BEA2:
CPU_UpdateObjInteract:
	moveq	#0,d0
	move.b	$3D(a0),d0
	lsl.w	#6,d0
	addi.l	#$FFFFB000,d0
	movea.l	d0,a3	; a3=object
	move.b	(a3),($FFFFF67E).w
	rts

; ===========================================================================
; AI State where Tails stops, drops, and spindashes in Sonic's direction
; ---------------------------------------------------------------------------
; loc_1BEB8:
CPU_Panic:
	bsr.w	CPU_CheckDespawn
	tst.w	($FFFFF672).w
	bne.w	return_1BF36
;	tst.w	$2E(a0)
;	bne.s	return_1BF36
	tst.b	$39(a0)
	bne.s	CPU_Panic_ChargingDash

CPU_Panic_NoDash:
	tst.w	$20(a0)
	bne.s	return_1BF36
	bclr	#0,$22(a0)
	move.w	8(a0),d0
	sub.w	8(a1),d0
	bcs.s	CPU13
	bset	#0,$22(a0)
CPU13:
	move.w	#$202,($FFFFF670).w
	move.b	($FFFFFE05).w,d0
	andi.b	#$7F,d0
	beq.s	CPU_Panic_ReleaseDash

	cmpi.b	#8,$1C(a0)
	bne.s	return_1BF36
	move.w	#$7272,($FFFFF670).w
	rts
; ---------------------------------------------------------------------------
; loc_1BF0C:
CPU_Panic_ChargingDash:
	move.w	#$202,($FFFFF670).w
	move.b	($FFFFFE05).w,d0
	andi.b	#$7F,d0
	bne.s	CPU_Panic_RevDash

; loc_1BF1C:
CPU_Panic_ReleaseDash:
	move.w	#0,($FFFFF670).w
	move.w	#6,($FFFFF678).w	; => CPU_Normal
	rts
; ---------------------------------------------------------------------------
; loc_1BF2A:
CPU_Panic_RevDash:
	andi.b	#$1F,d0
	bne.s	return_1BF36
	ori.w	#$7070,($FFFFF670).w

return_1BF36:
	rts
; End of function CPU_Control

; ---------------------------------------------------------------------------
; Subroutine to	record Sonic's previous positions for invincibility stars
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Main_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF7A8).w,d0
		lea	($FFFFE500).w,a1
		lea	(a1,d0.w),a1
		move.w	8(a0),(a1)+
		move.w	$C(a0),(a1)+
		addq.b	#4,($FFFFF7A9).w

		lea	($FFFFE400).w,a1
		lea	(a1,d0.w),a1
		move.w	($FFFFF602).w,(a1)+
		move.w	$22(a0),(a1)+
		rts

Partner_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF62E).w,d0
		lea	($FFFFE600).w,a1
		lea	(a1,d0.w),a1
		move.w	8(a0),(a1)+
		move.w	$C(a0),(a1)+
		addq.b	#4,($FFFFF72F).w
		rts
; End of function Main_RecordPos

; ---------------------------------------------------------------------------
; Subroutine for Sonic when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Water:				; XREF: loc_12C7E
	;	cmpi.b	#1,($FFFFFE10).w ; is level TJZ?
	;	beq.s	Obj01_InWater	; if yes, branch
		tst.b	(Water_flag).w ; does level have water?
		bne.s	Obj01_InWater ; if yes, branch

locret_12D80:
		rts	
; ===========================================================================

Obj01_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is Sonic above the water?
		bge.s	Obj01_OutWater	; if yes, branch
		bset	#6,$22(a0)
		bne.s	locret_12D80
		bsr.w	ResumeMusic

Obj01_InWaterCont:
		asr	$10(a0)
		asr	$12(a0)
		asr	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_InWaterCont2
		move.b	#$A,($FFFFB340).w ; load bubbles object	from Sonic's mouth
		move.b	#$81,($FFFFB368).w
		move.w	#$300,($FFFFF760).w ; change Sonic's top speed
		move.w	#6,($FFFFF762).w ; change Sonic's acceleration
		move.w	#$40,($FFFFF764).w ; change Sonic's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

Obj01_InWaterCont2:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; ===========================================================================

Obj01_OutWater:
		bclr	#6,$22(a0)
		beq.w	locret_12D80
		asl	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_OutWater2
		bsr.w	ResumeMusic
		move.w	#$600,($FFFFF760).w ; restore Sonic's speed
		move.w	#$C,($FFFFF762).w ; restore Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; restore Sonic's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

Obj01_OutWater2:
		cmpi.w	#-$1000,$12(a0)
		bgt.s	loc_12E0E
		move.w	#-$1000,$12(a0)	; set maximum speed on leaving water

loc_12E0E:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; End of function Sonic_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Sonic
; ---------------------------------------------------------------------------

Obj01_MdNormal:				; XREF: Obj01_Modes
		bsr.w	Sonic_SpinDash
		bsr.w	Sonic_Jump
		bsr.w	Sonic_SlopeResist
		bsr.w	Sonic_Move
		bsr.w	Sonic_Roll
		bsr.w	Sonic_LevelBound
		jsr	SpeedToPos
		bsr.w	Sonic_AnglePos
		bsr.w	Sonic_SlopeRepel
		rts	
; ===========================================================================

Obj01_MdJump:				; XREF: Obj01_Modes
		clr.b	$39(a0)
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_ChgJumpDir
		bsr.w	Sonic_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc_12E5C
		subi.w	#$28,$12(a0)

loc_12E5C:
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_Floor
		rts	
; ===========================================================================

Obj01_MdRoll:				; XREF: Obj01_Modes
		bsr.w	Sonic_Jump
		bsr.w	Sonic_RollRepel
		bsr.w	Sonic_RollSpeed
		bsr.w	Sonic_LevelBound
		jsr	SpeedToPos
		bsr.w	Sonic_AnglePos
		bsr.w	Sonic_SlopeRepel
		rts	
; ===========================================================================

Obj01_MdJump2:				; XREF: Obj01_Modes
		clr.b	$39(a0)
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_ChgJumpDir
		bsr.w	Sonic_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc_12EA6
		move.w	$10(a0),d0		; move Sonic's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj01_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj01_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Sonic speed less than $250?
		blt.s	loc_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move sonic's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Sonic slightly in the water?
		bgt.s	loc_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)

loc_12EA6:
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Move:				; XREF: Obj01_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		cmpi.w	#2,($FFFFFE10).w
		beq.s	Sonic_MachSpeed
		tst.b	($FFFFF7CA).w
		bne.w	loc_12FEE
		tst.w	$3E(a0)
		bne.w	Obj01_ResetScr
		btst	#7,$22(a0)
		bne.s	Sonic_Move2
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj01_NotLeft	; if not, branch
		bsr.w	Sonic_MoveLeft
		bra.s	Obj01_NotLeft

Sonic_MoveDone:
		rts

Sonic_MachSpeed:
		move.w	#$700,$20(a0)
		bsr.w	Sonic_MoveRight
		bra.s	Obj01_NotRight

Obj01_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr.w	Sonic_MoveRight
		bra.s	Obj01_NotRight

Sonic_Move2:
		btst	#2,($FFFFF670).w ; is left being pressed?
		beq.s	Obj01_NotLeft2	; if not, branch
		bsr.w	Sonic_MoveLeft

Obj01_NotLeft2:
		btst	#3,($FFFFF670).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr.w	Sonic_MoveRight

Obj01_NotRight:
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Sonic on a	slope?
		bne.w	Obj01_ResetScr	; if yes, branch
		tst.w	$20(a0)		; is Sonic moving?
		bne.w	Obj01_ResetScr	; if yes, branch
		bclr	#5,$22(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		btst	#3,$22(a0)
		beq.s	Sonic_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	$22(a1)
		bmi.s	Sonic_LookUp
		moveq	#0,d1
		move.b	$14(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	8(a0),d1
		sub.w	8(a1),d1
		cmpi.w	#4,d1
		blt.s	Sonic_BalanceLeft
		cmp.w	d2,d1
		bge.s	Sonic_BalanceRight
		bra.s	Sonic_LookUp

Sonic_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Sonic_LookUp
		cmpi.b	#3,$36(a0)	;Mercury Constants
		beq.s	Sonic_BalanceRight
		cmpi.b	#3,$37(a0)	;Mercury Constants
		bne.s	Sonic_LookUp

Sonic_BalanceLeft:
		btst	#0,$22(a0)	; is Sonic facing left?	;Mercury Constants
		beq.s	Sonic_BalanceBackward	; if not, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	Obj01_ResetScr	; branch

Sonic_BalanceRight:
		btst	#0,$22(a0)	; is Sonic facing left?	;Mercury Constants
		bne.s	Sonic_BalanceBackward	; if so, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	Obj01_ResetScr	; branch

Sonic_BalanceBackward:
		move.b	#$F,$1C(a0) ; use backward balancing animation
		bra.w	Obj01_ResetScr
; ===========================================================================

Sonic_LookUp:
		btst	#7,$22(a0)
		bne.s	Obj01_ResetScr
		btst	#0,($FFFFF602).w ; is up being pressed?
		bra.s	Sonic_LookUp3

Sonic_LookUp2:
		btst	#0,($FFFFF670).w ; is up being pressed?

Sonic_LookUp3:
		beq.s	Sonic_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================
 
Sonic_Duck:
		btst	#7,$22(a0)
		bne.s	Sonic_Duck2
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	Sonic_Duck3

Sonic_Duck2:
		btst	#1,($FFFFF670).w ; is down being pressed?

Sonic_Duck3:
		beq.s	Obj01_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2

; ===========================================================================
 
Obj01_ResetScr:
		move.b	#0,($FFFFC903).w
 
Obj01_ResetScr_Part2:
		btst	#7,$22(a0)
		bne.s	loc_12FC4
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc_12FC2	; if yes, branch
		bcc.s	loc_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default
 
loc_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc_12FC2:
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc_12FC23
		bra.s	loc_12FC22

loc_12FC23:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		bge.s	loc_12FC22
		tst.w	($FFFFF75E).w ; is	screen in its default position?
		beq.s	loc_12FC22	; if yes, branch
		bge.s	loc_12FBE2
		addq.w	#4,($FFFFF75E).w ; move	screen back to default
 
loc_12FBE2:
		subq.w	#2,($FFFFF75E).w ; move	screen back to default

loc_12FC22:
		cmpi.w	#2,($FFFFFE10).w
		beq.s	Obj01_ResetScrCont
		move.b	($FFFFF602).w,d0
		bra.s	loc_12FC6

loc_12FC4:		
		move.b	($FFFFF670).w,d0

loc_12FC6:
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc_12FEE	; if yes, branch

Obj01_ResetScrCont:
		move.w	$20(a0),d0
		beq.s	loc_12FEE
		bmi.s	loc_12FE2
		sub.w	d5,d0
		bcc.s	loc_12FDC
		move.w	#0,d0

loc_12FDC:
		move.w	d0,$20(a0)
		bra.s	loc_12FEE
; ===========================================================================

loc_12FE2:
		add.w	d5,d0
		bcc.s	loc_12FEA
		move.w	#0,d0

loc_12FEA:
		move.w	d0,$20(a0)

loc_12FEE:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)

loc_1300C:
		move.b	$26(a0),d0
		addi.b	#$40,d0
		bmi.w	locret_1307C
		move.b	#$40,d1
		tst.w	$20(a0)
		beq.s	locret_1307C
		bmi.s	loc_13024
		neg.w	d1

loc_13024:
		move.b	$26(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Sonic_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc_13078
		cmpi.b	#$40,d0
		beq.s	loc_13066
		cmpi.b	#$80,d0
		beq.s	loc_13060
		cmpi.w	#2,($FFFFFE10).w
		beq.s	JMP_HurtSonic
		add.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc_13060:
		sub.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_13066:
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc_13078:
		add.w	d1,$12(a0)

locret_1307C:
		rts	

JMP_HurtSonic:
		cmpi.w	#$600,$10(a0)
		bge.s	JMP_HSMach
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts

JMP_HSMach:
		subi.w	#$10,$C(a0)
		jmp		HurtSonic

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_MoveLeft:		   ; XREF: Sonic_Move
		move.w	$20(a0),d0
		beq.s	loc_13086
		bpl.s	loc_130B2
 
loc_13086:
		bset	#0,$22(a0)
		bne.s	loc_1309A
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_130A6
		move.w	d1,d0
 
loc_130A6:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc_130B2:				; XREF: Sonic_MoveLeft
		sub.w	d4,d0
		bcc.s	loc_130BA
		move.w	#-$80,d0

loc_130BA:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_130E8
		cmpi.w	#$400,d0
		blt.s	locret_130E8
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bclr	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound
		move.b	#6,($FFFFB1E4).w
		btst	#7,$22(a0)
		bne.s	locret_130E8
		move.b	#$15,($FFFFB1DA).w

locret_130E8:
		rts	
; End of function Sonic_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_MoveRight:	   ; XREF: Sonic_Move
		move.w	$20(a0),d0
		bmi.s	loc_13118
		bclr	#0,$22(a0)
		beq.s	loc_13104
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1310C
		move.w	d6,d0
 
loc_1310C:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc_13118:				; XREF: Sonic_MoveRight
		add.w	d4,d0
		bcc.s	loc_13120
		move.w	#$80,d0

loc_13120:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret_1314E
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bset	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound
		move.b	#6,($FFFFB1E4).w
		btst	#7,$22(a0)
		bne.s	locret_1314E
		move.b	#$15,($FFFFB1DA).w

locret_1314E:
		rts	
; End of function Sonic_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollSpeed:			; XREF: Obj01_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_131CC
		tst.w	$3E(a0)
		bne.s	loc_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_1317C	; if not, branch
		bsr.w	Sonic_RollLeft

loc_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_13188	; if not, branch
		bsr.w	Sonic_RollRight

loc_13188:
		move.w	$20(a0),d0
		beq.s	loc_131AA
		bmi.s	loc_1319E
		sub.w	d5,d0
		bcc.s	loc_13198
		move.w	#0,d0

loc_13198:
		move.w	d0,$20(a0)
		bra.s	loc_131AA
; ===========================================================================

loc_1319E:				; XREF: Sonic_RollSpeed
		add.w	d5,d0
		bcc.s	loc_131A6
		move.w	#0,d0

loc_131A6:
		move.w	d0,$20(a0)

loc_131AA:
		tst.w	$20(a0)		; is Sonic moving?
		bne.s	loc_131CC	; if yes, branch
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		subq.w	#5,$C(a0)

loc_131CC:
		cmp.w	#$60,($FFFFF73E).w
		beq.s	@cont2
		bcc.s	@cont1
		addq.w	#4,($FFFFF73E).w
 
@cont1:
		subq.w	#2,($FFFFF73E).w
 
@cont2:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		muls.w	$20(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_131F0
		move.w	#$1000,d1

loc_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc_131FA
		move.w	#-$1000,d1

loc_131FA:
		move.w	d1,$10(a0)
		bra.w	loc_1300C
; End of function Sonic_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollLeft:				; XREF: Sonic_RollSpeed
		move.w	$20(a0),d0
		beq.s	loc_1320A
		bpl.s	loc_13218

loc_1320A:
		bset	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_13218:
		sub.w	d4,d0
		bcc.s	loc_13220
		move.w	#-$80,d0

loc_13220:
		move.w	d0,$20(a0)
		rts	
; End of function Sonic_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRight:			; XREF: Sonic_RollSpeed
		move.w	$20(a0),d0
		bmi.s	loc_1323A
		bclr	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_1323A:
		add.w	d4,d0
		bcc.s	loc_13242
		move.w	#$80,d0

loc_13242:
		move.w	d0,$20(a0)
		rts	
; End of function Sonic_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_ChgJumpDir:		; XREF: Obj01_MdJump; Obj01_MdJump2
		cmpi.w	#2,($FFFFFE10).w
		beq.w	locret_132D2
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		btst	#4,$22(a0)	
		bne.s	Obj01_ResetScr2	
		move.w	$10(a0),d0	
		btst	#7,$22(a0)
		bne.s	Sonic_ChgJumpDir2
		btst	#2,($FFFFF602).w; is left being pressed?
		bra.s	Sonic_ChgJumpDir3

Sonic_ChgJumpDir2:		
		btst	#2,($FFFFF670).w; is left being pressed?

Sonic_ChgJumpDir3:	
		beq.s	loc_13278; if not, branch	
		bset	#0,$22(a0)	
		sub.w	d5,d0	
		move.w	d6,d1	
		neg.w	d1	
		cmp.w	d1,d0	
		bgt.s	loc_13278	
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc_13278	; +++ if speed was already greater than the maximum, branch	
		move.w	d1,d0
 
loc_13278:
		btst	#7,$22(a0)
		bne.s	loc_1327A
		btst	#3,($FFFFF602).w; is left being pressed?
		bra.s	loc_1327C

loc_1327A:		
		btst	#3,($FFFFF670).w; is left being pressed?

loc_1327C:	
		beq.s	Obj01_JumpMove; if not, branch	
		bclr	#0,$22(a0)	
		add.w	d5,d0	
		cmp.w	d6,d0	
		blt.s	Obj01_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	Obj01_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

Obj01_JumpMove:
		move.w	d0,$10(a0)	; change Sonic's horizontal speed

Obj01_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc_132A4	; if yes, branch
		bcc.s	loc_132A0
		addq.w	#4,($FFFFF73E).w

loc_132A0:
		subq.w	#2,($FFFFF73E).w

loc_132A4:
		cmpi.w	#-$400,$12(a0)	; is Sonic moving faster than -$400 upwards?
		bcs.s	locret_132D2	; if yes, branch
		move.w	$10(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_132D2
		bmi.s	loc_132C6
		sub.w	d1,d0
		bcc.s	loc_132C0
		move.w	#0,d0

loc_132C0:
		move.w	d0,$10(a0)
		rts	
; ===========================================================================

loc_132C6:
		sub.w	d1,d0
		bcs.s	loc_132CE
		move.w	#0,d0

loc_132CE:
		move.w	d0,$10(a0)

locret_132D2:
		rts	
; End of function Sonic_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Sonic leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_LevelBound:			; XREF: Obj01_MdNormal; et al
		move.l	8(a0),d1
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		bhi.s	Boundary_Sides	; if yes, branch
		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		bls.s	Boundary_Sides	; if yes, branch

loc_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has Sonic touched the	bottom boundary?
		blt.s	Boundary_Bottom	; if yes, branch
		rts	
; ===========================================================================

Boundary_Bottom:
		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1			; screen still scrolling down?
		blt.s	Boundary_Bottom_locret	; if so, don't kill Sonic
		jmp 	KillSonic
 
Boundary_Bottom_locret:
		rts
; ===========================================================================

Boundary_Sides:
		move.w	d0,8(a0)
		move.w	#0,$A(a0)
		move.w	#0,$10(a0)	; stop Sonic moving
		move.w	#0,$20(a0)
		bra.s	loc_13336
; End of function Sonic_LevelBound

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Roll:				; XREF: Obj01_MdNormal\
		tst.b	($FFFFF7CA).w
		bne.s	Obj01_NoRoll
		move.w	$20(a0),d0
		bpl.s	loc_13392
		neg.w	d0

loc_13392:
		cmpi.w	#$80,d0		; is Sonic moving at $80 speed or faster?
		bcs.s	Obj01_NoRoll	; if not, branch
		btst	#7,$22(a0)
		bne.s	loc_133922
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj01_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	loc_133923

loc_133922:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj01_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?

loc_133923:	
		bne.s	Obj01_ChkRoll	; if yes, branch

Obj01_NoRoll:
		rts	
; ===========================================================================

Obj01_ChkRoll:
		btst	#2,$22(a0)	; is Sonic already rolling?
		beq.s	Obj01_DoRoll	; if not, branch
		move.w	#0,($FFFFB030).w
		rts	

; ===========================================================================

Obj01_DoRoll:
		bset	#2,$22(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		move.w	#1,($FFFFB030).w
		addq.w	#5,$C(a0)
		move.w	#$3C,d0
		jsr	(PlaySound_Special).l ;	play rolling sound
		tst.w	$20(a0)
		bne.s	locret_133E8
		move.w	#$200,$20(a0)

locret_133E8:
		rts	
; End of function Sonic_Roll

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Jump:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		btst	#7,$22(a0)
		bne.s	Sonic_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Sonic_Jump3

Sonic_Jump2:	
		move.b	($FFFFF671).w,d0

Sonic_Jump3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.w	locret_1348E	; if not, branch
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		bsr.w	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc_1341C
		move.w	#$380,d2

loc_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Sonic jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Sonic jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$60,d0
		jsr	PlaySound ;	play jumping sound
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		btst	#2,$22(a0)
		bne.s	loc_13490
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "jumping"	animation
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)

locret_1348E:
		rts	
; ===========================================================================

loc_13490:
		bset	#4,$22(a0)
		rts	
; End of function Sonic_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpHeight:			; XREF: Obj01_MdJump; Obj01_MdJump2
		tst.b	$3C(a0)
		beq.s	loc_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc_134AE
		move.w	#-$200,d1

loc_134AE:
		cmp.w	$12(a0),d1
		ble.s	Sonic_JumpDash
		btst	#7,$22(a0)
		bne.s	Sonic_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Sonic_JumpHeight3

Sonic_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Sonic_JumpHeight3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret_134C2:
		rts	
; ===========================================================================

loc_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret_134D2
		move.w	#-$FC0,$12(a0)

locret_134D2:
		rts	
; End of function Sonic_JumpHeight

; ---------------------------------------------------------------------------
; Subroutine to perform a Jumpdash
; ---------------------------------------------------------------------------

Sonic_JumpDash:
		tst.b	$29(a0)		; was jumpdash flag set
		bne.w	JD_Move
		btst	#7,$22(a0)
		bne.s	Sonic_JumpDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Sonic_JumpDash3

Sonic_JumpDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Sonic_JumpDash3:	
		andi.b	#$70,d0			; is ABC pressed? (part 2)
		beq.w	JD_End			; if not, branch
		tst.b	$2F(a0)		; was jumpdash flag set
		bne.s	JD_End
		btst	#0,($FFFFFE2C).w
		bne.w	Sonic_FireShield

JD_FireCont:
		move.b	#1,$2F(a0)	; if not, set jumpdash flag
		move.b	#$14,$29(a0)	; if not, set jumpdash flag
		btst	#4,($FFFFFE2C).w
		bne.w	JD_FireCont2
		move.b	#$C,$29(a0)	; if not, set jumpdash flag
		move.b	#$B6,d0			; set jumpdash sound
		jsr	(PlaySound_Special).l	; play jumpdash sound

JD_FireCont2:
		cmpi.w	#2,($FFFFFE10).w
		beq.w	JD_Running
		move.w	$10(a0),d0
		move.w	d0,($FFFFF63C).w
		btst	#0,$22(a0)		; is sonic facing left?
		beq.s	JD_NoFlip		; if yes, branch
		sub.w	#$600,d0
		bra.s	JD_Cont

JD_Running:
		btst	#0,$22(a0)		; is sonic facing left?
		bne.s	JD_NoFlip		; if yes, branch
		sub.w	#$600,d0
		bra.s	JD_Cont

JD_NoFlip:
		add.w	#$600,d0

JD_Cont:
		move.w	d0,$10(a0)

JD_Move:
		sub.b	#1,$29(a0)
		tst.b	$29(a0)
		beq.s	JD_Reset
		clr.w	$12(a0)			; clear Sonic's Y-velocity to move sonic directly down

JD_End:
		rts				; return

JD_Reset:
		cmpi.w	#2,($FFFFFE10).w
		beq.w	JD_End
		tst.w	$10(a0)
		beq.s	JD_End
		blt.s	JD_Reset2
		tst.b	($FFFFF63C).w
		bgt.s	JD_Reset3
		bra.s	JD_Reset4

JD_Reset2:
		tst.b	($FFFFF63C).w
		blt.s	JD_Reset3

JD_Reset4:
		neg.w	($FFFFF63C).w

JD_Reset3:
		move.w	($FFFFF63C).w,$10(a0)
		rts

Sonic_FireShield:
		btst	#4,($FFFFFE2C).w
		beq.s	Sonic_LightningShield
		move.b	#4,($FFFFB19C).w
		move.w	#$43,d0			; play Bubble Shield attack sound
		jsr	(PlaySound_Special).l
		bra.w	JD_FireCont

Sonic_LightningShield:
		btst	#5,($FFFFFE2C).w
		beq.s	Sonic_BubbleShield
		;move.b	#5,($FFFFB19C).w
		move.b	#1,$2F(a0)
		move.w	#-$580,$12(a0)	; bounce Sonic up, creating the double jump effect
		clr.b	$3C(a0)
		move.w	$10(a0),d0
		btst	#0,$10(a0)
		bne.s	Sonic_LightningShield2		; if yes, branch
		asr.w	#1,d0
		bra.s	Sonic_LightningShield3

Sonic_LightningShield2:
		neg.w	d0
		asr.w	#1,d0
		neg.w	d0

Sonic_LightningShield3:
		move.w	d0,$10(a0)
		move.w	#$45,d0			; play Bubble Shield attack sound
		jmp	(PlaySound_Special).l

Sonic_BubbleShield:
		btst	#6,($FFFFFE2C).w
		beq.s	Sonic_NoShield
	;	move.b	#7,($FFFFB19C).w
		move.b	#1,$2F(a0)
		move.w	#$800,$12(a0)		; force Sonic down
		btst	#0,$22(a0)		; is sonic facing left?
		beq.s	JD2_NoFlip		; if yes, branch
		sub.w	#$600,d0
		bra.s	JD2_Cont

JD2_NoFlip:
		add.w	#$600,d0

JD2_Cont:
		move.w	d0,$10(a0)
		move.b	#$B6,d0			; set jumpdash sound
		jmp	(PlaySound_Special).l	; play jumpdash sound

Sonic_NoShield:
		rts
; End of function Sonic_JumpDash

; ---------------------------------------------------------------------------
; Subroutine to make Sonic perform a spindash
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Sonic_SpinDash:
		tst.b	$39(a0)
		bne.s	loc_1AC8E
		cmpi.b	#8,$1C(a0)
		bne.s	locret_1AC8C
		btst	#7,$22(a0)
		bne.s	Sonic_SpinDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Sonic_SpinDash3

Sonic_SpinDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Sonic_SpinDash3:	
		andi.b	#$70,d0
		beq.w	locret_1AC8C
		move.b	#9,$1C(a0)
		move.w	#$AB,d0
		jsr	(PlaySound_Special).l
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		btst	#7,$22(a0)
		bne.s	loc_1AC84
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.
 
loc_1AC84:
		bsr.w	Sonic_LevelBound
		bsr.w	Sonic_AnglePos
 
locret_1AC8C:
		rts	
; ---------------------------------------------------------------------------
 
loc_1AC8E:
		btst	#7,$22(a0)
		bne.s	loc_1AC8E3
		btst	#0,$22(a0)
		bne.s	loc_1AC8E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc_1AC8E3
		add.w	#2,($FFFFF75E).w
		bra.s	loc_1AC8E3

loc_1AC8E2:
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc_1AC8E3
		sub.w	#2,($FFFFF75E).w

loc_1AC8E3:
		move.b	#9,$1C(a0)
		btst	#7,$22(a0)
		bne.s	loc_1AC8E32
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	loc_1AC8E33

loc_1AC8E32:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

loc_1AC8E33:	
		btst	#1,d0
		bne.w	loc_1AD30
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		addq.w	#5,$C(a0)
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	Dash_Speeds(pc,d0.w),$20(a0)
	;	move.b	$20(a0),d0
	;	subi.b	#$8,d0
	;	add.b	d0,d0
	;	andi.b	#$1F,d0
	;	neg.b	d0
	;	addi.b	#$20,d0
	;	move.b	d0,($FFFFFEB3).w
		btst	#0,$22(a0)
		beq.s	loc_1ACF4
		neg.w	$20(a0)
 
loc_1ACF4:
		bset	#2,$22(a0)
		btst	#7,$22(a0)
		bne.s	loc_1ACF42
		move.b	#0,($FFFFB1DC).w	; clear Spin Dash dust animation.

loc_1ACF42:
		move.w	#-$4A,d0
		jsr	(PlaySound_Special).l
		bra.s	loc_1AD78
; ===========================================================================
Dash_Speeds:	dc.w  $800		; 0
		dc.w  $880		; 1
		dc.w  $900		; 2
		dc.w  $980		; 3
		dc.w  $A00		; 4
		dc.w  $A80		; 5
		dc.w  $B00		; 6
		dc.w  $B80		; 7
		dc.w  $C00		; 8
; ===========================================================================
 
loc_1AD30:				; If still charging the dash...
		tst.w	$3A(a0)
		beq.s	loc_1AD48
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc_1AD48
		move.w	#0,$3A(a0)
 
loc_1AD48:
		btst	#7,$22(a0)
		bne.s	loc_1AD482
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	loc_1AD483

loc_1AD482:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

loc_1AD483:
		andi.b	#$70,d0	; 'p'
		beq.w	loc_1AD78
		move.w	#$900,$1C(a0)
		move.w	#$AB,d0	; 'ร'
		jsr	(PlaySound_Special).l
		btst	#7,$22(a0)
		bne.s	loc_1AD4832
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.

loc_1AD4832:
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc_1AD78
		move.w	#$800,$3A(a0)
 
loc_1AD78:
		addq.l	#4,sp			; increase stack ptr
		cmpi.w	#$60,($FFFFF73E).w
		beq.s	loc_1AD8C
		bcc.s	loc_1AD88
		addq.w	#4,($FFFFF73E).w
 
loc_1AD88:
		subq.w	#2,($FFFFF73E).w
 
loc_1AD8C:
		bsr.w	Sonic_LevelBound
		bsr.w	Sonic_AnglePos
	;	move.w	#$60,($FFFFF73E).w	; reset looking up/down
		rts
; End of subroutine Sonic_SpinDash

; ---------------------------------------------------------------------------
; Subroutine to	slow Sonic walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeResist:			; XREF: Obj01_MdNormal
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bcc.s	locret_13508
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		beq.s	locret_13508
		bmi.s	loc_13504
		tst.w	d0
		beq.s	locret_13502
		add.w	d0,$20(a0)	; change Sonic's inertia

locret_13502:
		rts	
; ===========================================================================

loc_13504:
		add.w	d0,$20(a0)

locret_13508:
		rts	
; End of function Sonic_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRepel:			; XREF: Obj01_MdRoll
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_13544
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		bmi.s	loc_1353A
		tst.w	d0
		bpl.s	loc_13534
		asr.l	#2,d0

loc_13534:
		add.w	d0,$20(a0)
		rts	
; ===========================================================================

loc_1353A:
		tst.w	d0
		bmi.s	loc_13540
		asr.l	#2,d0

loc_13540:
		add.w	d0,$20(a0)

locret_13544:
		rts	
; End of function Sonic_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeRepel:			; XREF: Obj01_MdNormal; Obj01_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret_13580
		tst.w	$3E(a0)
		bne.s	loc_13582
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret_13580
		move.w	$20(a0),d0
		bpl.s	loc_1356A
		neg.w	d0

loc_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret_13580
		clr.w	$20(a0)
		bset	#1,$22(a0)
		move.w	#$1E,$3E(a0)

locret_13580:
		rts	
; ===========================================================================

loc_13582:
		subq.w	#1,$3E(a0)
		rts	
; End of function Sonic_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Sonic's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpAngle:			; XREF: Obj01_MdJump; Obj01_MdJump2
		move.b	$26(a0),d0	; get Sonic's angle
		beq.s	locret_135A2	; if already 0,	branch
		bpl.s	loc_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc_13596
		moveq	#0,d0

loc_13596:
		bra.s	loc_1359E
; ===========================================================================

loc_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc_1359E
		moveq	#0,d0

loc_1359E:
		move.b	d0,$26(a0)

locret_135A2:
		rts	
; End of function Sonic_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Sonic to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_13680
		cmpi.b	#$80,d0
		beq.w	loc_136E2
		cmpi.b	#-$40,d0
		beq.w	loc_1373E
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_135F0
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_135F0:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13602
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_13602:
        move.b  $12(a0),d0       ; * get blocks per frame (D)
        andi.w  #$F0,d0         ; * ''
        move.w  d0,-(sp)        ; * save D to stack

loc_13602_0:     
		exg d0,d2           ; * D as base Ypos
        add.w   $C(a0),d2      ; * add ypos
        move.w  8(a0),d3      ; * get xpos
        bsr.w   Sonic_HitFloor2     ; * check
        tst.w   d1          ; * success?
        bmi.s   loc_13602_1          ; * yes, branch
        subi.w  #$10,(sp)       ; * set D to previous $10 pixels
        move.w  (sp),d0         ; * get D to our scratch reg
        bpl.s   loc_13602_0          ; * if we have any remain to check, branch
        addq.w  #2,sp           ; * if not (if there's definitely nothing to collide with)
        rts             ;   fix the stack and return

loc_13602_1:     
		move.w  (sp),d0         ; * get D to our scratch reg
        addq.w  #2,sp           ; * fix the stack
        add.w   d0,d1           ; * add D to the "within-in-block" result (and fix final value)
        add.w   d1,$C(a0)      ; * add final value to ypos
    ;    move.b  d1,($FFFFFFEF).w
        tst.w   d0          ; * check D
        beq.s   loc_1361E          ; * if zero (falling slow), branch
        andi.w  #$FFF0,$C(a0)      ; * just in case, align ypos
 
loc_1361E:
        move.b  d3,$26(a0)
		move.b	#0,$1C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1364E
		asr	$12(a0)
		bra.s	loc_13670
; ===========================================================================

loc_1364E:
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
        bra.w   Sonic_ResetOnFloor
; ===========================================================================

loc_1365C:
		move.w	#0,$10(a0)
		cmpi.w	#$FC0,$12(a0)
		ble.s	loc_13670
		move.w	#$FC0,$12(a0)

loc_13670:
        bsr.w   Sonic_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret_1367E
		neg.w	$20(a0)

locret_1367E:
		rts	
; ===========================================================================

loc_13680:
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_1369A
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc_1369A:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_136B4
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret_136B2
		move.w	#0,$12(a0)

locret_136B2:
		rts	
; ===========================================================================

loc_136B4:
		tst.w	$12(a0)
		bmi.s	locret_136E0
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_136E0
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#0,$1C(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Sonic_ResetOnFloor

locret_136E0:
		rts	
; ===========================================================================

loc_136E2:
		bsr.w	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_136F4
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_136F4:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13706
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_13706:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret_1373C
		sub.w	d1,$C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_13726
		move.w	#0,$12(a0)
		rts	
; ===========================================================================

loc_13726:
		move.b	d3,$26(a0)
		bsr.w	Sonic_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret_1373C
		neg.w	$20(a0)

locret_1373C:
		rts	
; ===========================================================================

loc_1373E:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_13758
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc_13758:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_13772
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret_13770
		move.w	#0,$12(a0)

locret_13770:
		rts	
; ===========================================================================

loc_13772:
		tst.w	$12(a0)
		bmi.s	locret_1379E
		bsr.w	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_1379E
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Sonic_ResetOnFloor

locret_1379E:
		rts	
; End of function Sonic_Floor

; ---------------------------------------------------------------------------
; Subroutine to	reset Sonic's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Player_ResetOnFloor:			; XREF: PlatformObject; et al
		cmpi.b	#$8E,0(a0)
		beq.w	Shadow_ResetOnFloor
		cmpi.b	#$95,0(a0)
		beq.w	Tails_ResetOnFloor
		cmpi.b	#2,0(a0)
		beq.w	Silver_ResetOnFloor

Sonic_ResetOnFloor:
		btst	#4,$22(a0)
		beq.s	loc_137AE
		nop
		nop
		nop
		nop
		nop

loc_137AE:
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		btst	#7,$22(a0)
		bne.s	loc_137E6
		tst.b	$2F(a0)
		beq.s	loc_137E6
		move.b	#0,$2F(a0)	; clear jumpdash flag
		btst	#6,($FFFFFE2C).w
		bne.s	BubbleShield_Bounce

loc_137E6:
		tst.b	$29(a0)		; was jumpdash flag set
		beq.s	locret_12232
		move.b	#0,$29(a0)	; clear jumpdash flag
		bsr.w		JD_Reset
		move.w	$10(a0),$20(a0)

locret_12232:
		rts	
; End of function Player_ResetOnFloor

; =============== S U B R O U T I N E =======================================


BubbleShield_Bounce:
		movem.l	d1-d2,-(sp)
		move.w	#$780,d2
		btst	#6,$22(a0)
		beq.s	loc_12246
		move.w	#$400,d2

loc_12246:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)
		movem.l	(sp)+,d1-d2
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		bset	#2,$22(a0)
		clr.b	$3C(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		bset	#2,$22(a0)
		move.b	#8,($FFFFB19C).w
		move.w	#$44,d0
		jmp	(PlaySound_Special).l
; End of function BubbleShield_Bounce

; ---------------------------------------------------------------------------
; Subroutine to	reset Shadow's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_ResetOnFloor:			; XREF: PlatformObject; et al
		btst	#4,$22(a0)
		beq.s	loc3_137AE
		nop
		nop
		nop
		nop
		nop

loc3_137AE:
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc3_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc3_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		rts	
; End of function Shadow_ResetOnFloor

; ---------------------------------------------------------------------------
; Subroutine to	reset Shadow's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_ResetOnFloor:			; XREF: PlatformObject; et al
		btst	#4,$22(a0)
		beq.s	loc4_137AE
		nop
		nop
		nop
		nop
		nop

loc4_137AE:
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc4_137E4
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc4_137E4:
		move.b	#0,$3C(a0)
		move.b	#0,$2F(a0)
		move.w	#0,($FFFFF7D0).w
		rts	
; End of function Tails_ResetOnFloor


; ---------------------------------------------------------------------------
; Subroutine to	reset Silver's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_ResetOnFloor:			; XREF: PlatformObject; et al
		btst	#4,$22(a0)
		beq.s	loc2_137AE
		nop
		nop
		nop
		nop
		nop

loc2_137AE:
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc2_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc2_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		tst.b	$2F(a0)
		bne.s	Silver_ROFReset
		tst.b	$39(a0)
		bne.s	Silver_ROFReset
		rts

Silver_ROFReset:
		move.b	#0,$2F(a0)
		move.b	#0,$39(a0)
		btst	#7,$22(a0)
		bne.s	Silver_ROFEnd
		move.l	a0,-(sp)
		move.l	a1,-(sp)
		lea	Pal_Silver.l,a0		; load this palette
		lea	($FFFFFB00).l,a1		; set as line 2
		move.w	#3,d0

	@Loop:
		move.l	(a0)+,(a1)+			; copy colours to buffer
		move.l	(a0)+,(a1)+			; ''
		dbf	d0,@Loop		; repeat until done
		move.l	(sp)+,a1
		move.l	(sp)+,a0


Silver_ROFEnd:
		rts	

; End of function Silver_ResetOnFloor

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	gets hurt
; ---------------------------------------------------------------------------

Obj01_Hurt:				; XREF: Obj01_Index
		clr.b	($FFFFFEB3).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc_1380C
		subi.w	#$20,$12(a0)

loc_1380C:
		bsr.w	Sonic_HurtStop
		bsr.w	Sonic_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Sonic_Animate
		bsr.w	LoadSonicDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HurtStop:				; XREF: Obj01_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	JMP_KillSonic
		bsr.w	Sonic_Floor
		btst	#1,$22(a0)
		bne.s	locret_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret_13860:
		rts	
; End of function Sonic_HurtStop

JMP_KillSonic:
		jmp	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	dies
; ---------------------------------------------------------------------------

Obj01_Death:				; XREF: Obj01_Index
		clr.b	($FFFFFEB3).w
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Sonic_Animate
		bsr.w	LoadSonicDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver:				; XREF: Obj01_Death
		move.w	($FFFFF72E).w,d0
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcc.w	locret_13900
		move.w	#-$38,$12(a0)
		addq.b	#2,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		subq.b	#1,($FFFFFE12).w ; subtract 1 from number of lives
		bne.s	loc_138D4
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load GAME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#1,($FFFFB0DA).w ; set OVER object to correct frame
		clr.b	($FFFFFE1A).w

loc_138C2:
		moveq	#$1E,d0
		jsr	(PlaySound).l	; play game over music
		moveq	#3,d0
		jmp	(LoadPLC).l	; load game over patterns
; ===========================================================================

loc_138D4:
		move.w	#60,$3A(a0)	; set time delay to 1 second
		tst.b	($FFFFFE1A).w	; is TIME OVER tag set?
		beq.s	locret_13900	; if not, branch
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load TIME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		bra.s	loc_138C2
; ===========================================================================

locret_13900:
		rts	
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when the level is restarted
; ---------------------------------------------------------------------------

Obj01_ResetLevel:			; XREF: Obj01_Index
		tst.w	$3A(a0)
		beq.s	locret_13914
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	locret_13914
		move.w	#1,($FFFFFE02).w ; restart the level

locret_13914:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	animate	Sonic's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sonic_Animate:				; XREF: Obj01_Control; et al
		lea	(SonicAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	SAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

SAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

SAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	SAnim_End_FF				; MJ: if so, branch to flag routines
 
SAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

SAnim_Delay:
		rts	
; ===========================================================================

SAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

SAnim_End:
		rts	
; ===========================================================================

SAnim_WalkRun:				; XREF: SAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Sonic's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Sonic mirrored horizontally?
		bne.s	loc_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	SAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Sonic's speed
		bpl.s	loc_13A9C
		neg.w	d2

loc_13A9C:
		lea	(SonAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Sonic at running speed?
		bcc.s	loc_13AB4	; if yes, branch
		lea	(SonAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0

loc_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_13AC2
		moveq	#0,d2

loc_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	SAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

SAnim_RollJump:				; XREF: SAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	SAnim_Push	; if not, branch
		move.w	$20(a0),d2	; get Sonic's speed
		bpl.s	loc_13ADE
		neg.w	d2

loc_13ADE:
		lea	(SonAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Sonic moving fast?
		bcc.s	loc_13AF0	; if yes, branch
		lea	(SonAni_Roll).l,a1 ; use slower	animation

loc_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_13AFA
		moveq	#0,d2

loc_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SAnim_Do2
; ===========================================================================

SAnim_Push:				; XREF: SAnim_RollJump
		move.w	$20(a0),d2	; get Sonic's speed
		bmi.s	loc_13B1E
		neg.w	d2

loc_13B1E:
		addi.w	#$800,d2
		bpl.s	loc_13B26
		moveq	#0,d2

loc_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(SonAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SAnim_Do2
; End of function Sonic_Animate

SonicAniData:
	include "_anim\Sonic.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 02 - Silver
; ---------------------------------------------------------------------------

Obj02:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj02_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj02_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj02_Index(pc,d0.w),d1
		jmp	Obj02_Index(pc,d1.w)
; ===========================================================================
Obj02_Index:	dc.w Obj02_Main-Obj02_Index
		dc.w Obj02_Control-Obj02_Index
		dc.w Obj02_Hurt-Obj02_Index
		dc.w Obj02_Death-Obj02_Index
		dc.w Obj02_ResetLevel-Obj02_Index
; ===========================================================================

Obj02_Main:				; XREF: Obj02_Index
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Silver,4(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_Sec
		move.w	#$780,2(a0)
		bra.s	Obj02_Cont

Obj02_Sec:
		move.w	#$7A0,2(a0)

Obj02_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_Control
		move.w	#$480,($FFFFF760).w ; Silver's top speed
		move.w	#$A,($FFFFF762).w ; Silver's acceleration
		move.w	#$60,($FFFFF764).w ; Silver's deceleration
		move.b	#$92,($FFFFB1C0).w

Obj02_Control:				; XREF: Obj02_Index
		btst	#7,$22(a0)
		bne.s	loc2_12C58
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc2_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc2_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Silver	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc2_12C58:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc2_12C62	; if yes, branch
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control

loc2_12C62:
		bsr.w	CPU_Control
		bra.s	loc2_12C64

loc2_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc2_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc2_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne.s	loc2_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj02_Modes(pc,d0.w),d1
		jsr	Obj02_Modes(pc,d1.w)

loc2_12C7E:
		bsr.s	Silver_Display
		bsr.w	Main_RecordPos
		bsr.w	Silver_Water
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc2_12CA6
		tst.b	$1C(a0)
		bne.s	loc2_12CA6
		move.b	$1D(a0),$1C(a0)

loc2_12CA6:
		bsr.w	Silver_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc2_12CB6
		jsr	TouchResponse

loc2_12CB6:
		bsr.w	LoadSilverDynPLC
		rts
; ===========================================================================
Obj02_Modes:	dc.w Obj02_MdNormal-Obj02_Modes
		dc.w Obj02_MdJump-Obj02_Modes
		dc.w Obj02_ExitChk-Obj02_Modes
		dc.w Obj02_MdJump2-Obj02_Modes

Silver_Display:				; XREF: loc2_12C7E
		move.w	$30(a0),d0
		beq.s	Obj02_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_Display
		lsr.w	#3,d0
		bcc.s	Obj02_ChkInvin

Obj02_Display:
		jsr	DisplaySprite

Obj02_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Silver have invincibility?
		beq.w	Obj02_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj02_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj02_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj02_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj02_RmvInvin	; change to bcs.w
		moveq	#0,d0
		move.b	($FFFFF75D).w,d0
		jsr	(PlaySound).l	; play normal music

Obj02_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj02_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Silver have speed	shoes?
		beq.s	Obj02_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj02_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj02_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Silver's speed
		move.w	#$C,($FFFFF762).w ; restore Silver's acceleration
		move.w	#$80,($FFFFF764).w ; restore Silver's deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		move.w	#$0,d0
		jmp	(SetTempo).l	; run music at normal speed
; ===========================================================================

Obj02_ExitChk:
		rts	

; ---------------------------------------------------------------------------
; Subroutine for Silver when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_Water:				; XREF: loc2_12C7E
	;	cmpi.b	#1,($FFFFFE10).w ; is level TJZ?
	;	beq.s	Obj02_InWater	; if yes, branch
		tst.b	(Water_flag).w ; does level have water?
		bne.s	Obj02_InWater ; if yes, branch

locret2_12D80:
		rts	
; ===========================================================================
Obj02_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is Silver above the water?
		bge.s	Obj02_OutWater	; if yes, branch
		bset	#6,$22(a0)
		bne.s	locret2_12D80
		bsr.w	ResumeMusic

Obj02_InWaterCont:
		asr	$10(a0)
		asr	$12(a0)
		asr	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_InWaterCont2
		move.b	#$A,($FFFFB340).w ; load bubbles object	from Silver's mouth
		move.b	#$81,($FFFFB368).w
		move.w	#$200,($FFFFF760).w ; change Silver's top speed
		move.w	#6,($FFFFF762).w ; change Silver's acceleration
		move.w	#$40,($FFFFF764).w ; change Silver's deceleration

Obj02_InWaterCont2:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; ===========================================================================

Obj02_OutWater:
		bclr	#6,$22(a0)
		beq.s	locret2_12D80
		asl	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_OutWater2
		bsr.w	ResumeMusic
		move.w	#$300,($FFFFF760).w ; restore Silver's speed
		move.w	#$C,($FFFFF762).w ; restore Silver's acceleration
		move.w	#$80,($FFFFF764).w ; restore Silver's deceleration
		move.b	#8,($FFFFB300).w ; load	splash object
	
Obj02_OutWater2:
		cmpi.w	#-$1000,$12(a0)
		bgt.s	loc2_12E0E
		move.w	#-$1000,$12(a0)	; set maximum speed on leaving water

loc2_12E0E:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; End of function Silver_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Silver
; ---------------------------------------------------------------------------

Obj02_MdNormal:				; XREF: Obj02_Modes
		bsr.w	Silver_Sonar
		bsr.w	Silver_Jump
		bsr.w	Silver_Move
		bsr.w	Silver_LevelBound
		jsr	SpeedToPos
		bsr.w	Silver_AnglePos
		bsr.w	Silver_SlopeRepel
		tst.b	$29(a0)
		beq.s	Obj02_MdNormal2
		add.b	#1,$29(a0)

Obj02_MdNormal2:
		rts	
; ===========================================================================

Obj02_MdJump:				; XREF: Obj02_Modes
		clr.b	$39(a0)
		bsr.w	Silver_Sonar
		bsr.w	Silver_JumpHeight
		bsr.w	Silver_ChgJumpDir
		bsr.w	Silver_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc2_12E5C
		subi.w	#$28,$12(a0)

loc2_12E5C:
		bsr.w	Silver_JumpAngle
		bsr.w	Silver_Floor
		rts	
; ===========================================================================

Obj02_MdRoll:				; XREF: Obj02_Modes
		bsr.w	Silver_Jump
		bsr.w	Silver_LevelBound
		jsr	SpeedToPos
		bsr.w	Silver_AnglePos
		rts	
; ===========================================================================

Obj02_MdJump2:				; XREF: Obj02_Modes
		clr.b	$39(a0)
		bsr.w	Silver_Sonar
		bsr.w	Silver_Levitate
		bsr.w	Silver_JumpHeight
		bsr.w	Silver_ChgJumpDir
		bsr.w	Silver_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc2_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc2_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc2_12EA6
		move.w	$10(a0),d0		; move Sonic's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj02_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj02_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Sonic speed less than $250?
		blt.s	loc2_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move sonic's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Sonic slightly in the water?
		bgt.s	loc2_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water

loc2_12EA6:
		bsr.w	Silver_JumpAngle
		bsr.w	Silver_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	make Silver walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
Silver_MoveDone:
		rts

Silver_Move:				; XREF: Obj02_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc2_12FEE
		tst.w	$3E(a0)
		bne.w	Obj02_ResetScr
		btst	#7,$22(a0)
		bne.s	Silver_Move2
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj02_NotLeft	; if not, branch
		bsr.w	Silver_MoveLeft

Obj02_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj02_NotRight	; if not, branch
		bsr.w	Silver_MoveRight
		bra.s	Obj02_NotRight

Silver_Move2:
		btst	#2,($FFFFF670).w ; is left being pressed?
		beq.s	Obj02_NotLeft2	; if not, branch
		bsr.w	Silver_MoveLeft

Obj02_NotLeft2:
		btst	#3,($FFFFF670).w ; is right being pressed?
		beq.s	Obj02_NotRight	; if not, branch
		bsr.w	Silver_MoveRight

Obj02_NotRight:
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Silver on a	slope?
		bne.w	Obj02_ResetScr	; if yes, branch
		tst.w	$20(a0)		; is Silver moving?
		bne.w	Obj02_ResetScr	; if yes, branch
		bclr	#5,$22(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		btst	#3,$22(a0)
		beq.s	Silver_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	$22(a1)
		bmi.s	Silver_LookUp
		moveq	#0,d1
		move.b	$14(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	8(a0),d1
		sub.w	8(a1),d1
		cmpi.w	#4,d1
		blt.s	loc2_12F6A
		cmp.w	d2,d1
		bge.s	loc2_12F5A
		bra.s	Silver_LookUp

Silver_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Silver_LookUp
		cmpi.b	#3,$36(a0)
		bne.s	loc2_12F62

loc2_12F5A:
		bclr	#0,$22(a0)
		bra.s	loc2_12F70
; ===========================================================================

loc2_12F62:
		cmpi.b	#3,$37(a0)
		bne.s	Silver_LookUp

loc2_12F6A:
		bset	#0,$22(a0)

loc2_12F70:
		move.b	#6,$1C(a0)	; use "balancing" animation
		bra.w	Obj02_ResetScr
; ===========================================================================

Silver_LookUp:
		btst	#7,$22(a0)
		bne.s	Silver_LookUp2
		btst	#0,($FFFFF602).w ; is up being pressed?
		bra.s	Silver_LookUp3

Silver_LookUp2:
		btst	#0,($FFFFF670).w ; is up being pressed?

Silver_LookUp3:
		beq.s	Silver_Duck	; if not, branch
		cmpi.b	#9,$E ; is up being pressed?
		beq.s	Silver_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	Obj02_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc2_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc2_12FC2
; ===========================================================================
 
Silver_Duck:
		btst	#7,$22(a0)
		bne.s	Silver_Duck2
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	Silver_Duck3

Silver_Duck2:
		btst	#1,($FFFFF670).w ; is down being pressed?

Silver_Duck3:
		beq.s	Obj02_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	Obj02_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc2_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc2_12FC2
; ===========================================================================
 
Obj02_ResetScr:
		move.b	#0,($FFFFC903).w
 
Obj02_ResetScr_Part2:
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc2_12FC2	; if yes, branch
		bcc.s	loc2_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default
 
loc2_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc2_12FC2:
		btst	#7,$22(a0)
		bne.s	loc2_12FC4
		move.b	($FFFFF602).w,d0
		bra.s	loc2_12FC6

loc2_12FC4:		
		move.b	($FFFFF670).w,d0

loc2_12FC6:
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc2_12FEE	; if yes, branch

Obj02_ResetScrCont:
		move.w	$20(a0),d0
		beq.s	loc2_12FEE
		bmi.s	loc2_12FE2
		sub.w	d5,d0
		bcc.s	loc2_12FDC
		move.w	#0,d0

loc2_12FDC:
		move.w	d0,$20(a0)
		bra.s	loc2_12FEE
; ===========================================================================

loc2_12FE2:
		add.w	d5,d0
		bcc.s	loc2_12FEA
		move.w	#0,d0

loc2_12FEA:
		move.w	d0,$20(a0)

loc2_12FEE:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)

loc2_1300C:
		move.b	$26(a0),d0
		addi.b	#$40,d0
		bmi.s	locret2_1307C
		move.b	#$40,d1
		tst.w	$20(a0)
		beq.s	locret2_1307C
		bmi.s	loc2_13024
		neg.w	d1

loc2_13024:
		move.b	$26(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Silver_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret2_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc2_13078
		cmpi.b	#$40,d0
		beq.s	loc2_13066
		cmpi.b	#$80,d0
		beq.s	loc2_13060
		add.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc2_13060:
		sub.w	d1,$12(a0)
		rts	
; ===========================================================================

loc2_13066:
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc2_13078:
		add.w	d1,$12(a0)

locret2_1307C:
		rts	

; End of function Silver_Move

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_MoveLeft:		   ; XREF: Silver_Move
		move.w	$20(a0),d0
		beq.s	loc2_13086
		bpl.s	loc2_130B2
 
loc2_13086:
		bset	#0,$22(a0)
		bne.s	loc2_1309A
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc2_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc2_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc2_130A6
		move.w	d1,d0
 
loc2_130A6:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc2_130B2:				; XREF: Silver_MoveLeft
		sub.w	d4,d0
		bcc.s	loc2_130BA
		move.w	#-$80,d0

loc2_130BA:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret2_130E8
		cmpi.w	#$400,d0
		blt.s	locret2_130E8
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bclr	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret2_130E8:
		rts	
; End of function Silver_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_MoveRight:	   ; XREF: Silver_Move
		move.w	$20(a0),d0
		bmi.s	loc2_13118
		bclr	#0,$22(a0)
		beq.s	loc2_13104
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc2_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc2_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc2_1310C
		move.w	d6,d0
 
loc2_1310C:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc2_13118:				; XREF: Silver_MoveRight
		add.w	d4,d0
		bcc.s	loc2_13120
		move.w	#$80,d0

loc2_13120:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret2_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret2_1314E
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bset	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret2_1314E:
		rts	
; End of function Silver_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Silver's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_ChgJumpDir:		; XREF: Obj02_MdJump; Obj02_MdJump2
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		btst	#4,$22(a0)	
		bne.s	Obj02_ResetScr2	
		move.w	$10(a0),d0	
		btst	#7,$22(a0)
		bne.s	Silver_ChgJumpDir2
		btst	#2,($FFFFF602).w; is left being pressed?
		bra.s	Silver_ChgJumpDir3

Silver_ChgJumpDir2:		
		btst	#2,($FFFFF670).w; is left being pressed?

Silver_ChgJumpDir3:	
		beq.s	loc2_13278; if not, branch	
		bset	#0,$22(a0)	
		sub.w	d5,d0	
		move.w	d6,d1	
		neg.w	d1	
		cmp.w	d1,d0	
		bgt.s	loc2_13278	
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc2_13278	; +++ if speed was already greater than the maximum, branch	
		move.w	d1,d0
 
loc2_13278:
		btst	#7,$22(a0)
		bne.s	loc2_1327A
		btst	#3,($FFFFF602).w; is left being pressed?
		bra.s	loc2_1327C

loc2_1327A:		
		btst	#3,($FFFFF670).w; is left being pressed?

loc2_1327C:	
		beq.s	Obj02_JumpMove; if not, branch	
		bclr	#0,$22(a0)	
		add.w	d5,d0	
		cmp.w	d6,d0	
		blt.s	Obj02_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	Obj02_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

Obj02_JumpMove:
		move.w	d0,$10(a0)	; change Silver's horizontal speed

Obj02_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc2_132A4	; if yes, branch
		bcc.s	loc2_132A0
		addq.w	#4,($FFFFF73E).w

loc2_132A0:
		subq.w	#2,($FFFFF73E).w

loc2_132A4:
		cmpi.w	#-$400,$12(a0)	; is Silver moving faster than -$400 upwards?
		bcs.s	locret2_132D2	; if yes, branch
		move.w	$10(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret2_132D2
		bmi.s	loc2_132C6
		sub.w	d1,d0
		bcc.s	loc2_132C0
		move.w	#0,d0

loc2_132C0:
		move.w	d0,$10(a0)
		rts	
; ===========================================================================

loc2_132C6:
		sub.w	d1,d0
		bcs.s	loc2_132CE
		move.w	#0,d0

loc2_132CE:
		move.w	d0,$10(a0)

locret2_132D2:
		rts	
; End of function Silver_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Silver leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_LevelBound:			; XREF: Obj02_MdNormal; et al
		move.l	8(a0),d1
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Silver touched the	side boundary?
		bhi.s	Boundary_Sides2	; if yes, branch
		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		tst.b	($FFFFF7AA).w
		bne.s	loc2_13332
		addi.w	#$40,d0

loc2_13332:
		cmp.w	d1,d0		; has Silver touched the	side boundary?
		bls.s	Boundary_Sides2	; if yes, branch

loc2_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has Silver touched the	bottom boundary?
		blt.s	Boundary_Bottom2	; if yes, branch
		rts	
; ===========================================================================

Boundary_Bottom2:
		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1			; screen still scrolling down?
		blt.s	Boundary_Bottom2_locret	; if so, don't kill Sonic
		jmp 	KillSonic

Boundary_Bottom2_locret:
		rts

KillSilverBranch:
		jmp 	KillSonic
; ===========================================================================

Boundary_Sides2:
		move.w	d0,8(a0)
		move.w	#0,$A(a0)
		move.w	#0,$10(a0)	; stop Silver moving
		move.w	#0,$20(a0)
		bra.s	loc2_13336
; End of function Silver_LevelBound

; ---------------------------------------------------------------------------
; Subroutine to make Silver levitate
; ---------------------------------------------------------------------------

Silver_Levitate:
		tst.b	$2F(a0)		; was jumpdash flag set?
		bne.w	JD_Hold			; if yes, branch
		btst	#7,$22(a0)
		bne.s	Silver_Levitate2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Silver_Levitate3

Silver_Levitate2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Silver_Levitate3:	
		andi.b	#$30,d0			; is ABC pressed? (part 2)
		beq.w	LV_End			; if not, branch
		move.b	#1,$2F(a0)
		bclr	#4,$22(a0)		; clear double jump flag
		move.l	a0,-(sp)
		move.l	a1,-(sp)
		lea	Pal_SilverGlow.l,a0		; load this palette
		lea	($FFFFFB00).l,a1		; set as line 2
		move.w	#3,d0

	@Loop:
		move.l	(a0)+,(a1)+			; copy colours to buffer
		move.l	(a0)+,(a1)+			; ''
		dbf	d0,@Loop		; repeat until done
		move.l	(sp)+,a1
		move.l	(sp)+,a0
		rts	


JD_Hold:
		btst	#7,$22(a0)
		bne.s	JD_Hold2
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	JD_Hold3
JD_Hold2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

JD_Hold3:	
		andi.b	#$70,d0			; is ABC pressed? (part 2)
		beq.s	LV_Clear			; if not, branch
		sub.b	#1,$29(a0)
		bpl.s	LV_Clear
		clr.w	$12(a0)			; clear Sonic's Y-velocity to move sonic directly down
		move.b	#2,$1C(a0)		
		move.b	#$DA,d0			; set jumpdash sound
		jsr	PlaySound	; play jumpdash sound

LV_End:
		rts				; return

LV_Clear:
		move.b	#0,$2F(a0)
		move.b	#$C,$1C(a0)
		move.l	a0,-(sp)
		move.l	a1,-(sp)
		lea	Pal_SilverSon.l,a0		; load this palette
		tst.w	(Current_Character).w
		beq.s	LV_Clear2
		tst.w	(Current_Partner).w
		beq.s	LV_Clear2
		lea	Pal_SilverSha.l,a0		; load this palette
		cmpi.w	#1,(Current_Character).w
		beq.s	LV_Clear2
		cmpi.w	#1,(Current_Partner).w
		beq.s	LV_Clear2
		lea	Pal_Silver.l,a0		; load this palette

LV_Clear2:
		lea	($FFFFFB00).l,a1		; set as line 2
		move.w	#3,d0

	@Loop:
		move.l	(a0)+,(a1)+			; copy colours to buffer
		move.l	(a0)+,(a1)+			; ''
		dbf	d0,@Loop		; repeat until done
		move.l	(sp)+,a1
		move.l	(sp)+,a0
		rts	
; End of function Silver_Levitate

; ---------------------------------------------------------------------------
; Subroutine allowing Silver to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_Jump:				; XREF: Obj02_MdNormal; Obj02_MdRoll
		btst	#7,$22(a0)
		bne.s	Silver_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Silver_Jump3

Silver_Jump2:	
		move.b	($FFFFF671).w,d0

Silver_Jump3:	
		andi.b	#$30,d0		; is A,	B or C pressed?
		beq.w	locret2_1348E	; if not, branch
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		bsr.w	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret2_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc2_1341C
		move.w	#$380,d2

loc2_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Silver jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Silver jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$60,d0
		jsr	(PlaySound_Special).l ;	play jumping sound
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#$10,$1C(a0)	; use "jumping"	animation
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)

locret2_1348E:
		rts	
; End of function Silver_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_JumpHeight:			; XREF: Obj02_MdJump; Obj02_MdJump2
		tst.b	$3C(a0)
		beq.s	loc2_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc2_134AE
		move.w	#-$200,d1

loc2_134AE:
		cmp.w	$12(a0),d1
		ble.s	locret2_134C2
		btst	#7,$22(a0)
		bne.s	Silver_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Silver_JumpHeight3

Silver_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Silver_JumpHeight3:	
		andi.b	#$30,d0		; is A,	B or C pressed?
		bne.s	locret2_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret2_134C2:
		rts	
; ===========================================================================

loc2_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret2_134D2
		move.w	#-$FC0,$12(a0)

locret2_134D2:
		rts	
; End of function Sonic_JumpHeight

; ---------------------------------------------------------------------------
; Subroutine to	push Silver down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_SlopeRepel:			; XREF: Obj02_MdNormal; Obj02_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret2_13580
		tst.w	$3E(a0)
		bne.s	loc2_13582
		tst.w	$20(a0)
		bne.s	locret2_13580
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret2_13580
		move.w	$20(a0),d0
		bpl.s	loc2_1356A
		neg.w	d0

loc2_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret2_13580
		clr.w	$20(a0)
		bset	#1,$22(a0)
		move.w	#$1E,$3E(a0)

locret2_13580:
		rts	
; ===========================================================================

loc2_13582:
		subq.w	#1,$3E(a0)
		rts	
; End of function Silver_SlopeRepel

Silver_Sonar:
		tst.b	$39(a0)
		bne.s	Silver_SonarAni
		btst	#7,$22(a0)
		bne.s	Silver_Sonar2
		move.b	($FFFFF603).w,d0
		bra.s	Silver_Sonar3

Silver_Sonar2:	
		move.b	($FFFFF671).w,d0
		
Silver_Sonar3:	
		andi.b	#$40,d0
		beq.w	Silver_KAEnd
		move.b	#1,$39(a0)
		move.w	#$9F,d0
		jsr	(PlaySound_Special).l
		move.b	#4,($FFFFB1E4).w
		move.w	a0,($FFFFB1F0).w
		move.l	a0,-(sp)
		move.l	a1,-(sp)
		lea	Pal_SilverGlow.l,a0		; load this palette
		lea	($FFFFFB00).l,a1		; set as line 2
		move.w	#3,d0

	@Loop:
		move.l	(a0)+,(a1)+			; copy colours to buffer
		move.l	(a0)+,(a1)+			; ''
		dbf	d0,@Loop		; repeat until done
		move.l	(sp)+,a1
		move.l	(sp)+,a0

Silver_SonarAni:
		btst	#7,$22(a0)
		bne.s	Silver_SonarAni2
		btst	#6,($FFFFF602).w
		bra.s	Silver_SonarAni3

Silver_SonarAni2:	
		btst	#6,($FFFFF670).w

Silver_SonarAni3:	
		beq.s	Silver_SonarReset
		addq.l	#4,sp
		move.b	#9,$1C(a0)
		bsr.w	Sonic_LevelBound
		bsr.w	Sonic_AnglePos
		rts

Silver_SonarReset:
		move.b	#0,$39(a0)
		move.l	a0,-(sp)
		move.l	a1,-(sp)
		lea	Pal_SilverSon.l,a0		; load this palette
		tst.w	(Current_Character).w
		beq.s	Silver_SonarReset2
		tst.w	(Current_Partner).w
		beq.s	Silver_SonarReset2
		lea	Pal_SilverSha.l,a0		; load this palette
		cmpi.w	#1,(Current_Character).w
		beq.s	Silver_SonarReset2
		cmpi.w	#1,(Current_Partner).w
		beq.s	Silver_SonarReset2
		lea	Pal_Silver.l,a0		; load this palette

Silver_SonarReset2:
		lea	($FFFFFB00).l,a1		; set as line 2
		move.w	#3,d0

	@Loop:
		move.l	(a0)+,(a1)+			; copy colours to buffer
		move.l	(a0)+,(a1)+			; ''
		dbf	d0,@Loop		; repeat until done
		move.l	(sp)+,a1
		move.l	(sp)+,a0

Silver_KAEnd:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	return Silver's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_JumpAngle:			; XREF: Obj02_MdJump; Obj02_MdJump2
		move.b	$26(a0),d0	; get Silver's angle
		beq.s	locret2_135A2	; if already 0,	branch
		bpl.s	loc2_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc2_13596
		moveq	#0,d0

loc2_13596:
		bra.s	loc2_1359E
; ===========================================================================

loc2_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc2_1359E
		moveq	#0,d0

loc2_1359E:
		move.b	d0,$26(a0)

locret2_135A2:
		rts	
; End of function Silver_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Silver to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc2_13680
		cmpi.b	#$80,d0
		beq.w	loc2_136E2
		cmpi.b	#-$40,d0
		beq.w	loc2_1373E
		bsr.w	Silver_HitWall
		tst.w	d1
		bpl.s	loc2_135F0
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc2_135F0:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc2_13602
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc2_13602:
        move.b  $12(a0),d0       ; * get blocks per frame (D)
        andi.w  #$F0,d0         ; * ''
        move.w  d0,-(sp)        ; * save D to stack

loc2_13602_0:     
		exg d0,d2           ; * D as base Ypos
        add.w   $C(a0),d2      ; * add ypos
        move.w  8(a0),d3      ; * get xpos
        bsr.w   Silver_HitFloor2     ; * check
        tst.w   d1          ; * success?
        bmi.s   loc2_13602_1          ; * yes, branch
        subi.w  #$10,(sp)       ; * set D to previous $10 pixels
        move.w  (sp),d0         ; * get D to our scratch reg
        bpl.s   loc2_13602_0          ; * if we have any remain to check, branch
        addq.w  #2,sp           ; * if not (if there's definitely nothing to collide with)
        rts             ;   fix the stack and return

loc2_13602_1:     
		move.w  (sp),d0         ; * get D to our scratch reg
        addq.w  #2,sp           ; * fix the stack
        add.w   d0,d1           ; * add D to the "within-in-block" result (and fix final value)
        add.w   d1,$C(a0)      ; * add final value to ypos
    ;    move.b  d1,($FFFFFFEF).w
        tst.w   d0          ; * check D
        beq.s   loc2_1361E          ; * if zero (falling slow), branch
        andi.w  #$FFF0,$C(a0)      ; * just in case, align ypos
 
loc2_1361E:
        move.b  d3,$26(a0)
		move.b	#0,$1C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc2_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc2_1364E
		asr	$12(a0)
		bra.s	loc2_13670
; ===========================================================================

loc2_1364E:
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
        bra.w   Silver_ResetOnFloor
; ===========================================================================

loc2_1365C:
		move.w	#0,$10(a0)
		cmpi.w	#$FC0,$12(a0)
		ble.s	loc2_13670
		move.w	#$FC0,$12(a0)

loc2_13670:
        bsr.w   Silver_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret2_1367E
		neg.w	$20(a0)

locret2_1367E:
		rts	
; ===========================================================================

loc2_13680:
		bsr.w	Silver_HitWall
		tst.w	d1
		bpl.s	loc2_1369A
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc2_1369A:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc2_136B4
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret2_136B2
		move.w	#0,$12(a0)

locret2_136B2:
		rts	
; ===========================================================================

loc2_136B4:
		tst.w	$12(a0)
		bmi.s	locret2_136E0
		bsr.w	Silver_HitFloor
		tst.w	d1
		bpl.s	locret2_136E0
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#0,$1C(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Silver_ResetOnFloor

locret2_136E0:
		rts	
; ===========================================================================

loc2_136E2:
		bsr.w	Silver_HitWall
		tst.w	d1
		bpl.s	loc2_136F4
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc2_136F4:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc2_13706
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc2_13706:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret2_1373C
		sub.w	d1,$C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc2_13726
		move.w	#0,$12(a0)
		rts	
; ===========================================================================

loc2_13726:
		move.b	d3,$26(a0)
		bsr.w	Silver_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret2_1373C
		neg.w	$20(a0)

locret2_1373C:
		rts	
; ===========================================================================

loc2_1373E:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc2_13758
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc2_13758:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc2_13772
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret2_13770
		move.w	#0,$12(a0)

locret2_13770:
		rts	
; ===========================================================================

loc2_13772:
		tst.w	$12(a0)
		bmi.s	locret2_1379E
		bsr.w	Silver_HitFloor
		tst.w	d1
		bpl.s	locret2_1379E
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Silver_ResetOnFloor

locret2_1379E:
		rts	
; End of function Silver_Floor

; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when he	gets hurt
; ---------------------------------------------------------------------------

Obj02_Hurt:				; XREF: Obj02_Index
		clr.b	($FFFFFED0).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc2_1380C
		subi.w	#$20,$12(a0)

loc2_1380C:
		bsr.w	Silver_HurtStop
		bsr.w	Silver_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Silver_Animate
		bsr.w	LoadSilverDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Silver falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_HurtStop:				; XREF: Obj02_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	KillSilverBranch2
		bsr.w	Silver_Floor
		btst	#1,$22(a0)
		bne.s	locret2_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret2_13860:
		rts	
; End of function Silver_HurtStop

KillSilverBranch2:
		jmp 	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when he	dies
; ---------------------------------------------------------------------------

Obj02_Death:				; XREF: Obj02_Index
		clr.b	($FFFFFED0).w
		bsr.w	GameOver2
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Silver_Animate
		bsr.w	LoadSilverDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver2:				; XREF: Obj02_Death
		move.w	($FFFFF72E).w,d0
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcc.w	locret2_13900
		move.w	#-$38,$12(a0)
		addq.b	#2,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		addq.b	#1,($FFFFFE1C).w ; update lives	counter
		subq.b	#1,($FFFFFE12).w ; subtract 1 from number of lives
		bne.s	loc2_138D4
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load GAME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#1,($FFFFB0DA).w ; set OVER object to correct frame
		clr.b	($FFFFFE1A).w

loc2_138C2:
		move.w	#$1E,d0
		jsr	(PlaySound).l	; play game over music
		moveq	#3,d0
		jmp	(LoadPLC).l	; load game over patterns
; ===========================================================================

loc2_138D4:
		move.w	#60,$3A(a0)	; set time delay to 1 second
		tst.b	($FFFFFE1A).w	; is TIME OVER tag set?
		beq.s	locret2_13900	; if not, branch
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load TIME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		bra.s	loc2_138C2
; ===========================================================================

locret2_13900:
		rts	
; End of function GameOver2

; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when the level is restarted
; ---------------------------------------------------------------------------

Obj02_ResetLevel:			; XREF: Obj02_Index
		tst.w	$3A(a0)
		beq.s	locret2_13914
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	locret2_13914
		move.w	#1,($FFFFFE02).w ; restart the level

locret2_13914:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	animate	Silver's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Silver_Animate:				; XREF: Obj01_Control; et al
		lea	(SilverAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	SilAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

SilAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SilAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SilAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

SilAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	SilAnim_End_FF				; MJ: if so, branch to flag routines
 
SilAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

SilAnim_Delay:
		rts	
; ===========================================================================

SilAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SilAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	SilAnim_Next
; ===========================================================================

SilAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SilAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	SilAnim_Next
; ===========================================================================

SilAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SilAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

SilAnim_End:
		rts	
; ===========================================================================

SilAnim_WalkRun:				; XREF: SilAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SilAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SilAnim_Push	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Silver's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Silver mirrored horizontally?
		bne.s	loc2_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc2_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc2_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc2_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	SilAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Silver's speed
		bpl.s	loc2_13A9C
		neg.w	d2

loc2_13A9C:
		lea	(SilAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0

loc2_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc2_13AC2
		moveq	#0,d2

loc2_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	SilAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	
; ===========================================================================			

SilAnim_Push:				; XREF: SilAnim_RollJump
		move.w	$20(a0),d2	; get Silver's speed
		bmi.s	loc2_13B1E
		neg.w	d2

loc2_13B1E:
		addi.w	#$800,d2
		bpl.s	loc2_13B26
		moveq	#0,d2

loc2_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(SilAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SilAnim_Do2
; End of function Silver_Animate

; ===========================================================================
; ---------------------------------------------------------------------------
; subroutine to	change Silver's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Silver_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		btst	#3,$22(a0)
		beq.s	loc2_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc2_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	$26(a0),d0
		addi.b	#$20,d0
		bpl.s	loc2_14624
		move.b	$26(a0),d0
		bpl.s	loc2_1461E
		subq.b	#1,d0

loc2_1461E:
		addi.b	#$20,d0
		bra.s	loc2_14630
; ===========================================================================

loc2_14624:
		move.b	$26(a0),d0
		bpl.s	loc2_1462C
		addq.b	#1,d0

loc2_1462C:
		addi.b	#$1F,d0

loc2_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Silver_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Silver_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Silver_WalkVertR
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Silver_Angle
		tst.w	d1
		beq.s	locret2_146BE
		bpl.s	loc2_146C0
		cmpi.w	#-$E,d1
		blt.s	locret2_146E6
		add.w	d1,$C(a0)

locret2_146BE:
		rts	
; ===========================================================================

loc2_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc2_146CC

loc2_146C6:
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc2_146CC:
		tst.b	$38(a0)
		bne.s	loc2_146C6
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; ===========================================================================

locret2_146E6:
		rts	
; End of function Silver_AnglePos

; ===========================================================================
		move.l	8(a0),d2
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.l	d2,8(a0)
		move.w	#$38,d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
; ===========================================================================

locret2_1470A:
		rts	
; ===========================================================================
		move.l	$C(a0),d3
		move.w	$12(a0),d0
		subi.w	#$38,d0
		move.w	d0,$12(a0)
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
		rts	
; ===========================================================================
		move.l	8(a0),d2
		move.l	$C(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d2,8(a0)
		move.l	d3,$C(a0)
		rts	

; ---------------------------------------------------------------------------
; subroutine to	change Silver's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_Angle:				; XREF: Silver_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc2_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc2_1475E:
		btst	#0,d2
		bne.s	loc2_1476A
		move.b	d2,$26(a0)
		rts	
; ===========================================================================

loc2_1476A:
		move.b	$26(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,$26(a0)
		rts	
; End of function Silver_Angle

; ---------------------------------------------------------------------------
; subroutine allowing Silver to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_WalkVertR:			; XREF: Silver_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Silver_Angle
		tst.w	d1
		beq.s	locret2_147F0
		bpl.s	loc2_147F2
		cmpi.w	#-$E,d1
		blt.w	locret2_1470A
		add.w	d1,8(a0)

locret2_147F0:
		rts	
; ===========================================================================

loc2_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc2_147FE

loc2_147F8:
		add.w	d1,8(a0)
		rts	
; ===========================================================================

loc2_147FE:
		tst.b	$38(a0)
		bne.s	loc2_147F8
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Silver_WalkVertR

; ---------------------------------------------------------------------------
; subroutine allowing Silver to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_WalkCeiling:			; XREF: Silver_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Silver_Angle
		tst.w	d1
		beq.s	locret2_14892
		bpl.s	loc2_14894
		cmpi.w	#-$E,d1
		blt.w	locret2_146E6
		sub.w	d1,$C(a0)

locret2_14892:
		rts	
; ===========================================================================

loc2_14894:
		cmpi.w	#$E,d1
		bgt.s	loc2_148A0

loc2_1489A:
		sub.w	d1,$C(a0)
		rts	
; ===========================================================================

loc2_148A0:
		tst.b	$38(a0)
		bne.s	loc2_1489A
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Silver_WalkCeiling

; ---------------------------------------------------------------------------
; subroutine allowing Silver to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_WalkVertL:
		move.w	$C(a0),d2				; MJ: Load Y position
		move.w	8(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	$17(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	$16(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Silver_Angle
		tst.w	d1
		beq.s	locret2_14934
		bpl.s	loc2_14936
		cmpi.w	#-$E,d1
		blt.w	locret2_1470A
		sub.w	d1,8(a0)

locret2_14934:
		rts

; ===========================================================================

loc2_14936:
		cmpi.w	#$E,d1
		bgt.s	loc2_14942

loc2_1493C:
		sub.w	d1,8(a0)
		rts	

; ===========================================================================

loc2_14942:
		tst.b	$38(a0)
		bne.s	loc2_1493C
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Silver_WalkVertL

; ---------------------------------------------------------------------------
; subroutine to	make Silver land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_HitFloor:				; XREF: Silver_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

Silver_HitFloor2:
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc2_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc2_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc2_14DDE:
		btst	#0,d3
		beq.s	locret2_14DE6
		move.b	d2,d3

locret2_14DE6:
		rts	

; End of function Silver_HitFloor

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc2_14DF0:				; XREF: Silver_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc2_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret2_14E16
		move.b	d2,d3

locret2_14E16:
		rts	

; ---------------------------------------------------------------------------
; subroutine to	stop Silver when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_HitWall:				; XREF: Silver_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc2_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc2_14E0A
; End of function Silver_HitWall

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 92 - Silver's Sonar
; ---------------------------------------------------------------------------

Obj92:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj92_Index(pc,d0.w),d1
		jmp	Obj92_Index(pc,d1.w)
; ===========================================================================
Obj92_Index:	dc.w Obj92_Init-Obj92_Index
		dc.w Obj92_Display-Obj92_Index
		dc.w Obj92_SetPosition-Obj92_Index
		dc.w Obj92_Move-Obj92_Index
; ===========================================================================
Obj92_Init:
		addq.b	#2,$24(a0)
		move.l	#Map_Dust,4(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		move.b	#$20,$16(a0)
		move.b	#8,$17(a0)
		move.w	#$249C,2(a0)
		move.w	#$9380,$3C(a0)

; ===========================================================================
Obj92_Display:
		lea	(Ani_Obj92).l,a1
		jsr	AnimateSprite
		jsr Obj05_LoadArt
		jmp	DisplaySprite

; ===========================================================================
Obj92_SetPosition:
		movea.w	$30(a0),a1 ; a2=character
		addq.b	#2,$24(a0)
		move.w	#0,$1A(a0)	; reset	animation
		move.b	#1,$1C(a0)
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.w	#$400,$10(a0)
		bclr	#0,$22(a0)
		btst	#0,$22(a1)
		beq.s	Obj92_Move
		neg.w	$10(a0)
		bset	#0,$22(a0)

Obj92_Move:
		jsr	SpeedToPos
		bsr.s	SonarTouchResponse
		bra.w	Obj92_Display

SonarTouchResponse:
		move.w	8(a0),d2	; load its x-axis value
		move.w	$C(a0),d3	; load its y-axis value
		subq.w	#8,d2
		moveq	#0,d5
		move.b	$16(a0),d5	; load its's height
		subq.b	#3,d5
		sub.w	d5,d3

STouch_NoDuck:
		move.w	#$10,d4
		add.w	d5,d5
		lea	($FFFFB800).w,a1 ; begin checking the object RAM
		move.w	#$5F,d6

STouch_Loop:
		tst.b	1(a1)
		bpl.s	STouch_NextObj
		move.b	$20(a1),d0	; load STouch response number
		bne.s	STouch_Height	; if STouch response is not 0, branch

STouch_NextObj:
		lea	$40(a1),a1	; next object RAM
		dbf	d6,STouch_Loop	; repeat $5F more times

		moveq	#0,d0
		rts	
; ===========================================================================
STouch_Sizes:	dc.b  $14, $14		; width, height
		dc.b   $C, $14
		dc.b  $14,  $C
		dc.b	4, $10
		dc.b   $C, $12
		dc.b  $10, $10
		dc.b	6,   6
		dc.b  $18,  $C
		dc.b   $C, $10
		dc.b  $10,  $C
		dc.b	8,   8
		dc.b  $14, $10
		dc.b  $14,   8
		dc.b   $E,  $E
		dc.b  $18, $18
		dc.b  $28, $10
		dc.b  $10, $18
		dc.b	8, $10
		dc.b  $20, $70
		dc.b  $40, $20
		dc.b  $80, $20
		dc.b  $20, $20
		dc.b	8,   8
		dc.b	4,   4
		dc.b  $20,   8
		dc.b   $C,  $C
		dc.b	8,   4
		dc.b  $18,   4
		dc.b  $28,   4
		dc.b	4,   8
		dc.b	4, $18
		dc.b	4, $28
		dc.b	4, $20
		dc.b  $18, $18
		dc.b   $C, $18
		dc.b  $48,   8
; ===========================================================================

STouch_Height:				; XREF: STouchResponse
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	STouch_Sizes-2(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	8(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc2_1AE98
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	STouch_Width
		bra.w	STouch_NextObj
; ===========================================================================

loc2_1AE98:
		cmp.w	d4,d0
		bhi.w	STouch_NextObj

STouch_Width:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	$C(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc2_1AEB6
		add.w	d1,d1
		add.w	d0,d1
		bcs.s	STouch_ChkValue
		bra.w	STouch_NextObj
; ===========================================================================

loc2_1AEB6:
		cmp.w	d5,d0
		bhi.w	STouch_NextObj

STouch_ChkValue:
		move.b	$20(a1),d1	; load STouch response number
		cmpi.b	#$CC,d1			; is it a yadrin?
		beq.w	STouch_Enemy				; if so, branch
		andi.b	#$C0,d1		; is STouch response $40	or higher?
		beq.w	STouch_Enemy	; if not, branch
		cmpi.b	#$C0,d1		; is STouch response $C0	or higher?
		beq.s	locret2_1AEF2	; if yes, branch
		tst.b	d1		; is STouch response $80-$BF ?
		bmi.s	locret2_1AEF2	; if yes, branch

; Touch	response is $40-$7F

		move.b	$20(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0		; is STouch response $46	?
		beq.s	STouch_Monitor	; if yes, branch
		cmpi.b	#$12,d0		; is STouch response $46	?
		beq.s	locret2_1AEF2	; if yes, branch
		addq.b	#2,$24(a1)	; advance the object's routine counter

locret2_1AEF2:
		rts	
; ===========================================================================

STouch_Monitor:
		bpl.s	loc2_1AF1E	; if not, branch
		move.w	$C(a0),d0
		subi.w	#$10,d0
		cmp.w	$C(a1),d0
		bcs.s	locret2_1AF2E
		move.w	#-$180,$12(a1)
		tst.b	$25(a1)
		bne.s	locret2_1AF2E
		addq.b	#4,$25(a1)	; advance the monitor's routine counter
		rts	
; ===========================================================================

loc2_1AF1E:
		addq.b	#2,$24(a1)	; advance the monitor's routine counter

locret2_1AF2E:
		rts	
; ===========================================================================

STouch_Enemy:				; XREF: STouch_ChkValue

loc2_1AF40:
		tst.b	$21(a1)
		beq.s	STouch_KillEnemy
		subq.b	#1,$21(a1)
		bne.s	locret2_1AF68
		bset	#7,$22(a1)

locret2_1AF68:
		rts	
; ===========================================================================

STouch_KillEnemy:
		bset	#7,$22(a1)
		moveq	#0,d0
		move.w	($FFFFF7D0).w,d0
		addq.w	#2,($FFFFF7D0).w ; add 2 to item bonus counter
		cmpi.w	#6,d0
		bcs.s	loc2_1AF82
		moveq	#6,d0

loc2_1AF82:
		move.w	d0,$3E(a1)
		move.w	SEnemy_Points(pc,d0.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 enemies been destroyed?
		bcs.s	loc2_1AF9C	; if not, branch
		move.w	#1000,d0	; fix bonus to 10000
		move.w	#$A,$3E(a1)

loc2_1AF9C:
		jsr	AddPoints
		move.b	#$27,0(a1)	; change object	to points
		move.b	#0,$24(a1)
		rts	

; ===========================================================================
SEnemy_Points:	dc.w 10, 20, 50, 100
; ===========================================================================

Ani_Obj92:
	include	"_anim\obj92.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8E - Shadow
; ---------------------------------------------------------------------------

obj8E:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	obj8E_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

obj8E_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	obj8E_Index(pc,d0.w),d1
		jmp	obj8E_Index(pc,d1.w)
; ===========================================================================
obj8E_Index:	dc.w obj8E_Main-obj8E_Index
		dc.w obj8E_Control-obj8E_Index
		dc.w obj8E_Hurt-obj8E_Index
		dc.w obj8E_Death-obj8E_Index
		dc.w obj8E_ResetLevel-obj8E_Index
; ===========================================================================

obj8E_Main:				; XREF: obj8E_Index
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Shadow,4(a0)
		btst	#7,$22(a0)
		bne.s	Obj8E_Sec
		move.w	#$780,2(a0)
		bra.s	Obj8E_Cont

Obj8E_Sec:
		move.w	#$7A0,2(a0)

Obj8E_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		btst	#7,$22(a0)
		bne.s	Obj8E_Control
		move.w	#$700,($FFFFF760).w ; Shadow's top speed
		move.w	#$B,($FFFFF762).w ; Shadow's acceleration
		move.w	#$40,($FFFFF764).w ; Shadow's deceleration
		move.b	#5,($FFFFB1C0).w

obj8E_Control:				; XREF: obj8E_Index
		btst	#7,$22(a0)
		bne.s	loc3_12C58
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc3_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc3_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Shadow	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc3_12C58:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc3_12C62	; if yes, branch
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control

loc3_12C62:
		bsr.w	CPU_Control
		bra.s	loc3_12C64

loc3_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc3_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc3_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne.s	loc3_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	obj8E_Modes(pc,d0.w),d1
		jsr	obj8E_Modes(pc,d1.w)

loc3_12C7E:
		bsr.s	Shadow_Display
		bsr.w	Main_RecordPos
		bsr.w	Shadow_Water
		btst	#7,$22(a0)
		bne.s	loc3_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc3_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc3_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc3_12C7E2

loc3_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc3_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc3_12C7E2
		add.w	#2,($FFFFF75E).w

loc3_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc3_12CA6
		tst.b	$1C(a0)
		bne.s	loc3_12CA6
		move.b	$1D(a0),$1C(a0)

loc3_12CA6:
		bsr.w	Shadow_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc3_12CB6
		jsr	TouchResponse

loc3_12CB6:
		bsr.w	LoadShadowDynPLC
		rts
; ===========================================================================
obj8E_Modes:	dc.w obj8E_MdNormal-obj8E_Modes
		dc.w obj8E_MdJump-obj8E_Modes
		dc.w obj8E_MdRoll-obj8E_Modes
		dc.w obj8E_MdJump2-obj8E_Modes

Shadow_Display:				; XREF: loc3_12C7E
		move.w	$30(a0),d0
		beq.s	obj8E_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj8E_Display
		lsr.w	#3,d0
		bcc.s	obj8E_ChkInvin

obj8E_Display:
		jsr	DisplaySprite

obj8E_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Shadow have invincibility?
		beq.w	obj8E_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	obj8E_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	obj8E_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	obj8E_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	obj8E_RmvInvin	; change to bcs.w
		moveq	#0,d0
		move.b	($FFFFF75D).w,d0
		jsr	(PlaySound).l	; play normal music

obj8E_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

obj8E_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Shadow have speed	shoes?
		beq.s	obj8E_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	obj8E_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	obj8E_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Shadow"s speed
		move.w	#$C,($FFFFF762).w ; restore Shadow"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Shadow"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		move.w	#$0,d0
		jmp	(SetTempo).l	; run music at normal speed
; ===========================================================================

obj8E_ExitChk:
		rts	

; ---------------------------------------------------------------------------
; Subroutine for Shadow when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_Water:				; XREF: loc3_12C7E
	;	cmpi.b	#1,($FFFFFE10).w ; is level TJZ?
	;	beq.s	obj8E_InWater	; if yes, branch
		tst.b	(Water_flag).w ; does level have water?
		bne.s	obj8E_InWater ; if yes, branch

locret3_12D80:
		rts	
; ===========================================================================
obj8E_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is Shadow above the water?
		bge.s	obj8E_OutWater	; if yes, branch
		bset	#6,$22(a0)
		bne.s	locret3_12D80
		bsr.w	ResumeMusic

obj8E_InWaterCont:
		asr	$10(a0)
		asr	$12(a0)
		asr	$12(a0)
		btst	#7,$22(a0)
		bne.s	obj8E_InWaterCont2
		move.b	#$A,($FFFFB340).w ; load bubbles object	from Shadow's mouth
		move.b	#$81,($FFFFB368).w
		move.w	#$300,($FFFFF760).w ; change Shadow's top speed
		move.w	#6,($FFFFF762).w ; change Shadow's acceleration
		move.w	#$40,($FFFFF764).w ; change Shadow's deceleration
		beq.s	locret3_12D80
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

obj8E_InWaterCont2:
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; ===========================================================================

obj8E_OutWater:
		bclr	#6,$22(a0)
		beq.s	locret3_12D80
		asl	$12(a0)
		btst	#7,$22(a0)
		bne.s	obj8E_OutWater2
		bsr.w	ResumeMusic
		move.w	#$600,($FFFFF760).w ; restore Shadow's speed
		move.w	#$C,($FFFFF762).w ; restore Shadow's acceleration
		move.w	#$80,($FFFFF764).w ; restore Shadow's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

obj8E_OutWater2:
		cmpi.w	#-$1000,$12(a0)
		bgt.s	loc3_12E0E
		move.w	#-$1000,$12(a0)	; set maximum speed on leaving water

loc3_12E0E:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; End of function Shadow_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Shadow
; ---------------------------------------------------------------------------

obj8E_MdNormal:				; XREF: obj8E_Modes
		bsr.w	Shadow_SpinDash
		bsr.w	Shadow_Jump
		bsr.w	Shadow_SlopeResist
		bsr.w	Shadow_Move
		bsr.w	Shadow_Roll
		bsr.w	Shadow_LevelBound
		jsr	SpeedToPos
		bsr.w	Shadow_AnglePos
		bsr.w	Shadow_SlopeRepel
		rts	
; ===========================================================================

obj8E_MdJump:				; XREF: obj8E_Modes
		clr.b	$39(a0)
		bsr.w	Shadow_JumpHeight
		bsr.w	Shadow_ChgJumpDir
		bsr.w	Shadow_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc3_12E5C
		subi.w	#$28,$12(a0)

loc3_12E5C:
		bsr.w	Shadow_JumpAngle
		bsr.w	Shadow_Floor
		rts	
; ===========================================================================

obj8E_MdRoll:				; XREF: obj8E_Modes
		bsr.w	Shadow_Jump
		bsr.w	Shadow_RollRepel
		bsr.w	Shadow_RollSpeed
		bsr.w	Shadow_LevelBound
		jsr	SpeedToPos
		bsr.w	Shadow_AnglePos
		bsr.w	Shadow_SlopeRepel
		rts	
; ===========================================================================

obj8E_MdJump2:				; XREF: obj8E_Modes
		clr.b	$39(a0)
		bsr.w	Shadow_JumpHeight
		bsr.w	Shadow_ChgJumpDir
		bsr.w	Shadow_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc3_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc3_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc3_12EA6
		move.w	$10(a0),d0		; move Shadow's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	obj8E_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

obj8E_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Shadow speed less than $250?
		blt.s	loc3_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move Shadow's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Shadow slightly in the water?
		bgt.s	loc3_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)		; jump out of water

loc3_12EA6:
		bsr.w	Shadow_JumpAngle
		bsr.w	Shadow_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	make Shadow walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
Shadow_MoveDone:
		rts

Shadow_Move:				; XREF: obj8E_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc3_12FEE
		tst.w	$3E(a0)
		bne.w	obj8E_ResetScr
		btst	#7,$22(a0)
		bne.s	Shadow_Move2
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj8E_NotLeft	; if not, branch
		bsr.w	Shadow_MoveLeft

Obj8E_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj8E_NotRight	; if not, branch
		bsr.w	Shadow_MoveRight
		bra.s	Obj8E_NotRight

Shadow_Move2:
		btst	#2,($FFFFF670).w ; is left being pressed?
		beq.s	Obj8E_NotLeft2	; if not, branch
		bsr.w	Shadow_MoveLeft

Obj8E_NotLeft2:
		btst	#3,($FFFFF670).w ; is right being pressed?
		beq.s	Obj8E_NotRight	; if not, branch
		bsr.w	Shadow_MoveRight

Obj8E_NotRight:
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Shadow on a	slope?
		bne.w	obj8E_ResetScr	; if yes, branch
		tst.w	$20(a0)		; is Shadow moving?
		bne.w	obj8E_ResetScr	; if yes, branch
		bclr	#5,$22(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		btst	#3,$22(a0)
		beq.s	Shadow_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	$22(a1)
		bmi.s	Shadow_LookUp
		moveq	#0,d1
		move.b	$14(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	8(a0),d1
		sub.w	8(a1),d1
		cmpi.w	#4,d1
		blt.s	Shadow_BalanceLeft
		cmp.w	d2,d1
		bge.s	Shadow_BalanceRight
		bra.s	Shadow_LookUp

Shadow_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Shadow_LookUp
		cmpi.b	#3,$36(a0)	;Mercury Constants
		beq.s	Shadow_BalanceRight
		cmpi.b	#3,$37(a0)	;Mercury Constants
		bne.s	Shadow_LookUp

Shadow_BalanceLeft:
		btst	#0,$22(a0)	; is Shadow facing left?	;Mercury Constants
		beq.s	Shadow_BalanceBackward	; if not, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	obj8E_ResetScr	; branch

Shadow_BalanceRight:
		btst	#0,$22(a0)	; is Shadow facing left?	;Mercury Constants
		bne.s	Shadow_BalanceBackward	; if so, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	obj8E_ResetScr	; branch

Shadow_BalanceBackward:
		move.b	#$F,$1C(a0) ; use backward balancing animation
		bra.w	obj8E_ResetScr
; ===========================================================================

Shadow_LookUp:
		btst	#7,$22(a0)
		bne.s	Shadow_LookUp2
		btst	#0,($FFFFF602).w ; is up being pressed?
		bra.s	Shadow_LookUp3

Shadow_LookUp2:
		btst	#0,($FFFFF670).w ; is up being pressed?

Shadow_LookUp3:
		beq.s	Shadow_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	obj8E_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc3_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc3_12FC2
; ===========================================================================
 
Shadow_Duck:
		btst	#7,$22(a0)
		bne.s	Shadow_Duck2
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	Shadow_Duck3

Shadow_Duck2:
		btst	#1,($FFFFF670).w ; is down being pressed?

Shadow_Duck3:
		beq.s	obj8E_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	obj8E_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc3_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc3_12FC2
; ===========================================================================
 
obj8E_ResetScr:
		move.b	#0,($FFFFC903).w
 
obj8E_ResetScr_Part2:
		btst	#7,$22(a0)
		bne.s	loc3_12FC4
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc3_12FC2	; if yes, branch
		bcc.s	loc3_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default
 
loc3_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc3_12FC2:
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc3_12FC23
		bra.s	loc3_12FC22

loc3_12FC23:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		bge.s	loc3_12FC22
		tst.w	($FFFFF75E).w ; is	screen in its default position?
		beq.s	loc3_12FC22	; if yes, branch
		bge.s	loc3_12FBE2
		addq.w	#4,($FFFFF75E).w ; move	screen back to default
 
loc3_12FBE2:
		subq.w	#2,($FFFFF75E).w ; move	screen back to default

loc3_12FC22:
		btst	#7,$22(a0)
		bne.s	loc3_12FC4
		move.b	($FFFFF602).w,d0
		bra.s	loc3_12FC6

loc3_12FC4:		
		move.b	($FFFFF670).w,d0

loc3_12FC6:
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc3_12FEE	; if yes, branch

obj8E_ResetScrCont:
		move.w	$20(a0),d0
		beq.s	loc3_12FEE
		bmi.s	loc3_12FE2
		sub.w	d5,d0
		bcc.s	loc3_12FDC
		move.w	#0,d0

loc3_12FDC:
		move.w	d0,$20(a0)
		bra.s	loc3_12FEE
; ===========================================================================

loc3_12FE2:
		add.w	d5,d0
		bcc.s	loc3_12FEA
		move.w	#0,d0

loc3_12FEA:
		move.w	d0,$20(a0)

loc3_12FEE:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)

loc3_1300C:
		move.b	$26(a0),d0
		addi.b	#$40,d0
		bmi.w	locret3_1307C
		move.b	#$40,d1
		tst.w	$20(a0)
		beq.s	locret3_1307C
		bmi.s	loc3_13024
		neg.w	d1

loc3_13024:
		move.b	$26(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Shadow_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret3_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc3_13078
		cmpi.b	#$40,d0
		beq.s	loc3_13066
		cmpi.b	#$80,d0
		beq.s	loc3_13060
		add.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc3_13060:
		sub.w	d1,$12(a0)
		rts	
; ===========================================================================

loc3_13066:
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc3_13078:
		add.w	d1,$12(a0)

locret3_1307C:
		rts	
; End of function Shadow_Move

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_MoveLeft:		   ; XREF: Shadow_Move
		move.w	$20(a0),d0
		beq.s	loc3_13086
		bpl.s	loc3_130B2
 
loc3_13086:
		bset	#0,$22(a0)
		bne.s	loc3_1309A
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc3_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc3_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc3_130A6
		move.w	d1,d0
 
loc3_130A6:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc3_130B2:				; XREF: Shadow_MoveLeft
		sub.w	d4,d0
		bcc.s	loc3_130BA
		move.w	#-$80,d0

loc3_130BA:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret3_130E8
		cmpi.w	#$400,d0
		blt.s	locret3_130E8
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bclr	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret3_130E8:
		rts	
; End of function Shadow_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_MoveRight:	   ; XREF: Shadow_Move
		move.w	$20(a0),d0
		bmi.s	loc3_13118
		bclr	#0,$22(a0)
		beq.s	loc3_13104
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc3_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc3_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc3_1310C
		move.w	d6,d0
 
loc3_1310C:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc3_13118:				; XREF: Shadow_MoveRight
		add.w	d4,d0
		bcc.s	loc3_13120
		move.w	#$80,d0

loc3_13120:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret3_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret3_1314E
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bset	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret3_1314E:
		rts	
; End of function Shadow_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Shadow's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_RollSpeed:			; XREF: obj8E_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc3_131CC
		tst.w	$3E(a0)
		bne.s	loc3_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc3_1317C	; if not, branch
		bsr.w	Shadow_RollLeft

loc3_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc3_13188	; if not, branch
		bsr.w	Shadow_RollRight

loc3_13188:
		move.w	$20(a0),d0
		beq.s	loc3_131AA
		bmi.s	loc3_1319E
		sub.w	d5,d0
		bcc.s	loc3_13198
		move.w	#0,d0

loc3_13198:
		move.w	d0,$20(a0)
		bra.s	loc3_131AA
; ===========================================================================

loc3_1319E:				; XREF: Shadow_RollSpeed
		add.w	d5,d0
		bcc.s	loc3_131A6
		move.w	#0,d0

loc3_131A6:
		move.w	d0,$20(a0)

loc3_131AA:
		tst.w	$20(a0)		; is Shadow moving?
		bne.s	loc3_131CC	; if yes, branch
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		subq.w	#5,$C(a0)

loc3_131CC:
		cmp.w	#$60,($FFFFF73E).w
		beq.s	@cont2
		bcc.s	@cont1
		addq.w	#4,($FFFFF73E).w
 
@cont1:
		subq.w	#2,($FFFFF73E).w
 
@cont2:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		muls.w	$20(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc3_131F0
		move.w	#$1000,d1

loc3_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc3_131FA
		move.w	#-$1000,d1

loc3_131FA:
		move.w	d1,$10(a0)
		bra.w	loc3_1300C
; End of function Shadow_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_RollLeft:				; XREF: Shadow_RollSpeed
		move.w	$20(a0),d0
		beq.s	loc3_1320A
		bpl.s	loc3_13218

loc3_1320A:
		bset	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc3_13218:
		sub.w	d4,d0
		bcc.s	loc3_13220
		move.w	#-$80,d0

loc3_13220:
		move.w	d0,$20(a0)
		rts	
; End of function Shadow_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_RollRight:			; XREF: Shadow_RollSpeed
		move.w	$20(a0),d0
		bmi.s	loc3_1323A
		bclr	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc3_1323A:
		add.w	d4,d0
		bcc.s	loc3_13242
		move.w	#$80,d0

loc3_13242:
		move.w	d0,$20(a0)
		rts	
; End of function Shadow_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Shadow's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_ChgJumpDir:		; XREF: obj8E_MdJump; obj8E_MdJump2\
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		btst	#4,$22(a0)	
		bne.s	obj8E_ResetScr2	
		move.w	$10(a0),d0	
		btst	#7,$22(a0)
		bne.s	Shadow_ChgJumpDir2
		btst	#2,($FFFFF602).w; is left being pressed?
		bra.s	Shadow_ChgJumpDir3

Shadow_ChgJumpDir2:		
		btst	#2,($FFFFF670).w; is left being pressed?

Shadow_ChgJumpDir3:	
		beq.s	loc3_13278; if not, branch	
		bset	#0,$22(a0)	
		sub.w	d5,d0	
		move.w	d6,d1	
		neg.w	d1	
		cmp.w	d1,d0	
		bgt.s	loc3_13278	
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc3_13278	; +++ if speed was already greater than the maximum, branch	
		move.w	d1,d0
 
loc3_13278:
		btst	#7,$22(a0)
		bne.s	loc3_1327A
		btst	#3,($FFFFF602).w; is left being pressed?
		bra.s	loc3_1327C

loc3_1327A:		
		btst	#3,($FFFFF670).w; is left being pressed?

loc3_1327C:	
		beq.s	obj8E_JumpMove; if not, branch	
		bclr	#0,$22(a0)	
		add.w	d5,d0	
		cmp.w	d6,d0	
		blt.s	obj8E_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	obj8E_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

obj8E_JumpMove:
		move.w	d0,$10(a0)	; change Shadow's horizontal speed

obj8E_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc3_132A4	; if yes, branch
		bcc.s	loc3_132A0
		addq.w	#4,($FFFFF73E).w

loc3_132A0:
		subq.w	#2,($FFFFF73E).w

loc3_132A4:
		cmpi.w	#-$400,$12(a0)	; is Shadow moving faster than -$400 upwards?
		bcs.s	locret3_132D2	; if yes, branch
		move.w	$10(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret3_132D2
		bmi.s	loc3_132C6
		sub.w	d1,d0
		bcc.s	loc3_132C0
		move.w	#0,d0

loc3_132C0:
		move.w	d0,$10(a0)
		rts	
; ===========================================================================

loc3_132C6:
		sub.w	d1,d0
		bcs.s	loc3_132CE
		move.w	#0,d0

loc3_132CE:
		move.w	d0,$10(a0)

locret3_132D2:
		rts	
; End of function Shadow_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Shadow leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_LevelBound:			; XREF: obj8E_MdNormal; et al
		move.l	8(a0),d1
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Shadow touched the	side boundary?
		bhi.s	Boundary_Sides3	; if yes, branch
		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		cmp.w	d1,d0		; has Shadow touched the	side boundary?
		bls.s	Boundary_Sides3	; if yes, branch

loc3_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has Shadow touched the	bottom boundary?
		blt.s	Boundary_Bottom3	; if yes, branch
		rts	
; ===========================================================================

Boundary_Bottom3:
		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1			; screen still scrolling down?
		blt.s	Boundary_Bottom3_locret	; if so, don't kill Shadow
		jmp 	KillSonic
 
Boundary_Bottom3_locret:
		rts
; ===========================================================================

Boundary_Sides3:
		move.w	d0,8(a0)
		move.w	#0,$A(a0)
		move.w	#0,$10(a0)	; stop Shadow moving
		move.w	#0,$20(a0)
		bra.s	loc3_13336
; End of function Shadow_LevelBound

; ---------------------------------------------------------------------------
; Subroutine allowing Shadow to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_Roll:				; XREF: obj8E_MdNormal\
		tst.b	($FFFFF7CA).w
		bne.s	obj8E_NoRoll
		move.w	$20(a0),d0
		bpl.s	loc3_13392
		neg.w	d0

loc3_13392:
		cmpi.w	#$80,d0		; is Shadow moving at $80 speed or faster?
		bcs.s	obj8E_NoRoll	; if not, branch
		btst	#7,$22(a0)
		bne.s	loc3_133922
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	obj8E_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	loc3_133923

loc3_133922:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	obj8E_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?

loc3_133923:	
		bne.s	obj8E_ChkRoll	; if yes, branch

obj8E_NoRoll:
		rts	
; ===========================================================================

obj8E_ChkRoll:
		btst	#2,$22(a0)	; is Shadow already rolling?
		beq.s	obj8E_DoRoll	; if not, branch
		move.w	#0,($FFFFB030).w
		rts	

; ===========================================================================

obj8E_DoRoll:
		bset	#2,$22(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		move.w	#1,($FFFFB030).w
		addq.w	#5,$C(a0)
		move.w	#$3C,d0
		jsr	(PlaySound_Special).l ;	play rolling sound
		tst.w	$20(a0)
		bne.s	locret3_133E8
		move.w	#$200,$20(a0)

locret3_133E8:
		rts	
; End of function Shadow_Roll

; ---------------------------------------------------------------------------
; Subroutine allowing Shadow to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_Jump:				; XREF: obj8E_MdNormal; obj8E_MdRoll
		btst	#7,$22(a0)
		bne.s	Shadow_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Shadow_Jump3

Shadow_Jump2:	
		move.b	($FFFFF671).w,d0

Shadow_Jump3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.w	locret3_1348E	; if not, branch
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		bsr.w	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret3_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc3_1341C
		move.w	#$380,d2

loc3_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Shadow jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Shadow jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$60,d0
		jsr	PlaySound ;	play jumping sound
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		btst	#2,$22(a0)
		bne.s	loc3_13490
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "jumping"	animation
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)

locret3_1348E:
		rts	
; ===========================================================================

loc3_13490:
		bset	#4,$22(a0)
		rts	
; End of function Shadow_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_JumpHeight:			; XREF: obj8E_MdJump; obj8E_MdJump2
		tst.b	$3C(a0)
		beq.s	loc3_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc3_134AE
		move.w	#-$200,d1

loc3_134AE:
		cmp.w	$12(a0),d1
		ble.s	locret3_134C2
		btst	#7,$22(a0)
		bne.s	Shadow_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Shadow_JumpHeight3

Shadow_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Shadow_JumpHeight3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret3_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret3_134C2:
		rts	
; ===========================================================================

loc3_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret3_134D2
		move.w	#-$FC0,$12(a0)

locret3_134D2:
		rts	
; End of function Shadow_JumpHeight

; ---------------------------------------------------------------------------
; Subroutine to make Shadow perform a spindash
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Shadow_SpinDash:
		tst.b	$39(a0)
		bne.s	loc3_1AC8E
		cmpi.b	#8,$1C(a0)
		bne.s	locret3_1AC8C
		btst	#7,$22(a0)
		bne.s	Shadow_SpinDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Shadow_SpinDash3

Shadow_SpinDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Shadow_SpinDash3:
		andi.b	#$70,d0
		beq.w	locret3_1AC8C
		move.b	#9,$1C(a0)
		move.w	#$AB,d0
		jsr	(PlaySound_Special).l
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		cmpi.b	#$C,$28(a0)
		btst	#7,$22(a0)
		bne.s	loc3_1AC84
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.
 
loc3_1AC84:
		bsr.w	Shadow_LevelBound
		bsr.w	Shadow_AnglePos
 
locret3_1AC8C:
		rts	
; ---------------------------------------------------------------------------
 
loc3_1AC8E:
		btst	#7,$22(a0)
		bne.s	loc3_1AC8E5
		btst	#0,$22(a0)
		bne.s	loc3_1AC8E4
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc3_1AC8E5
		add.w	#2,($FFFFF75E).w
		bra.s	loc3_1AC8E5

loc3_1AC8E4:
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc3_1AC8E5
		sub.w	#2,($FFFFF75E).w

loc3_1AC8E5:
		move.b	#9,$1C(a0)
		btst	#7,$22(a0)
		bne.s	loc3_1AC8E2
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	loc3_1AC8E3

loc3_1AC8E2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

loc3_1AC8E3:
		btst	#1,d0
		bne.w	loc3_1AD30
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		addq.w	#5,$C(a0)
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	Dash_Speeds2(pc,d0.w),$20(a0)
	;	move.b	$20(a0),d0
	;	subi.b	#$8,d0
	;	add.b	d0,d0
	;	andi.b	#$1F,d0
	;	neg.b	d0
	;	addi.b	#$20,d0
	;	move.b	d0,($FFFFFEB3).w
		btst	#0,$22(a0)
		beq.s	loc3_1ACF4
		neg.w	$20(a0)
 
loc3_1ACF4:
		bset	#2,$22(a0)
		btst	#7,$22(a0)
		bne.s	loc3_1ACF42
		move.b	#0,($FFFFB1DC).w	; clear Spin Dash dust animation.

loc3_1ACF42:
		move.w	#-$4A,d0
		jsr	(PlaySound_Special).l
		bra.s	loc3_1AD78
; ===========================================================================
Dash_Speeds2:	dc.w  $800		; 0
		dc.w  $880		; 1
		dc.w  $900		; 2
		dc.w  $980		; 3
		dc.w  $A00		; 4
		dc.w  $A80		; 5
		dc.w  $B00		; 6
		dc.w  $B80		; 7
		dc.w  $C00		; 8
; ===========================================================================
 
loc3_1AD30:				; If still charging the dash...
		tst.w	$3A(a0)
		beq.s	loc3_1AD48
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc3_1AD48
		move.w	#0,$3A(a0)
 
loc3_1AD48:
		btst	#7,$22(a0)
		bne.s	loc3_1AD482
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	loc3_1AD483

loc3_1AD482:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

loc3_1AD483:
		andi.b	#$70,d0	; 'p'
		beq.w	loc3_1AD78
		move.w	#$900,$1C(a0)
		move.w	#$AB,d0	; 'ร'
		jsr	(PlaySound_Special).l
		btst	#7,$22(a0)
		bne.s	loc3_1AD484
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.

loc3_1AD484:
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc3_1AD78
		move.w	#$800,$3A(a0)
 
loc3_1AD78:
		addq.l	#4,sp			; increase stack ptr
		cmpi.w	#$60,($FFFFF73E).w
		beq.s	loc3_1AD8C
		bcc.s	loc3_1AD88
		addq.w	#4,($FFFFF73E).w
 
loc3_1AD88:
		subq.w	#2,($FFFFF73E).w
 
loc3_1AD8C:
		bsr.w	Shadow_LevelBound
		bsr.w	Shadow_AnglePos
	;	move.w	#$60,($FFFFF73E).w	; reset looking up/down
		rts
; End of subroutine Shadow_SpinDash

; ---------------------------------------------------------------------------
; Subroutine to	slow Shadow walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_SlopeResist:			; XREF: obj8E_MdNormal
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bcc.s	locret3_13508
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		beq.s	locret3_13508
		bmi.s	loc3_13504
		tst.w	d0
		beq.s	locret3_13502
		add.w	d0,$20(a0)	; change Shadow's inertia

locret3_13502:
		rts	
; ===========================================================================

loc3_13504:
		add.w	d0,$20(a0)

locret3_13508:
		rts	
; End of function Shadow_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Shadow down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_RollRepel:			; XREF: obj8E_MdRoll
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret3_13544
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		bmi.s	loc3_1353A
		tst.w	d0
		bpl.s	loc3_13534
		asr.l	#2,d0

loc3_13534:
		add.w	d0,$20(a0)
		rts	
; ===========================================================================

loc3_1353A:
		tst.w	d0
		bmi.s	loc3_13540
		asr.l	#2,d0

loc3_13540:
		add.w	d0,$20(a0)

locret3_13544:
		rts	
; End of function Shadow_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Shadow down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_SlopeRepel:			; XREF: obj8E_MdNormal; obj8E_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret3_13580
		tst.w	$3E(a0)
		bne.s	loc3_13582
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret3_13580
		move.w	$20(a0),d0
		bpl.s	loc3_1356A
		neg.w	d0

loc3_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret3_13580
		clr.w	$20(a0)
		bset	#1,$22(a0)
		move.w	#$1E,$3E(a0)

locret3_13580:
		rts	
; ===========================================================================

loc3_13582:
		subq.w	#1,$3E(a0)
		rts	
; End of function Shadow_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Shadow's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_JumpAngle:			; XREF: obj8E_MdJump; obj8E_MdJump2
		move.b	$26(a0),d0	; get Shadow's angle
		beq.s	locret3_135A2	; if already 0,	branch
		bpl.s	loc3_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc3_13596
		moveq	#0,d0

loc3_13596:
		bra.s	loc3_1359E
; ===========================================================================

loc3_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc3_1359E
		moveq	#0,d0

loc3_1359E:
		move.b	d0,$26(a0)

locret3_135A2:
		rts	
; End of function Shadow_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Shadow to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc3_13680
		cmpi.b	#$80,d0
		beq.w	loc3_136E2
		cmpi.b	#-$40,d0
		beq.w	loc3_1373E
		bsr.w	Shadow_HitWall
		tst.w	d1
		bpl.s	loc3_135F0
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc3_135F0:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc3_13602
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc3_13602:
        move.b  $12(a0),d0       ; * get blocks per frame (D)
        andi.w  #$F0,d0         ; * ''
        move.w  d0,-(sp)        ; * save D to stack

loc3_13602_0:     
		exg d0,d2           ; * D as base Ypos
        add.w   $C(a0),d2      ; * add ypos
        move.w  8(a0),d3      ; * get xpos
        bsr.w   Shadow_HitFloor2     ; * check
        tst.w   d1          ; * success?
        bmi.s   loc3_13602_1          ; * yes, branch
        subi.w  #$10,(sp)       ; * set D to previous $10 pixels
        move.w  (sp),d0         ; * get D to our scratch reg
        bpl.s   loc3_13602_0          ; * if we have any remain to check, branch
        addq.w  #2,sp           ; * if not (if there's definitely nothing to collide with)
        rts             ;   fix the stack and return

loc3_13602_1:     
		move.w  (sp),d0         ; * get D to our scratch reg
        addq.w  #2,sp           ; * fix the stack
        add.w   d0,d1           ; * add D to the "within-in-block" result (and fix final value)
        add.w   d1,$C(a0)      ; * add final value to ypos
    ;    move.b  d1,($FFFFFFEF).w
        tst.w   d0          ; * check D
        beq.s   loc3_1361E          ; * if zero (falling slow), branch
        andi.w  #$FFF0,$C(a0)      ; * just in case, align ypos
 
loc3_1361E:
        move.b  d3,$26(a0)
		move.b	#0,$1C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc3_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc3_1364E
		asr	$12(a0)
		bra.s	loc3_13670
; ===========================================================================

loc3_1364E:
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
        bra.w   Shadow_ResetOnFloor
; ===========================================================================

loc3_1365C:
		move.w	#0,$10(a0)
		cmpi.w	#$FC0,$12(a0)
		ble.s	loc3_13670
		move.w	#$FC0,$12(a0)

loc3_13670:
        bsr.w   Shadow_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret3_1367E
		neg.w	$20(a0)

locret3_1367E:
		rts	
; ===========================================================================

loc3_13680:
		bsr.w	Shadow_HitWall
		tst.w	d1
		bpl.s	loc3_1369A
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc3_1369A:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc3_136B4
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret3_136B2
		move.w	#0,$12(a0)

locret3_136B2:
		rts	
; ===========================================================================

loc3_136B4:
		tst.w	$12(a0)
		bmi.s	locret3_136E0
		bsr.w	Shadow_HitFloor
		tst.w	d1
		bpl.s	locret3_136E0
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#0,$1C(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Shadow_ResetOnFloor

locret3_136E0:
		rts	
; ===========================================================================

loc3_136E2:
		bsr.w	Shadow_HitWall
		tst.w	d1
		bpl.s	loc3_136F4
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc3_136F4:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc3_13706
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc3_13706:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret3_1373C
		sub.w	d1,$C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc3_13726
		move.w	#0,$12(a0)
		rts	
; ===========================================================================

loc3_13726:
		move.b	d3,$26(a0)
		bsr.w	Shadow_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret3_1373C
		neg.w	$20(a0)

locret3_1373C:
		rts	
; ===========================================================================

loc3_1373E:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc3_13758
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc3_13758:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc3_13772
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret3_13770
		move.w	#0,$12(a0)

locret3_13770:
		rts	
; ===========================================================================

loc3_13772:
		tst.w	$12(a0)
		bmi.s	locret3_1379E
		bsr.w	Shadow_HitFloor
		tst.w	d1
		bpl.s	locret3_1379E
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Shadow_ResetOnFloor

locret3_1379E:
		rts	
; End of function Shadow_Floor

; ===========================================================================
; ---------------------------------------------------------------------------
; Shadow	when he	gets hurt
; ---------------------------------------------------------------------------

obj8E_Hurt:				; XREF: obj8E_Index
		clr.b	($FFFFFEB3).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc3_1380C
		subi.w	#$20,$12(a0)

loc3_1380C:
		bsr.w	Shadow_HurtStop
		bsr.w	Shadow_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Shadow_Animate
		bsr.w	LoadShadowDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Shadow falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_HurtStop:				; XREF: obj8E_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	JMP_KillShadow
		bsr.w	Shadow_Floor
		btst	#1,$22(a0)
		bne.s	locret3_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret3_13860:
		rts	
; End of function Shadow_HurtStop

JMP_KillShadow:
		jmp	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Shadow	when he	dies
; ---------------------------------------------------------------------------

obj8E_Death:				; XREF: obj8E_Index
		clr.b	($FFFFFEB3).w
		bsr.w	GameOver3
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Shadow_Animate
		bsr.w	LoadShadowDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver3:				; XREF: obj8E_Death
		move.w	($FFFFF72E).w,d0
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcc.w	locret3_13900
		move.w	#-$38,$12(a0)
		addq.b	#2,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		addq.b	#1,($FFFFFE1C).w ; update lives	counter
		subq.b	#1,($FFFFFE12).w ; subtract 1 from number of lives
		bne.s	loc3_138D4
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load GAME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#1,($FFFFB0DA).w ; set OVER object to correct frame
		clr.b	($FFFFFE1A).w

loc3_138C2:
		moveq	#$1E,d0
		jsr	(PlaySound).l	; play game over music
		moveq	#3,d0
		jmp	(LoadPLC).l	; load game over patterns
; ===========================================================================

loc3_138D4:
		move.w	#60,$3A(a0)	; set time delay to 1 second
		tst.b	($FFFFFE1A).w	; is TIME OVER tag set?
		beq.s	locret3_13900	; if not, branch
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load TIME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		bra.s	loc3_138C2
; ===========================================================================

locret3_13900:
		rts	
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Shadow	when the level is restarted
; ---------------------------------------------------------------------------

Obj8E_ResetLevel:			; XREF: obj8E_Index
		tst.w	$3A(a0)
		beq.s	locret3_13914
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	locret3_13914
		move.w	#1,($FFFFFE02).w ; restart the level

locret3_13914:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	animate	Shadow's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Shadow_Animate:				; XREF: obj8E_Control; et al
		lea	(ShadowAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	ShaAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

ShaAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	ShaAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	ShaAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

ShaAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	ShaAnim_End_FF				; MJ: if so, branch to flag routines
 
ShaAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

ShaAnim_Delay:
		rts	
; ===========================================================================

ShaAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	ShaAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	ShaAnim_Next
; ===========================================================================

ShaAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	ShaAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	ShaAnim_Next
; ===========================================================================

ShaAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	ShaAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

ShaAnim_End:
		rts	
; ===========================================================================

ShaAnim_WalkRun:				; XREF: ShaAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	ShaAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	ShaAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Shadow's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Shadow mirrored horizontally?
		bne.s	loc3_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc3_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc3_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc3_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	ShaAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Shadow's speed
		bpl.s	loc3_13A9C
		neg.w	d2

loc3_13A9C:
		lea	(ShaAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Shadow at running speed?
		bcc.s	loc3_13AB4	; if yes, branch
		lea	(ShaAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc3_13AC2
		moveq	#0,d2
		bra.s	loc3_13AC2

loc3_13AB4:
		add.b	d0,d0
        move.b  d0,d1
        lsr.b   #$1,d1
        add.b   d1,d0
        add.b   d0,d0
        move.b  d0,d3
        neg.w   d2
        addi.w  #$800,d2
        cmp.w	#$300,d2                              
        bge.s   loc3_13AC2
        move.w	#$300,d2

loc3_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	ShaAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

ShaAnim_RollJump:				; XREF: ShaAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	ShaAnim_Push	; if not, branch
		move.w	$20(a0),d2	; get Shadow's speed
		bpl.s	loc3_13ADE
		neg.w	d2

loc3_13ADE:
		lea	(ShaAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Shadow moving fast?
		bcc.s	loc3_13AF0	; if yes, branch
		lea	(ShaAni_Roll).l,a1 ; use slower	animation

loc3_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc3_13AFA
		moveq	#0,d2

loc3_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	ShaAnim_Do2
; ===========================================================================

ShaAnim_Push:				; XREF: ShaAnim_RollJump
		move.w	$20(a0),d2	; get Shadow's speed
		bmi.s	loc3_13B1E
		neg.w	d2

loc3_13B1E:
		addi.w	#$800,d2
		bpl.s	loc3_13B26
		moveq	#0,d2

loc3_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(ShaAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	ShaAnim_Do2
; End of function Shadow_Animate

; ===========================================================================
; ---------------------------------------------------------------------------
; subroutine to	change Shadow's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Shadow_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		btst	#3,$22(a0)
		beq.s	loc3_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc3_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	$26(a0),d0
		addi.b	#$20,d0
		bpl.s	loc3_14624
		move.b	$26(a0),d0
		bpl.s	loc3_1461E
		subq.b	#1,d0

loc3_1461E:
		addi.b	#$20,d0
		bra.s	loc3_14630
; ===========================================================================

loc3_14624:
		move.b	$26(a0),d0
		bpl.s	loc3_1462C
		addq.b	#1,d0

loc3_1462C:
		addi.b	#$1F,d0

loc3_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Shadow_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Shadow_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Shadow_WalkVertR
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Shadow_Angle
		tst.w	d1
		beq.s	locret3_146BE
		bpl.s	loc3_146C0
		cmpi.w	#-$E,d1
		blt.s	locret3_146E6
		add.w	d1,$C(a0)

locret3_146BE:
		rts	
; ===========================================================================

loc3_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc3_146CC

loc3_146C6:
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc3_146CC:
		tst.b	$38(a0)
		bne.s	loc3_146C6
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; ===========================================================================

locret3_146E6:
		rts	
; End of function Shadow_AnglePos

; ===========================================================================
		move.l	8(a0),d2
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.l	d2,8(a0)
		move.w	#$38,d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
; ===========================================================================

locret3_1470A:
		rts	
; ===========================================================================
		move.l	$C(a0),d3
		move.w	$12(a0),d0
		subi.w	#$38,d0
		move.w	d0,$12(a0)
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
		rts	
; ===========================================================================
		move.l	8(a0),d2
		move.l	$C(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d2,8(a0)
		move.l	d3,$C(a0)
		rts	

; ---------------------------------------------------------------------------
; subroutine to	change Shadow's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_Angle:				; XREF: Shadow_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc3_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc3_1475E:
		btst	#0,d2
		bne.s	loc3_1476A
		move.b	d2,$26(a0)
		rts	
; ===========================================================================

loc3_1476A:
		move.b	$26(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,$26(a0)
		rts	
; End of function Shadow_Angle

; ---------------------------------------------------------------------------
; subroutine allowing Shadow to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_WalkVertR:			; XREF: Shadow_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Shadow_Angle
		tst.w	d1
		beq.s	locret3_147F0
		bpl.s	loc3_147F2
		cmpi.w	#-$E,d1
		blt.w	locret3_1470A
		add.w	d1,8(a0)

locret3_147F0:
		rts	
; ===========================================================================

loc3_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc3_147FE

loc3_147F8:
		add.w	d1,8(a0)
		rts	
; ===========================================================================

loc3_147FE:
		tst.b	$38(a0)
		bne.s	loc3_147F8
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Shadow_WalkVertR

; ---------------------------------------------------------------------------
; subroutine allowing Shadow to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_WalkCeiling:			; XREF: Shadow_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Shadow_Angle
		tst.w	d1
		beq.s	locret3_14892
		bpl.s	loc3_14894
		cmpi.w	#-$E,d1
		blt.w	locret3_146E6
		sub.w	d1,$C(a0)

locret3_14892:
		rts	
; ===========================================================================

loc3_14894:
		cmpi.w	#$E,d1
		bgt.s	loc3_148A0

loc3_1489A:
		sub.w	d1,$C(a0)
		rts	
; ===========================================================================

loc3_148A0:
		tst.b	$38(a0)
		bne.s	loc3_1489A
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Shadow_WalkCeiling

; ---------------------------------------------------------------------------
; subroutine allowing Shadow to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_WalkVertL:
		move.w	$C(a0),d2				; MJ: Load Y position
		move.w	8(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	$17(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	$16(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Shadow_Angle
		tst.w	d1
		beq.s	locret3_14934
		bpl.s	loc3_14936
		cmpi.w	#-$E,d1
		blt.w	locret3_1470A
		sub.w	d1,8(a0)

locret3_14934:
		rts

; ===========================================================================

loc3_14936:
		cmpi.w	#$E,d1
		bgt.s	loc3_14942

loc3_1493C:
		sub.w	d1,8(a0)
		rts	

; ===========================================================================

loc3_14942:
		tst.b	$38(a0)
		bne.s	loc3_1493C
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Shadow_WalkVertL

; ---------------------------------------------------------------------------
; subroutine to	make Shadow land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_HitFloor:				; XREF: Shadow_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

Shadow_HitFloor2:
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc3_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc3_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc3_14DDE:
		btst	#0,d3
		beq.s	locret3_14DE6
		move.b	d2,d3

locret3_14DE6:
		rts	

; End of function Shadow_HitFloor

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc3_14DF0:				; XREF: Shadow_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc3_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret3_14E16
		move.b	d2,d3

locret3_14E16:
		rts	

; ---------------------------------------------------------------------------
; subroutine to	stop Shadow when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_HitWall:				; XREF: Shadow_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc3_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc3_14E0A
; End of function Shadow_HitWall

; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 95 - Tails
; ---------------------------------------------------------------------------

Obj95:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj95_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj95_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj95_Index(pc,d0.w),d1
		jmp	Obj95_Index(pc,d1.w)
; ===========================================================================
Obj95_Index:	dc.w Obj95_Main-Obj95_Index
		dc.w Obj95_Control-Obj95_Index
		dc.w Obj95_Hurt-Obj95_Index
		dc.w Obj95_Death-Obj95_Index
		dc.w Obj95_ResetLevel-Obj95_Index
; ===========================================================================

Obj95_Main:				; XREF: Obj95_Index
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		addq.b	#2,$24(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Tails,4(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_Sec
		move.w	#$780,2(a0)
		bra.s	Obj95_Cont

Obj95_Sec:
		move.w	#$7A0,2(a0)

Obj95_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$96,($FFFFB3C0).w ; load Obj05 (Tails' Tails)
		move.w	a0,($FFFFB3F2).w ; set its parent object to this
		btst	#7,$22(a0)
		bne.s	loc4_12C58
		move.w	#$700,($FFFFF760).w ; Tails's top speed
		move.w	#$B,($FFFFF762).w ; Tails's acceleration
		move.w	#$40,($FFFFF764).w ; Tails's deceleration
		move.b	#5,($FFFFB1C0).w

Obj95_Control:				; XREF: Obj95_Index
		btst	#7,$22(a0)
		bne.s	loc4_12C58
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc4_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc4_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Tails	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc4_12C58:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc4_12C62	; if yes, branch
		move.b	#0,$2F(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control

loc4_12C62:
		bsr.w	CPU_Control
		bra.s	loc4_12C64

loc4_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc4_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc4_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne.s	loc4_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj95_Modes(pc,d0.w),d1
		jsr	Obj95_Modes(pc,d1.w)

loc4_12C7E:
		bsr.s	Tails_Display
		bsr.w	Main_RecordPos
		bsr.w	Tails_Water
		btst	#7,$22(a0)
		bne.s	loc4_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc4_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc4_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc4_12C7E2

loc4_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc4_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc4_12C7E2
		add.w	#2,($FFFFF75E).w

loc4_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc4_12CA6
		tst.b	$1C(a0)
		bne.s	loc4_12CA6
		move.b	$1D(a0),$1C(a0)

loc4_12CA6:
		bsr.w	Tails_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc4_12CB6
		jsr	TouchResponse

loc4_12CB6:
		bsr.w	LoadTailsDynPLC
		rts
; ===========================================================================
Obj95_Modes:	dc.w Obj95_MdNormal-Obj95_Modes
		dc.w Obj95_MdJump-Obj95_Modes
		dc.w Obj95_MdRoll-Obj95_Modes
		dc.w Obj95_MdJump2-Obj95_Modes

Tails_Display:				; XREF: loc4_12C7E
		move.w	$30(a0),d0
		beq.s	Obj95_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_Display
		lsr.w	#3,d0
		bcc.s	Obj95_ChkInvin

Obj95_Display:
		jsr	DisplaySprite

Obj95_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Tails have invincibility?
		beq.w	Obj95_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj95_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj95_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj95_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj95_RmvInvin	; change to bcs.w
		moveq	#0,d0
		move.b	($FFFFF75D).w,d0
		jsr	(PlaySound).l	; play normal music

Obj95_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj95_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Tails have speed	shoes?
		beq.s	Obj95_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj95_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj95_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Tails"s speed
		move.w	#$C,($FFFFF762).w ; restore Tails"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Tails"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		move.w	#$0,d0
		jmp	(SetTempo).l	; run music at normal speed
; ===========================================================================

Obj95_ExitChk:
		rts	

; ---------------------------------------------------------------------------
; Subroutine for Tails when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Water:				; XREF: loc4_12C7E
	;	cmpi.b	#1,($FFFFFE10).w ; is level TJZ?
	;	beq.s	Obj95_InWater	; if yes, branch
		tst.b	(Water_flag).w ; does level have water?
		bne.s	Obj95_InWater ; if yes, branch

locret4_12D80:
		rts	
; ===========================================================================
Obj95_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is Tails above the water?
		bge.s	Obj95_OutWater	; if yes, branch
		bset	#6,$22(a0)
		bne.s	locret4_12D80
		bsr.w	ResumeMusic

Obj95_InWaterCont:
		asr	$10(a0)
		asr	$12(a0)
		asr	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_InWaterCont2
		move.b	#$A,($FFFFB340).w ; load bubbles object	from Tails's mouth
		move.b	#$81,($FFFFB368).w
		move.w	#$300,($FFFFF760).w ; change Tails's top speed
		move.w	#6,($FFFFF762).w ; change Tails's acceleration
		move.w	#$40,($FFFFF764).w ; change Tails's deceleration
		beq.s	locret4_12D80
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

Obj95_InWaterCont2:
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; ===========================================================================

Obj95_OutWater:
		bclr	#6,$22(a0)
		beq.s	locret4_12D80
		asl	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_OutWater2
		bsr.w	ResumeMusic
		move.w	#$600,($FFFFF760).w ; restore Tails's speed
		move.w	#$C,($FFFFF762).w ; restore Tails's acceleration
		move.w	#$80,($FFFFF764).w ; restore Tails's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.

Obj95_OutWater2:
		cmpi.w	#-$1000,$12(a0)
		bgt.s	loc4_12E0E
		move.w	#-$1000,$12(a0)	; set maximum speed on leaving water

loc4_12E0E:
		move.w	#$6C,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; End of function Tails_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Tails
; ---------------------------------------------------------------------------

Obj95_MdNormal:				; XREF: Obj95_Modes
		bsr.w	Tails_SpinDash
		bsr.w	Tails_Jump
		bsr.w	Tails_SlopeResist
		bsr.w	Tails_Move
		bsr.w	Tails_Roll
		bsr.w	Tails_LevelBound
		jsr	SpeedToPos
		bsr.w	Tails_AnglePos
		bsr.w	Tails_SlopeRepel
		rts	
; ===========================================================================

Obj95_MdJump:				; XREF: Obj95_Modes
		clr.b	$39(a0)
		tst.b	$2F(a0)
		bne.w	Tails_FlyingSwimming
		bsr.w	Tails_JumpHeight
		bsr.w	Tails_ChgJumpDir
		bsr.w	Tails_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc4_12E5C
		subi.w	#$28,$12(a0)

loc4_12E5C:
		bsr.w	Tails_JumpAngle
		bsr.w	Tails_Floor
		rts	
; ===========================================================================

Obj95_MdRoll:				; XREF: Obj95_Modes
		bsr.w	Tails_Jump
		bsr.w	Tails_RollRepel
		bsr.w	Tails_RollSpeed
		bsr.w	Tails_LevelBound
		jsr	SpeedToPos
		bsr.w	Tails_AnglePos
		bsr.w	Tails_SlopeRepel
		rts	
; ===========================================================================

Obj95_MdJump2:				; XREF: Obj95_Modes
		clr.b	$39(a0)
		bsr.w	Tails_JumpHeight
		bsr.w	Tails_ChgJumpDir
		bsr.w	Tails_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc4_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc4_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc4_12EA6
		move.w	$10(a0),d0		; move Tails's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj95_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj95_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Tails speed less than $250?
		blt.s	loc4_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move Tails's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Tails slightly in the water?
		bgt.s	loc4_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)		; jump out of water

loc4_12EA6:
		bsr.w	Tails_JumpAngle
		bsr.w	Tails_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	make Tails walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
Tails_MoveDone:
		rts

Tails_Move:				; XREF: Obj95_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc4_12FEE
		tst.w	$3E(a0)
		bne.w	Obj95_ResetScr
		btst	#7,$22(a0)
		bne.s	Tails_Move2
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj95_NotLeft	; if not, branch
		bsr.w	Tails_MoveLeft

Obj95_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj95_NotRight	; if not, branch
		bsr.w	Tails_MoveRight
		bra.s	Obj95_NotRight

Tails_Move2:
		btst	#2,($FFFFF670).w ; is left being pressed?
		beq.s	Obj95_NotLeft2	; if not, branch
		bsr.w	Tails_MoveLeft

Obj95_NotLeft2:
		btst	#3,($FFFFF670).w ; is right being pressed?
		beq.s	Obj95_NotRight	; if not, branch
		bsr.w	Tails_MoveRight

Obj95_NotRight:
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Tails on a	slope?
		bne.w	Obj95_ResetScr	; if yes, branch
		tst.w	$20(a0)		; is Tails moving?
		bne.w	Obj95_ResetScr	; if yes, branch
		bclr	#5,$22(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		btst	#3,$22(a0)
		beq.s	Tails_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	$22(a1)
		bmi.s	Tails_LookUp
		moveq	#0,d1
		move.b	$14(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	8(a0),d1
		sub.w	8(a1),d1
		cmpi.w	#4,d1
		blt.s	Tails_BalanceLeft
		cmp.w	d2,d1
		bge.s	Tails_BalanceRight
		bra.s	Tails_LookUp

Tails_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Tails_LookUp
		cmpi.b	#3,$36(a0)	;Mercury Constants
		beq.s	Tails_BalanceRight
		cmpi.b	#3,$37(a0)	;Mercury Constants
		bne.s	Tails_LookUp

Tails_BalanceLeft:
		btst	#0,$22(a0)	; is Tails facing left?	;Mercury Constants
		beq.s	Tails_BalanceBackward	; if not, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	Obj95_ResetScr	; branch

Tails_BalanceRight:
		btst	#0,$22(a0)	; is Tails facing left?	;Mercury Constants
		bne.s	Tails_BalanceBackward	; if so, balance backward
		move.b	#$E,$1C(a0) ; use forward balancing animation
		bra.w	Obj95_ResetScr	; branch

Tails_BalanceBackward:
		move.b	#$F,$1C(a0) ; use backward balancing animation
		bra.w	Obj95_ResetScr
; ===========================================================================

Tails_LookUp:
		btst	#7,$22(a0)
		bne.s	Tails_LookUp2
		btst	#0,($FFFFF602).w ; is up being pressed?
		bra.s	Tails_LookUp3

Tails_LookUp2:
		btst	#0,($FFFFF670).w ; is up being pressed?

Tails_LookUp3:
		beq.s	Tails_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	Obj95_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc4_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc4_12FC2
; ===========================================================================
 
Tails_Duck:
		btst	#7,$22(a0)
		bne.s	Tails_Duck2
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	Tails_Duck3

Tails_Duck2:
		btst	#1,($FFFFF670).w ; is down being pressed?

Tails_Duck3:
		beq.s	Obj95_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	Obj95_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc4_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc4_12FC2
; ===========================================================================
 
Obj95_ResetScr:
		move.b	#0,($FFFFC903).w
 
Obj95_ResetScr_Part2:
		btst	#7,$22(a0)
		bne.s	loc4_12FC4
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc4_12FC2	; if yes, branch
		bcc.s	loc4_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default
 
loc4_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc4_12FC2:
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc4_12FC23
		bra.s	loc4_12FC22

loc4_12FC23:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		bge.s	loc4_12FC22
		tst.w	($FFFFF75E).w ; is	screen in its default position?
		beq.s	loc4_12FC22	; if yes, branch
		bge.s	loc4_12FBE2
		addq.w	#4,($FFFFF75E).w ; move	screen back to default
 
loc4_12FBE2:
		subq.w	#2,($FFFFF75E).w ; move	screen back to default

loc4_12FC22:
		btst	#7,$22(a0)
		bne.s	loc4_12FC4
		move.b	($FFFFF602).w,d0
		bra.s	loc4_12FC6

loc4_12FC4:		
		move.b	($FFFFF670).w,d0

loc4_12FC6:
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc4_12FEE	; if yes, branch

Obj95_ResetScrCont:
		move.w	$20(a0),d0
		beq.s	loc4_12FEE
		bmi.s	loc4_12FE2
		sub.w	d5,d0
		bcc.s	loc4_12FDC
		move.w	#0,d0

loc4_12FDC:
		move.w	d0,$20(a0)
		bra.s	loc4_12FEE
; ===========================================================================

loc4_12FE2:
		add.w	d5,d0
		bcc.s	loc4_12FEA
		move.w	#0,d0

loc4_12FEA:
		move.w	d0,$20(a0)

loc4_12FEE:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)

loc4_1300C:
		move.b	$26(a0),d0
		addi.b	#$40,d0
		bmi.w	locret4_1307C
		move.b	#$40,d1
		tst.w	$20(a0)
		beq.s	locret4_1307C
		bmi.s	loc4_13024
		neg.w	d1

loc4_13024:
		move.b	$26(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Tails_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret4_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc4_13078
		cmpi.b	#$40,d0
		beq.s	loc4_13066
		cmpi.b	#$80,d0
		beq.s	loc4_13060
		add.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc4_13060:
		sub.w	d1,$12(a0)
		rts	
; ===========================================================================

loc4_13066:
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc4_13078:
		add.w	d1,$12(a0)

locret4_1307C:
		rts	
; End of function Tails_Move

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_MoveLeft:		   ; XREF: Tails_Move
		move.w	$20(a0),d0
		beq.s	loc4_13086
		bpl.s	loc4_130B2
 
loc4_13086:
		bset	#0,$22(a0)
		bne.s	loc4_1309A
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc4_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc4_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc4_130A6
		move.w	d1,d0
 
loc4_130A6:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc4_130B2:				; XREF: Tails_MoveLeft
		sub.w	d4,d0
		bcc.s	loc4_130BA
		move.w	#-$80,d0

loc4_130BA:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret4_130E8
		cmpi.w	#$400,d0
		blt.s	locret4_130E8
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bclr	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret4_130E8:
		rts	
; End of function Tails_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_MoveRight:	   ; XREF: Tails_Move
		move.w	$20(a0),d0
		bmi.s	loc4_13118
		bclr	#0,$22(a0)
		beq.s	loc4_13104
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc4_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc4_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc4_1310C
		move.w	d6,d0
 
loc4_1310C:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc4_13118:				; XREF: Tails_MoveRight
		add.w	d4,d0
		bcc.s	loc4_13120
		move.w	#$80,d0

loc4_13120:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret4_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret4_1314E
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bset	#0,$22(a0)
		move.w	#$36,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret4_1314E:
		rts	
; End of function Tails_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Tails's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_RollSpeed:			; XREF: Obj95_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc4_131CC
		tst.w	$3E(a0)
		bne.s	loc4_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc4_1317C	; if not, branch
		bsr.w	Tails_RollLeft

loc4_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc4_13188	; if not, branch
		bsr.w	Tails_RollRight

loc4_13188:
		move.w	$20(a0),d0
		beq.s	loc4_131AA
		bmi.s	loc4_1319E
		sub.w	d5,d0
		bcc.s	loc4_13198
		move.w	#0,d0

loc4_13198:
		move.w	d0,$20(a0)
		bra.s	loc4_131AA
; ===========================================================================

loc4_1319E:				; XREF: Tails_RollSpeed
		add.w	d5,d0
		bcc.s	loc4_131A6
		move.w	#0,d0

loc4_131A6:
		move.w	d0,$20(a0)

loc4_131AA:
		tst.w	$20(a0)		; is Tails moving?
		bne.s	loc4_131CC	; if yes, branch
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		subq.w	#5,$C(a0)

loc4_131CC:
		cmp.w	#$60,($FFFFF73E).w
		beq.s	@cont2
		bcc.s	@cont1
		addq.w	#4,($FFFFF73E).w
 
@cont1:
		subq.w	#2,($FFFFF73E).w
 
@cont2:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		muls.w	$20(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc4_131F0
		move.w	#$1000,d1

loc4_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc4_131FA
		move.w	#-$1000,d1

loc4_131FA:
		move.w	d1,$10(a0)
		bra.w	loc4_1300C
; End of function Tails_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_RollLeft:				; XREF: Tails_RollSpeed
		move.w	$20(a0),d0
		beq.s	loc4_1320A
		bpl.s	loc4_13218

loc4_1320A:
		bset	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc4_13218:
		sub.w	d4,d0
		bcc.s	loc4_13220
		move.w	#-$80,d0

loc4_13220:
		move.w	d0,$20(a0)
		rts	
; End of function Tails_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_RollRight:			; XREF: Tails_RollSpeed
		move.w	$20(a0),d0
		bmi.s	loc4_1323A
		bclr	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc4_1323A:
		add.w	d4,d0
		bcc.s	loc4_13242
		move.w	#$80,d0

loc4_13242:
		move.w	d0,$20(a0)
		rts	
; End of function Tails_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Tails's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_ChgJumpDir:		; XREF: Obj95_MdJump; Obj95_MdJump2\
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		btst	#4,$22(a0)	
		bne.s	Obj95_ResetScr2	
		move.w	$10(a0),d0	
		btst	#7,$22(a0)
		bne.s	Tails_ChgJumpDir2
		btst	#2,($FFFFF602).w; is left being pressed?
		bra.s	Tails_ChgJumpDir3

Tails_ChgJumpDir2:		
		btst	#2,($FFFFF670).w; is left being pressed?

Tails_ChgJumpDir3:	
		beq.s	loc4_13278; if not, branch	
		bset	#0,$22(a0)	
		sub.w	d5,d0	
		move.w	d6,d1	
		neg.w	d1	
		cmp.w	d1,d0	
		bgt.s	loc4_13278	
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc4_13278	; +++ if speed was already greater than the maximum, branch	
		move.w	d1,d0
 
loc4_13278:
		btst	#7,$22(a0)
		bne.s	loc4_1327A
		btst	#3,($FFFFF602).w; is left being pressed?
		bra.s	loc4_1327C

loc4_1327A:		
		btst	#3,($FFFFF670).w; is left being pressed?

loc4_1327C:	
		beq.s	Obj95_JumpMove; if not, branch	
		bclr	#0,$22(a0)	
		add.w	d5,d0	
		cmp.w	d6,d0	
		blt.s	Obj95_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	Obj95_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

Obj95_JumpMove:
		move.w	d0,$10(a0)	; change Tails's horizontal speed

Obj95_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc4_132A4	; if yes, branch
		bcc.s	loc4_132A0
		addq.w	#4,($FFFFF73E).w

loc4_132A0:
		subq.w	#2,($FFFFF73E).w

loc4_132A4:
		cmpi.w	#-$400,$12(a0)	; is Tails moving faster than -$400 upwards?
		bcs.s	locret4_132D2	; if yes, branch
		move.w	$10(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret4_132D2
		bmi.s	loc4_132C6
		sub.w	d1,d0
		bcc.s	loc4_132C0
		move.w	#0,d0

loc4_132C0:
		move.w	d0,$10(a0)
		rts	
; ===========================================================================

loc4_132C6:
		sub.w	d1,d0
		bcs.s	loc4_132CE
		move.w	#0,d0

loc4_132CE:
		move.w	d0,$10(a0)

locret4_132D2:
		rts	
; End of function Tails_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Tails leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_LevelBound:			; XREF: Obj95_MdNormal; et al
		move.l	8(a0),d1
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Tails touched the	side boundary?
		bhi.s	Boundary_Sides4	; if yes, branch
		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		cmp.w	d1,d0		; has Tails touched the	side boundary?
		bls.s	Boundary_Sides4	; if yes, branch

loc4_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has Tails touched the	bottom boundary?
		blt.s	Boundary_Bottom4	; if yes, branch
		rts	
; ===========================================================================

Boundary_Bottom4:
		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1			; screen still scrolling down?
		blt.s	Boundary_Bottom4_locret	; if so, don't kill Tails
		jmp 	KillSonic
 
Boundary_Bottom4_locret:
		rts
; ===========================================================================

Boundary_Sides4:
		move.w	d0,8(a0)
		move.w	#0,$A(a0)
		move.w	#0,$10(a0)	; stop Tails moving
		move.w	#0,$20(a0)
		bra.s	loc4_13336
; End of function Tails_LevelBound

; ---------------------------------------------------------------------------
; Subroutine allowing Tails to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Roll:				; XREF: Obj95_MdNormal\
		tst.b	($FFFFF7CA).w
		bne.s	Obj95_NoRoll
		move.w	$20(a0),d0
		bpl.s	loc4_13392
		neg.w	d0

loc4_13392:
		cmpi.w	#$80,d0		; is Tails moving at $80 speed or faster?
		bcs.s	Obj95_NoRoll	; if not, branch
		btst	#7,$22(a0)
		bne.s	loc4_133922
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj95_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?
		bra.s	loc4_133923

loc4_133922:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj95_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?

loc4_133923:	
		bne.s	Obj95_ChkRoll	; if yes, branch

Obj95_NoRoll:
		rts	
; ===========================================================================

Obj95_ChkRoll:
		btst	#2,$22(a0)	; is Tails already rolling?
		beq.s	Obj95_DoRoll	; if not, branch
		move.w	#0,($FFFFB030).w
		rts	

; ===========================================================================

Obj95_DoRoll:
		bset	#2,$22(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		move.w	#1,($FFFFB030).w
		addq.w	#5,$C(a0)
		move.w	#$3C,d0
		jsr	(PlaySound_Special).l ;	play rolling sound
		tst.w	$20(a0)
		bne.s	locret4_133E8
		move.w	#$200,$20(a0)

locret4_133E8:
		rts	
; End of function Tails_Roll

; ---------------------------------------------------------------------------
; Subroutine allowing Tails to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Jump:				; XREF: Obj95_MdNormal; Obj95_MdRoll
		btst	#7,$22(a0)
		bne.s	Tails_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Tails_Jump3

Tails_Jump2:	
		move.b	($FFFFF671).w,d0

Tails_Jump3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.w	locret4_1348E	; if not, branch
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		bsr.w	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret4_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc4_1341C
		move.w	#$380,d2

loc4_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Tails jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Tails jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$60,d0
		jsr	PlaySound ;	play jumping sound
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		btst	#2,$22(a0)
		bne.s	loc4_13490
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "jumping"	animation
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)

locret4_1348E:
		rts	
; ===========================================================================

loc4_13490:
		bset	#4,$22(a0)
		rts	
; End of function Tails_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_JumpHeight:			; XREF: Obj95_MdJump; Obj95_MdJump2
		tst.b	$3C(a0)
		beq.s	loc4_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc4_134AE
		move.w	#-$200,d1

loc4_134AE:
		cmp.w	$12(a0),d1
		ble.s	Tails_Test_For_FLight
		btst	#7,$22(a0)
		bne.s	Tails_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Tails_JumpHeight3

Tails_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Tails_JumpHeight3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret4_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret4_134C2:
		rts	
; ===========================================================================

loc4_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret4_134D2
		move.w	#-$FC0,$12(a0)

locret4_134D2:
		rts	
; End of function Tails_JumpHeight

Tails_Test_For_Flight:
		tst.b	$2F(a0)
		bne.w	locret_151A2
		move.b	($FFFFF603).w,d0
		andi.b	#$70,d0
		beq.w	locret_151A2
	;	cmpi.w	#2,(Player_mode).w
	;	bne.s	loc_15156
	;	tst.b	(Super_Tails_flag).w
	;	bne.s	loc_1515C
	;	cmpi.b	#7,(Super_emerald_count).w
	;	blo.s	loc_1515C
	;	cmpi.w	#$32,(Ring_count).w
	;	blo.s	loc_1515C
	;	tst.b	(Update_HUD_timer).w
	;	bne.s	Tails_Transform
	;	bra.s	loc_1515C
; ---------------------------------------------------------------------------

loc_15156:
	;	tst.w	($FFFFF672).w
	;	beq.s	locret_151A2

loc_1515C:
		btst	#2,$22(a0)
		beq.s	loc_1518C
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	$16(a0),d1
		sub.b	#$F,d1
		ext.w	d1
	;	tst.b	(Reverse_gravity_flag).w
	;	beq.s	loc_15188
	;	neg.w	d0

loc_15188:
		add.w	d1,$C(a0)

loc_1518C:
		bclr	#4,$22(a0)
		move.b	#1,$2F(a0)
		move.b	#-$10,$29(a0)
		bsr.w	Tails_Set_Flying_Animation

locret_151A2:
					; Tails_JumpHeight+52j	...
		rts

; ---------------------------------------------------------------------------
; Subroutine to make Tails perform a spindash
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Tails_SpinDash:
		tst.b	$39(a0)
		bne.s	loc4_1AC8E
		cmpi.b	#8,$1C(a0)
		bne.s	locret4_1AC8C
		btst	#7,$22(a0)
		bne.s	Tails_SpinDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Tails_SpinDash3

Tails_SpinDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Tails_SpinDash3:
		andi.b	#$70,d0
		beq.w	locret4_1AC8C
		move.b	#9,$1C(a0)
		move.w	#$AB,d0
		jsr	(PlaySound_Special).l
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		cmpi.b	#$C,$28(a0)
		btst	#7,$22(a0)
		bne.s	loc4_1AC84
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.
 
loc4_1AC84:
		bsr.w	Tails_LevelBound
		bsr.w	Tails_AnglePos
 
locret4_1AC8C:
		rts	
; ---------------------------------------------------------------------------
 
loc4_1AC8E:
		btst	#7,$22(a0)
		bne.s	loc4_1AC8E5
		btst	#0,$22(a0)
		bne.s	loc4_1AC8E4
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc4_1AC8E5
		add.w	#2,($FFFFF75E).w
		bra.s	loc4_1AC8E5

loc4_1AC8E4:
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc4_1AC8E5
		sub.w	#2,($FFFFF75E).w

loc4_1AC8E5:
		move.b	#9,$1C(a0)
		btst	#7,$22(a0)
		bne.s	loc4_1AC8E2
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	loc4_1AC8E3

loc4_1AC8E2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

loc4_1AC8E3:
		btst	#1,d0
		bne.w	loc4_1AD30
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		addq.w	#5,$C(a0)
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	Dash_Speeds3(pc,d0.w),$20(a0)
	;	move.b	$20(a0),d0
	;	subi.b	#$8,d0
	;	add.b	d0,d0
	;	andi.b	#$1F,d0
	;	neg.b	d0
	;	addi.b	#$20,d0
	;	move.b	d0,($FFFFFEB3).w
		btst	#0,$22(a0)
		beq.s	loc4_1ACF4
		neg.w	$20(a0)
 
loc4_1ACF4:
		bset	#2,$22(a0)
		btst	#7,$22(a0)
		bne.s	loc4_1ACF42
		move.b	#0,($FFFFB1DC).w	; clear Spin Dash dust animation.

loc4_1ACF42:
		move.w	#-$4A,d0
		jsr	(PlaySound_Special).l
		bra.s	loc4_1AD78
; ===========================================================================
Dash_Speeds3:	dc.w  $800		; 0
		dc.w  $880		; 1
		dc.w  $900		; 2
		dc.w  $980		; 3
		dc.w  $A00		; 4
		dc.w  $A80		; 5
		dc.w  $B00		; 6
		dc.w  $B80		; 7
		dc.w  $C00		; 8
; ===========================================================================
 
loc4_1AD30:				; If still charging the dash...
		tst.w	$3A(a0)
		beq.s	loc4_1AD48
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc4_1AD48
		move.w	#0,$3A(a0)
 
loc4_1AD48:
		btst	#7,$22(a0)
		bne.s	loc4_1AD482
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	loc4_1AD483

loc4_1AD482:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

loc4_1AD483:
		andi.b	#$70,d0	; 'p'
		beq.w	loc4_1AD78
		move.w	#$900,$1C(a0)
		move.w	#$AB,d0	; 'ร'
		jsr	(PlaySound_Special).l
		btst	#7,$22(a0)
		bne.s	loc4_1AD484
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.

loc4_1AD484:
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc4_1AD78
		move.w	#$800,$3A(a0)
 
loc4_1AD78:
		addq.l	#4,sp			; increase stack ptr
		cmpi.w	#$60,($FFFFF73E).w
		beq.s	loc4_1AD8C
		bcc.s	loc4_1AD88
		addq.w	#4,($FFFFF73E).w
 
loc4_1AD88:
		subq.w	#2,($FFFFF73E).w
 
loc4_1AD8C:
		bsr.w	Tails_LevelBound
		bsr.w	Tails_AnglePos
	;	move.w	#$60,($FFFFF73E).w	; reset looking up/down
		rts
; End of subroutine Tails_SpinDash

Tails_FlyingSwimming:
		bsr.w	Tails_Move_FlySwim
		bsr.w	Tails_ChgJumpDir
		bsr.w	Tails_LevelBound
		jsr	(ObjectFall2).l
		bsr.w	Tails_JumpAngle
		movem.l	a4-a6,-(sp)
		bsr.w	Tails_Floor
		movem.l	(sp)+,a4-a6
	;	tst.w	(Player_mode).w
	;	bne.s	locret_14820
	;	lea	(Flying_carrying_Sonic_flag).w,a2
	;	lea	(Player_1).w,a1
	;	move.w	(Ctrl_1).w,d0
	;	bsr.w	Tails_Carry_Sonic

locret_14820:
		rts

; =============== S U B R O U T I N E =======================================


Tails_Move_FlySwim:
		move.b	($FFFFFE05).w,d0
		andi.b	#1,d0
		beq.s	loc_14836
		tst.b	$29(a0)
		beq.s	loc_14836
		subq.b	#1,$29(a0)

loc_14836:
					; Tails_Move_FlySwim+Ej
		cmpi.b	#1,$2F(a0)
		beq.s	loc_14860
		cmpi.w	#-$100,$12(a0)
		blt.s	loc_14858
		subi.w	#$20,$12(a0)
		addq.b	#1,$2F(a0)
		cmpi.b	#$20,$2F(a0)
		bne.s	loc_1485E

loc_14858:
		move.b	#1,$2F(a0)

loc_1485E:
		bra.s	loc_14892
; ---------------------------------------------------------------------------

loc_14860:
		move.b	($FFFFF602).w,d0
		andi.b	#$70,d0
		beq.s	loc_1488C
		cmpi.w	#-$100,$12(a0)
		blt.s	loc_1488C
		tst.b	$29(a0)
		beq.s	loc_1488C
	;	btst	#6,$22(a0)
	;	beq.s	loc_14886
	;	tst.b	(Flying_carrying_Sonic_flag).w
	;	bne.s	loc_1488C

loc_14886:
		move.b	#2,$2F(a0)

loc_1488C:
					; Tails_Move_FlySwim+4Ej ...
		addi.w	#8,$12(a0)

loc_14892:
		move.w	($FFFFF72C).w,d0
		addi.w	#$10,d0
		cmp.w	$C(a0),d0
		blt.s	Tails_Set_Flying_Animation
		tst.w	$12(a0)
		bpl.s	Tails_Set_Flying_Animation
		move.w	#0,$12(a0)
; End of function Tails_Move_FlySwim


; =============== S U B R O U T I N E =======================================


Tails_Set_Flying_Animation:

		btst	#6,$22(a0)
		bne.s	loc_14914
		moveq	#$1E,d0
		tst.w	$12(a0)
		bpl.s	loc_148C4
		moveq	#$1D,d0

loc_148C4:
	;	tst.b	(Flying_carrying_Sonic_flag).w
	;	beq.s	loc_148CC
	;	addq.b	#2,d0

loc_148CC:
		tst.b	$29(a0)
		bne.s	loc_148F4
		moveq	#$21,d0
		move.b	d0,$1C(a0)
		tst.b	1(a0)
		bpl.s	locret_148F2
		move.b	($FFFFFE05).w,d0
		addq.b	#8,d0
		andi.b	#$F,d0
		bne.s	locret_148F2
		moveq	#-$45,d0
		jsr	(PlaySound_Special).l

locret_148F2:
					; Tails_Set_Flying_Animation+3Cj
		rts
; ---------------------------------------------------------------------------
loc_148F4:
					; Tails_Set_Flying_Animation+24j
		move.b	d0,$1C(a0)
		tst.b	1(a0)
		bpl.s	locret_14912
		move.b	($FFFFFE05).w,d0
		addq.b	#8,d0
		andi.b	#$F,d0
		bne.s	locret_14912
		moveq	#-$46,d0
		jsr	(PlaySound_Special).l

locret_14912:
					; Tails_Set_Flying_Animation+5Cj
		rts

loc_14914:
		moveq	#$25,d0
		tst.w	$12(a0)
		bpl.s	loc_1491E
		moveq	#$23,d0

loc_1491E:
	;	tst.b	(Flying_carrying_Sonic_flag).w
	;	beq.s	loc_14926
	;	moveq	#$24,d0

loc_14926:
		tst.b	$29(a0)
		bne.s	loc_1492E
		moveq	#$25,d0

loc_1492E:
		move.b	d0,$1C(a0)
		rts
; End of function Tails_Set_Flying_Animation

; ---------------------------------------------------------------------------
; Subroutine to	slow Tails walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_SlopeResist:			; XREF: Obj95_MdNormal
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bcc.s	locret4_13508
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		beq.s	locret4_13508
		bmi.s	loc4_13504
		tst.w	d0
		beq.s	locret4_13502
		add.w	d0,$20(a0)	; change Tails's inertia

locret4_13502:
		rts	
; ===========================================================================

loc4_13504:
		add.w	d0,$20(a0)

locret4_13508:
		rts	
; End of function Tails_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Tails down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_RollRepel:			; XREF: Obj95_MdRoll
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret4_13544
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		bmi.s	loc4_1353A
		tst.w	d0
		bpl.s	loc4_13534
		asr.l	#2,d0

loc4_13534:
		add.w	d0,$20(a0)
		rts	
; ===========================================================================

loc4_1353A:
		tst.w	d0
		bmi.s	loc4_13540
		asr.l	#2,d0

loc4_13540:
		add.w	d0,$20(a0)

locret4_13544:
		rts	
; End of function Tails_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Tails down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_SlopeRepel:			; XREF: Obj95_MdNormal; Obj95_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret4_13580
		tst.w	$3E(a0)
		bne.s	loc4_13582
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret4_13580
		move.w	$20(a0),d0
		bpl.s	loc4_1356A
		neg.w	d0

loc4_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret4_13580
		clr.w	$20(a0)
		bset	#1,$22(a0)
		move.w	#$1E,$3E(a0)

locret4_13580:
		rts	
; ===========================================================================

loc4_13582:
		subq.w	#1,$3E(a0)
		rts	
; End of function Tails_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Tails's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_JumpAngle:			; XREF: Obj95_MdJump; Obj95_MdJump2
		move.b	$26(a0),d0	; get Tails's angle
		beq.s	locret4_135A2	; if already 0,	branch
		bpl.s	loc4_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc4_13596
		moveq	#0,d0

loc4_13596:
		bra.s	loc4_1359E
; ===========================================================================

loc4_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc4_1359E
		moveq	#0,d0

loc4_1359E:
		move.b	d0,$26(a0)

locret4_135A2:
		rts	
; End of function Tails_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Tails to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc4_13680
		cmpi.b	#$80,d0
		beq.w	loc4_136E2
		cmpi.b	#-$40,d0
		beq.w	loc4_1373E
		bsr.w	Tails_HitWall
		tst.w	d1
		bpl.s	loc4_135F0
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc4_135F0:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc4_13602
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc4_13602:
        move.b  $12(a0),d0       ; * get blocks per frame (D)
        andi.w  #$F0,d0         ; * ''
        move.w  d0,-(sp)        ; * save D to stack

loc4_13602_0:     
		exg d0,d2           ; * D as base Ypos
        add.w   $C(a0),d2      ; * add ypos
        move.w  8(a0),d3      ; * get xpos
        bsr.w   Tails_HitFloor2     ; * check
        tst.w   d1          ; * success?
        bmi.s   loc4_13602_1          ; * yes, branch
        subi.w  #$10,(sp)       ; * set D to previous $10 pixels
        move.w  (sp),d0         ; * get D to our scratch reg
        bpl.s   loc4_13602_0          ; * if we have any remain to check, branch
        addq.w  #2,sp           ; * if not (if there's definitely nothing to collide with)
        rts             ;   fix the stack and return

loc4_13602_1:     
		move.w  (sp),d0         ; * get D to our scratch reg
        addq.w  #2,sp           ; * fix the stack
        add.w   d0,d1           ; * add D to the "within-in-block" result (and fix final value)
        add.w   d1,$C(a0)      ; * add final value to ypos
    ;    move.b  d1,($FFFFFFEF).w
        tst.w   d0          ; * check D
        beq.s   loc4_1361E          ; * if zero (falling slow), branch
        andi.w  #$FFF0,$C(a0)      ; * just in case, align ypos
 
loc4_1361E:
        move.b  d3,$26(a0)
		move.b	#0,$1C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc4_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc4_1364E
		asr	$12(a0)
		bra.s	loc4_13670
; ===========================================================================

loc4_1364E:
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
        bra.w   Tails_ResetOnFloor
; ===========================================================================

loc4_1365C:
		move.w	#0,$10(a0)
		cmpi.w	#$FC0,$12(a0)
		ble.s	loc4_13670
		move.w	#$FC0,$12(a0)

loc4_13670:
        bsr.w   Tails_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret4_1367E
		neg.w	$20(a0)

locret4_1367E:
		rts	
; ===========================================================================

loc4_13680:
		bsr.w	Tails_HitWall
		tst.w	d1
		bpl.s	loc4_1369A
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc4_1369A:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc4_136B4
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret4_136B2
		move.w	#0,$12(a0)

locret4_136B2:
		rts	
; ===========================================================================

loc4_136B4:
		tst.w	$12(a0)
		bmi.s	locret4_136E0
		bsr.w	Tails_HitFloor
		tst.w	d1
		bpl.s	locret4_136E0
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#0,$1C(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Tails_ResetOnFloor

locret4_136E0:
		rts	
; ===========================================================================

loc4_136E2:
		bsr.w	Tails_HitWall
		tst.w	d1
		bpl.s	loc4_136F4
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc4_136F4:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc4_13706
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc4_13706:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret4_1373C
		sub.w	d1,$C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc4_13726
		move.w	#0,$12(a0)
		rts	
; ===========================================================================

loc4_13726:
		move.b	d3,$26(a0)
		bsr.w	Tails_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret4_1373C
		neg.w	$20(a0)

locret4_1373C:
		rts	
; ===========================================================================

loc4_1373E:
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc4_13758
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc4_13758:
		bsr.w	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc4_13772
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret4_13770
		move.w	#0,$12(a0)

locret4_13770:
		rts	
; ===========================================================================

loc4_13772:
		tst.w	$12(a0)
		bmi.s	locret4_1379E
		bsr.w	Tails_HitFloor
		tst.w	d1
		bpl.s	locret4_1379E
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Tails_ResetOnFloor

locret4_1379E:
		rts	
; End of function Tails_Floor

; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when he	gets hurt
; ---------------------------------------------------------------------------

Obj95_Hurt:				; XREF: Obj95_Index
		clr.b	($FFFFFEB3).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc4_1380C
		subi.w	#$20,$12(a0)

loc4_1380C:
		bsr.w	Tails_HurtStop
		bsr.w	Tails_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Tails_Animate
		bsr.w	LoadTailsDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Tails falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_HurtStop:				; XREF: Obj95_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	JMP_KillTails
		bsr.w	Tails_Floor
		btst	#1,$22(a0)
		bne.s	locret4_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret4_13860:
		rts	
; End of function Tails_HurtStop

JMP_KillTails:
		jmp	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when he	dies
; ---------------------------------------------------------------------------

Obj95_Death:				; XREF: Obj95_Index
		clr.b	($FFFFFEB3).w
		bsr.w	GameOver4
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Tails_Animate
		bsr.w	LoadTailsDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver4:				; XREF: Obj95_Death
		move.w	($FFFFF72E).w,d0
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcc.w	locret4_13900
		move.w	#-$38,$12(a0)
		addq.b	#2,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		addq.b	#1,($FFFFFE1C).w ; update lives	counter
		subq.b	#1,($FFFFFE12).w ; subtract 1 from number of lives
		bne.s	loc4_138D4
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load GAME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#1,($FFFFB0DA).w ; set OVER object to correct frame
		clr.b	($FFFFFE1A).w

loc4_138C2:
		moveq	#$1E,d0
		jsr	(PlaySound).l	; play game over music
		moveq	#3,d0
		jmp	(LoadPLC).l	; load game over patterns
; ===========================================================================

loc4_138D4:
		move.w	#60,$3A(a0)	; set time delay to 1 second
		tst.b	($FFFFFE1A).w	; is TIME OVER tag set?
		beq.s	locret4_13900	; if not, branch
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w ; load TIME object
		move.b	#$39,($FFFFB0C0).w ; load OVER object
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		bra.s	loc4_138C2
; ===========================================================================

locret4_13900:
		rts	
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when the level is restarted
; ---------------------------------------------------------------------------

Obj95_ResetLevel:			; XREF: Obj95_Index
		tst.w	$3A(a0)
		beq.s	locret4_13914
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	locret4_13914
		move.w	#1,($FFFFFE02).w ; restart the level

locret4_13914:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	animate	Tails's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Tails_Animate:				; XREF: Obj95_Control; et al
		lea	(TailsAniData).l,a1

Tails_Animate_Part2:
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	TaiAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

TaiAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	TaiAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	TaiAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

TaiAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	TaiAnim_End_FF				; MJ: if so, branch to flag routines
 
TaiAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

TaiAnim_Delay:
		rts	
; ===========================================================================

TaiAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	TaiAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	TaiAnim_Next
; ===========================================================================

TaiAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	TaiAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	TaiAnim_Next
; ===========================================================================

TaiAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	TaiAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

TaiAnim_End:
		rts	
; ===========================================================================

TaiAnim_WalkRun:				; XREF: TaiAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	TaiAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	TaiAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Tails's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Tails mirrored horizontally?
		bne.s	loc4_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc4_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc4_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc4_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	TaiAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Tails's speed
		bpl.s	loc4_13A32
		neg.w	d2

loc4_13A32:
		lea	(TaiAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Tails at running speed?
		bcc.s	loc4_13AB4	; if yes, branch
		lea	(TaiAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0

loc4_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc4_13AC2
		moveq	#0,d2

loc4_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	TaiAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

TaiAnim_RollJump:				; XREF: TaiAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	TaiAnim_GetTailFrame	; if not, branch
		move.w	$20(a0),d2	; get Tails's speed
		bpl.s	loc4_13ADE
		neg.w	d2

loc4_13ADE:
		lea	(TaiAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Tails moving fast?
		bcc.s	loc4_13AF0	; if yes, branch
		lea	(TaiAni_Roll).l,a1 ; use slower	animation

loc4_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc4_13AFA
		moveq	#0,d2

loc4_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	TaiAnim_Do2
; ===========================================================================

TaiAnim_Push:				; XREF: TaiAnim_RollJump
		move.w	$20(a0),d2	; get Tails's speed
		bmi.s	loc4_13B1E
		neg.w	d2

loc4_13B1E:
		addi.w	#$800,d2
		bpl.s	loc4_13B26
		moveq	#0,d2

loc4_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(TaiAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	TaiAnim_Do2

TaiAnim_GetTailFrame:
		move.w	$10(a2),d1
		move.w	$12(a2),d2
		jsr	(CalcAngle).l
		moveq	#0,d1
		move.b	$22(a0),d2
		andi.b	#1,d2
		bne.s	loc4_1D002
		not.b	d0
		bra.s	loc4_1D006
; ===========================================================================

loc4_1D002:
	addi.b	#$80,d0

loc4_1D006:
	addi.b	#$10,d0
	bpl.s	loc4_1D008
	moveq	#3,d1

loc4_1D008:
	andi.b	#$FC,1(a0)
	eor.b	d1,d2
	or.b	d2,1(a0)
	lsr.b	#3,d0
	andi.b	#$C,d0
	move.b	d0,d3
	lea	(Obj96Ani_Directional).l,a1
	move.b	#3,$23(a0)
	bsr.w	TaiAnim_Do2
	add.b	d3,$1A(a0)
	rts
; End of function Tails_Animate

; ===========================================================================
; ---------------------------------------------------------------------------
; subroutine to	change Tails's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Tails_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		btst	#3,$22(a0)
		beq.s	loc4_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc4_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	$26(a0),d0
		addi.b	#$20,d0
		bpl.s	loc4_14624
		move.b	$26(a0),d0
		bpl.s	loc4_1461E
		subq.b	#1,d0

loc4_1461E:
		addi.b	#$20,d0
		bra.s	loc4_14630
; ===========================================================================

loc4_14624:
		move.b	$26(a0),d0
		bpl.s	loc4_1462C
		addq.b	#1,d0

loc4_1462C:
		addi.b	#$1F,d0

loc4_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Tails_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Tails_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Tails_WalkVertR
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Tails_Angle
		tst.w	d1
		beq.s	locret4_146BE
		bpl.s	loc4_146C0
		cmpi.w	#-$E,d1
		blt.s	locret4_146E6
		add.w	d1,$C(a0)

locret4_146BE:
		rts	
; ===========================================================================

loc4_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc4_146CC

loc4_146C6:
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc4_146CC:
		tst.b	$38(a0)
		bne.s	loc4_146C6
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; ===========================================================================

locret4_146E6:
		rts	
; End of function Tails_AnglePos

; ===========================================================================
		move.l	8(a0),d2
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.l	d2,8(a0)
		move.w	#$38,d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
; ===========================================================================

locret4_1470A:
		rts	
; ===========================================================================
		move.l	$C(a0),d3
		move.w	$12(a0),d0
		subi.w	#$38,d0
		move.w	d0,$12(a0)
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
		rts	
; ===========================================================================
		move.l	8(a0),d2
		move.l	$C(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d2,8(a0)
		move.l	d3,$C(a0)
		rts	

; ---------------------------------------------------------------------------
; subroutine to	change Tails's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Angle:				; XREF: Tails_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc4_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc4_1475E:
		btst	#0,d2
		bne.s	loc4_1476A
		move.b	d2,$26(a0)
		rts	
; ===========================================================================

loc4_1476A:
		move.b	$26(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,$26(a0)
		rts	
; End of function Tails_Angle

; ---------------------------------------------------------------------------
; subroutine allowing Tails to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_WalkVertR:			; XREF: Tails_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Tails_Angle
		tst.w	d1
		beq.s	locret4_147F0
		bpl.s	loc4_147F2
		cmpi.w	#-$E,d1
		blt.w	locret4_1470A
		add.w	d1,8(a0)

locret4_147F0:
		rts	
; ===========================================================================

loc4_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc4_147FE

loc4_147F8:
		add.w	d1,8(a0)
		rts	
; ===========================================================================

loc4_147FE:
		tst.b	$38(a0)
		bne.s	loc4_147F8
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Tails_WalkVertR

; ---------------------------------------------------------------------------
; subroutine allowing Tails to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_WalkCeiling:			; XREF: Tails_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Tails_Angle
		tst.w	d1
		beq.s	locret4_14892
		bpl.s	loc4_14894
		cmpi.w	#-$E,d1
		blt.w	locret4_146E6
		sub.w	d1,$C(a0)

locret4_14892:
		rts	
; ===========================================================================

loc4_14894:
		cmpi.w	#$E,d1
		bgt.s	loc4_148A0

loc4_1489A:
		sub.w	d1,$C(a0)
		rts	
; ===========================================================================

loc4_148A0:
		tst.b	$38(a0)
		bne.s	loc4_1489A
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Tails_WalkCeiling

; ---------------------------------------------------------------------------
; subroutine allowing Tails to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_WalkVertL:
		move.w	$C(a0),d2				; MJ: Load Y position
		move.w	8(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	$17(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	$16(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Tails_Angle
		tst.w	d1
		beq.s	locret4_14934
		bpl.s	loc4_14936
		cmpi.w	#-$E,d1
		blt.w	locret4_1470A
		sub.w	d1,8(a0)

locret4_14934:
		rts

; ===========================================================================

loc4_14936:
		cmpi.w	#$E,d1
		bgt.s	loc4_14942

loc4_1493C:
		sub.w	d1,8(a0)
		rts	

; ===========================================================================

loc4_14942:
		tst.b	$38(a0)
		bne.s	loc4_1493C
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Tails_WalkVertL

; ---------------------------------------------------------------------------
; subroutine to	make Tails land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_HitFloor:				; XREF: Tails_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

Tails_HitFloor2:
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc4_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc4_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc4_14DDE:
		btst	#0,d3
		beq.s	locret4_14DE6
		move.b	d2,d3

locret4_14DE6:
		rts	

; End of function Tails_HitFloor

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc4_14DF0:				; XREF: Tails_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc4_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret4_14E16
		move.b	d2,d3

locret4_14E16:
		rts	

; ---------------------------------------------------------------------------
; subroutine to	stop Tails when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_HitWall:				; XREF: Tails_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc4_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc4_14E0A
; End of function Tails_HitWall

; ===========================================================================

; ----------------------------------------------------------------------------
; Object 96 - Tails' tails
; ----------------------------------------------------------------------------
; Sprite_1D200:
Obj96:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj96_Index(pc,d0.w),d1
	jmp	Obj96_Index(pc,d1.w)
; ===========================================================================
; off_1D20E: Obj96_States:
Obj96_Index:
		dc.w Obj96_Init-Obj96_Index	; 0
		dc.w Obj96_Main-Obj96_Index	; 2
; ===========================================================================
; loc_1D212
Obj96_Init:
	addq.b	#2,$24(a0) ; => Obj96_Main
	move.l	#Map_TailsTails,4(a0)
	move.w	#$100,$18(a0)
	move.b	#$18,$14(a0)
	move.b	#4,1(a0)
	move.w	#$7B0,2(a0)
	cmpi.b	#$95,($FFFFB380).w
	beq.s	Obj96_Main
	move.w	#$790,2(a0)

; loc_1D23A:
Obj96_Main:
	movea.w	$32(a0),a2 ; a2=character
	move.b	$2C(a2),$2C(a0)
	move.b	$22(a2),$22(a0)
	move.w	8(a2),8(a0)
	move.w	$C(a2),$C(a0)
	andi.w	#$7FFF,2(a0)
	tst.w	2(a2)
	bpl.s	Obj96_1
	ori.w	#(1<<15),2(a0)

Obj96_1:
	moveq	#0,d0
	move.b	$1C(a2),d0
	btst	#5,$22(a2)		; is Tails about to push against something?
	beq.s	Obj96_2			; if not, branch
	cmpi.b	#$A9,$1A(a2)	; Is Tails in his pushing animation yet?
	blo.s	Obj96_2			; If not yet, branch, and do not set tails' tail pushing animation
	cmpi.b	#$AC,$1A(a2)	; ''
	bhi.s	Obj96_2			; ''
	moveq	#4,d0

Obj96_2:
	cmp.b	$30(a0),d0
	beq.s	loc_1D288
	move.b	d0,$30(a0)
	move.b	Obj96AniSelection(pc,d0.w),$1C(a0)

loc_1D288:
	lea	(Obj96AniData).l,a1
	bsr.w	Tails_Animate_Part2
	bsr.w	LoadTailsTailsDynPLC
	movea.w	$32(a0),a1			; Move Tails' register to a1
	move.w	$30(a1),d0	; Move Tails' invulnerable time to d0
	beq.s	Obj96_display			; Is invulnerable_time 0?  If so, always display his tails
	addq.w	#1,d0				; Make d0 the same as old invulnerable_time's d0
	lsr.w	#3,d0				; Shift bits to the right 3 times
	bcc.s	Obj96_return				; If the Carry bit is not set, branch and do not display Tails' tails

Obj96_display:
	jmp	(DisplaySprite).l               ; Display Tails' tails

Obj96_return:
	rts
; ===========================================================================
; animation master script table for the tails
; chooses which animation script to run depending on what Tails is doing
; byte_1D29E:
Obj96AniSelection:
	dc.b	0,0	; TailsAni_Walk,Run	->
	dc.b	3	; TailsAni_Roll		-> Directional
	dc.b	3	; TailsAni_Roll2	-> Directional
	dc.b	9	; TailsAni_Push		-> Pushing
	dc.b	1	; TailsAni_Wait		-> Swish
	dc.b	$A	; TailsAni_Balance	-> Blank
	dc.b	1	; TailsAni_LookUp	-> Flick
	dc.b	1	; TailsAni_Duck		-> Swish
	dc.b	7	; TailsAni_Spindash	-> Spindash
	dc.b	0,0,0	; TailsAni_Dummy1,2,3	->
	dc.b	8	; TailsAni_Stop		-> Skidding
	dc.b	0,0	; TailsAni_Float,2	->
	dc.b	0	; TailsAni_Spring	->
	dc.b	0	; TailsAni_Hang		->
	dc.b	0,0	; TailsAni_Blink,2	->
	dc.b	$A	; TailsAni_Surf	-> Hanging
	dc.b	0	; TailsAni_Bubble	->
	dc.b	0,0,0,0	; TailsAni_Death,2,3,4	->
	dc.b	0,0	; TailsAni_Hurt,Slide	->
	dc.b	0	; TailsAni_Blank	->
	dc.b	$B,$B,$B,$B,$B,$B,$B,$B,$B	; TailsAni_Fly		->
	even

; ---------------------------------------------------------------------------
; Animation script - Tails' tails
; ---------------------------------------------------------------------------
; off_1D2C0:
Obj96AniData:
		dc.w Obj96Ani_Blank-Obj96AniData	;  0
		dc.w Obj96Ani_Swish-Obj96AniData	;  1
		dc.w Obj96Ani_Flick-Obj96AniData	;  2
		dc.w Obj96Ani_Directional-Obj96AniData	;  3
		dc.w Obj96Ani_DownLeft-Obj96AniData	;  4
		dc.w Obj96Ani_Down-Obj96AniData	;  5
		dc.w Obj96Ani_DownRight-Obj96AniData	;  6
		dc.w Obj96Ani_Spindash-Obj96AniData	;  7
		dc.w Obj96Ani_Skidding-Obj96AniData	;  8
		dc.w Obj96Ani_Pushing-Obj96AniData	;  9
		dc.w Obj96Ani_Hanging-Obj96AniData	; $A
		dc.w Obj96Ani_Fly-Obj96AniData	; $B

Obj96Ani_Blank:		dc.b $20,  0,$FF
	even
Obj96Ani_Swish:		dc.b   7,  $22, $23, $24, $25, $26,$FF
	even
Obj96Ani_Flick:		dc.b   3,  $22, $23, $24, $25, $26,$FD,  1
	even
Obj96Ani_Directional:	dc.b $FC,5,6,7,8,$FF ; Tails is moving right
	even
Obj96Ani_DownLeft:	dc.b   3,9,$A,$B,$C,$FF ; Tails is moving up-right
	even
Obj96Ani_Down:		dc.b   3,$D,$E,$F,$10,$FF ; Tails is moving up
	even
Obj96Ani_DownRight:	dc.b   3,$11,$12,$13,$14,$FF ; Tails is moving up-left
	even
Obj96Ani_Spindash:	dc.b   2,$1A,$1B,$1C,$1D,$FF
	even
Obj96Ani_Skidding:	dc.b   2,$1E,$1F,$20,$21,$FF
	even
Obj96Ani_Pushing:	dc.b   9,$1E,$1F,$20,$21,$FF
	even
Obj96Ani_Hanging:	dc.b   9,$1A,$1B,$1C,$1D,$FF
	even
Obj96Ani_Fly:		dc.b   3,$27,$28,$FF
	even

; ===========================================================================

ShadowAniData:
	include "_anim\Shadow.asm"

SilverAniData:
	include "_anim\Silver.asm"

TailsAniData:
	include "_anim\Tails.asm"

LoadTailsTailsDynPLC:
		movea.l	#TailsTailsDynPLC,a2	; get DPLC location
		move.l	#Art_TailsTails,d6	; get art location
		move.w	#$F600,d4		; offset in VRAM to store art
		cmpi.b	#$95,($FFFFB380).w
		beq.s	LoadTailsTailsDynPLC2
		move.w	#$F200,d4		; offset in VRAM to store art
		
LoadTailsTailsDynPLC2:
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF767).w,d0	; check if equal with last queued frame
		beq.w	DPLC_End	; if is, don't load new DPLC
		move.b	d0,($FFFFF767).w	; remember queued frame
		bra.w	Load_DPLC

LoadSCharacterDynPLC:
		tst.w	(Current_Character).w
		beq.s	LoadSonicDynPLC
		cmpi.w	#1,(Current_Character).w
		beq.s	LoadShadowDynPLC
		cmpi.w	#2,(Current_Character).w
		beq.s	LoadSilverDynPLC
		bra.s	LoadTailsDynPLC

LoadSonicDynPLC:
LoadSonicDynPLC_Part2:
		movea.l	#SonicDynPLC,a2	; get DPLC location
		move.l	#Art_Sonic2,d6	; get art location
		cmpi.w	#1,(Current_Character).w
		beq.s	LoadSonicDynPLC2
		cmpi.w	#1,(Current_Partner).w
		beq.s	LoadSonicDynPLC2
		move.l	#Art_Sonic,d6	; get art location

LoadSonicDynPLC2:
		bra.s	LoadMainDynPLC

LoadSilverDynPLC:
		movea.l	#SilverDynPLC,a2	; get DPLC location
		move.l	#Art_Silver,d6	; get art location
		bra.s	LoadMainDynPLC

LoadShadowDynPLC:
		movea.l	#ShadowDynPLC,a2	; get DPLC location
		move.l	#Art_Shadow2,d6	; get art location
		tst.w	(Current_Character).w
		beq.s	LoadMainDynPLC
		tst.w	(Current_Partner).w
		beq.s	LoadMainDynPLC
		move.l	#Art_Shadow,d6	; get art location
		bra.s	LoadMainDynPLC

LoadTailsDynPLC:
LoadTailsDynPLC_Part2:
		movea.l	#TailsDynPLC,a2	; get DPLC location
		move.l	#Art_Tails,d6	; get art location

LoadMainDynPLC:
		btst	#7,$22(a0)
		bne.s	LoadSecondaryDynPLC
		move.w	#$F000,d4		; offset in VRAM to store art
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF766).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End	; if is, don't load new DPLC
		move.b	d0,($FFFFF766).w	; remember queued frame
		bra.s	Load_DPLC

LoadSecondaryDynPLC:	
		move.w	#$F400,d4		; offset in VRAM to store art
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF76D).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End	; if is, don't load new DPLC
		move.b	d0,($FFFFF76D).w	; remember queued frame
; End of function LoadSonicDynPLC

; ---------------------------------------------------------------------------
; Subroutine to queue any pattern load cue
; Input: a2 - DPLC file, d4 - VRAM address, d6 - Art file, d0 - frame number
; ---------------------------------------------------------------------------

Load_DPLC:
		add.w	d0,d0		; multiply by 2
		adda.w	(a2,d0.w),a2	; get the right DPLC location
		moveq	#0,d5		; quckly clear d5
		move.b	(a2)+,d5	; then move the amount of requests to d5
		subq.w	#1,d5		; subtract 1
		bmi.s	DPLC_End	; if negative, branch away

DPLC_ReadEntry:
		moveq	#0,d1
		move.b	(a2)+,d1	; get first byte to d1, and increment pointer
		lsl.w	#8,d1		; shift 8 bits left
		move.b	(a2)+,d1 	; move second byte to d1

		move.w	d1,d3		; move d1 to d3
		lsr.w	#8,d3		; shift 8 bits right
		andi.w	#$F0,d3		; leave only bits 7, 6, 5, and 4
		addi.w	#$10,d3		; add $10 to d3

		andi.w	#$FFF,d1	; filter out bits 15, 14, 13 and 12
		lsl.l	#5,d1		; shift 5 bits left
		add.l	d6,d1		; add the art address to d1
		move.w	d4,d2		; move VRAM location to d2
		add.w	d3,d4		; add d3 to VRAM address
		add.w	d3,d4		; add d3 to VRAM address

		jsr	QueueDMATransfer; Save it to the DMA queue
		dbf	d5,DPLC_ReadEntry; repeat for number of requests

DPLC_End:
		rts			; return

; End of function LoadDPLC
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0A - drowning countdown numbers and small bubbles (TJZ)
; ---------------------------------------------------------------------------

Obj0A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0A_Index(pc,d0.w),d1
		jmp	Obj0A_Index(pc,d1.w)
; ===========================================================================
Obj0A_Index:	dc.w Obj0A_Main-Obj0A_Index, Obj0A_Animate-Obj0A_Index
		dc.w Obj0A_ChkWater-Obj0A_Index, Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index,	Obj0A_Countdown-Obj0A_Index
		dc.w Obj0A_AirLeft-Obj0A_Index,	Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index
; ===========================================================================

Obj0A_Main:				; XREF: Obj0A_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj64,4(a0)
		move.w	#$8390,2(a0)
		move.b	#$84,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$80,$18(a0)
		move.b	$28(a0),d0
		bpl.s	loc_13D00
		addq.b	#8,$24(a0)
		move.l	#Map_obj0A,4(a0)
		move.w	#$440,2(a0)
		andi.w	#$7F,d0
		move.b	d0,$33(a0)
		bra.w	Obj0A_Countdown
; ===========================================================================

loc_13D00:
		move.b	d0,$1C(a0)
		move.w	8(a0),$30(a0)
		move.w	#-$88,$12(a0)

Obj0A_Animate:				; XREF: Obj0A_Index
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite

Obj0A_ChkWater:				; XREF: Obj0A_Index
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; has bubble reached the water surface?
		bcs.s	Obj0A_Wobble	; if not, branch
		move.b	#6,$24(a0)
		addq.b	#7,$1C(a0)
		cmpi.b	#$D,$1C(a0)
		beq.s	Obj0A_Display
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Wobble:
		tst.b	($FFFFF7C7).w
		beq.s	loc_13D44
		addq.w	#4,$30(a0)

loc_13D44:
		move.b	$26(a0),d0
		addq.b	#1,$26(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)
		bsr.s	Obj0A_ShowNumber
		jsr	SpeedToPos
		tst.b	1(a0)
		bpl.s	Obj0A_Delete
		btst	#6,($FFFFFE2C).w	; does Sonic have a bubble shield?
		bne.s	Obj0A_Delete	; if so, branch
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj0A_Display:				; XREF: Obj0A_Index
		bsr.s	Obj0A_ShowNumber
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete2:				; XREF: Obj0A_Index
		jmp	DeleteObject
; ===========================================================================

Obj0A_AirLeft:				; XREF: Obj0A_Index
		cmpi.w	#$C,($FFFFFE14).w ; check air remaining
		bhi.s	Obj0A_Delete3	; if higher than $C, branch
		subq.w	#1,$38(a0)
		bne.s	Obj0A_Display2
		move.b	#$E,$24(a0)
		addq.b	#7,$1C(a0)
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Display2:
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		tst.b	1(a0)
		bpl.s	Obj0A_Delete3
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete3:
		jmp	DeleteObject
; ===========================================================================

Obj0A_ShowNumber:			; XREF: Obj0A_Wobble; Obj0A_Display
		tst.w	$38(a0)
		beq.s	locret_13E1A
		subq.w	#1,$38(a0)
		bne.s	locret_13E1A
		cmpi.b	#7,$1C(a0)
		bcc.s	locret_13E1A
		move.w	#$F,$38(a0)
		clr.w	$12(a0)
		move.b	#$80,1(a0)
		move.w	8(a0),d0
		sub.w	($FFFFF700).w,d0
		addi.w	#$80,d0
		move.w	d0,8(a0)
		move.w	$C(a0),d0
		sub.w	($FFFFF704).w,d0
		addi.w	#$80,d0
		move.w	d0,$A(a0)
		move.b	#$C,$24(a0)

locret_13E1A:
		rts	
; ===========================================================================
Obj0A_WobbleData:
		dc.b 0, 0, 0, 0, 0, 0,	1, 1, 1, 1, 1, 2, 2, 2,	2, 2, 2
		dc.b 2,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 4, 3
		dc.b 3,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 2, 2, 2, 2
		dc.b 2,	2, 2, 1, 1, 1, 1, 1, 0,	0, 0, 0, 0, 0, -1, -1
		dc.b -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2
		dc.b -2, -2, -2, -2, -1, -1, -1, -1, -1
		dc.b 0, 0, 0, 0, 0, 0,	1, 1, 1, 1, 1, 2, 2, 2,	2, 2, 2
		dc.b 2,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 4, 3
		dc.b 3,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 2, 2, 2, 2
		dc.b 2,	2, 2, 1, 1, 1, 1, 1, 0,	0, 0, 0, 0, 0, -1, -1
		dc.b -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2
		dc.b -2, -2, -2, -2, -1, -1, -1, -1, -1
; ===========================================================================

Obj0A_Countdown:			; XREF: Obj0A_Index
		tst.w	$2C(a0)
		bne.w	loc_13F86
		btst	#6,($FFFFFE2C).w	; was a bubble shield monitor broken?
		bne.w	locret_1408C	; if yes, branch
		cmpi.b	#6,($FFFFB024).w
		bcc.w	locret_1408C
		btst	#6,($FFFFB022).w
		beq.w	locret_1408C
		subq.w	#1,$38(a0)
		bpl.w	loc_13FAC
		move.w	#59,$38(a0)
		move.w	#1,$36(a0)
		jsr	(RandomNumber).l
		andi.w	#1,d0
		move.b	d0,$34(a0)
		move.w	($FFFFFE14).w,d0 ; check air remaining
		cmpi.w	#$19,d0
		beq.s	Obj0A_WarnSound	; play sound if	air is $19
		cmpi.w	#$14,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$F,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$C,d0
		bhi.s	Obj0A_ReduceAir	; if air is above $C, branch
		
loc_13F02:
		subq.b	#1,$32(a0)
		bpl.s	Obj0A_ReduceAir
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)
		move.b	#$9D,d0
		jsr	PlaySound
		bra.s	Obj0A_ReduceAir
; ===========================================================================

Obj0A_WarnSound:			; XREF: Obj0A_Countdown
		move.w	#$A9,d0
		jsr	(PlaySound_Special).l ;	play "ding-ding" warning sound

Obj0A_ReduceAir:
		subq.w	#1,($FFFFFE14).w ; subtract 1 from air remaining
		bcc.w	Obj0A_GoMakeItem ; if air is above 0, branch
		move.b	#$81,($FFFFF7C8).w ; lock controls
		move.w	#$3B,d0
		jsr	(PlaySound_Special).l ;	play drowning sound
		move.w	#$E1,d0
		jsr	PlaySound
		move.b	#$A,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$78,$2C(a0)
		move.l	a0,-(sp)
		lea	($FFFFB000).w,a0
		bsr.w	Player_ResetOnFloor
		move.b	#$17,$1C(a0)	; use Sonic's drowning animation
		bset	#1,$22(a0)
		bset	#7,2(a0)
		move.w	#0,$12(a0)
		move.w	#0,$10(a0)
		move.w	#0,$20(a0)
		move.b	#1,($FFFFF744).w
		movea.l	(sp)+,a0
		rts	
; ===========================================================================

loc_13F86:
		subq.w	#1,$2C(a0)
		bne.s	loc_13F94
		move.b	#6,($FFFFB024).w
		rts	
; ===========================================================================

loc_13F94:
		move.l	a0,-(sp)
		lea	($FFFFB000).w,a0
		jsr	SpeedToPos
		addi.w	#$10,$12(a0)
		movea.l	(sp)+,a0
		bra.s	loc_13FAC
; ===========================================================================

Obj0A_GoMakeItem:			; XREF: Obj0A_ReduceAir
		bra.s	Obj0A_MakeItem
; ===========================================================================

loc_13FAC:
		tst.w	$36(a0)
		beq.w	locret_1408C
		subq.w	#1,$3A(a0)
		bpl.w	locret_1408C

Obj0A_MakeItem:
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		move.w	d0,$3A(a0)
		jsr	SingleObjLoad
		bne.w	locret_1408C
		move.b	#$A,0(a1)	; load object
		move.w	($FFFFB008).w,8(a1) ; match X position to Sonic
		moveq	#6,d0
		btst	#0,($FFFFB022).w
		beq.s	loc_13FF2
		neg.w	d0
		move.b	#$40,$26(a1)

loc_13FF2:
		add.w	d0,8(a1)
		move.w	($FFFFB00C).w,$C(a1)
		move.b	#6,$28(a1)
		tst.w	$2C(a0)
		beq.w	loc_1403E
		andi.w	#7,$3A(a0)
		addi.w	#0,$3A(a0)
		move.w	($FFFFB00C).w,d0
		subi.w	#$C,d0
		move.w	d0,$C(a1)
		jsr	(RandomNumber).l
		move.b	d0,$26(a1)
		move.w	($FFFFFE04).w,d0
		andi.b	#3,d0
		bne.s	loc_14082
		move.b	#$E,$28(a1)
		bra.s	loc_14082
; ===========================================================================

loc_1403E:
		btst	#7,$36(a0)
		beq.s	loc_14082
		move.w	($FFFFFE14).w,d2
		lsr.w	#1,d2
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_1406A
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,$28(a1)
		move.w	#$1C,$38(a1)

loc_1406A:
		tst.b	$34(a0)
		bne.s	loc_14082
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,$28(a1)
		move.w	#$1C,$38(a1)

loc_14082:
		subq.b	#1,$34(a0)
		bpl.s	locret_1408C
		clr.w	$36(a0)

locret_1408C:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	play music for TJZ/ABZ3 after a countdown
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ResumeMusic:				; XREF: Obj64_Wobble; Sonic_Water; Obj0A_ReduceAir
		move.w	#$1E,($FFFFFE14).w
		clr.b	($FFFFB372).w
		rts	
; End of function ResumeMusic

; ===========================================================================
Ani_obj0A:
	include "_anim\obj0A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - drowning countdown numbers (TJZ)
; ---------------------------------------------------------------------------
Map_obj0A:
	include "_maps\obj0A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 38 - Shield
; ---------------------------------------------------------------------------

Obj38:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w  Shield_Index(pc,d0.w),d1
		jmp     Shield_Index(pc,d1.w)
; ===========================================================================		
Shield_Index:                 
		dc.w    Shield_Init-Shield_Index		
		dc.w    FlameShield-Shield_Index
		dc.w    LightningShield-Shield_Index
		dc.w    BubbleShield-Shield_Index
		dc.w	Shield_Underwater2-Shield_Index
; ===========================================================================		
Shield_Init:
		lea	($FFFFB000).w,a1
		addq.b	#2,$24(a0)
		move.b  #4,1(a0)						
		move.w  #$80,$18(a0)
		move.b  #$18,$14(a0)
		btst	#0,($FFFFFE2C).w
		beq.s	Shield_Delete
		btst	#4,($FFFFFE2C).w
		beq.s	Shield_ChkLightning
        move.b  #3,$1C(a0)
		move.w  #$4BE,2(a0)		        ; Set VRAM location
		move.l	#Map_fshield,4(a0)  
		bra.s	FlameShield

Shield_ChkLightning:
		btst	#5,($FFFFFE2C).w
		beq.s	Shield_ChkBubble
        move.b  #1,$1C(a0)
		addq.b	#2,$24(a0)
		move.w  #$24BE,2(a0)		        ; Set VRAM location
		move.l	#Map_lshield,4(a0)  
		bra.w	LightningShield

Shield_ChkBubble:
		btst	#6,($FFFFFE2C).w
		beq.s	Shield_Delete
        move.b  #2,$1C(a0)
		addq.b	#4,$24(a0)
		move.w  #$24BE,2(a0)		        ; Set VRAM location
		move.l	#Map_bshield,4(a0)  
		bra.w	BubbleShield

Shield_Delete:
		jmp	DeleteObject

FlameShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a FShield
		bne.w  SonicHasFShield			        ; If so, branch to do nothing
		btst	#6,$22(a1)
		beq.s	FShieldProperties	; if not, branch
		andi.b	#$8E,($FFFFFE2C).w
		jmp	DeleteObject


FShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position
		btst    #7,2(a1)
		bclr    #7,2(a0)
		beq.s   FShieldCont
		bset    #7,2(a0)

FShieldCont:
		bclr    #0,$22(a0)
		btst    #0,$22(a1)
		beq.s   FShieldCont2
		bset    #0,$22(a0)

FShieldCont2:
        lea     (Ani_obj38).l,a1  
		jsr     AnimateSprite
		move.w	#$80,$18(a0)	; Layer FShield over player sprite
		cmpi.b	#$F,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	FShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer FShield behind player sprite

FShield_Display:	; +  
		moveq	#0,d0                 ; Load Shield Map into place  	
		movea.l	#FShieldDynPLC,a2	; get DPLC location
		move.w	#$97C0,d4		; offset in VRAM to store art
		move.l	#UnC_FlameShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	FShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC        		

FShield_Display2:
		jmp     DisplaySprite    

SonicHasFShield:
		rts    

LightningShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a LShield
		bne.w  SonicHasLShield			        ; If so, branch to do nothing
		btst	#6,$22(a1)
		beq.s	LShieldProperties	; if not, branch

Shield_Underwater:
		move.b	#8,$24(a0)
		andi.b	#$8E,($FFFFFE2C).w	; Sets Status_Shield, Status_FireShield, Status_LtngShield, and Status_BublShield to 0

		; Flashes the underwater palette white
		lea	($FFFFFA80).w,a1
		lea	($FFFFFA00).w,a2
		move.w	#$1F,d0			; Size of Water_palette/4-1

loc_197F2:
		move.l	(a1),(a2)+			; Backup palette entries
		move.l	#$0EEE0EEE,(a1)+		; Overwrite palette entries with white
		dbf	d0,loc_197F2				; Loop until entire thing is overwritten

		move.b	#4,$23(a0)
		move.b	#1,$30(a0)
		jmp	DestroyEnemiesUW

LShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position
		btst    #7,2(a1)
		bclr    #7,2(a0)
		beq.s   LShieldCont
		bset    #7,2(a0)

LShieldCont:
		bclr    #0,$22(a0)
		btst    #0,$22(a1)
		beq.s   LShieldCont2
		bset    #0,$22(a0)

LShieldCont2:
        lea     (Ani_obj38).l,a1  
		jsr     AnimateSprite
		move.w	#$80,$18(a0)	; Layer Shield over player sprite
		cmpi.b	#$E,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	LShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer LShield behind player sprite

LShield_Display:	; +  
		moveq	#0,d0                 ; Load Shield Map into place  	
		movea.l	#LShieldDynPLC,a2	; get DPLC location
		move.w	#$97C0,d4		; offset in VRAM to store art
		move.l	#UnC_LightningShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	LShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC        		

LShield_Display2:
		jmp     DisplaySprite    

SonicHasLShield:
		rts    

BubbleShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a BShield
		bne.w  SonicHasBShield			        ; If so, branch to do nothing
		move.w	($FFFFF646).w,d0

BShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position
		btst    #7,2(a1)
		bclr    #7,2(a0)
		beq.s   BShieldCont
		bset    #7,2(a0)

BShieldCont:
		bclr    #0,$22(a0)
		btst    #0,$22(a1)
		beq.s   BShieldCont2
		bset    #0,$22(a0)

BShieldCont2:
        lea     (Ani_obj38).l,a1  
		jsr     AnimateSprite
		move.w	#$80,$18(a0)	; Layer BShield over player sprite 
		cmpi.b	#$D,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	BShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer BShield behind player sprite

BShield_Display:	; +  
		moveq	#0,d0 	
		movea.l	#BShieldDynPLC,a2	; get DPLC location
		move.w	#$97C0,d4		; offset in VRAM to store art
		move.l	#UnC_BubbleShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	BShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC        		

BShield_Display2:
		jmp     DisplaySprite    

SonicHasBShield:
		rts    

Shield_Underwater2:
		subq.b	#1,$23(a0)		; Is it time to end the white flash?
		bpl.s	locret_198BC			; If not, return
		lea	($FFFFFA00).w,a1
		lea	($FFFFFA80).w,a2
		move.w	#$1F,d0			; Size of Water_palette/4-1

loc_198B6:
		move.l	(a1)+,(a2)+			; Restore backed-up underwater palette
		dbf	d0,loc_198B6				; Loop until entire thing is restored
		jmp	DeleteObject

locret_198BC:
		rts

; ---------------------------------------------------------------------------
; Object 4A - New Invincibility Object
; ---------------------------------------------------------------------------

Obj4A:					; XREF: Obj_Index
Invincibility_Main:
		moveq	#0,d0
		move.b	$24(a0),d0
Invincibility_Init:		
		addq.b	#2,$24(a0)
		move.l	#Map_obj4A,4(a0)	; loads mapping
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		move.w	#$24BE,2(a0)	; shield specific code
		move.l	#UnC_Stars,d1
		move.w	#$97C0,d2
		move.w	#$200,d3
		jsr	(QueueDMATransfer).l
; ===========================================================================

Obj4A_Stars:				; XREF: Obj38_Index
		btst	#1,($FFFFFE2C).w	; does Sonic have invincibility?
		beq.s	Obj4A_Delete2	; if not, branch
		move.w	($FFFFF7A8).w,d0
		move.b	$1C(a0),d1
		subq.b	#1,d1
		bra.s	Obj4A_StarTrail
; ===========================================================================
		lsl.b	#4,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	$30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		andi.b	#$F,d1
		move.b	d1,$30(a0)
		bra.s	Obj4A_StarTrail2a
; ===========================================================================

Obj4A_StarTrail:			; XREF: Obj4A_Stars
		lsl.b	#7,d1
		move.b	d1,d2
		add.b	d1,d1
		add.b	d2,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	$30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		cmpi.b	#$18,d1
		bcs.s	Obj4A_StarTrail2
		moveq	#0,d1

Obj4A_StarTrail2:
		move.b	d1,$30(a0)

Obj4A_StarTrail2a:
		lea	($FFFFE500).w,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,8(a0)
		move.w	(a1)+,$C(a0)
		move.b	($FFFFB022).w,$22(a0)
		lea	(Ani_obj4A).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

Obj4A_Delete2:				; XREF: Obj4A_Stars
		jmp	(DeleteObject).l			
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 08 - water splash (TJZ)
; ---------------------------------------------------------------------------

Obj08:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj08_Index(pc,d0.w),d1
		jmp	Obj08_Index(pc,d1.w)
; ===========================================================================
Obj08_Index:	dc.w Obj08_Main-Obj08_Index
		dc.w Obj08_Display-Obj08_Index
		dc.w Obj08_Delete-Obj08_Index
; ===========================================================================

Obj08_Main:				; XREF: Obj08_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj08,4(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		move.w	#$4259,2(a0)
		move.w	($FFFFB008).w,8(a0) ; copy x-position from Sonic

Obj08_Display:				; XREF: Obj08_Index
		move.w	($FFFFF646).w,$C(a0) ; copy y-position from water height
		lea	(Ani_obj08).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj08_Delete:				; XREF: Obj08_Index
		jmp	DeleteObject	; delete when animation	is complete
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - shield and invincibility stars
; ---------------------------------------------------------------------------
Map_obj4A:
	include "_maps\obj4A.asm"

Ani_obj4A:
	include "_anim\obj4A.asm"

Map_lshield:
	include "_maps\obj38shield.asm"

Map_bshield:
	include "_maps\obj38bubbleshield.asm"

Map_fshield:
	include "_maps\obj38flameshield.asm"

Ani_obj38:
	include "_anim\obj38.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage entry	from beta
; ---------------------------------------------------------------------------
Ani_obj08:
	include "_anim\obj08.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - water splash (TJZ)
; ---------------------------------------------------------------------------
Map_obj08:
	include "_maps\obj08.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sonic_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		btst	#3,$22(a0)
		beq.s	loc_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	$26(a0),d0
		addi.b	#$20,d0
		bpl.s	loc_14624
		move.b	$26(a0),d0
		bpl.s	loc_1461E
		subq.b	#1,d0

loc_1461E:
		addi.b	#$20,d0
		bra.s	loc_14630
; ===========================================================================

loc_14624:
		move.b	$26(a0),d0
		bpl.s	loc_1462C
		addq.b	#1,d0

loc_1462C:
		addi.b	#$1F,d0

loc_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Sonic_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Sonic_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Sonic_WalkVertR
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_146BE
		bpl.s	loc_146C0
		cmpi.w	#-$E,d1
		blt.s	locret_146E6
		add.w	d1,$C(a0)

locret_146BE:
		rts	
; ===========================================================================

loc_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc_146CC

loc_146C6:
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_146CC:
		tst.b	$38(a0)
		bne.s	loc_146C6
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; ===========================================================================

locret_146E6:
		rts	
; End of function Sonic_AnglePos

; ===========================================================================
		move.l	8(a0),d2
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.l	d2,8(a0)
		move.w	#$38,d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
; ===========================================================================

locret_1470A:
		rts	
; ===========================================================================
		move.l	$C(a0),d3
		move.w	$12(a0),d0
		subi.w	#$38,d0
		move.w	d0,$12(a0)
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
		rts	
; ===========================================================================
		move.l	8(a0),d2
		move.l	$C(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d2,8(a0)
		move.l	d3,$C(a0)
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Angle:				; XREF: Sonic_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc_1475E:
		btst	#0,d2
		bne.s	loc_1476A
		move.b	d2,$26(a0)
		rts	
; ===========================================================================

loc_1476A:
		move.b	$26(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,$26(a0)
		rts	
; End of function Sonic_Angle

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertR:			; XREF: Sonic_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_147F0
		bpl.s	loc_147F2
		cmpi.w	#-$E,d1
		blt.w	locret_1470A
		add.w	d1,8(a0)

locret_147F0:
		rts	
; ===========================================================================

loc_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc_147FE

loc_147F8:
		add.w	d1,8(a0)
		rts	
; ===========================================================================

loc_147FE:
		tst.b	$38(a0)
		bne.s	loc_147F8
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Sonic_WalkVertR

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkCeiling:			; XREF: Sonic_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_14892
		bpl.s	loc_14894
		cmpi.w	#-$E,d1
		blt.w	locret_146E6
		sub.w	d1,$C(a0)

locret_14892:
		rts	
; ===========================================================================

loc_14894:
		cmpi.w	#$E,d1
		bgt.s	loc_148A0

loc_1489A:
		sub.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_148A0:
		tst.b	$38(a0)
		bne.s	loc_1489A
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Sonic_WalkCeiling

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertL:
		move.w	$C(a0),d2				; MJ: Load Y position
		move.w	8(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	$17(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	$16(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Sonic_Angle
		tst.w	d1
		beq.s	locret_14934
		bpl.s	loc_14936
		cmpi.w	#-$E,d1
		blt.w	locret_1470A
		sub.w	d1,8(a0)

locret_14934:
		rts

; ===========================================================================

loc_14936:
		cmpi.w	#$E,d1
		bgt.s	loc_14942

loc_1493C:
		sub.w	d1,8(a0)
		rts	

; ===========================================================================

loc_14942:
		tst.b	$38(a0)
		bne.s	loc_1493C
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Sonic_WalkVertL

; ---------------------------------------------------------------------------
; Subroutine to	find which tile	the object is standing on
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Floor_ChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0780,d0				; MJ: get within 780 (E00 pixels) in multiples of 80
		add.w	d0,d0					; MJ: multiply by 2
		move.w	d3,d1					; MJ: load X position
		lsr.w	#7,d1					; MJ: shift to right side
		andi.w	#$007F,d1				; MJ: get within 7F
		add.w	d1,d0					; MJ: add calc'd Y to calc'd X
		moveq	#-1,d1					; MJ: prepare FFFF in d3
		movea.l	($FFFF8000).w,a1			; MJ: load address of Layout to a1
		move.b	(a1,d0.w),d1				; MJ: collect correct chunk ID based on the X and Y position
		andi.w	#$FF,d1					; MJ: keep within FF
		lsl.w	#$07,d1					; MJ: multiply by 80
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0070,d0				; MJ: keep Y within 80 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID
		move.w	d3,d0					; MJ: load X position
		lsr.w	#3,d0					; MJ: divide by 8
		andi.w	#$000E,d0				; MJ: keep X within 10 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID

loc_14996:
		movea.l	d1,a1					; MJ: set address (Chunk to read)
		rts						; MJ: return
; ===========================================================================

loc_1499A:
		andi.w	#$7F,d1
		btst	#6,1(a0)
		beq.s	loc_149B2
		addq.w	#1,d1
		cmpi.w	#$29,d1
		bne.s	loc_149B2
		move.w	#$51,d1

loc_149B2:
		ror.w	#7,d1
		ror.w	#2,d1
		move.w	d2,d0
		add.w	d0,d0
		andi.w	#$070,d0
		add.w	d0,d1
		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$0E,d0
		add.w	d0,d1
		movea.l	d1,a1
		rts

Floor_BGChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0					; MJ: load Y position
		add.w	($FFFFFE00),d0
		andi.w	#$0780,d0				; MJ: get within 780 (E00 pixels) in multiples of 80
		add.w	d0,d0					; MJ: multiply by 2
		move.w	d3,d1					; MJ: load X position
		lsr.w	#7,d1					; MJ: shift to right side
		andi.w	#$007F,d1				; MJ: get within 7F
		add.w	d1,d0					; MJ: add calc'd Y to calc'd X
		moveq	#-1,d1					; MJ: prepare FFFF in d3
		add.w	#$80,d0
		movea.l	($FFFF8000).w,a1			; MJ: load address of Layout to a1
		move.b	(a1,d0.w),d1				; MJ: collect correct chunk ID based on the X and Y position
		andi.w	#$FF,d1					; MJ: keep within FF
		lsl.w	#$07,d1					; MJ: multiply by 80
		move.w	d2,d0					; MJ: load Y position
		add.w	($FFFFFE00),d0
		andi.w	#$0070,d0				; MJ: keep Y within 80 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID
		move.w	d3,d0					; MJ: load X position
		lsr.w	#3,d0					; MJ: divide by 8
		andi.w	#$000E,d0				; MJ: keep X within 10 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID

loc2_14996:
		movea.l	d1,a1					; MJ: set address (Chunk to read)
		rts						; MJ: return
; ===========================================================================

loc2_1499A:
		andi.w	#$7F,d1
		btst	#6,1(a0)
		beq.s	loc2_149B2
		addq.w	#1,d1
		cmpi.w	#$29,d1
		bne.s	loc2_149B2
		move.w	#$51,d1

loc2_149B2:
		ror.w	#7,d1
		ror.w	#2,d1
		move.w	d2,d0
		add.w	($FFFFFE00),d0
		add.w	d0,d0
		andi.w	#$070,d0
		add.w	d0,d1
		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$0E,d0
		add.w	d0,d1
		movea.l	d1,a1
		rts
; End of function Floor_ChkTile

FindFloor:
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_149DE
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE:
		tst.b	($FFFFFE07).w
		beq.s	loc_149DE2				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_149DE2
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE2:
		add.w	a3,d2
		bsr.w	FindFloor2
		sub.w	a3,d2
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_149EC:
		movea.l	($FFFFF796).w,a2			; MJ: load collision index address
		move.b	(a2,d0.w),d0				; MJ: load correct Collision ID based on the Block ID
		andi.w	#$FF,d0					; MJ: clear the left byte
		beq.s	loc_149DE				; MJ: if collision ID is 00, branch
		movea.l	($FFFFF78C).w,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: collect correct angle based on the collision ID
		lsl.w	#4,d0					; MJ: multiply collision ID by 10
		move.w	d3,d1					; MJ: load X position
		btst	#$A,d4					; MJ: is the block mirrored?
		beq.s	loc_14A12				; MJ: if not, branch
		not.w	d1					; MJ: reverse bits of the X position
		neg.b	(a4)					; MJ: reverse the angle ID

loc_14A12:
		btst	#$B,d4					; MJ: is the block flipped?
		beq.s	loc_14A22				; MJ: if not, branch
		addi.b	#$40,(a4)				; MJ: increase angle ID by 40..
		neg.b	(a4)					; MJ: ..reverse the angle ID..
		subi.b	#$40,(a4)				; MJ: ..and subtract 40 again 

loc_14A22:
		andi.w	#$F,d1					; MJ: get only within 10 (d1 is pixel based on the collision block)
		add.w	d0,d1					; MJ: add collision ID (x10) (d0 is the collision block being read)
		movea.l	($FFFFF784).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0				; MJ: load solid value
		ext.w	d0					; MJ: clear left byte
		eor.w	d6,d4					; MJ: set ceiling/wall bits
		btst	#$B,d4					; MJ: is sonic walking on the left wall?
		beq.s	loc_14A3E				; MJ: if not, branch
		neg.w	d0					; MJ: reverse solid value

loc_14A3E:
		tst.w	d0					; MJ: is the solid data null?
		beq.w	loc_149DE				; MJ: if so, branch
		bmi.s	loc_14A5A				; MJ: if it's negative, branch
		cmpi.b	#$10,d0					; MJ: is it 10?
		beq.s	loc_14A66				; MJ: if so, branch
		move.w	d2,d1					; MJ: load Y position
		andi.w	#$F,d1					; MJ: get only within 10 pixels
		add.w	d1,d0					; MJ: add to solid value
		move.w	#$F,d1					; MJ: set F
		sub.w	d0,d1					; MJ: minus solid value from F
		rts			; d1 = position?	; MJ: return

; ===========================================================================

loc_14A5A:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_149DE

loc_14A66:
		sub.w	a3,d2
		bsr.w	FindFloor2
		add.w	a3,d2
		subi.w	#$10,d1
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindFloor2:				; XREF: FindFloor
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14A86
		btst	d5,d4
		bne.s	loc_14A94

loc_14A86:
		tst.b	($FFFFFE07).w
		beq.s	loc_14A862				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14A862
		btst	d5,d4
		bne.s	loc_14A94

loc_14A862:
		move.w	#$F,d1
		move.w	d2,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14A94:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14A86
		movea.l	($FFFFF78C).w,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14ABA
		not.w	d1
		neg.b	(a4)

loc_14ABA:
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14ACA
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14ACA:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF784).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14AE6
		neg.w	d0

loc_14AE6:
		tst.w	d0
		beq.s	loc_14A86
		bmi.s	loc_14AFC
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14AFC:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14A86
		not.w	d1
		rts	

; End of function FindFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall:
		bsr.w	Floor_ChkTile				; MJ: get chunk/block location
		move.w	(a1),d0					; MJ: load block ID from chunk
		move.w	d0,d4					; MJ: copy to d4
		andi.w	#$3FF,d0				; MJ: clear flip/mirror/etc data
		beq.s	loc_14B1E				; MJ: if it was null, branch
		btst	d5,d4					; MJ: check solid set (C top solid | D Left/right solid)
		bne.s	loc_14B2C				; MJ: if the specific solid is set, branch

loc_14B1E:
		tst.b	($FFFFFE07).w
		beq.s	loc_14B1E2				; if so, branch
		bsr.w	Floor_BGChkTile				; MJ: get chunk/block location
		move.w	(a1),d0					; MJ: load block ID from chunk
		move.w	d0,d4					; MJ: copy to d4
		andi.w	#$3FF,d0				; MJ: clear flip/mirror/etc data
		beq.s	loc_14B1E2				; MJ: if it was null, branch
		btst	d5,d4					; MJ: check solid set (C top solid | D Left/right solid)
		bne.s	loc_14B2C				; MJ: if the specific solid is set, branch

loc_14B1E2:
		add.w	a3,d3					; MJ: add 10 to X position
		bsr.w	FindWall2
		sub.w	a3,d3					; MJ: minus 10 from X position
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_14B2C:
		movea.l	($FFFFF796).w,a2	; MJ: load address of collision for level
		move.b	(a2,d0.w),d0		; MJ: load correct colision ID based on the block ID
		andi.w	#$FF,d0					; MJ: keep within FF
		beq.s	loc_14B1E				; MJ: if it's null, branch
		movea.l	($FFFFF78C).w,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: load angle set location based on collision ID
		lsl.w	#4,d0					; MJ: multiply by 10
		move.w	d2,d1					; MJ: load Y position
		btst	#$B,d4					; MJ: is the block ID flipped?
		beq.s	loc_14B5A				; MJ: if not, branch
		not.w	d1
		addi.b	#$40,(a4)				; MJ: increase angle set by 40
		neg.b	(a4)					; MJ: negate to opposite
		subi.b	#$40,(a4)				; MJ: decrease angle set by 40

loc_14B5A:
		btst	#$A,d4					; MJ: is the block ID mirrored?
		beq.s	loc_14B62				; MJ: if not, branch
		neg.b	(a4)					; MJ: negate to opposite

loc_14B62:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF788).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14B7E
		neg.w	d0

loc_14B7E:
		tst.w	d0
		beq.s	loc_14B1E
		bmi.s	loc_14B9A
		cmpi.b	#$10,d0
		beq.s	loc_14BA6
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14B9A:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14B1E

loc_14BA6:
		sub.w	a3,d3
		bsr.w	FindWall2
		add.w	a3,d3
		subi.w	#$10,d1
		rts	
; End of function FindWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall2:				; XREF: FindWall
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14BC6
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC6:
		tst.b	($FFFFFE07).w
		beq.s	loc_14BC62				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14BC62
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC62:
		move.w	#$F,d1
		move.w	d3,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14BD4:
		movea.l	($FFFFF796).w,a2	; MJ: load address of collision for level
		move.b	(a2,d0.w),d0		; MJ: load correct colision ID based on the block I
		andi.w	#$FF,d0
		beq.s	loc_14BC6
		movea.l	($FFFFF78C).w,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14C02
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14C02:
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C0A
		neg.b	(a4)

loc_14C0A:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF788).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C26
		neg.w	d0

loc_14C26:
		tst.w	d0
		beq.s	loc_14BC6
		bmi.s	loc_14C3C
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14C3C:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14BC6
		not.w	d1
		rts	
; End of function FindWall2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkSpeed:			; XREF: Sonic_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc_14D1A
		move.b	d1,d0
		bpl.s	loc_14D14
		subq.b	#1,d0

loc_14D14:
		addi.b	#$20,d0
		bra.s	loc_14D24
; ===========================================================================

loc_14D1A:
		move.b	d1,d0
		bpl.s	loc_14D20
		addq.b	#1,d0

loc_14D20:
		addi.b	#$1F,d0

loc_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc_14D3C
		addq.w	#8,d2

loc_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Sonic_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc2_14D1A
		move.b	d1,d0
		bpl.s	loc2_14D14
		subq.b	#1,d0

loc2_14D14:
		addi.b	#$20,d0
		bra.s	loc2_14D24
; ===========================================================================

loc2_14D1A:
		move.b	d1,d0
		bpl.s	loc2_14D20
		addq.b	#1,d0

loc2_14D20:
		addi.b	#$1F,d0

loc2_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc2_14D3C
		addq.w	#8,d2

loc2_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Silver_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc3_14D1A
		move.b	d1,d0
		bpl.s	loc3_14D14
		subq.b	#1,d0

loc3_14D14:
		addi.b	#$20,d0
		bra.s	loc3_14D24
; ===========================================================================

loc3_14D1A:
		move.b	d1,d0
		bpl.s	loc3_14D20
		addq.b	#1,d0

loc3_14D20:
		addi.b	#$1F,d0

loc3_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc3_14D3C
		addq.w	#8,d2

loc3_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Shadow_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc4_14D1A
		move.b	d1,d0
		bpl.s	loc4_14D14
		subq.b	#1,d0

loc4_14D14:
		addi.b	#$20,d0
		bra.s	loc4_14D24
; ===========================================================================

loc4_14D1A:
		move.b	d1,d0
		bpl.s	loc4_14D20
		addq.b	#1,d0

loc4_14D20:
		addi.b	#$1F,d0

loc4_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc4_14D3C
		addq.w	#8,d2

loc4_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Shadow_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14D48:				; XREF: Sonic_Jump
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD9).w,d5			; MJ: load L/R/B soldity bit
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		addi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_14FD6
		cmpi.b	#$80,d0
		beq.w	Sonic_DontRunOnWalls
		cmpi.b	#$C0,d0
		beq.w	sub_14E50

; End of function sub_14D48
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitFloor:				; XREF: Sonic_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

Sonic_HitFloor2:
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,($FFFFFFD8).w			; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:
		move.b	($FFFFFFD8).w,d5			; MJ: load L/R/B soldity bit
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc_14DDE:
		btst	#0,d3
		beq.s	locret_14DE6
		move.b	d2,d3

locret_14DE6:
		rts	

; End of function Sonic_HitFloor

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14DF0:				; XREF: Sonic_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E16
		move.b	d2,d3

locret_14E16:
		rts	

; ---------------------------------------------------------------------------
; Subroutine allowing objects to interact with the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor:
		move.w	8(a0),d3

; End of function ObjHitFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor2:
		move.w	$C(a0),d2
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		moveq	#$C,d5					; MJ: set solid type to check
		cmpi.b	#1,(a0)			; MJ: is the parent object Sonic?
		beq.s	@sonic				; MJ: if not, branch and only use first collision set
		cmpi.b	#2,(a0)			; MJ: is the parent object Sonic?
		beq.s	@sonic				; MJ: if not, branch and only use first collision set
		cmpi.b	#$8E,(a0)			; MJ: is the parent object Sonic?
		beq.s	@sonic				; MJ: if not, branch and only use first collision set
		bra.s	@notsonic

@sonic:
		move.b	($FFFFFFD8).w,d5			; MJ: load solid type to check
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,d5					; MJ: is second collision set to be used?
		beq.s	@first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
@first:	
@notsonic:
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3		; height of a 16x16 tile
		move.w	#0,d6
		bsr.w	FindFloor		; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E4E
		move.b	#0,d3

	locret_14E4E:
		rts	
; End of function ObjHitFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14E50:				; XREF: sub_14D48
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$40,d2
		bra.w	loc_14DD0

; End of function sub_14E50


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14EB4:				; XREF: Sonic_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14EBC:
		addi.w	#$A,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#-$40,d2
		bra.w	loc_14E0A

; End of function sub_14EB4

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallRight:
		add.w	8(a0),d3
		move.w	$C(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14F06
		move.b	#-$40,d3

locret_14F06:
		rts	

; End of function ObjHitWallRight

; ---------------------------------------------------------------------------
; Subroutine preventing	Sonic from running on walls and	ceilings when he
; touches them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_DontRunOnWalls:			; XREF: Sonic_Floor; et al
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$80,d2
		bra.w	loc_14DD0
; End of function Sonic_DontRunOnWalls

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14F7C:
		subi.w	#$A,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#-$80,d2
		bra.w	loc_14E0A

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitCeiling:
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14FD4
		move.b	#-$80,d3

locret_14FD4:
		rts	
; End of function ObjHitCeiling

; ===========================================================================

loc_14FD6:				; XREF: sub_14D48
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#$40,d2
		bra.w	loc_14DD0

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitWall:				; XREF: Sonic_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc_14E0A
; End of function Sonic_HitWall

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallLeft:
		add.w	8(a0),d3
		move.w	$C(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_15098
		move.b	#$40,d3

locret_15098:
		rts	
; End of function ObjHitWallLeft

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 66 - rotating disc that grabs Sonic (ABZ)
; ---------------------------------------------------------------------------

Obj66:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj66_Index(pc,d0.w),d1
		jmp	Obj66_Index(pc,d1.w)
; ===========================================================================
Obj66_Index:	dc.w Obj66_Main-Obj66_Index
		dc.w Obj66_Action-Obj66_Index
		dc.w Obj66_Display-Obj66_Index
		dc.w Obj66_Release-Obj66_Index
; ===========================================================================

Obj66_Main:				; XREF: Obj66_Index
		addq.b	#2,$24(a0)
		move.w	#1,d1
		movea.l	a0,a1
		bra.s	Obj66_MakeItem
; ===========================================================================

Obj66_Loop:
		jsr	SingleObjLoad
		bne.s	loc_150FE
		move.b	#$66,0(a1)
		addq.b	#4,$24(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	#$180,$18(a1)
		move.b	#$10,$1A(a1)

Obj66_MakeItem:				; XREF: Obj66_Main
		move.l	#Map_obj66,4(a1)
		move.w	#$4390,2(a1)
		ori.b	#4,1(a1)
		move.b	#$38,$14(a1)

loc_150FE:
		dbf	d1,Obj66_Loop

		move.b	#$30,$14(a0)
		move.w	#$200,$18(a0)
		move.w	#$3C,$30(a0)
		move.b	#1,$34(a0)
		move.b	$28(a0),$38(a0)

Obj66_Action:				; XREF: Obj66_Index
		bsr.w	Obj66_ChkSwitch
		tst.b	1(a0)
		bpl.w	Obj66_Display
		move.w	#$30,d1
		move.w	d1,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		jsr	SolidObject
		btst	#5,$22(a0)
		beq.w	Obj66_Display
		lea	($FFFFB000).w,a1
		moveq	#$E,d1
		move.w	8(a1),d0
		cmp.w	8(a0),d0
		bcs.s	Obj66_GrabSonic
		moveq	#7,d1

Obj66_GrabSonic:
		cmp.b	$1A(a0),d1
		bne.s	Obj66_Display
		move.b	d1,$32(a0)
		addq.b	#4,$24(a0)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#2,$1C(a1)	; make Sonic use "rolling" animation
		move.w	#$800,$20(a1)
		move.w	#0,$10(a1)
		move.w	#0,$12(a1)
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)
		bset	#1,$22(a1)
		move.w	8(a1),d2
		move.w	$C(a1),d3
		bsr.w	Obj66_ChgPos
		add.w	d2,8(a1)
		add.w	d3,$C(a1)
		asr	8(a1)
		asr	$C(a1)

Obj66_Display:				; XREF: Obj66_Index
		jmp	MarkObjGone
; ===========================================================================

Obj66_Release:				; XREF: Obj66_Index
		move.b	$1A(a0),d0
		cmpi.b	#4,d0
		beq.s	loc_151C8
		cmpi.b	#7,d0
		bne.s	loc_151F8

loc_151C8:
		cmp.b	$32(a0),d0
		beq.s	loc_151F8
		lea	($FFFFB000).w,a1
		move.w	#0,$10(a1)
		move.w	#$800,$12(a1)
		cmpi.b	#4,d0
		beq.s	loc_151F0
		move.w	#$800,$10(a1)
		move.w	#$800,$12(a1)

loc_151F0:
		clr.b	($FFFFF7C8).w	; unlock controls
		subq.b	#4,$24(a0)

loc_151F8:
		bsr.s	Obj66_ChkSwitch
		bsr.s	Obj66_ChgPos
		jmp	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChkSwitch:			; XREF: Obj66_Action
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$38(a0),d0
		btst	#0,(a2,d0.w)	; is switch pressed?
		beq.s	loc_15224	; if not, branch
		tst.b	$36(a0)		; has switch previously	been pressed?
		bne.s	Obj66_Animate	; if yes, branch
		neg.b	$34(a0)
		move.b	#1,$36(a0)	; set to "previously pressed"
		bra.s	Obj66_Animate
; ===========================================================================

loc_15224:
		clr.b	$36(a0)		; set to "not yet pressed"

Obj66_Animate:
		subq.b	#1,$23(a0)
		bpl.s	locret_15246
		move.b	#7,$23(a0)
		move.b	$34(a0),d1
		move.b	$1A(a0),d0
		add.b	d1,d0
		andi.b	#$F,d0
		move.b	d0,$1A(a0)

locret_15246:
		rts	
; End of function Obj66_ChkSwitch


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChgPos:				; XREF: Obj66_GrabSonic
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.b	$1A(a0),d0
		add.w	d0,d0
		lea	Obj66_PosData(pc,d0.w),a2
		move.b	(a2)+,d0
		ext.w	d0
		add.w	8(a0),d0
		move.w	d0,8(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	$C(a0),d0
		move.w	d0,$C(a1)
		rts	
; End of function Obj66_ChgPos

; ===========================================================================
Obj66_PosData:	dc.b  $E0,   0,	$E2,  $E ; disc	x-pos, Sonic x-pos, disc y-pos,	Sonic y-pos
		dc.b  $E8, $18,	$F2, $1E
		dc.b	0, $20,	 $E, $1E
		dc.b  $18, $18,	$1E,  $E
		dc.b  $20,   0,	$1E, $F2
		dc.b  $18, $E8,	 $E, $E2
		dc.b	0, $E0,	$F2, $E2
		dc.b  $E8, $E8,	$E2, $F2
; ---------------------------------------------------------------------------
; Sprite mappings - rotating disc that grabs Sonic (ABZ)
; ---------------------------------------------------------------------------
Map_obj66:
	include "_maps\obj66.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 67 - disc that	you run	around (ABZ)
; ---------------------------------------------------------------------------

Obj67:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj67_Index(pc,d0.w),d1
		jmp	Obj67_Index(pc,d1.w)
; ===========================================================================
Obj67_Index:	dc.w Obj67_Main-Obj67_Index
		dc.w Obj67_Action-Obj67_Index
; ===========================================================================

Obj67_Main:				; XREF: Obj67_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj67,4(a0)
		move.w	#$C344,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#8,$14(a0)
		move.w	8(a0),$32(a0)
		move.w	$C(a0),$30(a0)
		move.b	#$18,$34(a0)
		move.b	#$48,$38(a0)
		move.b	$28(a0),d1	; get object type
		andi.b	#$F,d1		; read only the	2nd digit
		beq.s	loc_15546
		move.b	#$10,$34(a0)
		move.b	#$38,$38(a0)

loc_15546:
		move.b	$28(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1
		move.w	d1,$36(a0)
		move.b	$22(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,$26(a0)

Obj67_Action:				; XREF: Obj67_Index
		bsr.w	Obj67_MoveSonic
		bsr.w	Obj67_MoveSpot
		bra.w	Obj67_ChkDel
; ===========================================================================

Obj67_MoveSonic:			; XREF: Obj67_Action
		moveq	#0,d2
		move.b	$38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	$32(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	loc_155A8
		move.w	$C(a1),d1
		sub.w	$30(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.s	loc_155A8
		btst	#1,$22(a1)
		beq.s	loc_155B8
		clr.b	$3A(a0)
		rts	
; ===========================================================================

loc_155A8:
		tst.b	$3A(a0)
		beq.s	locret_155B6
		clr.b	$38(a1)
		clr.b	$3A(a0)

locret_155B6:
		rts	
; ===========================================================================

loc_155B8:
		tst.b	$3A(a0)
		bne.s	loc_155E2
		move.b	#1,$3A(a0)
		btst	#2,$22(a1)
		bne.s	loc_155D0
		clr.b	$1C(a1)

loc_155D0:
		bclr	#5,$22(a1)
		move.b	#1,$1D(a1)
		move.b	#1,$38(a1)

loc_155E2:
		move.w	$20(a1),d0
		tst.w	$36(a0)
		bpl.s	loc_15608
		cmpi.w	#-$400,d0
		ble.s	loc_155FA
		move.w	#-$400,$20(a1)
		rts	
; ===========================================================================

loc_155FA:
		cmpi.w	#-$F00,d0
		bge.s	locret_15606
		move.w	#-$F00,$20(a1)

locret_15606:
		rts	
; ===========================================================================

loc_15608:
		cmpi.w	#$400,d0
		bge.s	loc_15616
		move.w	#$400,$20(a1)
		rts	
; ===========================================================================

loc_15616:
		cmpi.w	#$F00,d0
		ble.s	locret_15622
		move.w	#$F00,$20(a1)

locret_15622:
		rts	
; ===========================================================================

Obj67_MoveSpot:				; XREF: Obj67_Action
		move.w	$36(a0),d0
		add.w	d0,$26(a0)
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.w	$30(a0),d2
		move.w	$32(a0),d3
		moveq	#0,d4
		move.b	$34(a0),d4
		lsl.w	#8,d4
		move.l	d4,d5
		muls.w	d0,d4
		swap	d4
		muls.w	d1,d5
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,$C(a0)
		move.w	d5,8(a0)
		rts	
; ===========================================================================

Obj67_ChkDel:				; XREF: Obj67_Action
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#-$80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj67_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj67_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - disc that you run around (ABZ)
; (It's just a small blob that moves around in a circle. The disc itself is
; part of the level tiles.)
; ---------------------------------------------------------------------------
Map_obj67:
	include "_maps\obj67.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 68 - conveyor belts (ABZ)
; ---------------------------------------------------------------------------

Obj68:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj68_Index(pc,d0.w),d1
		jmp	Obj68_Index(pc,d1.w)
; ===========================================================================
Obj68_Index:	dc.w Obj68_Main-Obj68_Index
		dc.w Obj68_Action-Obj68_Index
; ===========================================================================

Obj68_Main:				; XREF: Obj68_Index
		addq.b	#2,$24(a0)
		move.b	#128,$38(a0)	; set width to 128 pixels
		move.b	$28(a0),d1	; get object type
		andi.b	#$F,d1		; read only the	2nd digit
		beq.s	loc_156BA	; if zero, branch
		move.b	#56,$38(a0)	; set width to 56 pixels

loc_156BA:
		move.b	$28(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asr.w	#4,d1
		move.w	d1,$36(a0)	; set belt speed

Obj68_Action:				; XREF: Obj68_Index
		bsr.s	Obj68_MoveSonic
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj68_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj68_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj68_Delete

Obj68_Done:
		rts	
; ===========================================================================

Obj68_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj68_MoveSonic:			; XREF: Obj68_Action
		btst 	#6,($FFFFFE2C).w
		bne.s 	Obj68_Bubble
		moveq	#0,d2
		move.b	$38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	locret_1572E
		move.w	$C(a1),d1
		sub.w	$C(a0),d1
		addi.w	#$30,d1
		cmpi.w	#$30,d1
		bcc.s	locret_1572E
		btst	#1,$22(a1)
		bne.s	locret_1572E
		move.w	$36(a0),d0
		add.w	d0,8(a1)
		rts

Obj68_Bubble:
		move.b	#2,$1C(a1)
		move.w	#$A00,$20(a1)

locret_1572E:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 69 - spinning platforms and trapdoors (ABZ)
; ---------------------------------------------------------------------------

Obj69:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj69_Index(pc,d0.w),d1
		jmp	Obj69_Index(pc,d1.w)
; ===========================================================================
Obj69_Index:	dc.w Obj69_Main-Obj69_Index
		dc.w Obj69_Trapdoor-Obj69_Index
		dc.w Obj69_Spinner-Obj69_Index
; ===========================================================================

Obj69_Main:				; XREF: Obj69_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj69,4(a0)
		move.w	#$4492,2(a0)
		ori.b	#4,1(a0)
		move.b	#$80,$14(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		mulu.w	#$3C,d0
		move.w	d0,$32(a0)
		tst.b	$28(a0)
		bpl.s	Obj69_Trapdoor
		addq.b	#2,$24(a0)
		move.l	#Map_obj69a,4(a0)
		move.w	#$4DF,2(a0)
		move.b	#$10,$14(a0)
		move.b	#2,$1C(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		move.w	d0,d1
		andi.w	#$F,d0		; read only the	2nd digit
		mulu.w	#6,d0		; multiply by 6
		move.w	d0,$30(a0)	; set time delay
		move.w	d0,$32(a0)
		andi.w	#$70,d1
		addi.w	#$10,d1
		lsl.w	#2,d1
		subq.w	#1,d1
		move.w	d1,$36(a0)
		bra.s	Obj69_Spinner
; ===========================================================================

Obj69_Trapdoor:				; XREF: Obj69_Index
		subq.w	#1,$30(a0)
		bpl.s	Obj69_Animate
		move.w	$32(a0),$30(a0)
		bchg	#0,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj69_Animate
		move.w	#$58,d0
		jsr	(PlaySound_Special).l ;	play door sound

Obj69_Animate:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	$1A(a0)		; is frame number 0 displayed?
		bne.s	Obj69_NotSolid	; if not, branch
		move.w	#$4B,d1
		move.w	#$C,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid:
		btst	#3,$22(a0)
		beq.s	Obj69_Display
		lea	($FFFFB000).w,a1
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)

Obj69_Display:
		jmp	MarkObjGone
; ===========================================================================

Obj69_Spinner:				; XREF: Obj69_Index
		move.w	($FFFFFE04).w,d0
		and.w	$36(a0),d0
		bne.s	Obj69_Delay
		move.b	#1,$34(a0)

Obj69_Delay:
		tst.b	$34(a0)
		beq.s	Obj69_Animate2
		subq.w	#1,$30(a0)
		bpl.s	Obj69_Animate2
		move.w	$32(a0),$30(a0)
		clr.b	$34(a0)
		bchg	#0,$1C(a0)

Obj69_Animate2:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	$1A(a0)		; check	if frame number	0 is displayed
		bne.s	Obj69_NotSolid2	; if not, branch
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid2:
		btst	#3,$22(a0)
		beq.s	Obj69_Display2
		lea	($FFFFB000).w,a1
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)

Obj69_Display2:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj69:
	include "_anim\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - trapdoor (ABZ)
; ---------------------------------------------------------------------------
Map_obj69:
	include "_maps\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spinning platforms (ABZ)
; ---------------------------------------------------------------------------
Map_obj69a:
	include "_maps\obj69a.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6A - ground saws and pizza cutters (ABZ)
; ---------------------------------------------------------------------------

Obj6A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6A_Index(pc,d0.w),d1
		jmp	Obj6A_Index(pc,d1.w)
; ===========================================================================
Obj6A_Index:	dc.w Obj6A_Main-Obj6A_Index
		dc.w Obj6A_Action-Obj6A_Index
; ===========================================================================

Obj6A_Main:				; XREF: Obj6A_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj6A,4(a0)
		move.w	#$43B5,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$20,$14(a0)
		move.w	8(a0),$3A(a0)
		move.w	$C(a0),$38(a0)
		cmpi.b	#3,$28(a0)
		bcc.s	Obj6A_Action
		move.b	#$A2,$20(a0)

Obj6A_Action:				; XREF: Obj6A_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj6A_TypeIndex(pc,d0.w),d1
		jsr	Obj6A_TypeIndex(pc,d1.w)
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj6A_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj6A_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj6A_Delete

Obj6A_Done:
		jmp	DisplaySprite
; ===========================================================================

Obj6A_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6A_TypeIndex:dc.w Obj6A_Type00-Obj6A_TypeIndex, Obj6A_Type01-Obj6A_TypeIndex
		dc.w Obj6A_Type02-Obj6A_TypeIndex, Obj6A_Type03-Obj6A_TypeIndex
		dc.w Obj6A_Type04-Obj6A_TypeIndex
; ===========================================================================

Obj6A_Type00:				; XREF: Obj6A_TypeIndex
		rts	
; ===========================================================================

Obj6A_Type01:				; XREF: Obj6A_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,$22(a0)
		beq.s	Obj6A_Animate01
		neg.w	d0
		add.w	d1,d0

Obj6A_Animate01:
		move.w	$3A(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)	; move saw sideways
		subq.b	#1,$23(a0)
		bpl.s	loc_15A46
		move.b	#2,$23(a0)	; time between frame changes
		bchg	#0,$1A(a0)	; change frame

loc_15A46:
		tst.b	1(a0)
		bpl.s	locret_15A60
		move.w	($FFFFFE04).w,d0
		andi.w	#$F,d0
		bne.s	locret_15A60
		move.w	#$D8,d0
		jsr	(PlaySound_Special).l ;	play saw sound

locret_15A60:
		rts	
; ===========================================================================

Obj6A_Type02:				; XREF: Obj6A_TypeIndex
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE64).w,d0
		btst	#0,$22(a0)
		beq.s	Obj6A_Animate02
		neg.w	d0
		addi.w	#$80,d0

Obj6A_Animate02:
		move.w	$38(a0),d1
		sub.w	d0,d1
		move.w	d1,$C(a0)	; move saw vertically
		subq.b	#1,$23(a0)
		bpl.s	loc_15A96
		move.b	#2,$23(a0)
		bchg	#0,$1A(a0)

loc_15A96:
		tst.b	1(a0)
		bpl.s	locret_15AB0
		move.b	($FFFFFE64).w,d0
		cmpi.b	#$18,d0
		bne.s	locret_15AB0
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play saw sound

locret_15AB0:
		rts	
; ===========================================================================

Obj6A_Type03:				; XREF: Obj6A_TypeIndex
		tst.b	$3D(a0)
		bne.s	Obj6A_Animate03
		move.w	($FFFFB008).w,d0
		subi.w	#$C0,d0
		bcs.s	loc_15B02
		sub.w	8(a0),d0
		bcs.s	loc_15B02
		move.w	($FFFFB00C).w,d0
		subi.w	#$80,d0
		cmp.w	$C(a0),d0
		bcc.s	locret_15B04
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcs.s	locret_15B04
		move.b	#1,$3D(a0)
		move.w	#$600,$10(a0)	; move object to the right
		move.b	#$A2,$20(a0)
		move.b	#2,$1A(a0)
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play saw sound

loc_15B02:
		addq.l	#4,sp

locret_15B04:
		rts	
; ===========================================================================

Obj6A_Animate03:			; XREF: ROM:00015AB6j
		jsr	SpeedToPos
		move.w	8(a0),$3A(a0)
		subq.b	#1,$23(a0)
		bpl.s	locret_15B24
		move.b	#2,$23(a0)
		bchg	#0,$1A(a0)

locret_15B24:
		rts	
; ===========================================================================

Obj6A_Type04:				; XREF: Obj6A_TypeIndex
		tst.b	$3D(a0)
		bne.s	Obj6A_Animate04
		move.w	($FFFFB008).w,d0
		addi.w	#$E0,d0
		sub.w	8(a0),d0
		bcc.s	loc_15B74
		move.w	($FFFFB00C).w,d0
		subi.w	#$80,d0
		cmp.w	$C(a0),d0
		bcc.s	locret_15B76
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcs.s	locret_15B76
		move.b	#1,$3D(a0)
		move.w	#-$600,$10(a0)	; move object to the left
		move.b	#$A2,$20(a0)
		move.b	#2,$1A(a0)
		move.w	#$DB,d0
		jsr	(PlaySound_Special).l ;	play saw sound

loc_15B74:
		addq.l	#4,sp

locret_15B76:
		rts	
; ===========================================================================

Obj6A_Animate04:
		jsr	SpeedToPos
		move.w	8(a0),$3A(a0)
		subq.b	#1,$23(a0)
		bpl.s	locret_15B96
		move.b	#2,$23(a0)
		bchg	#0,$1A(a0)

locret_15B96:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - ground saws	and pizza cutters (ABZ)
; ---------------------------------------------------------------------------
Map_obj6A:
	include "_maps\obj6A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6B - stomper (ABZ)
; ---------------------------------------------------------------------------

Obj6B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6B_Index(pc,d0.w),d1
		jmp	Obj6B_Index(pc,d1.w)
; ===========================================================================
Obj6B_Index:	dc.w Obj6B_Main-Obj6B_Index
		dc.w Obj6B_Action-Obj6B_Index

Obj6B_Var:	dc.b  $40,  $C,	$80,   1 ; width, height, ????,	type number
		dc.b  $1C, $20,	$38,   3
		dc.b  $1C, $20,	$40,   4
		dc.b  $1C, $20,	$60,   4
		dc.b  $80, $40,	  0,   5
; ===========================================================================

Obj6B_Main:				; XREF: Obj6B_Index
		addq.b	#2,$24(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj6B_Var(pc,d0.w),a3
		move.b	(a3)+,$14(a0)
		move.b	(a3)+,$16(a0)
		lsr.w	#2,d0
		move.b	d0,$1A(a0)
		move.l	#Map_obj6B,4(a0)
		move.w	#$22C0,2(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is TJZ/ABZ3
		bne.s	Obj6B_ABZ12	; if not, branch
		bset	#0,($FFFFF7CB).w
		beq.s	Obj6B_ABZ3

Obj6B_ChkGone:				; XREF: Obj6B_ABZ3
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   Obj6B_Delete   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

Obj6B_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj6B_ABZ3:				; XREF: Obj6B_Main
		move.w	#$41F0,2(a0)
		cmpi.w	#$A80,8(a0)
		bne.s	Obj6B_ABZ12
		move.w	$1E(a0),d0
		beq.s	Obj6B_ABZ12
		movea.w	d0,a2	; load address into a2
		btst	#0,(a2)
		beq.s	Obj6B_ABZ12
		clr.b	($FFFFF7CB).w
		bra.s	Obj6B_ChkGone
; ===========================================================================

Obj6B_ABZ12:				; XREF: Obj6B_Main
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.w	8(a0),$34(a0)
		move.w	$C(a0),$30(a0)
		moveq	#0,d0
		move.b	(a3)+,d0
		move.w	d0,$3C(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		bpl.s	Obj6B_Action
		andi.b	#$F,d0
		move.b	d0,$3E(a0)
		move.b	(a3),$28(a0)
		cmpi.b	#5,(a3)
		bne.s	Obj6B_ChkGone2
		bset	#4,1(a0)

Obj6B_ChkGone2:
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   Obj6B_Action   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

Obj6B_Action:				; XREF: Obj6B_Index
		move.w	8(a0),-(sp)
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj6B_TypeIndex(pc,d0.w),d1
		jsr	Obj6B_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	1(a0)
		bpl.s	Obj6B_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj6B_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_15D64
		jmp	DisplaySprite
; ===========================================================================

loc_15D64:
		cmpi.b	#1,($FFFFFE10).w
		bne.s	Obj6B_Delete2
		clr.b	($FFFFF7CB).w
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   Obj6B_Delete2   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

Obj6B_Delete2:
		jmp	DeleteObject
; ===========================================================================
Obj6B_TypeIndex:dc.w Obj6B_Type00-Obj6B_TypeIndex, Obj6B_Type01-Obj6B_TypeIndex
		dc.w Obj6B_Type02-Obj6B_TypeIndex, Obj6B_Type03-Obj6B_TypeIndex
		dc.w Obj6B_Type04-Obj6B_TypeIndex, Obj6B_Type05-Obj6B_TypeIndex
; ===========================================================================

Obj6B_Type00:				; XREF: Obj6B_TypeIndex
		rts	
; ===========================================================================

Obj6B_Type01:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15DB4
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_15DC2
		move.b	#1,$38(a0)

loc_15DB4:
		move.w	$3C(a0),d0
		cmp.w	$3A(a0),d0
		beq.s	loc_15DE0
		addq.w	#2,$3A(a0)

loc_15DC2:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_15DD4
		neg.w	d0
		addi.w	#$80,d0

loc_15DD4:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

loc_15DE0:
		addq.b	#1,$28(a0)
		move.w	#$B4,$36(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_15DC2
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		bra.s	loc_15DC2
; ===========================================================================

Obj6B_Type02:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15E14
		subq.w	#1,$36(a0)
		bne.s	loc_15E1E
		move.b	#1,$38(a0)

loc_15E14:
		tst.w	$3A(a0)
		beq.s	loc_15E3C
		subq.w	#2,$3A(a0)

loc_15E1E:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_15E30
		neg.w	d0
		addi.w	#$80,d0

loc_15E30:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,8(a0)
		rts	
; ===========================================================================

loc_15E3C:
		subq.b	#1,$28(a0)
		clr.b	$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_15E1E
		movea.w	d0,a2	; load address into a2
		bclr	#0,(a2)
		bra.s	loc_15E1E
; ===========================================================================

Obj6B_Type03:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15E7C
		tst.w	$3A(a0)
		beq.s	loc_15E6A
		subq.w	#1,$3A(a0)
		bra.s	loc_15E8E
; ===========================================================================

loc_15E6A:
		subq.w	#1,$36(a0)
		bpl.s	loc_15E8E
		move.w	#$3C,$36(a0)
		move.b	#1,$38(a0)

loc_15E7C:
		addq.w	#8,$3A(a0)
		move.w	$3A(a0),d0
		cmp.w	$3C(a0),d0
		bne.s	loc_15E8E
		clr.b	$38(a0)

loc_15E8E:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_15EA0
		neg.w	d0
		addi.w	#$38,d0

loc_15EA0:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

Obj6B_Type04:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15ED0
		tst.w	$3A(a0)
		beq.s	loc_15EBE
		subq.w	#8,$3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EBE:
		subq.w	#1,$36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,$36(a0)
		move.b	#1,$38(a0)

loc_15ED0:
		move.w	$3A(a0),d0
		cmp.w	$3C(a0),d0
		beq.s	loc_15EE0
		addq.w	#8,$3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EE0:
		subq.w	#1,$36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,$36(a0)
		clr.b	$38(a0)

loc_15EF0:
		move.w	$3A(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_15F02
		neg.w	d0
		addi.w	#$38,d0

loc_15F02:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,$C(a0)
		rts	
; ===========================================================================

Obj6B_Type05:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15F3E
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	locret_15F5C
		move.b	#1,$38(a0)
		move.w	$1E(a0),d0
		beq.s	loc_15F3E
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)

loc_15F3E:
		subi.l	#$10000,8(a0)
		addi.l	#$8000,$C(a0)
		move.w	8(a0),$34(a0)
		cmpi.w	#$980,8(a0)
		beq.s	loc_15F5E

locret_15F5C:
		rts	
; ===========================================================================

loc_15F5E:
		clr.b	$28(a0)
		clr.b	$38(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - stomper and	platforms (ABZ)
; ---------------------------------------------------------------------------
Map_obj6B:
	include "_maps\obj6B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6C - vanishing	platforms (ABZ)
; ---------------------------------------------------------------------------

Obj6C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6C_Index(pc,d0.w),d1
		jmp	Obj6C_Index(pc,d1.w)
; ===========================================================================
Obj6C_Index:	dc.w Obj6C_Main-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w loc_16068-Obj6C_Index
; ===========================================================================

Obj6C_Main:				; XREF: Obj6C_Index
		addq.b	#6,$24(a0)
		move.l	#Map_obj6C,4(a0)
		move.w	#$44C3,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		addq.w	#1,d0		; add 1
		lsl.w	#7,d0		; multiply by $80
		move.w	d0,d1
		subq.w	#1,d0
		move.w	d0,$30(a0)
		move.w	d0,$32(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; get object type
		andi.w	#$F0,d0		; read only the	1st digit
		addi.w	#$80,d1
		mulu.w	d1,d0
		lsr.l	#8,d0
		move.w	d0,$36(a0)
		subq.w	#1,d1
		move.w	d1,$38(a0)

loc_16068:				; XREF: Obj6C_Index
		move.w	($FFFFFE04).w,d0
		sub.w	$36(a0),d0
		and.w	$38(a0),d0
		bne.s	Obj6C_Animate
		subq.b	#4,$24(a0)
		bra.s	Obj6C_Vanish
; ===========================================================================

Obj6C_Animate:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		jmp	MarkObjGone
; ===========================================================================

Obj6C_Vanish:				; XREF: Obj6C_Index
		subq.w	#1,$30(a0)
		bpl.s	loc_160AA
		move.w	#127,$30(a0)
		tst.b	$1C(a0)
		beq.s	loc_160A4
		move.w	$32(a0),$30(a0)

loc_160A4:
		bchg	#0,$1C(a0)

loc_160AA:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		btst	#1,$1A(a0)	; has platform vanished?
		bne.s	Obj6C_NotSolid	; if yes, branch
		cmpi.b	#2,$24(a0)
		bne.s	loc_160D6
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(PlatformObject).l
		jmp	MarkObjGone
; ===========================================================================

loc_160D6:
		moveq	#0,d1
		move.b	$14(a0),d1
		jsr	(ExitPlatform).l
		move.w	8(a0),d2
		jsr	(MvSonicOnPtfm2).l
		jmp	MarkObjGone
; ===========================================================================

Obj6C_NotSolid:				; XREF: Obj6C_Vanish
		btst	#3,$22(a0)
		beq.s	Obj6C_Display
		lea	($FFFFB000).w,a1
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		move.b	#2,$24(a0)
		clr.b	$25(a0)

Obj6C_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6C:
	include "_anim\obj6C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - vanishing platforms	(ABZ)
; ---------------------------------------------------------------------------
Map_obj6C:
	include "_maps\obj6C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6E - electrocution orbs (ABZ)
; ---------------------------------------------------------------------------

Obj6E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6E_Index(pc,d0.w),d1
		jmp	Obj6E_Index(pc,d1.w)
; ===========================================================================
Obj6E_Index:	dc.w Obj6E_Main-Obj6E_Index
		dc.w Obj6E_Shock-Obj6E_Index
; ===========================================================================

Obj6E_Main:				; XREF: Obj6E_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj6E,4(a0)
		move.w	#$47E,2(a0)
		ori.b	#4,1(a0)
		move.b	#$28,$14(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; read object type
		lsl.w	#4,d0		; multiply by $10
		subq.w	#1,d0
		move.w	d0,$34(a0)

Obj6E_Shock:				; XREF: Obj6E_Index
		move.w	($FFFFFE04).w,d0
		and.w	$34(a0),d0
		bne.s	Obj6E_Animate
		move.b	#1,$1C(a0)	; run "shocking" animation
		tst.b	1(a0)
		bpl.s	Obj6E_Animate
		move.w	#$79,d0
		jsr	(PlaySound_Special).l ;	play electricity sound

Obj6E_Animate:
		lea	(Ani_obj6E).l,a1
		jsr	AnimateSprite
		move.b	#0,$20(a0)
		cmpi.b	#4,$1A(a0)	; is frame number 4 displayed?
		bne.s	Obj6E_Display	; if not, branch
		move.b	#$A4,$20(a0)	; if yes, make object hurt Sonic
		bset	#5,$2B(a0)

Obj6E_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6E:
	include "_anim\obj6E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - electrocution orbs (ABZ)
; ---------------------------------------------------------------------------
Map_obj6E:
	include "_maps\obj6E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6F - spinning platforms that move around a conveyor belt (ABZ)
; ---------------------------------------------------------------------------

Obj6F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj6F_Index(pc,d0.w),d1
		jsr	Obj6F_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj6F_Display
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj6F_Display	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	loc_1629A

Obj6F_Display:
		jmp	DisplaySprite
; ===========================================================================

loc_1629A:
		cmpi.b	#2,($FFFFFE11).w ; check if act	is 3
		bne.s	Obj6F_Act1or2	; if not, branch
		cmpi.w	#-$80,d0
		bcc.s	Obj6F_Display

Obj6F_Act1or2:
		move.b	$2F(a0),d0
		bpl.s	Obj6F_Delete
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)

Obj6F_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6F_Index:	dc.w Obj6F_Main-Obj6F_Index
		dc.w loc_163D8-Obj6F_Index
; ===========================================================================

Obj6F_Main:				; XREF: Obj6F_Index
		move.b	$28(a0),d0
		bmi.w	loc_16380
		addq.b	#2,$24(a0)
		move.l	#Map_obj69a,4(a0)
		move.w	#$4DF,2(a0)
		move.b	#$10,$14(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	off_164A6(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$38(a0)
		move.w	(a2)+,$30(a0)
		move.l	a2,$3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,$38(a0)
		move.b	#4,$3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_16356
		move.b	#1,$3B(a0)
		neg.b	$3A(a0)
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_16352
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16352
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_16352:
		move.b	d1,$38(a0)

loc_16356:
		move.w	(a2,d1.w),$34(a0)
		move.w	2(a2,d1.w),$36(a0)
		tst.w	d1
		bne.s	loc_1636C
		move.b	#1,$1C(a0)

loc_1636C:
		cmpi.w	#8,d1
		bne.s	loc_16378
		move.b	#0,$1C(a0)

loc_16378:
		jsr	Obj63_ChangeDir
		bra.w	loc_163D8
; ===========================================================================

loc_16380:				; XREF: Obj6F_Main
		move.b	d0,$2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		beq.s	loc_1639A
		jmp	DeleteObject
; ===========================================================================

loc_1639A:
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	(ObjPos_ABZ1pf_Index).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj6F_LoadPform
; ===========================================================================

Obj6F_Loop:
		jsr	SingleObjLoad
		bne.s	loc_163D0

Obj6F_LoadPform:			; XREF: loc_1639A
		move.b	#$6F,0(a1)
		move.w	(a2)+,8(a1)
		move.w	(a2)+,$C(a1)
		move.w	(a2)+,d0
		move.b	d0,$28(a1)

loc_163D0:
		dbf	d1,Obj6F_Loop

		addq.l	#4,sp
		rts	
; ===========================================================================

loc_163D8:				; XREF: Obj6F_Index
		lea	(Ani_obj6F).l,a1
		jsr	AnimateSprite
		tst.b	$1A(a0)
		bne.s	loc_16404
		move.w	8(a0),-(sp)
		bsr.w	loc_16424
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jmp	SolidObject
; ===========================================================================

loc_16404:
		btst	#3,$22(a0)
		beq.s	loc_16420
		lea	($FFFFB000).w,a1
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)

loc_16420:
		bra.w	*+4

loc_16424:
		move.w	8(a0),d0
		cmp.w	$34(a0),d0
		bne.s	loc_16484
		move.w	$C(a0),d0
		cmp.w	$36(a0),d0
		bne.s	loc_16484
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_16456
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16456
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_16456:
		move.b	d1,$38(a0)
		movea.l	$3C(a0),a1
		move.w	(a1,d1.w),$34(a0)
		move.w	2(a1,d1.w),$36(a0)
		tst.w	d1
		bne.s	loc_16474
		move.b	#1,$1C(a0)

loc_16474:
		cmpi.w	#8,d1
		bne.s	loc_16480
		move.b	#0,$1C(a0)

loc_16480:
		jsr	Obj63_ChangeDir

loc_16484:
		jmp	SpeedToPos
; ===========================================================================
Ani_obj6F:
	include "_anim\obj6F.asm"

off_164A6:	dc.w word_164B2-off_164A6, word_164C6-off_164A6, word_164DA-off_164A6
		dc.w word_164EE-off_164A6, word_16502-off_164A6, word_16516-off_164A6
word_164B2:	dc.w $10, $E80,	$E14, $370, $EEF, $302,	$EEF, $340, $E14, $3AE
word_164C6:	dc.w $10, $F80,	$F14, $2E0, $FEF, $272,	$FEF, $2B0, $F14, $31E
word_164DA:	dc.w $10, $1080, $1014,	$270, $10EF, $202, $10EF, $240,	$1014, $2AE
word_164EE:	dc.w $10, $F80,	$F14, $570, $FEF, $502,	$FEF, $540, $F14, $5AE
word_16502:	dc.w $10, $1B80, $1B14,	$670, $1BEF, $602, $1BEF, $640,	$1B14, $6AE
word_16516:	dc.w $10, $1C80, $1C14,	$5E0, $1CEF, $572, $1CEF, $5B0,	$1C14, $61E
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 70 - large girder block (ABZ)
; ---------------------------------------------------------------------------

Obj70:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj70_Index(pc,d0.w),d1
		jmp	Obj70_Index(pc,d1.w)
; ===========================================================================
Obj70_Index:	dc.w Obj70_Main-Obj70_Index
		dc.w Obj70_Action-Obj70_Index
; ===========================================================================

Obj70_Main:				; XREF: Obj70_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj70,4(a0)
		move.w	#$42F0,2(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$60,$14(a0)
		move.b	#$18,$16(a0)
		move.w	8(a0),$32(a0)
		move.w	$C(a0),$30(a0)
		bsr.w	Obj70_Move2

Obj70_Action:				; XREF: Obj70_Index
		move.w	8(a0),-(sp)
		tst.w	$3A(a0)
		beq.s	Obj70_Move
		subq.w	#1,$3A(a0)
		bne.s	Obj70_Solid

Obj70_Move:
		jsr	SpeedToPos
		subq.w	#1,$34(a0)	; subtract 1 from movement duration
		bne.s	Obj70_Solid	; if time remains, branch
		bsr.w	Obj70_Move2	; if time is zero, branch

Obj70_Solid:
		move.w	(sp)+,d4
		tst.b	1(a0)
		bpl.s	Obj70_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj70_ChkDel:
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj70_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj70_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj70_Delete

Obj70_Done:
		jmp	DisplaySprite
; ===========================================================================

Obj70_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj70_Move2:				; XREF: Obj70_Main
		move.b	$38(a0),d0
		andi.w	#$18,d0
		lea	(Obj70_MoveData).l,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,$10(a0)
		move.w	(a1)+,$12(a0)
		move.w	(a1)+,$34(a0)
		addq.b	#8,$38(a0)	; use next movedata set
		move.w	#7,$3A(a0)
		rts	
; ===========================================================================
Obj70_MoveData:	dc.w   $100,	 0,   $60,	 0 ; x-speed, y-speed, duration, blank
		dc.w	  0,  $100,   $30,	 0
		dc.w  $FF00, $FFC0,   $60,	 0
		dc.w	  0, $FF00,   $18,	 0
; ---------------------------------------------------------------------------
; Sprite mappings - large girder block (ABZ)
; ---------------------------------------------------------------------------
Map_obj70:
	include "_maps\obj70.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 72 - teleporter (ABZ)
; ---------------------------------------------------------------------------

Obj72:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj72_Index(pc,d0.w),d1
		jsr	Obj72_Index(pc,d1.w)
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj72_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj72_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj72_Delete

Obj72_Done:
		rts	
; ===========================================================================

Obj72_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj72_Index:	dc.w Obj72_Main-Obj72_Index
		dc.w loc_166C8-Obj72_Index
		dc.w loc_1675E-Obj72_Index
		dc.w loc_16798-Obj72_Index
; ===========================================================================

Obj72_Main:				; XREF: Obj72_Index
		addq.b	#2,$24(a0)
		move.b	$28(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj72_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$3A(a0)
		move.l	a2,$3C(a0)
		move.w	(a2)+,$36(a0)
		move.w	(a2)+,$38(a0)

loc_166C8:				; XREF: Obj72_Index
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_166E0
		addi.w	#$F,d0

loc_166E0:
		cmpi.w	#$10,d0
		bcc.s	locret_1675C
		move.w	$C(a1),d1
		sub.w	$C(a0),d1
		addi.w	#$20,d1
		cmpi.w	#$40,d1
		bcc.s	locret_1675C
		tst.b	($FFFFF7C8).w
		bne.s	locret_1675C
		cmpi.b	#7,$28(a0)
		bne.s	loc_1670E
		cmpi.w	#50,($FFFFFE20).w
		bcs.s	locret_1675C

loc_1670E:
		addq.b	#2,$24(a0)
		move.b	#$81,($FFFFF7C8).w ; lock controls
		move.b	#2,$1C(a1)	; use Sonic's rolling animation
		move.w	#$800,$20(a1)
		move.w	#0,$10(a1)
		move.w	#0,$12(a1)
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)
		bset	#1,$22(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		clr.b	$32(a0)
		move.w	#$53,d0
		jsr	(PlaySound_Special).l ;	play transporting sound

locret_1675C:
		rts	
; ===========================================================================

loc_1675E:				; XREF: Obj72_Index
		lea	($FFFFB000).w,a1
		move.b	$32(a0),d0
		addq.b	#1,$32(a0)
		jsr	(CalcSine).l
		asr.w	#5,d0
		move.w	$C(a0),d2
		sub.w	d0,d2
		move.w	d2,$C(a1)
		cmpi.b	#$98,$32(a0)
		bne.s	locret_16796
		bsr.w	sub_1681C
		addq.b	#2,$24(a0)
		move.w	#$54,d0
		jsr	(PlaySound_Special).l ;	play teleport sound

locret_16796:
		rts	
; ===========================================================================

loc_16798:				; XREF: Obj72_Index
		addq.l	#4,sp
		lea	($FFFFB000).w,a1
		subq.b	#1,$2E(a0)
		bpl.s	loc_167DA
		move.w	$36(a0),8(a1)
		move.w	$38(a0),$C(a1)
		moveq	#0,d1
		move.b	$3A(a0),d1
		addq.b	#4,d1
		cmp.b	$3B(a0),d1
		bcs.s	loc_167C2
		moveq	#0,d1
		bra.s	loc_16800
; ===========================================================================

loc_167C2:
		move.b	d1,$3A(a0)
		movea.l	$3C(a0),a2
		move.w	(a2,d1.w),$36(a0)
		move.w	2(a2,d1.w),$38(a0)
		bra.w	sub_1681C
; ===========================================================================

loc_167DA:
		move.l	8(a1),d2
		move.l	$C(a1),d3
		move.w	$10(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	$12(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,8(a1)
		move.l	d3,$C(a1)
		rts	
; ===========================================================================

loc_16800:
		andi.w	#$7FF,$C(a1)
		clr.b	$24(a0)
		clr.b	($FFFFF7C8).w
		move.w	#0,$10(a1)
		move.w	#$200,$12(a1)
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1681C:
		moveq	#0,d0
		move.w	#$1000,d2
		move.w	$36(a0),d0
		sub.w	8(a1),d0
		bge.s	loc_16830
		neg.w	d0
		neg.w	d2

loc_16830:
		moveq	#0,d1
		move.w	#$1000,d3
		move.w	$38(a0),d1
		sub.w	$C(a1),d1
		bge.s	loc_16844
		neg.w	d1
		neg.w	d3

loc_16844:
		cmp.w	d0,d1
		bcs.s	loc_1687A
		moveq	#0,d1
		move.w	$38(a0),d1
		sub.w	$C(a1),d1
		swap	d1
		divs.w	d3,d1
		moveq	#0,d0
		move.w	$36(a0),d0
		sub.w	8(a1),d0
		beq.s	loc_16866
		swap	d0
		divs.w	d1,d0

loc_16866:
		move.w	d0,$10(a1)
		move.w	d3,$12(a1)
		tst.w	d1
		bpl.s	loc_16874
		neg.w	d1

loc_16874:
		move.w	d1,$2E(a0)
		rts	
; ===========================================================================

loc_1687A:
		moveq	#0,d0
		move.w	$36(a0),d0
		sub.w	8(a1),d0
		swap	d0
		divs.w	d2,d0
		moveq	#0,d1
		move.w	$38(a0),d1
		sub.w	$C(a1),d1
		beq.s	loc_16898
		swap	d1
		divs.w	d0,d1

loc_16898:
		move.w	d1,$12(a1)
		move.w	d2,$10(a1)
		tst.w	d0
		bpl.s	loc_168A6
		neg.w	d0

loc_168A6:
		move.w	d0,$2E(a0)
		rts	
; End of function sub_1681C

; ===========================================================================
Obj72_Data:	dc.w word_168BC-Obj72_Data, word_168C2-Obj72_Data, word_168C8-Obj72_Data
		dc.w word_168E6-Obj72_Data, word_168EC-Obj72_Data, word_1690A-Obj72_Data
		dc.w word_16910-Obj72_Data, word_1692E-Obj72_Data
word_168BC:	dc.w 4,	$794, $98C
word_168C2:	dc.w 4,	$94, $38C
word_168C8:	dc.w $1C, $794,	$2E8
		dc.w $7A4, $2C0, $7D0
		dc.w $2AC, $858, $2AC
		dc.w $884, $298, $894
		dc.w $270, $894, $190
word_168E6:	dc.w 4,	$894, $690
word_168EC:	dc.w $1C, $1194, $470
		dc.w $1184, $498, $1158
		dc.w $4AC, $FD0, $4AC
		dc.w $FA4, $4C0, $F94
		dc.w $4E8, $F94, $590
word_1690A:	dc.w 4,	$1294, $490
word_16910:	dc.w $1C, $1594, $FFE8
		dc.w $1584, $FFC0, $1560
		dc.w $FFAC, $14D0, $FFAC
		dc.w $14A4, $FF98, $1494
		dc.w $FF70, $1494, $FD90
word_1692E:	dc.w 4,	$894, $90
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 78 - Caterkiller enemy	(DDZ, ABZ)
; ---------------------------------------------------------------------------

Obj78:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj78_Index(pc,d0.w),d1
		jmp	Obj78_Index(pc,d1.w)
; ===========================================================================
Obj78_Index:	dc.w Obj78_Main-Obj78_Index
		dc.w Obj78_Action-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_BodySeg2-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_Delete-Obj78_Index
		dc.w loc_16CC0-Obj78_Index
; ===========================================================================

locret_16950:
		rts	
; ===========================================================================

Obj78_Main:				; XREF: Obj78_Index
		move.b	#7,$16(a0)
		move.b	#8,$17(a0)
		jsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_16950
		add.w	d1,$C(a0)
		clr.w	$12(a0)
		addq.b	#2,$24(a0)
		move.l	#Map_obj78,4(a0)
		move.w	#$22B0,2(a0)
		cmpi.b	#5,($FFFFFE10).w ; if level is ABZ, branch
		beq.s	loc_16996
		move.w	#$24FF,2(a0)	; DDZ specific code

loc_16996:
		andi.b	#3,1(a0)
		ori.b	#4,1(a0)
		move.b	1(a0),$22(a0)
		move.w	#$200,$18(a0)
		move.b	#8,$14(a0)
		move.b	#$B,$20(a0)
		move.w	8(a0),d2
		moveq	#$C,d5
		btst	#0,$22(a0)
		beq.s	loc_169CA
		neg.w	d5

loc_169CA:
		move.b	#4,d6
		moveq	#0,d3
		moveq	#4,d4
		movea.l	a0,a2
		moveq	#2,d1

Obj78_LoadBody:
		jsr	SingleObjLoad2
		bne.s	Obj78_QuitLoad
		move.b	#$78,0(a1)	; load body segment object
		move.b	d6,$24(a1)
		addq.b	#2,d6
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		move.w	#$280,$18(a1)
		move.b	#8,$14(a1)
		move.b	#$CB,$20(a1)
		add.w	d5,d2
		move.w	d2,8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$22(a0),$22(a1)
		move.b	$22(a0),1(a1)
		move.b	#8,$1A(a1)
		move.l	a2,$3C(a1)
		move.b	d4,$3C(a1)
		addq.b	#4,d4
		movea.l	a1,a2

Obj78_QuitLoad:
		dbf	d1,Obj78_LoadBody ; repeat sequence 2 more times

		move.b	#7,$2A(a0)
		clr.b	$3C(a0)

Obj78_Action:				; XREF: Obj78_Index
		tst.b	$22(a0)
		bmi.w	loc_16C96
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj78_Index2(pc,d0.w),d1
		jsr	Obj78_Index2(pc,d1.w)
		move.b	$2B(a0),d1
		bpl.s	Obj78_Display
		lea	(Ani_obj78).l,a1
		move.b	$26(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,$26(a0)
		move.b	(a1,d0.w),d0
		bpl.s	Obj78_AniHead
		bclr	#7,$2B(a0)
		bra.s	Obj78_Display
; ===========================================================================

Obj78_AniHead:
		andi.b	#$10,d1
		add.b	d1,d0
		move.b	d0,$1A(a0)

Obj78_Display:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================

Obj78_ChkGone:
        move.w  $1E(a0),d0    ; get address in respawn table
        beq.s   loc_16ABC   ; if it's zero, object was placed in debug mode
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again

loc_16ABC:
		move.b	#$A,$24(a0)	; run "Obj78_Delete" routine
		rts	
; ===========================================================================

Obj78_Delete:				; XREF: Obj78_Index
		jmp	DeleteObject
; ===========================================================================
Obj78_Index2:	dc.w Obj78_Move-Obj78_Index2
		dc.w loc_16B02-Obj78_Index2
; ===========================================================================

Obj78_Move:				; XREF: Obj78_Index2
		subq.b	#1,$2A(a0)
		bmi.s	Obj78_Move2
		rts	
; ===========================================================================

Obj78_Move2:
		addq.b	#2,$25(a0)
		move.b	#$10,$2A(a0)
		move.w	#-$C0,$10(a0)
		move.w	#$40,$1C(a0)
		bchg	#4,$2B(a0)
		bne.s	loc_16AFC
		clr.w	$10(a0)
		neg.w	$1C(a0)

loc_16AFC:
		bset	#7,$2B(a0)

loc_16B02:				; XREF: Obj78_Index2
		subq.b	#1,$2A(a0)
		bmi.s	loc_16B5E
		move.l	8(a0),-(sp)
		move.l	8(a0),d2
		move.w	$10(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_16B1E
		neg.w	d0

loc_16B1E:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,8(a0)
		jsr	ObjHitFloor
		move.l	(sp)+,d2
		cmpi.w	#-8,d1
		blt.s	loc_16B70
		cmpi.w	#$C,d1
		bge.s	loc_16B70
		add.w	d1,$C(a0)
		swap	d2
		cmp.w	8(a0),d2
		beq.s	locret_16B5C
		moveq	#0,d0
		move.b	$3C(a0),d0
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		move.b	d1,$2C(a0,d0.w)

locret_16B5C:
		rts	
; ===========================================================================

loc_16B5E:
		subq.b	#2,$25(a0)
		move.b	#7,$2A(a0)
		move.w	#0,$10(a0)
		rts	
; ===========================================================================

loc_16B70:
		move.l	d2,8(a0)
		bchg	#0,$22(a0)
		move.b	$22(a0),1(a0)
		moveq	#0,d0
		move.b	$3C(a0),d0
		move.b	#$80,$2C(a0,d0.w)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		rts	
; ===========================================================================

Obj78_BodySeg2:				; XREF: Obj78_Index
		movea.l	$3C(a0),a1
		move.b	$2B(a1),$2B(a0)
		bpl.s	Obj78_BodySeg1
		lea	(Ani_obj78).l,a1
		move.b	$26(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,$26(a0)
		tst.b	4(a1,d0.w)
		bpl.s	Obj78_AniBody
		addq.b	#4,$26(a0)

Obj78_AniBody:
		move.b	(a1,d0.w),d0
		addq.b	#8,d0
		move.b	d0,$1A(a0)

Obj78_BodySeg1:				; XREF: Obj78_Index
		movea.l	$3C(a0),a1
		tst.b	$22(a0)
		bmi.w	loc_16C90
		move.b	$2B(a1),$2B(a0)
		move.b	$25(a1),$25(a0)
		beq.w	loc_16C64
		move.w	$1C(a1),$1C(a0)
		move.w	$10(a1),d0
		add.w	$1C(a1),d0
		move.w	d0,$10(a0)
		move.l	8(a0),d2
		move.l	d2,d3
		move.w	$10(a0),d0
		btst	#0,$22(a0)
		beq.s	loc_16C0C
		neg.w	d0

loc_16C0C:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,8(a0)
		swap	d3
		cmp.w	8(a0),d3
		beq.s	loc_16C64
		moveq	#0,d0
		move.b	$3C(a0),d0
		move.b	$2C(a1,d0.w),d1
		cmpi.b	#-$80,d1
		bne.s	loc_16C50
		swap	d3
		move.l	d3,8(a0)
		move.b	d1,$2C(a0,d0.w)
		bchg	#0,$22(a0)
		move.b	$22(a0),1(a0)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		bra.s	loc_16C64
; ===========================================================================

loc_16C50:
		ext.w	d1
		add.w	d1,$C(a0)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		move.b	d1,$2C(a0,d0.w)

loc_16C64:
		cmpi.b	#$C,$24(a1)
		beq.s	loc_16C90
		cmpi.b	#$27,0(a1)
		beq.s	loc_16C7C
		cmpi.b	#$A,$24(a1)
		bne.s	loc_16C82

loc_16C7C:
		move.b	#$A,$24(a0)

loc_16C82:
		jmp	DisplaySprite

; ===========================================================================
Obj78_FragSpeed:dc.w $FE00, $FE80, $180, $200
; ===========================================================================

loc_16C90:
		bset	#7,$22(a1)

loc_16C96:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj78_FragSpeed-2(pc,d0.w),d0
		btst	#0,$22(a0)
		beq.s	loc_16CAA
		neg.w	d0

loc_16CAA:
		move.w	d0,$10(a0)
		move.w	#-$400,$12(a0)
		move.b	#$C,$24(a0)
		andi.b	#-8,$1A(a0)

loc_16CC0:				; XREF: Obj78_Index
		jsr	ObjectFall
		tst.w	$12(a0)
		bmi.s	loc_16CE0
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_16CE0
		add.w	d1,$C(a0)
		move.w	#-$400,$12(a0)

loc_16CE0:
		tst.b	1(a0)
		bpl.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================
Ani_obj78:
	include "_anim\obj78.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Caterkiller	enemy (DDZ, ABZ)
; ---------------------------------------------------------------------------
Map_obj78:
	include "_maps\obj78.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 79 - lamppost
; ---------------------------------------------------------------------------

Obj79:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj79_Index(pc,d0.w),d1
		jsr	Obj79_Index(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
Obj79_Index:	dc.w Obj79_Main-Obj79_Index
		dc.w Obj79_BlueLamp-Obj79_Index
		dc.w Obj79_AfterHit-Obj79_Index
		dc.w Obj79_Twirl-Obj79_Index
		dc.w Obj79_Animate-Obj79_Index
; ===========================================================================

Obj79_Main:				; XREF: Obj79_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj79,4(a0)
		move.w	#$47C,2(a0)
		move.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$280,$18(a0)
        move.w  $1E(a0),d0    ; get address in respawn table
        movea.w d0,a2   ; load address into a2
        bclr    #7,(a2) ; clear respawn entry, so object can be loaded again
		btst	#0,(a2)
		bne.s	Obj79_RedLamp
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	$28(a0),d2	; get lamppost number
		andi.b	#$7F,d2
		cmp.b	d2,d1		; is lamppost number higher than the number hit?
		bcs.s	Obj79_BlueLamp	; if yes, branch

Obj79_RedLamp:
		bset	#0,2(a2,d0.w)
		move.b	#8,$24(a0)
		rts
; ===========================================================================

Obj79_BlueLamp:				; XREF: Obj79_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret_16F90	; if yes, branch
		tst.b	($FFFFF7C8).w
		bmi.w	locret_16F90
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	$28(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		bcs.s	Obj79_HitLamp
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		move.b	#4,$24(a0)
		move.b	#3,$1A(a0)
		bra.w	locret_16F90
; ===========================================================================

Obj79_HitLamp:
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		addq.w	#8,d0
		cmpi.w	#$10,d0
		bcc.w	locret_16F90
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$68,d0
		bcc.s	locret_16F90
		move.w	#$63,d0
		jsr	(PlaySound_Special).l ;	play lamppost sound
		addq.b	#2,$24(a0)
		jsr	SingleObjLoad
		bne.s	loc_16F76
		move.b	#$79,0(a1)	; load twirling	lamp object
		move.b	#6,$24(a1)	; use "Obj79_Twirl" routine
		move.w	8(a0),$30(a1)
		move.w	$C(a0),$32(a1)
		subi.w	#$18,$32(a1)
		move.l	#Map_obj79,4(a1)
		move.w	#$47C,2(a1)
		move.b	#4,1(a1)
		move.b	#8,$14(a1)
		move.w	#$200,$18(a1)
		move.b	#4,$1A(a1)
		move.w	#$20,$36(a1)

loc_16F76:
		move.b	#1,$1A(a0)	; use "post only" frame, with no lamp
		bsr.w	Obj79_StoreInfo
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)

locret_16F90:
		rts	
; ===========================================================================

Obj79_AfterHit:				; XREF: Obj79_Index
		rts	
; ===========================================================================

Obj79_Twirl:				; XREF: Obj79_Index
		subq.w	#1,$36(a0)
		bpl.s	loc_16FA0
		move.b	#1,$1C(a0)
		move.b	#8,$24(a0)

loc_16FA0:
		move.b	$26(a0),d0
		subi.b	#$10,$26(a0)
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$C00,d1
		swap	d1
		add.w	$30(a0),d1
		move.w	d1,8(a0)
		muls.w	#$C00,d0
		swap	d0
		add.w	$32(a0),d0
		move.w	d0,$C(a0)
		rts	

Obj79_Animate:
		lea	(Ani_obj79).l,a1
		jmp	AnimateSprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	store information when you hit a lamppost
; ---------------------------------------------------------------------------

Obj79_StoreInfo:			; XREF: Obj79_HitLamp
		move.b	$28(a0),($FFFFFE30).w 		; lamppost number
		move.b	($FFFFFE30).w,($FFFFFE31).w
		move.w	8(a0),($FFFFFE32).w		; x-position
		move.w	$C(a0),($FFFFFE34).w		; y-position
		move.w	($FFFFFE20).w,($FFFFFE36).w 	; rings
		move.b	($FFFFFE1B).w,($FFFFFE54).w 	; lives
		move.l	($FFFFFE22).w,($FFFFFE38).w 	; time
		move.b	($FFFFF742).w,($FFFFFE3C).w 	; routine counter for dynamic level mod
		move.w	($FFFFF72E).w,($FFFFFE3E).w 	; lower y-boundary of level
		move.w	($FFFFF700).w,($FFFFFE40).w 	; screen x-position
		move.w	($FFFFF704).w,($FFFFFE42).w 	; screen y-position
		move.w	($FFFFF708).w,($FFFFFE44).w 	; bg position
		move.w	($FFFFF70C).w,($FFFFFE46).w 	; bg position
		move.w	($FFFFF710).w,($FFFFFE48).w 	; bg position
		move.w	($FFFFF714).w,($FFFFFE4A).w 	; bg position
		move.w	($FFFFF718).w,($FFFFFE4C).w 	; bg position
		move.w	($FFFFF71C).w,($FFFFFE4E).w 	; bg position
		move.w	($FFFFF648).w,($FFFFFE50).w 	; water height
		move.b	($FFFFF64D).w,($FFFFFE52).w 	; rountine counter for water
		move.b	($FFFFF64E).w,($FFFFFE53).w 	; water direction
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load stored info when you start	a level	from a lamppost
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj79_LoadInfo:				; XREF: LevelSizeLoad
		move.b	($FFFFFE31).w,($FFFFFE30).w
		move.w	($FFFFFE32).w,($FFFFB008).w
		move.w	($FFFFFE34).w,($FFFFB00C).w
		move.w	($FFFFFE36).w,($FFFFFE20).w
		move.b	($FFFFFE54).w,($FFFFFE1B).w
		clr.w	($FFFFFE20).w
		clr.b	($FFFFFE1B).w
		move.l	($FFFFFE38).w,($FFFFFE22).w
		move.b	#59,($FFFFFE25).w
		subq.b	#1,($FFFFFE24).w
		move.b	($FFFFFE3C).w,($FFFFF742).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.w	($FFFFFE3E).w,($FFFFF72E).w
		move.w	($FFFFFE3E).w,($FFFFF726).w
		move.w	($FFFFFE40).w,($FFFFF700).w
		move.w	($FFFFFE42).w,($FFFFF704).w
		move.w	($FFFFFE44).w,($FFFFF708).w
		move.w	($FFFFFE46).w,($FFFFF70C).w
		move.w	($FFFFFE48).w,($FFFFF710).w
		move.w	($FFFFFE4A).w,($FFFFF714).w
		move.w	($FFFFFE4C).w,($FFFFF718).w
		move.w	($FFFFFE4E).w,($FFFFF71C).w
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_170E4
		move.w	($FFFFFE50).w,($FFFFF648).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.b	($FFFFFE53).w,($FFFFF64E).w

loc_170E4:
		tst.b	($FFFFFE30).w
		bpl.s	locret_170F6
		move.w	($FFFFFE32).w,d0
		subi.w	#$A0,d0
		move.w	d0,($FFFFF728).w

locret_170F6:
		rts	
; End of function Obj79_LoadInfo

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamppost
; ---------------------------------------------------------------------------
Map_obj79:
	include "_maps\obj79.asm"

Ani_obj79:
	include "_anim\obj79.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7D - hidden points at the end of a level
; ---------------------------------------------------------------------------

Obj7D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7D_Index(pc,d0.w),d1
		jmp	Obj7D_Index(pc,d1.w)
; ===========================================================================
Obj7D_Index:	dc.w Obj7D_Main-Obj7D_Index
		dc.w Obj7D_DelayDel-Obj7D_Index
; ===========================================================================

Obj7D_Main:				; XREF: Obj7D_Index
		moveq	#$10,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	Obj7D_ChkDel
		move.w	$C(a1),d1
		sub.w	$C(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.s	Obj7D_ChkDel
		tst.w	($FFFFFE08).w
		bne.s	Obj7D_ChkDel
		tst.b	($FFFFF7CD).w
		bne.s	Obj7D_ChkDel
		addq.b	#2,$24(a0)
		move.l	#Map_obj7D,4(a0)
		move.w	#$84B6,2(a0)
		ori.b	#4,1(a0)
		move.w	#0,$18(a0)
		move.b	#$10,$14(a0)
		move.b	$28(a0),$1A(a0)
		move.w	#119,$30(a0)	; set display time to 2	seconds
		move.w	#$5B,d0
		jsr	(PlaySound_Special).l ;	play bonus sound
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	Obj7D_Points(pc,d0.w),d0 ; load	bonus points array
		jsr	AddPoints

Obj7D_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj7D_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj7D_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj7D_Delete

Obj7D_Done:
		rts	
; ===========================================================================

Obj7D_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj7D_Points:	dc.w 0			; Bonus	points array
		dc.w 1000
		dc.w 100
		dc.w 1
; ===========================================================================

Obj7D_DelayDel:				; XREF: Obj7D_Index
		subq.w	#1,$30(a0)	; subtract 1 from display time
		bmi.s	Obj7D_Delete2	; if time is zero, branch
		move.w	8(a0),d0
		andi.w	#-$80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#-$80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj7D_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj7D_Delete2:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - hidden points at the end of	a level
; ---------------------------------------------------------------------------
Map_obj7D:
	include "_maps\obj7D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8A - "SONIC TEAM PRESENTS" and	credits
; ---------------------------------------------------------------------------

Obj8A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8A_Index(pc,d0.w),d1
		jmp	Obj8A_Index(pc,d1.w)
; ===========================================================================
Obj8A_Index:	dc.w Obj8A_Main-Obj8A_Index
		dc.w Obj8A_Display-Obj8A_Index
; ===========================================================================

Obj8A_Main:				; XREF: Obj8A_Index
		addq.b	#2,$24(a0)
		move.w	#$120,8(a0)
		move.w	#$F0,$A(a0)
		move.l	#Map_obj8A,4(a0)
		move.w	#$5A0,2(a0)
		move.w	($FFFFFFF4).w,d0 ; load	credits	index number
		move.b	d0,$1A(a0)	; display appropriate sprite
		move.b	#0,1(a0)
		move.w	#0,$18(a0)
		cmpi.b	#4,($FFFFF600).w ; is the scene	number 04 (title screen)?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$A6,2(a0)
		move.b	#$A,$1A(a0)	; display "SONIC TEAM PRESENTS"
		tst.b	($FFFFFFE3).w	; is hidden credits cheat on?
		beq.s	Obj8A_Display	; if not, branch
		cmpi.b	#$72,($FFFFF604).w ; is	Start+A+C+Down being pressed?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$EEE,($FFFFFBC0).w ; 3rd pallet, 1st entry = white
		move.w	#$880,($FFFFFBC2).w ; 3rd pallet, 2nd entry = cyan
		jmp	DeleteObject
; ===========================================================================

Obj8A_Display:				; XREF: Obj8A_Index
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - "SONIC TEAM	PRESENTS" and credits
; ---------------------------------------------------------------------------
Map_obj8A:
	include "_maps\obj8A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3D - Eggman (WOZ)
; ---------------------------------------------------------------------------

Obj3D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3D_Index(pc,d0.w),d1
		jmp	Obj3D_Index(pc,d1.w)
; ===========================================================================
Obj3D_Index:	dc.w Obj3D_Main-Obj3D_Index
		dc.w Obj3D_ShipMain-Obj3D_Index
		dc.w Obj3D_FaceMain-Obj3D_Index
		dc.w Obj3D_FlameMain-Obj3D_Index

Obj3D_ObjData:	dc.b 2,	0		; routine counter, animation
		dc.b 4,	1
		dc.b 6,	7
; ===========================================================================

Obj3D_Main:				; XREF: Obj3D_Index
		lea	(Obj3D_ObjData).l,a2
		movea.l	a0,a1
		moveq	#2,d1
		bra.s	Obj3D_LoadBoss
; ===========================================================================

Obj3D_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_17772

Obj3D_LoadBoss:				; XREF: Obj3D_Main
		move.b	(a2)+,$24(a1)
		move.b	#$3D,0(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.l	#Map_Eggman,4(a1)
		move.w	#$300,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.w	#$180,$18(a1)
		move.b	(a2)+,$1C(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj3D_Loop	; repeat sequence 2 more times

loc_17772:
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$F,$20(a0)
		move.b	#8,$21(a0)	; set number of	hits to	8

Obj3D_ShipMain:				; XREF: Obj3D_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj3D_ShipIndex(pc,d0.w),d1
		jsr	Obj3D_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		move.b	$22(a0),d0
		andi.b	#3,d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj3D_ShipIndex:dc.w Obj3D_ShipStart-Obj3D_ShipIndex
		dc.w Obj3D_MakeBall-Obj3D_ShipIndex
		dc.w Obj3D_ShipMove-Obj3D_ShipIndex
		dc.w loc_17954-Obj3D_ShipIndex
		dc.w loc_1797A-Obj3D_ShipIndex
		dc.w loc_179AC-Obj3D_ShipIndex
		dc.w loc_179F6-Obj3D_ShipIndex
; ===========================================================================

Obj3D_ShipStart:			; XREF: Obj3D_ShipIndex
		move.w	#$100,$12(a0)	; move ship down
		bsr.w	BossMove
		cmpi.w	#$280,$38(a0)
		bne.s	loc_177E6
		move.w	#0,$12(a0)	; stop ship
		addq.b	#2,$25(a0)	; goto next routine

loc_177E6:
		move.b	$3F(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$38(a0),d0
		move.w	d0,$C(a0)
		move.w	$30(a0),8(a0)
		addq.b	#2,$3F(a0)
		cmpi.b	#8,$25(a0)
		bcc.s	locret_1784A
		tst.b	$22(a0)
		bmi.s	loc_1784C
		tst.b	$20(a0)
		bne.s	locret_1784A
		tst.b	$3E(a0)
		bne.s	Obj3D_ShipFlash
		move.b	#$20,$3E(a0)	; set number of	times for ship to flash
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound

Obj3D_ShipFlash:
		lea	($FFFFFB22).w,a1 ; load	1st pallet, 2nd	entry
		move.w	#0,d0		; move 0 (black) to d0
		tst.w	(a1)
		bne.s	loc_1783C
		move.w	#$EEE,d0	; move 0EEE (white) to d0

loc_1783C:
		move.w	d0,(a1)		; load colour stored in	d0
		subq.b	#1,$3E(a0)
		bne.s	locret_1784A
		move.b	#$F,$20(a0)

locret_1784A:
		rts	

; ===========================================================================

loc_1784C:				; XREF: loc_177E6
		moveq	#100,d0
		bsr.w	AddPoints
		move.b	#8,$25(a0)
		move.w	#$B3,$3C(a0)
		rts	

; ---------------------------------------------------------------------------
; Defeated boss	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossDefeated:
		move.b	($FFFFFE0F).w,d0
		andi.b	#7,d0
		bne.s	locret_178A2
		jsr	SingleObjLoad
		bne.s	locret_178A2
		move.b	#$3F,0(a1)	; load explosion object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,8(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,$C(a1)

locret_178A2:
	;	cmpi.w	#$502,($FFFFFE10).w ; is level FZ (ABZ3) ?
	;	beq.s locret_178A2  ; if yes, branch
	;	clr.b	($FFFFFE1E).w	; stop time counter
		rts	
; End of function BossDefeated

; ---------------------------------------------------------------------------
; Subroutine to	move a boss
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossMove:
		move.l	$30(a0),d2
		move.l	$38(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$30(a0)
		move.l	d3,$38(a0)
		rts	
; End of function BossMove

; ===========================================================================

Obj3D_MakeBall:				; XREF: Obj3D_ShipIndex
		move.w	#-$100,$10(a0)
		move.w	#-$40,$12(a0)
		bsr.w	BossMove
		cmpi.w	#$18A0,$30(a0)
		bne.s	loc_17916
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		addq.b	#2,$25(a0)
		jsr	SingleObjLoad2
		bne.s	loc_17910
		move.b	#$48,0(a1)	; load swinging	ball object
		move.w	$30(a0),8(a1)
		move.w	$38(a0),$C(a1)
		move.l	a0,$34(a1)

loc_17910:
		move.w	#$77,$3C(a0)

loc_17916:
		bra.w	loc_177E6
; ===========================================================================

Obj3D_ShipMove:				; XREF: Obj3D_ShipIndex
		subq.w	#1,$3C(a0)
		bpl.s	Obj3D_Reverse
		addq.b	#2,$25(a0)
		move.w	#$3F,$3C(a0)
		move.w	#$100,$10(a0)	; move the ship	sideways
		cmpi.w	#$18A0,$30(a0)
		bne.s	Obj3D_Reverse
		move.w	#$7F,$3C(a0)
		move.w	#$40,$10(a0)

Obj3D_Reverse:
		btst	#0,$22(a0)
		bne.s	loc_17950
		neg.w	$10(a0)		; reverse direction of the ship

loc_17950:
		bra.w	loc_177E6
; ===========================================================================

loc_17954:				; XREF: Obj3D_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_17960
		bsr.w	BossMove
		bra.s	loc_17976
; ===========================================================================

loc_17960:
		bchg	#0,$22(a0)
		move.w	#$3F,$3C(a0)
		subq.b	#2,$25(a0)
		move.w	#0,$10(a0)

loc_17976:
		bra.w	loc_177E6
; ===========================================================================

loc_1797A:				; XREF: Obj3D_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_17984
		bra.w	BossDefeated
; ===========================================================================

loc_17984:
		bset	#0,$22(a0)
		bclr	#7,$22(a0)
		clr.w	$10(a0)
		addq.b	#2,$25(a0)
		move.w	#-$26,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	locret_179AA
		move.b	#1,($FFFFF7A7).w

locret_179AA:
		rts	
; ===========================================================================

loc_179AC:				; XREF: Obj3D_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_179BC
		bpl.s	loc_179C2
		addi.w	#$18,$12(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179BC:
		clr.w	$12(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179C2:
		cmpi.w	#$30,$3C(a0)
		bcs.s	loc_179DA
		beq.s	loc_179E0
		cmpi.w	#$38,$3C(a0)
		bcs.s	loc_179EE
		addq.b	#2,$25(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179DA:
		subq.w	#8,$12(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179E0:
		clr.w	$12(a0)
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play WOZ music

loc_179EE:
		bsr.w	BossMove
		bra.w	loc_177E6
; ===========================================================================

loc_179F6:				; XREF: Obj3D_ShipIndex
		move.w	#$400,$10(a0)
		move.w	#-$40,$12(a0)
		cmpi.w	#$2AC0,($FFFFF72A).w
		beq.s	loc_17A10
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_17A16
; ===========================================================================

loc_17A10:
		tst.b	1(a0)
		bpl.s	Obj3D_ShipDel

loc_17A16:
		bsr.w	BossMove
		bra.w	loc_177E6
; ===========================================================================

Obj3D_ShipDel:
		jmp	DeleteObject
; ===========================================================================

Obj3D_FaceMain:				; XREF: Obj3D_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	$25(a1),d0
		subq.b	#4,d0
		bne.s	loc_17A3E
		cmpi.w	#$2A00,$30(a1)
		bne.s	loc_17A46
		moveq	#4,d1

loc_17A3E:
		subq.b	#6,d0
		bmi.s	loc_17A46
		moveq	#$A,d1
		bra.s	loc_17A5A
; ===========================================================================

loc_17A46:
		tst.b	$20(a1)
		bne.s	loc_17A50
		moveq	#5,d1
		bra.s	loc_17A5A
; ===========================================================================

loc_17A50:
		cmpi.b	#4,($FFFFB024).w
		bcs.s	loc_17A5A
		moveq	#4,d1

loc_17A5A:
		move.b	d1,$1C(a0)
		subq.b	#2,d0
		bne.s	Obj3D_FaceDisp
		move.b	#6,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj3D_FaceDel

Obj3D_FaceDisp:
		bra.s	Obj3D_Display
; ===========================================================================

Obj3D_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj3D_FlameMain:			; XREF: Obj3D_Index
		move.b	#7,$1C(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$C,$25(a1)
		bne.s	loc_17A96
		move.b	#$B,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj3D_FlameDel
		bra.s	Obj3D_FlameDisp
; ===========================================================================

loc_17A96:
		move.w	$10(a1),d0
		beq.s	Obj3D_FlameDisp
		move.b	#8,$1C(a0)

Obj3D_FlameDisp:
		bra.s	Obj3D_Display
; ===========================================================================

Obj3D_FlameDel:
		jmp	DeleteObject
; ===========================================================================

Obj3D_Display:				; XREF: Obj3D_FaceDisp; Obj3D_FlameDisp
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.b	$22(a1),$22(a0)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		move.b	$22(a0),d0
		andi.b	#3,d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 48 - ball on a	chain that Eggman swings (WOZ)
; ---------------------------------------------------------------------------

Obj48:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj48_Index(pc,d0.w),d1
		jmp	Obj48_Index(pc,d1.w)
; ===========================================================================
Obj48_Index:	dc.w Obj48_Main-Obj48_Index
		dc.w Obj48_Base-Obj48_Index
		dc.w Obj48_Display2-Obj48_Index
		dc.w loc_17C68-Obj48_Index
		dc.w Obj48_ChkVanish-Obj48_Index
; ===========================================================================

Obj48_Main:				; XREF: Obj48_Index
		addq.b	#2,$24(a0)
		move.w	#$4080,$26(a0)
		move.w	#-$200,$3E(a0)
		move.l	#Map_obj15,4(a0)
		move.w	#$378,2(a0)
		lea	$28(a0),a2
		move.b	#0,(a2)+
		moveq	#5,d1
		movea.l	a0,a1
		bra.s	loc_17B60
; ===========================================================================

Obj48_MakeLinks:
		jsr	SingleObjLoad2
		bne.s	Obj48_MakeBall
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	#$48,0(a1)	; load chain link object
		move.b	#6,$24(a1)
		move.l	#Map_obj15,4(a1)
		move.w	#$378,2(a1)
		move.b	#1,$1A(a1)
		addq.b	#1,$28(a0)

loc_17B60:				; XREF: Obj48_Main
		move.w	a1,d5
		subi.w	#$D000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,1(a1)
		move.b	#8,$14(a1)
		move.w	#$300,$18(a1)
		move.l	$34(a0),$34(a1)
		move.l	a0,$38(a1)
		dbf	d1,Obj48_MakeLinks ; repeat sequence 5 more times

Obj48_MakeBall:
		move.b	#8,$24(a1)
		move.l	#Map_obj48,4(a1) ; load	different mappings for final link
		move.w	#$42DC,2(a1)	; use different	graphics
		move.b	#0,$1A(a0)
		move.w	#$280,$18(a1)
		move.b	#$81,$20(a1)	; make object hurt Sonic
		rts	
; ===========================================================================

Obj48_PosData:	dc.b 0,	$10, $20, $30, $40, $60	; y-position data for links and	giant ball

; ===========================================================================

Obj48_Base:				; XREF: Obj48_Index
		lea	(Obj48_PosData).l,a3
		lea	$28(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_17BC6:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFB000,d4
		movea.l	d4,a1
		move.b	(a3)+,d0
		cmp.b	$3C(a1),d0
		beq.s	loc_17BE0
		addq.b	#1,$3C(a1)

loc_17BE0:
		dbf	d6,loc_17BC6

		cmp.b	$3C(a1),d0
		bne.s	loc_17BFA
		movea.l	$34(a0),a1
		cmpi.b	#2,$25(a1)
		bne.s	loc_17BFA
		addq.b	#2,$24(a0)

loc_17BFA:
		cmpi.w	#$20,$32(a0)
		beq.s	Obj48_Display
		addq.w	#1,$32(a0)

Obj48_Display:
		bsr.w	sub_17C2A
		move.b	$26(a0),d0
		jsr	(Obj15_Move2).l
		jmp	DisplaySprite
; ===========================================================================

Obj48_Display2:				; XREF: Obj48_Index
		bsr.w	sub_17C2A
		jsr	(Obj48_Move).l
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_17C2A:				; XREF: Obj48_Display; Obj48_Display2
		movea.l	$34(a0),a1
		move.b	#1,$1A(a0)

loc_17C3C:
		move.w	8(a1),$3A(a0)
		move.w	$C(a1),d0
		add.w	$32(a0),d0
		move.w	d0,$38(a0)
		move.b	$22(a1),$22(a0)
		tst.b	$22(a1)
		bpl.s	locret_17C66
		move.b	#$3F,0(a0)
		move.b	#0,$24(a0)

locret_17C66:
		rts	
; End of function sub_17C2A

; ===========================================================================

loc_17C68:				; XREF: Obj48_Index
		movea.l	$34(a0),a1
		tst.b	$22(a1)
		bpl.s	Obj48_Display3
		move.b	#$3F,0(a0)
		move.b	#0,$24(a0)

Obj48_Display3:
		jmp	DisplaySprite
; ===========================================================================

Obj48_ChkVanish:			; XREF: Obj48_Index
		movea.l	$38(a0),a1
		move.b	$26(a1),d0
		lsr.b	#3,d0
		andi.b	#7,d0
		addi.b	#1,d0
		move.b	d0,$1A(a0)

Obj48_Vanish:
		movea.l	$34(a0),a1
		tst.b	$22(a1)
		bpl.s	Obj48_Display4
		move.b	#0,$20(a0)
		bsr.w	BossDefeated
		subq.b	#1,$3C(a0)
		bpl.s	Obj48_Display4
		move.b	#$3F,(a0)
		move.b	#0,$24(a0)

Obj48_Display4:
		movea.l	#DDZBallDynPLC,a2	; get DPLC location
		move.w	#$5B80,d4		; offset in VRAM to store art
		move.l	#Art_DDZBall,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3D(a0),d0	; check if equal with last queued frame
		beq.w	Obj48_Display5	; if is, don't load new DPLC
		move.b	d0,$3D(a0)	; remember queued frame
		jsr 	Load_DPLC

Obj48_Display5:
		jmp	DisplaySprite
; ===========================================================================
Ani_Eggman:
	include "_anim\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Eggman (boss levels)
; ---------------------------------------------------------------------------
Map_Eggman:
	include "_maps\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - extra boss items (e.g. swinging ball on a chain in WOZ)
; ---------------------------------------------------------------------------
Map_BossItems:
	include "_maps\Boss items.asm"

Art_DDZBall:	incbin	artunc\DDZball.bin	; WOZ giant ball
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 77 - Eggman (TJZ)
; ---------------------------------------------------------------------------

Obj77:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj77_Index(pc,d0.w),d1
		jmp	Obj77_Index(pc,d1.w)
; ===========================================================================
Obj77_Index:	dc.w Obj77_Main-Obj77_Index
		dc.w Obj77_ShipMain-Obj77_Index
		dc.w Obj77_FaceMain-Obj77_Index
		dc.w Obj77_FlameMain-Obj77_Index

Obj77_ObjData:	dc.b 2,	0		; routine number, animation
		dc.b 4,	1
		dc.b 6,	7
; ===========================================================================

Obj77_Main:				; XREF: Obj77_Index
		move.w	#$1E10,8(a0)
		move.w	#$5C0,$C(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$F,$20(a0)
		move.b	#8,$21(a0)	; set number of	hits to	8
		move.w	#$200,$18(a0)
		lea	Obj77_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#2,d1
		bra.s	Obj77_LoadBoss
; ===========================================================================

Obj77_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj77_ShipMain
		move.b	#$77,0(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj77_LoadBoss:				; XREF: Obj77_Main
		bclr	#0,$22(a0)
		clr.b	$25(a1)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1C(a1)
		move.w	$18(a0),$18(a1)
		move.l	#Map_Eggman,4(a1)
		move.w	#$400,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj77_Loop

Obj77_ShipMain:
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj77_ShipIndex(pc,d0.w),d1
		jsr	Obj77_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj77_ShipIndex:dc.w loc_17F1E-Obj77_ShipIndex,	loc_17FA0-Obj77_ShipIndex
		dc.w loc_17FE0-Obj77_ShipIndex,	loc_1801E-Obj77_ShipIndex
		dc.w loc_180BC-Obj77_ShipIndex,	loc_180F6-Obj77_ShipIndex
		dc.w loc_1812A-Obj77_ShipIndex,	loc_18152-Obj77_ShipIndex
; ===========================================================================

loc_17F1E:				; XREF: Obj77_ShipIndex
		move.w	8(a1),d0
		cmpi.w	#$1DA0,d0
		bcs.s	loc_17F38
		move.w	#-$180,$12(a0)
		move.w	#$60,$10(a0)
		addq.b	#2,$25(a0)

loc_17F38:
		bsr.w	BossMove
		move.w	$38(a0),$C(a0)
		move.w	$30(a0),8(a0)

loc_17F48:
		tst.b	$3D(a0)
		bne.s	loc_17F8E
		tst.b	$22(a0)
		bmi.s	loc_17F92
		tst.b	$20(a0)
		bne.s	locret_17F8C
		tst.b	$3E(a0)
		bne.s	loc_17F70
		move.b	#$20,$3E(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l

loc_17F70:
		lea	($FFFFFB02).w,a1
		move.w	#$222,d0
		cmp.w	#$222,(a1)
		bne.s	loc_17F7E
		move.w	#$EEE,d0

loc_17F7E:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_17F8C
		move.b	#$F,$20(a0)

locret_17F8C:
		rts	
; ===========================================================================

loc_17F8E:				; XREF: loc_17F48
		bra.w	BossDefeated
; ===========================================================================

loc_17F92:				; XREF: loc_17F48
		moveq	#100,d0
		bsr.w	AddPoints
		move.b	#-1,$3D(a0)
		rts	
; ===========================================================================

loc_17FA0:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1E48,$30(a0)
		bcs.s	loc_17FB6
		move.w	#$1E48,$30(a0)
		clr.w	$10(a0)
		addq.w	#1,d0

loc_17FB6:
		cmpi.w	#$500,$38(a0)
		bgt.s	loc_17FCA
		move.w	#$500,$38(a0)
		clr.w	$12(a0)
		addq.w	#1,d0

loc_17FCA:
		bne.s	loc_17FDC
		move.w	#$140,$10(a0)
		move.w	#-$200,$12(a0)
		addq.b	#2,$25(a0)

loc_17FDC:
		bra.w	loc_17F38
; ===========================================================================

loc_17FE0:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1E70,$30(a0)
		bcs.s	loc_17FF6
		move.w	#$1E70,$30(a0)
		clr.w	$10(a0)
		addq.w	#1,d0

loc_17FF6:
		cmpi.w	#$4C0,$38(a0)
		bgt.s	loc_1800A
		move.w	#$4C0,$38(a0)
		clr.w	$12(a0)
		addq.w	#1,d0

loc_1800A:
		bne.s	loc_1801A
		move.w	#-$180,$12(a0)
		addq.b	#2,$25(a0)
		clr.b	$3F(a0)

loc_1801A:
		bra.w	loc_17F38
; ===========================================================================

loc_1801E:				; XREF: Obj77_ShipIndex
		cmpi.w	#$100,$38(a0)
		bgt.s	loc_1804E
		move.w	#$100,$38(a0)
		move.w	#$140,$10(a0)
		move.w	#-$80,$12(a0)
		tst.b	$3D(a0)
		beq.s	loc_18046
		asl	$10(a0)
		asl	$12(a0)

loc_18046:
		addq.b	#2,$25(a0)
		bra.w	loc_17F38
; ===========================================================================

loc_1804E:
		bset	#0,$22(a0)
		addq.b	#2,$3F(a0)
		move.b	$3F(a0),d0
		jsr	(CalcSine).l
		tst.w	d1
		bpl.s	loc_1806C
		bclr	#0,$22(a0)

loc_1806C:
		asr.w	#4,d0
		swap	d0
		clr.w	d0
		add.l	$30(a0),d0
		swap	d0
		move.w	d0,8(a0)
		move.w	$12(a0),d0
		move.w	($FFFFB00C).w,d1
		sub.w	$C(a0),d1
		bcs.s	loc_180A2
		subi.w	#$48,d1
		bcs.s	loc_180A2
		asr.w	#1,d0
		subi.w	#$28,d1
		bcs.s	loc_180A2
		asr.w	#1,d0
		subi.w	#$28,d1
		bcs.s	loc_180A2
		moveq	#0,d0

loc_180A2:
		ext.l	d0
		asl.l	#8,d0
		tst.b	$3D(a0)
		beq.s	loc_180AE
		add.l	d0,d0

loc_180AE:
		add.l	d0,$38(a0)
		move.w	$38(a0),$C(a0)
		bra.w	loc_17F48
; ===========================================================================

loc_180BC:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1F4C,$30(a0)
		bcs.s	loc_180D2
		move.w	#$1F4C,$30(a0)
		clr.w	$10(a0)
		addq.w	#1,d0

loc_180D2:
		cmpi.w	#$C0,$38(a0)
		bgt.s	loc_180E6
		move.w	#$C0,$38(a0)
		clr.w	$12(a0)
		addq.w	#1,d0

loc_180E6:
		bne.s	loc_180F2
		addq.b	#2,$25(a0)
		bclr	#0,$22(a0)

loc_180F2:
		bra.w	loc_17F38
; ===========================================================================

loc_180F6:				; XREF: Obj77_ShipIndex
		tst.b	$3D(a0)
		bne.s	loc_18112
		cmpi.w	#$1EC8,8(a1)
		blt.s	loc_18126
		cmpi.w	#$F0,$C(a1)
		bgt.s	loc_18126
		move.b	#$32,$3C(a0)
		clr.b	($FFFFFE1E).w	; stop time counter

loc_18112:
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play TJZ music
		bset	#0,$22(a0)
		addq.b	#2,$25(a0)

loc_18126:
		bra.w	loc_17F38
; ===========================================================================

loc_1812A:				; XREF: Obj77_ShipIndex
		tst.b	$3D(a0)
		bne.s	loc_18136
		subq.b	#1,$3C(a0)
		bne.s	loc_1814E

loc_18136:
		clr.b	$3C(a0)
		move.w	#$400,$10(a0)
		move.w	#-$40,$12(a0)
		clr.b	$3D(a0)
		addq.b	#2,$25(a0)

loc_1814E:
		bra.w	loc_17F38
; ===========================================================================

loc_18152:				; XREF: Obj77_ShipIndex
		cmpi.w	#$2030,($FFFFF72A).w
		bcc.s	loc_18160
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_18166
; ===========================================================================

loc_18160:
		tst.b	1(a0)
		bpl.s	Obj77_ShipDel

loc_18166:
		bra.w	loc_17F38
; ===========================================================================

Obj77_ShipDel:
		jmp	DeleteObject
; ===========================================================================

Obj77_FaceMain:				; XREF: Obj77_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.s	Obj77_FaceDel
		moveq	#0,d0
		move.b	$25(a1),d0
		moveq	#1,d1
		tst.b	$3D(a0)
		beq.s	loc_1818C
		moveq	#$A,d1
		bra.s	loc_181A0
; ===========================================================================

loc_1818C:
		tst.b	$20(a1)
		bne.s	loc_18196
		moveq	#5,d1
		bra.s	loc_181A0
; ===========================================================================

loc_18196:
		cmpi.b	#4,($FFFFB024).w
		bcs.s	loc_181A0
		moveq	#4,d1

loc_181A0:
		move.b	d1,$1C(a0)
		cmpi.b	#$E,d0
		bne.s	loc_181B6
		move.b	#6,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj77_FaceDel

loc_181B6:
		bra.s	Obj77_Display
; ===========================================================================

Obj77_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj77_FlameMain:			; XREF: Obj77_Index
		move.b	#7,$1C(a0)
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.s	Obj77_FlameDel
		cmpi.b	#$E,$25(a1)
		bne.s	loc_181F0
		move.b	#$B,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj77_FlameDel
		bra.s	loc_181F0
; ===========================================================================
		tst.w	$10(a1)
		beq.s	loc_181F0
		move.b	#8,$1C(a0)

loc_181F0:
		bra.s	Obj77_Display
; ===========================================================================

Obj77_FlameDel:				; XREF: Obj77_FlameMain
		jmp	DeleteObject
; ===========================================================================

Obj77_Display:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.b	$22(a1),$22(a0)
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#-4,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 73 - Eggman (DDZ)
; ---------------------------------------------------------------------------

Obj73:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj73_Index(pc,d0.w),d1
		jmp	Obj73_Index(pc,d1.w)
; ===========================================================================
Obj73_Index:	dc.w Obj73_Main-Obj73_Index
		dc.w Obj73_Wait-Obj73_Index
		dc.w Obj73_ShipMain-Obj73_Index
		dc.w Obj73_FaceMain-Obj73_Index
		dc.w Obj73_FlameMain-Obj73_Index
		dc.w Obj73_TubeMain-Obj73_Index

Obj73_ObjData:	dc.b 2,	0, 5		; routine number, animation, priority
		dc.b 6,	1, 4
		dc.b 8,	7, 4
		dc.b $A,	0, 3
; ===========================================================================

Obj73_Main:				; XREF: Obj73_Index
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$F,$20(a0)
		move.b	#$C,$21(a0)	; set number of	hits to	12
		move.b	#$80,$32(a0)
		lea	Obj73_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		move.b	#1,($FFFFF746).w
		bra.s	Obj73_LoadBoss
; ===========================================================================

Obj73_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj73_ShipMain
		move.b	#$73,0(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj73_LoadBoss:				; XREF: Obj73_Main
		bclr	#0,$22(a0)
		clr.b	$25(a1)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1C(a1)
		move.b	(a2)+,$18(a1)
		move.w 	$18(a1),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a1)
		move.l	#Map_Eggman,4(a1)
		move.w	#$300,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj73_Loop	; repeat sequence 3 more times

Obj73_Wait:
		subq.b	#1,$32(a0)
		bpl.w	Obj73_Animate
		addq.b	#2,$24(a0)
		tst.b	$25(a0)
		beq.s	Obj73_ShipMain
		moveq	#$15,d0
		jsr	PlaySound	; play boss music
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w

Obj73_ShipMain:
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj73_ShipIndex(pc,d0.w),d1
		jsr	Obj73_ShipIndex(pc,d1.w)

Obj73_Animate:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj73_ShipIndex:dc.w loc_18302-Obj73_ShipIndex
		dc.w loc_183AA-Obj73_ShipIndex
		dc.w loc_184F6-Obj73_ShipIndex
		dc.w loc_1852C-Obj73_ShipIndex
		dc.w loc_18582-Obj73_ShipIndex
		dc.w Obj73_MakeBall-Obj73_ShipIndex
; ===========================================================================

loc_18302:				; XREF: Obj73_ShipIndex
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#2,d0
		moveq	#0,d0
		move.w	d0,$10(a0)
		move.w	#-$800,$12(a0)
		bsr.w	BossMove
		cmpi.w	#$2AC,$38(a0)
		beq.s	loc_18304
		cmpi.w	#$20C,$38(a0)
		bne.s	loc_18334
		addq.b	#2,$25(a0)
		clr.b	$28(a0)
		clr.l	$10(a0)
		move.b	#$40,$32(a0)
		subq.b	#2,$24(a0)
		bra.s	loc_18334

loc_18304:
		move.b	#0,($FFFFF746).w
		move.b	#$59,d0
		jsr	PlaySound_Special

loc_18334:
		jsr	(RandomNumber).l
		move.b	d0,$34(a0)

loc_1833E:
		move.w	$38(a0),$C(a0)
		move.w	$30(a0),8(a0)
		cmpi.b	#4,$25(a0)
		bcc.s	locret_18390
		tst.b	$22(a0)
		bmi.s	loc_18392
		tst.b	$20(a0)
		bne.s	locret_18390
		tst.b	$3E(a0)
		bne.s	loc_18374
		move.b	#$28,$3E(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound
		cmpi.b 	#6,$21(a0)
		bne.s	loc_18374
		move.b	#$A,$25(a0)
		

loc_18374:
		lea	($FFFFFB22).w,a1
		move.w	#0,d0
		tst.w	(a1)
		bne.s	loc_18382
		move.w	#$EEE,d0

loc_18382:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_18390
		move.b	#$F,$20(a0)

locret_18390:
		rts	
; ===========================================================================

loc_18392:				; XREF: loc_1833E
		moveq	#100,d0
		bsr.w	AddPoints
		move.b	#4,$25(a0)
		move.w	#$B4,$3C(a0)
		clr.w	$10(a0)
		rts	
; ===========================================================================

loc_183AA:				; XREF: Obj73_ShipIndex
		moveq	#0,d0
		move.b	$28(a0),d0
		move.w	off_183C2(pc,d0.w),d0
		jsr	off_183C2(pc,d0.w)
		andi.b	#6,$28(a0)
		bra.w	loc_1833E
; ===========================================================================
off_183C2:	dc.w loc_183CA-off_183C2
		dc.w Obj73_MakeLava2-off_183C2
		dc.w loc_183CA-off_183C2
		dc.w Obj73_MakeLava2-off_183C2
; ===========================================================================

loc_183CA:				; XREF: off_183C2
		tst.w	$10(a0)
		bne.s	loc_183FE
		moveq	#$40,d0
		cmpi.w	#$20C,$38(a0)
		beq.s	loc_183E6
		bcs.s	loc_183DE
		neg.w	d0

loc_183DE:
		move.w	d0,$12(a0)
		bra.w	BossMove
; ===========================================================================

loc_183E6:
		move.w	#$200,$10(a0)
		move.w	#$100,$12(a0)
		btst	#0,$22(a0)
		bne.s	loc_183FE
		neg.w	$10(a0)

loc_183FE:
		cmpi.b	#$18,$3E(a0)
		bcc.s	Obj73_MakeLava
		bsr.w	BossMove
		subq.w	#4,$12(a0)

Obj73_MakeLava:
		jsr	(RandomNumber).l
		andi.b	#$1F,d0
		addi.b	#$40,d0
		move.b	d0,$34(a0)

loc_1845C:
		btst	#0,$22(a0)
		beq.s	loc_18474
		cmpi.w	#$1910,$30(a0)
		blt.s	locret_1849C
		move.w	#$1910,$30(a0)
		bra.s	loc_18482
; ===========================================================================

loc_18474:
		cmpi.w	#$1830,$30(a0)
		bgt.s	locret_1849C
		move.w	#$1830,$30(a0)

loc_18482:
		clr.w	$10(a0)
		move.w	#-$180,$12(a0)
		cmpi.w	#$20C,$38(a0)
		bcc.s	loc_18498
		neg.w	$12(a0)

loc_18498:
		addq.b	#2,$28(a0)

locret_1849C:
		rts	
; ===========================================================================

Obj73_MakeLava2:			; XREF: off_183C2
		bsr.w	BossMove
		move.w	$38(a0),d0
		subi.w	#$20C,d0
		bgt.s	locret_184F4
		move.w	#$20C,d0
		tst.w	$12(a0)
		beq.s	loc_184EA
		clr.w	$12(a0)
		move.w	#$50,$3C(a0)
		bchg	#0,$22(a0)
		jsr	SingleObjLoad
		bne.s	loc_184EA
		move.w	$30(a0),8(a1)
		move.w	$38(a0),$C(a1)
		addi.w	#$18,$C(a1)
		move.b	#$74,(a1)	; load lava ball object
		move.b	#1,$28(a1)

loc_184EA:
		subq.w	#1,$3C(a0)
		bne.s	locret_184F4
		addq.b	#2,$28(a0)

locret_184F4:
		rts	
; ===========================================================================

loc_184F6:				; XREF: Obj73_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_18500
		bra.w	BossDefeated
; ===========================================================================

loc_18500:
		bset	#0,$22(a0)
		bclr	#7,$22(a0)
		clr.w	$10(a0)
		addq.b	#2,$25(a0)
		move.w	#-$26,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	locret_1852A
		move.b	#1,($FFFFF7A7).w
		clr.w	$12(a0)

locret_1852A:
		rts	
; ===========================================================================

loc_1852C:				; XREF: Obj73_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_18544
		bpl.s	loc_1854E
		cmpi.w	#$250,$38(a0)
		bcc.s	loc_18544
		addi.w	#$18,$12(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_18544:
		clr.w	$12(a0)
		clr.w	$3C(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_1854E:
		cmpi.w	#$30,$3C(a0)
		bcs.s	loc_18566
		beq.s	loc_1856C
		cmpi.w	#$38,$3C(a0)
		bcs.s	loc_1857A
		addq.b	#2,$25(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_18566:
		subq.w	#8,$12(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_1856C:
		clr.w	$12(a0)
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play DDZ music

loc_1857A:
		bsr.w	BossMove
		bra.w	loc_1833E
; ===========================================================================

loc_18582:				; XREF: Obj73_ShipIndex
		move.w	#$500,$10(a0)
		move.w	#-$40,$12(a0)
		cmpi.w	#$1960,($FFFFF72A).w
		bcc.s	loc_1859C
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_185A2
; ===========================================================================

loc_1859C:
		tst.b	1(a0)
		bpl.s	Obj73_ShipDel

loc_185A2:
		bsr.w	BossMove
		bra.w	loc_1833E
; ===========================================================================

Obj73_ShipDel:
		jmp	DeleteObject
; ===========================================================================

Obj73_FaceMain:				; XREF: Obj73_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	$25(a1),d0
		subq.w	#2,d0
		bne.s	loc_185D2
		btst	#1,$28(a1)
		beq.s	loc_185DA
		tst.w	$12(a1)
		bne.s	loc_185DA
		moveq	#4,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185D2:
		subq.b	#2,d0
		bmi.s	loc_185DA
		moveq	#$A,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185DA:
		tst.b	$20(a1)
		bne.s	loc_185E4
		moveq	#5,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185E4:
		cmpi.b	#4,($FFFFB024).w
		bcs.s	loc_185EE
		moveq	#4,d1

loc_185EE:
		move.b	d1,$1C(a0)
		subq.b	#4,d0
		bne.s	loc_18602
		move.b	#6,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj73_FaceDel

loc_18602:
		bra.w	Obj73_Display
; ===========================================================================

Obj73_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj73_FlameMain:			; XREF: Obj73_Index
		move.b	#7,$1C(a0)
		movea.l	$34(a0),a1
		cmpi.b	#8,$25(a1)
		blt.s	loc_1862A
		move.b	#$B,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj73_FlameDel
		bra.s	loc_18636
; ===========================================================================

loc_1862A:
		tst.w	$10(a1)
		beq.s	loc_18636
		move.b	#8,$1C(a0)

loc_18636:
		bra.s	Obj73_Display
; ===========================================================================

Obj73_FlameDel:				; XREF: Obj73_FlameMain
		jmp	DeleteObject
; ===========================================================================

Obj73_MakeBall:				; XREF: Obj3D_ShipIndex
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.b	#2,$25(a0)
		jsr	SingleObjLoad2
		bne.s	loc2_17910
		move.b	#$48,0(a1)	; load swinging	ball object
		move.w	$30(a0),8(a1)
		move.w	$38(a0),$C(a1)
		move.l	a0,$34(a1)

loc2_17910:
		bra.w	loc_1833E

Obj73_Display:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite

loc_1864A:
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.b	$22(a1),$22(a0)
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#-4,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj73_TubeMain:				; XREF: Obj73_Index
		movea.l	$34(a0),a1
		cmpi.b	#8,$25(a1)
		bne.s	loc_18688
		tst.b	1(a0)
		bpl.s	Obj73_TubeDel

loc_18688:
		move.l	#Map_BossItems,4(a0)
		move.w	#$2394,2(a0)
		move.b	#4,$1A(a0)
		bra.s	loc_1864A
; ===========================================================================

Obj73_TubeDel:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 74 - lava that	Eggman drops (DDZ)
; ---------------------------------------------------------------------------

Obj74:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj74_Index(pc,d0.w),d0
		jsr	Obj74_Index(pc,d0.w)
		jmp	DisplaySprite
; ===========================================================================
Obj74_Index:	dc.w Obj74_Main-Obj74_Index
		dc.w Obj74_Action-Obj74_Index
		dc.w loc_18886-Obj74_Index
		dc.w Obj74_Delete3-Obj74_Index
; ===========================================================================

Obj74_Main:				; XREF: Obj74_Index
		move.b	#8,$16(a0)
		move.b	#8,$17(a0)
		move.l	#Map_obj14,4(a0)
		move.w	#$37C,2(a0)
		move.b	#4,1(a0)
		move.w	#$280,$18(a0)
		move.w	$C(a0),$38(a0)
		move.b	#8,$14(a0)
		addq.b	#2,$24(a0)
		tst.b	$28(a0)
		bne.s	loc_1870A
		addq.b	#2,$24(a0)
		bra.w	loc_18886
; ===========================================================================

loc_1870A:
		move.b	#$1E,$29(a0)
		move.w	#$70,d0
		jsr	(PlaySound_Special).l ;	play lava sound

Obj74_Action:				; XREF: Obj74_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj74_Index2(pc,d0.w),d0
		jsr	Obj74_Index2(pc,d0.w)
		jsr	SpeedToPos
		lea	(Ani_obj14).l,a1
		jsr	AnimateSprite
		cmpi.w	#$2E8,$C(a0)
		bhi.s	Obj74_Delete
		move.b	#$8B,$20(a0)
		bset	#4,$2B(a0)

Obj74_RTS:
		rts	
; ===========================================================================

Obj74_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj74_Index2:	dc.w Obj74_Drop-Obj74_Index2
		dc.w Obj74_MakeFlame-Obj74_Index2
		dc.w Obj74_Duplicate-Obj74_Index2
		dc.w Obj74_FallEdge-Obj74_Index2
; ===========================================================================

Obj74_Drop:				; XREF: Obj74_Index2
		bset	#1,$22(a0)
		subq.b	#1,$29(a0)
		bpl.s	locret_18780
		bset	#4,$2B(a0)
		move.b	#$8B,$20(a0)


Obj74_DropCont:
		clr.b	$28(a0)
		addi.w	#$18,$12(a0)
		bclr	#1,$22(a0)
		bsr.w	ObjHitFloor
		tst.w	d1
		bpl.s	locret_18780
		addq.b	#2,$25(a0)

locret_18780:
		rts	
; ===========================================================================

Obj74_MakeFlame:			; XREF: Obj74_Index2
		subq.w	#2,$C(a0)
		bset	#7,2(a0)
		move.w	#$A0,$10(a0)
		clr.w	$12(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#3,$29(a0)
		jsr	SingleObjLoad2
		bne.s	loc_187CA
		lea	(a1),a3
		lea	(a0),a2
		moveq	#3,d0

Obj74_Loop:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d0,Obj74_Loop

		neg.w	$10(a1)
		addq.b	#2,$25(a1)

loc_187CA:
		addq.b	#2,$25(a0)
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj74_Duplicate2:			; XREF: Obj74_Duplicate
		jsr	SingleObjLoad2
		bne.s	locret_187EE
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	#$74,(a1)
		move.w	#$67,$28(a1)

locret_187EE:
		rts	
; End of function Obj74_Duplicate2

; ===========================================================================

Obj74_Duplicate:			; XREF: Obj74_Index2
		bsr.w	ObjHitFloor
		tst.w	d1
		bpl.s	loc_18826
		move.w	8(a0),d0
		cmpi.w	#$1940,d0
		bgt.s	loc_1882C
		move.w	$30(a0),d1
		cmp.w	d0,d1
		beq.s	loc_1881E
		andi.w	#$10,d0
		andi.w	#$10,d1
		cmp.w	d0,d1
		beq.s	loc_1881E
		bsr.s	Obj74_Duplicate2
		move.w	8(a0),$32(a0)

loc_1881E:
		move.w	8(a0),$30(a0)
		rts	
; ===========================================================================

loc_18826:
		addq.b	#2,$25(a0)
		rts	
; ===========================================================================

loc_1882C:
		addq.b	#2,$24(a0)
		rts	
; ===========================================================================

Obj74_FallEdge:				; XREF: Obj74_Index2
		bclr	#1,$22(a0)
		addi.w	#$24,$12(a0)	; make flame fall
		move.w	8(a0),d0
		sub.w	$32(a0),d0
		bpl.s	loc_1884A
		neg.w	d0

loc_1884A:
		cmpi.w	#$12,d0
		bne.s	loc_18856
		bclr	#7,2(a0)

loc_18856:
		bsr.w	ObjHitFloor
		tst.w	d1
		bpl.s	locret_1887E
		subq.b	#1,$29(a0)
		beq.s	Obj74_Delete2
		clr.w	$12(a0)
		move.w	$32(a0),8(a0)
		move.w	$38(a0),$C(a0)
		bset	#7,2(a0)
		subq.b	#2,$25(a0)

locret_1887E:
		rts	
; ===========================================================================

Obj74_Delete2:
		jmp	DeleteObject
; ===========================================================================

loc_18886:				; XREF: Obj74_Index
		bset	#7,2(a0)
		subq.b	#1,$29(a0)
		bne.s	Obj74_Animate
		move.b	#1,$1C(a0)
		subq.w	#4,$C(a0)
		clr.b	$20(a0)

Obj74_Animate:
		lea	(Ani_obj14).l,a1
		jmp	AnimateSprite
; ===========================================================================

Obj74_Delete3:				; XREF: Obj74_Index
		jmp	DeleteObject
; ===========================================================================

Obj7A_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7A - Eggman (KVZ)
; ---------------------------------------------------------------------------

Obj7A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7A_Index(pc,d0.w),d1
		jmp	Obj7A_Index(pc,d1.w)
; ===========================================================================
Obj7A_Index:	dc.w Obj7A_Main-Obj7A_Index
		dc.w Obj7A_ShipMain-Obj7A_Index
		dc.w Obj7A_FaceMain-Obj7A_Index
		dc.w Obj7A_FlameMain-Obj7A_Index
		dc.w Obj7A_TubeMain-Obj7A_Index

Obj7A_ObjData:	dc.b 2,	0, 4		; routine number, animation, priority
		dc.b 4,	1, 4
		dc.b 6,	7, 4
		dc.b 8,	0, 3
; ===========================================================================

Obj7A_Main:				; XREF: Obj7A_Index
		move.w	#$2188,8(a0)
		move.w	#$228,$C(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$F,$20(a0)
		move.b	#8,$21(a0)	; set number of	hits to	8
		lea	Obj7A_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj7A_LoadBoss
; ===========================================================================

Obj7A_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_1895C
		move.b	#$7A,0(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj7A_LoadBoss:				; XREF: Obj7A_Main
		bclr	#0,$22(a0)
		clr.b	$25(a1)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1C(a1)
		move.b	(a2)+,$18(a1)
		move.w 	$18(a1),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a1)
		move.l	#Map_Eggman,4(a1)
		move.w	#$400,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj7A_Loop	; repeat sequence 3 more times

loc_1895C:
		lea	($FFFFB040).w,a1
		lea	$2A(a0),a2
		moveq	#$5E,d0
		moveq	#$3E,d1

loc_18968:
		cmp.b	(a1),d0
		bne.s	loc_18974
		tst.b	$28(a1)
		beq.s	loc_18974
		move.w	a1,(a2)+

loc_18974:
		adda.w	#$40,a1
		dbf	d1,loc_18968

Obj7A_ShipMain:				; XREF: Obj7A_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj7A_ShipIndex(pc,d0.w),d0
		jsr	Obj7A_ShipIndex(pc,d0.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj7A_ShipIndex:dc.w loc_189B8-Obj7A_ShipIndex
		dc.w loc_18A5E-Obj7A_ShipIndex
		dc.w Obj7A_MakeBall-Obj7A_ShipIndex
		dc.w loc_18B48-Obj7A_ShipIndex
		dc.w loc_18B80-Obj7A_ShipIndex
		dc.w loc_18BC6-Obj7A_ShipIndex
; ===========================================================================

loc_189B8:				; XREF: Obj7A_ShipIndex
		move.w	#-$100,$10(a0)
		cmpi.w	#$2120,$30(a0)
		bcc.s	loc_189CA
		addq.b	#2,$25(a0)

loc_189CA:
		bsr.w	BossMove
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$38(a0),d0
		move.w	d0,$C(a0)
		move.w	$30(a0),8(a0)
		bra.s	loc_189FE
; ===========================================================================

loc_189EE:
		bsr.w	BossMove
		move.w	$38(a0),$C(a0)
		move.w	$30(a0),8(a0)

loc_189FE:
		cmpi.b	#6,$25(a0)
		bcc.s	locret_18A44
		tst.b	$22(a0)
		bmi.s	loc_18A46
		tst.b	$20(a0)
		bne.s	locret_18A44
		tst.b	$3E(a0)
		bne.s	loc_18A28
		move.b	#$20,$3E(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound

loc_18A28:
		lea	($FFFFFB02).w,a1
		move.w	#$222,d0
		cmp.w	#$222,(a1)
		bne.s	loc_18A36
		move.w	#$EEE,d0

loc_18A36:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_18A44
		move.b	#$F,$20(a0)

locret_18A44:
		rts	
; ===========================================================================

loc_18A46:
		moveq	#100,d0
		bsr.w	AddPoints
		move.b	#6,$25(a0)
		move.b	#$78,$3C(a0)
		clr.w	$10(a0)
		rts	
; ===========================================================================

loc_18A5E:				; XREF: Obj7A_ShipIndex
		move.w	$30(a0),d0
		move.w	#$200,$10(a0)
		btst	#0,$22(a0)
		bne.s	loc_18A7C
		neg.w	$10(a0)
		cmpi.w	#$2008,d0
		bgt.s	loc_18A88
		bra.s	loc_18A82
; ===========================================================================

loc_18A7C:
		cmpi.w	#$2138,d0
		blt.s	loc_18A88

loc_18A82:
		bchg	#0,$22(a0)

loc_18A88:
		move.w	8(a0),d0
		moveq	#-1,d1
		moveq	#2,d2
		lea	$2A(a0),a2
		moveq	#$28,d4
		tst.w	$10(a0)
		bpl.s	loc_18A9E
		neg.w	d4

loc_18A9E:
		move.w	(a2)+,d1
		movea.l	d1,a3
		btst	#3,$22(a3)
		bne.s	loc_18AB4
		move.w	8(a3),d3
		add.w	d4,d3
		sub.w	d0,d3
		beq.s	loc_18AC0

loc_18AB4:
		dbf	d2,loc_18A9E

		move.b	d2,$28(a0)
		bra.w	loc_189CA
; ===========================================================================

loc_18AC0:
		move.b	d2,$28(a0)
		addq.b	#2,$25(a0)
		move.b	#$28,$3C(a0)
		bra.w	loc_189CA
; ===========================================================================

Obj7A_MakeBall:				; XREF: Obj7A_ShipIndex
		cmpi.b	#$28,$3C(a0)
		bne.s	loc_18B36
		moveq	#-1,d0
		move.b	$28(a0),d0
		ext.w	d0
		bmi.s	loc_18B40
		subq.w	#2,d0
		neg.w	d0
		add.w	d0,d0
		lea	$2A(a0),a1
		move.w	(a1,d0.w),d0
		movea.l	d0,a2
		lea	($FFFFB040).w,a1
		moveq	#$3E,d1

loc_18AFA:
		cmp.l	$3C(a1),d0
		beq.s	loc_18B40
		adda.w	#$40,a1
		dbf	d1,loc_18AFA

		move.l	a0,-(sp)
		lea	(a2),a0
		jsr	SingleObjLoad2
		movea.l	(sp)+,a0
		bne.s	loc_18B40
		move.b	#$7B,(a1)	; load spiked ball object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$20,$C(a1)
		move.b	$22(a2),$22(a1)
		move.l	a2,$3C(a1)

loc_18B36:
		subq.b	#1,$3C(a0)
		beq.s	loc_18B40
		bra.w	loc_189FE
; ===========================================================================

loc_18B40:
		subq.b	#2,$25(a0)
		bra.w	loc_189CA
; ===========================================================================

loc_18B48:				; XREF: Obj7A_ShipIndex
		subq.b	#1,$3C(a0)
		bmi.s	loc_18B52
		bra.w	BossDefeated
; ===========================================================================

loc_18B52:
		addq.b	#2,$25(a0)
		clr.w	$12(a0)
		bset	#0,$22(a0)
		bclr	#7,$22(a0)
		clr.w	$10(a0)
		move.b	#-$18,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_18B7C
		move.b	#1,($FFFFF7A7).w

loc_18B7C:
		bra.w	loc_189FE
; ===========================================================================

loc_18B80:				; XREF: Obj7A_ShipIndex
		addq.b	#1,$3C(a0)
		beq.s	loc_18B90
		bpl.s	loc_18B96
		addi.w	#$18,$12(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18B90:
		clr.w	$12(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18B96:
		cmpi.b	#$20,$3C(a0)
		bcs.s	loc_18BAE
		beq.s	loc_18BB4
		cmpi.b	#$2A,$3C(a0)
		bcs.s	loc_18BC2
		addq.b	#2,$25(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18BAE:
		subq.w	#8,$12(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18BB4:
		clr.w	$12(a0)
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play KVZ music

loc_18BC2:
		bra.w	loc_189EE
; ===========================================================================

loc_18BC6:				; XREF: Obj7A_ShipIndex
		move.w	#$400,$10(a0)
		move.w	#-$40,$12(a0)
		cmpi.w	#$2160,($FFFFF72A).w
		bcc.s	loc_18BE0
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_18BE8
; ===========================================================================

loc_18BE0:
		tst.b	1(a0)
		bpl.w	Obj7A_Delete

loc_18BE8:
		bsr.w	BossMove
		bra.w	loc_189CA
; ===========================================================================

Obj7A_FaceMain:				; XREF: Obj7A_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	$25(a1),d0
		cmpi.b	#6,d0
		bmi.s	loc_18C06
		moveq	#$A,d1
		bra.s	loc_18C1A
; ===========================================================================

loc_18C06:
		tst.b	$20(a1)
		bne.s	loc_18C10
		moveq	#5,d1
		bra.s	loc_18C1A
; ===========================================================================

loc_18C10:
		cmpi.b	#4,($FFFFB024).w
		bcs.s	loc_18C1A
		moveq	#4,d1

loc_18C1A:
		move.b	d1,$1C(a0)
		cmpi.b	#$A,d0
		bne.s	loc_18C32
		move.b	#6,$1C(a0)
		tst.b	1(a0)
		bpl.w	Obj7A_Delete

loc_18C32:
		bra.s	loc_18C6C
; ===========================================================================

Obj7A_FlameMain:			; XREF: Obj7A_Index
		move.b	#8,$1C(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,$25(a1)
		bne.s	loc_18C56
		tst.b	1(a0)
		bpl.w	Obj7A_Delete
		move.b	#$B,$1C(a0)
		bra.s	loc_18C6C
; ===========================================================================

loc_18C56:
		cmpi.b	#8,$25(a1)
		bgt.s	loc_18C6C
		cmpi.b	#4,$25(a1)
		blt.s	loc_18C6C
		move.b	#7,$1C(a0)

loc_18C6C:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite

loc_18C78:
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.b	$22(a1),$22(a0)
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#-4,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj7A_TubeMain:				; XREF: Obj7A_Index
		movea.l	$34(a0),a1
		cmpi.b	#$A,$25(a1)
		bne.s	loc_18CB8
		tst.b	1(a0)
		bpl.w	Obj7A_Delete

loc_18CB8:
		move.l	#Map_BossItems,4(a0)
		move.w	#$246C,2(a0)
		move.b	#3,$1A(a0)
		bra.s	loc_18C78
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7B - exploding	spikeys	that Eggman drops (KVZ)
; ---------------------------------------------------------------------------

Obj7B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj7B_Index(pc,d0.w),d0
		jsr	Obj7B_Index(pc,d0.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	Obj7A_Delete
		cmpi.w	#$280,d0
		bhi.w	Obj7A_Delete
		jmp	DisplaySprite
; ===========================================================================
Obj7B_Index:	dc.w Obj7B_Main-Obj7B_Index
		dc.w Obj7B_Fall-Obj7B_Index
		dc.w loc_18DC6-Obj7B_Index
		dc.w loc_18EAA-Obj7B_Index
		dc.w Obj7B_Explode-Obj7B_Index
		dc.w Obj7B_MoveFrag-Obj7B_Index
; ===========================================================================

Obj7B_Main:				; XREF: Obj7B_Index
		move.l	#Map_obj5Ea,4(a0)
		move.w	#$518,2(a0)
		move.b	#1,$1A(a0)
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$8B,$20(a0)
		move.b	#$C,$14(a0)
		movea.l	$3C(a0),a1
		move.w	8(a1),$30(a0)
		move.w	$C(a1),$34(a0)
		bset	#0,$22(a0)
		move.w	8(a0),d0
		cmp.w	8(a1),d0
		bgt.s	loc_18D68
		bclr	#0,$22(a0)
		move.b	#2,$3A(a0)

loc_18D68:
		addq.b	#2,$24(a0)

Obj7B_Fall:				; XREF: Obj7B_Index
		jsr	ObjectFall
		movea.l	$3C(a0),a1
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	$1A(a1),d0
		move.w	8(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18D8E
		addq.w	#2,d0

loc_18D8E:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	$C(a0),d1
		bgt.s	locret_18DC4
		movea.l	$3C(a0),a1
		moveq	#2,d1
		btst	#0,$22(a0)
		beq.s	loc_18DAE
		moveq	#0,d1

loc_18DAE:
		move.w	#$F0,$28(a0)
		move.b	#10,$25(a0)	; set frame duration to	10 frames
		move.b	$25(a0),$23(a0)
		bra.w	loc_18FA2
; ===========================================================================

locret_18DC4:
		rts	
; ===========================================================================

loc_18DC6:				; XREF: Obj7B_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$3A(a0),d0
		sub.b	$3A(a1),d0
		beq.s	loc_18E2A
		bcc.s	loc_18DDA
		neg.b	d0

loc_18DDA:
		move.w	#-$818,d1
		move.w	#-$114,d2
		cmpi.b	#1,d0
		beq.s	loc_18E00
		move.w	#-$960,d1
		move.w	#-$F4,d2
		cmpi.w	#$9C0,$38(a1)
		blt.s	loc_18E00
		move.w	#-$A20,d1
		move.w	#-$80,d2

loc_18E00:
		move.w	d1,$12(a0)
		move.w	d2,$10(a0)
		move.w	8(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_18E16
		neg.w	$10(a0)

loc_18E16:
		move.b	#1,$1A(a0)
		move.w	#$20,$28(a0)
		addq.b	#2,$24(a0)
		bra.w	loc_18EAA
; ===========================================================================

loc_18E2A:				; XREF: loc_18DC6
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	$1A(a1),d0
		move.w	#$28,d2
		move.w	8(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18E48
		neg.w	d2
		addq.w	#2,d0

loc_18E48:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		move.w	d1,$C(a0)
		add.w	$30(a0),d2
		move.w	d2,8(a0)
		clr.w	$E(a0)
		clr.w	$A(a0)
		subq.w	#1,$28(a0)
		bne.s	loc_18E7A
		move.w	#$20,$28(a0)
		move.b	#8,$24(a0)
		rts	
; ===========================================================================

loc_18E7A:
		cmpi.w	#$78,$28(a0)
		bne.s	loc_18E88
		move.b	#5,$25(a0)

loc_18E88:
		cmpi.w	#$3C,$28(a0)
		bne.s	loc_18E96
		move.b	#2,$25(a0)

loc_18E96:
		subq.b	#1,$23(a0)
		bgt.s	locret_18EA8
		bchg	#0,$1A(a0)
		move.b	$25(a0),$23(a0)

locret_18EA8:
		rts	
; ===========================================================================

loc_18EAA:				; XREF: Obj7B_Index
		lea	($FFFFB040).w,a1
		moveq	#$7A,d0
		moveq	#$40,d1
		moveq	#$3E,d2

loc_18EB4:
		cmp.b	(a1),d0
		beq.s	loc_18EC0
		adda.w	d1,a1
		dbf	d2,loc_18EB4

		bra.s	loc_18F38
; ===========================================================================

loc_18EC0:
		move.w	8(a1),d0
		move.w	$C(a1),d1
		move.w	8(a0),d2
		move.w	$C(a0),d3
		lea	byte_19022(pc),a2
		lea	byte_19026(pc),a3
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d0
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d2
		cmp.w	d0,d2
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d0
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d2
		cmp.w	d2,d0
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d1
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d3
		cmp.w	d1,d3
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d1
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d3
		cmp.w	d3,d1
		bcs.s	loc_18F38
		addq.b	#2,$24(a0)
		clr.w	$28(a0)
		clr.b	$20(a1)
		subq.b	#1,$21(a1)
		bne.s	loc_18F38
		bset	#7,$22(a1)
		clr.w	$10(a0)
		clr.w	$12(a0)

loc_18F38:
		tst.w	$12(a0)
		bpl.s	loc_18F5C
		jsr	ObjectFall
		move.w	$34(a0),d0
		subi.w	#$2F,d0
		cmp.w	$C(a0),d0
		bgt.s	loc_18F58
		jsr	ObjectFall

loc_18F58:
		bra.w	loc_18E7A
; ===========================================================================

loc_18F5C:
		jsr	ObjectFall
		movea.l	$3C(a0),a1
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	$1A(a1),d0
		move.w	8(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18F7E
		addq.w	#2,d0

loc_18F7E:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	$C(a0),d1
		bgt.s	loc_18F58
		movea.l	$3C(a0),a1
		moveq	#2,d1
		tst.w	$10(a0)
		bmi.s	loc_18F9C
		moveq	#0,d1

loc_18F9C:
		move.w	#0,$28(a0)

loc_18FA2:
		move.b	d1,$3A(a1)
		move.b	d1,$3A(a0)
		cmp.b	$1A(a1),d1
		beq.s	loc_19008
		bclr	#3,$22(a1)
		beq.s	loc_19008
		clr.b	$25(a1)
		move.b	#2,$24(a1)
		lea	($FFFFB000).w,a2
		move.w	$12(a0),$12(a2)
		neg.w	$12(a2)
		cmpi.b	#1,$1A(a1)
		bne.s	loc_18FDC
		asr	$12(a2)

loc_18FDC:
		bset	#1,$22(a2)
		bclr	#3,$22(a2)
		clr.b	$3C(a2)
		move.l	a0,-(sp)
		lea	(a2),a0
		jsr	Obj01_ChkRoll
		movea.l	(sp)+,a0
		move.b	#2,$24(a2)
		move.w	#$B1,d0
		jsr	(PlaySound_Special).l ;	play "spring" sound

loc_19008:
		clr.w	$10(a0)
		clr.w	$12(a0)
		addq.b	#2,$24(a0)
		bra.w	loc_18E7A
; ===========================================================================
word_19018:	dc.w $FFF8, $FFE4, $FFD1, $FFE4, $FFF8
		even
byte_19022:	dc.b $E8, $30, $E8, $30
		even
byte_19026:	dc.b 8,	$F0, 8,	$F0
		even
; ===========================================================================

Obj7B_Explode:				; XREF: Obj7B_Index
		move.b	#$3F,(a0)
		clr.b	$24(a0)
		cmpi.w	#$20,$28(a0)
		beq.s	Obj7B_MakeFrag
		rts	
; ===========================================================================

Obj7B_MakeFrag:
		move.w	$34(a0),$C(a0)
		moveq	#3,d1
		lea	Obj7B_FragSpeed(pc),a2

Obj7B_Loop:
		jsr	SingleObjLoad
		bne.s	loc_1909A
		move.b	#$7B,(a1)	; load shrapnel	object
		move.b	#$A,$24(a1)
		move.l	#Map_obj7B,4(a1)
		move.w	#$180,$18(a1)
		move.w	#$518,2(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	(a2)+,$10(a1)
		move.w	(a2)+,$12(a1)
		ori.b	#4,1(a1)
		bset	#7,1(a1)
		move.b	#$C,$14(a1)

loc_1909A:
		dbf	d1,Obj7B_Loop	; repeat sequence 3 more times
		rts	
; ===========================================================================
Obj7B_FragSpeed:dc.w $FF00, $FCC0	; horizontal, vertical
		dc.w $FF60, $FDC0
		dc.w $100, $FCC0
		dc.w $A0, $FDC0
; ===========================================================================

Obj7B_MoveFrag:				; XREF: Obj7B_Index
		jsr	SpeedToPos
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$34(a0)
		addi.w	#$18,$12(a0)
		moveq	#4,d0
		and.w	($FFFFFE0E).w,d0
		lsr.w	#2,d0
		move.b	d0,$1A(a0)
		tst.b	1(a0)
		bpl.w	Obj7A_Delete
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - exploding spikeys that the KVZ boss	drops
; ---------------------------------------------------------------------------
Map_obj7B:
	include "_maps\obj7B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 75 - Eggman (CCZ)
; ---------------------------------------------------------------------------

Obj75:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj75_Index(pc,d0.w),d1
		jmp	Obj75_Index(pc,d1.w)
; ===========================================================================
Obj75_Index:	dc.w Obj75_Main-Obj75_Index
		dc.w Obj75_ShipMain-Obj75_Index
		dc.w Obj75_FaceMain-Obj75_Index
		dc.w Obj75_FlameMain-Obj75_Index
		dc.w Obj75_SpikeMain-Obj75_Index

Obj75_ObjData:	dc.b 2,	0, 5		; routine number, animation, priority
		dc.b 4,	1, 5
		dc.b 6,	7, 5
		dc.b 8,	0, 5
; ===========================================================================

Obj75_Main:				; XREF: Obj75_Index
		move.w	#$2DB0,8(a0)
		move.w	#$4DA,$C(a0)
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$F,$20(a0)
		move.b	#8,$21(a0)	; set number of	hits to	8
		lea	Obj75_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj75_LoadBoss
; ===========================================================================

Obj75_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj75_ShipMain
		move.b	#$75,(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj75_LoadBoss:				; XREF: Obj75_Main
		bclr	#0,$22(a0)
		clr.b	$25(a1)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1C(a1)
		move.b	(a2)+,$18(a1)
		move.w 	$18(a1),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a1)
		move.l	#Map_Eggman,4(a1)
		move.w	#$400,2(a1)
		move.b	#4,1(a1)
		move.b	#$20,$14(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj75_Loop	; repeat sequence 3 more times

Obj75_ShipMain:				; XREF: Obj75_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj75_ShipIndex(pc,d0.w),d1
		jsr	Obj75_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj75_ShipIndex:dc.w loc_191CC-Obj75_ShipIndex,	loc_19270-Obj75_ShipIndex
		dc.w loc_192EC-Obj75_ShipIndex,	loc_19474-Obj75_ShipIndex
		dc.w loc_194AC-Obj75_ShipIndex,	loc_194F2-Obj75_ShipIndex
; ===========================================================================

loc_191CC:				; XREF: Obj75_ShipIndex
		move.w	#-$100,$10(a0)
		cmpi.w	#$2D38,$30(a0)
		bcc.s	loc_191DE
		addq.b	#2,$25(a0)

loc_191DE:
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#2,d0
		move.w	d0,$12(a0)

loc_191F2:
		bsr.w	BossMove
		move.w	$38(a0),$C(a0)
		move.w	$30(a0),8(a0)

loc_19202:
		move.w	8(a0),d0
		subi.w	#$2C00,d0
		lsr.w	#5,d0
		move.b	d0,$34(a0)
		cmpi.b	#6,$25(a0)
		bcc.s	locret_19256
		tst.b	$22(a0)
		bmi.s	loc_19258
		tst.b	$20(a0)
		bne.s	locret_19256
		tst.b	$3E(a0)
		bne.s	loc_1923A
		move.b	#$20,$3E(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound

loc_1923A:
		lea	($FFFFFB02).w,a1
		move.w	#$222,d0
		cmp.w	#$222,(a1)
		bne.s	loc_19248
		move.w	#$CCC,d0

loc_19248:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_19256
		move.b	#$F,$20(a0)

locret_19256:
		rts	
; ===========================================================================

loc_19258:				; XREF: loc_19202
		moveq	#100,d0
		bsr.w	AddPoints
		move.b	#6,$25(a0)
		move.w	#$B4,$3C(a0)
		clr.w	$10(a0)
		rts	
; ===========================================================================

loc_19270:				; XREF: Obj75_ShipIndex
		move.w	$30(a0),d0
		move.w	#$140,$10(a0)
		btst	#0,$22(a0)
		bne.s	loc_1928E
		neg.w	$10(a0)
		cmpi.w	#$2C08,d0
		bgt.s	loc_1929E
		bra.s	loc_19294
; ===========================================================================

loc_1928E:
		cmpi.w	#$2D38,d0
		blt.s	loc_1929E

loc_19294:
		bchg	#0,$22(a0)
		clr.b	$3D(a0)

loc_1929E:
		subi.w	#$2C10,d0
		andi.w	#$1F,d0
		subi.w	#$1F,d0
		bpl.s	loc_192AE
		neg.w	d0

loc_192AE:
		subq.w	#1,d0
		bgt.s	loc_192E8
		tst.b	$3D(a0)
		bne.s	loc_192E8
		move.w	($FFFFB008).w,d1
		subi.w	#$2C00,d1
		asr.w	#5,d1
		cmp.b	$34(a0),d1
		bne.s	loc_192E8
		moveq	#0,d0
		move.b	$34(a0),d0
		asl.w	#5,d0
		addi.w	#$2C10,d0
		move.w	d0,$30(a0)
		bsr.w	Obj75_FindBlocks
		addq.b	#2,$25(a0)
		clr.w	$28(a0)
		clr.w	$10(a0)

loc_192E8:
		bra.w	loc_191DE
; ===========================================================================

loc_192EC:				; XREF: Obj75_ShipIndex
		moveq	#0,d0
		move.b	$28(a0),d0
		move.w	off_192FA(pc,d0.w),d0
		jmp	off_192FA(pc,d0.w)
; ===========================================================================
off_192FA:	dc.w loc_19302-off_192FA
		dc.w loc_19348-off_192FA
		dc.w loc_1938E-off_192FA
		dc.w loc_193D0-off_192FA
; ===========================================================================

loc_19302:				; XREF: off_192FA
		move.w	#$180,$12(a0)
		move.w	$38(a0),d0
		cmpi.w	#$556,d0
		bcs.s	loc_19344
		move.w	#$556,$38(a0)
		clr.w	$3C(a0)
		moveq	#-1,d0
		move.w	$36(a0),d0
		beq.s	loc_1933C
		movea.l	d0,a1
		move.b	#-1,$29(a1)
		move.b	#-1,$29(a0)
		move.l	a0,$34(a1)
		move.w	#$32,$3C(a0)

loc_1933C:
		clr.w	$12(a0)
		addq.b	#2,$28(a0)

loc_19344:
		bra.w	loc_191F2
; ===========================================================================

loc_19348:				; XREF: off_192FA
		subq.w	#1,$3C(a0)
		bpl.s	loc_19366
		addq.b	#2,$28(a0)
		move.w	#-$800,$12(a0)
		tst.w	$36(a0)
		bne.s	loc_19362
		asr	$12(a0)

loc_19362:
		moveq	#0,d0
		bra.s	loc_1937C
; ===========================================================================

loc_19366:
		moveq	#0,d0
		cmpi.w	#$1E,$3C(a0)
		bgt.s	loc_1937C
		moveq	#2,d0
		btst	#1,$3D(a0)
		beq.s	loc_1937C
		neg.w	d0

loc_1937C:
		add.w	$38(a0),d0
		move.w	d0,$C(a0)
		move.w	$30(a0),8(a0)
		bra.w	loc_19202
; ===========================================================================

loc_1938E:				; XREF: off_192FA
		move.w	#$4DA,d0
		tst.w	$36(a0)
		beq.s	loc_1939C
		subi.w	#$18,d0

loc_1939C:
		cmp.w	$38(a0),d0
		blt.s	loc_193BE
		move.w	#8,$3C(a0)
		tst.w	$36(a0)
		beq.s	loc_193B4
		move.w	#$2D,$3C(a0)

loc_193B4:
		addq.b	#2,$28(a0)
		clr.w	$12(a0)
		bra.s	loc_193CC
; ===========================================================================

loc_193BE:
		cmpi.w	#-$40,$12(a0)
		bge.s	loc_193CC
		addi.w	#$C,$12(a0)

loc_193CC:
		bra.w	loc_191F2
; ===========================================================================

loc_193D0:				; XREF: off_192FA
		subq.w	#1,$3C(a0)
		bgt.s	loc_19406
		bmi.s	loc_193EE
		moveq	#-1,d0
		move.w	$36(a0),d0
		beq.s	loc_193E8
		movea.l	d0,a1
		move.b	#$A,$29(a1)

loc_193E8:
		clr.w	$36(a0)
		bra.s	loc_19406
; ===========================================================================

loc_193EE:
		cmpi.w	#-$1E,$3C(a0)
		bne.s	loc_19406
		clr.b	$29(a0)
		subq.b	#2,$25(a0)
		move.b	#-1,$3D(a0)
		bra.s	loc_19446
; ===========================================================================

loc_19406:
		moveq	#1,d0
		tst.w	$36(a0)
		beq.s	loc_19410
		moveq	#2,d0

loc_19410:
		cmpi.w	#$4DA,$38(a0)
		beq.s	loc_19424
		blt.s	loc_1941C
		neg.w	d0

loc_1941C:
		tst.w	$36(a0)
		add.w	d0,$38(a0)

loc_19424:
		moveq	#0,d0
		tst.w	$36(a0)
		beq.s	loc_19438
		moveq	#2,d0
		btst	#0,$3D(a0)
		beq.s	loc_19438
		neg.w	d0

loc_19438:
		add.w	$38(a0),d0
		move.w	d0,$C(a0)
		move.w	$30(a0),8(a0)

loc_19446:
		bra.w	loc_19202

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj75_FindBlocks:			; XREF: loc_192AE
		clr.w	$36(a0)
		lea	($FFFFB040).w,a1
		moveq	#$3E,d0
		moveq	#$76,d1
		move.b	$34(a0),d2

Obj75_FindLoop:
		cmp.b	(a1),d1		; is object a CCZ boss block?
		bne.s	loc_1946A	; if not, branch
		cmp.b	$28(a1),d2
		bne.s	loc_1946A
		move.w	a1,$36(a0)
		bra.s	locret_19472
; ===========================================================================

loc_1946A:
		lea	$40(a1),a1	; next object RAM entry
		dbf	d0,Obj75_FindLoop

locret_19472:
		rts	
; End of function Obj75_FindBlocks

; ===========================================================================

loc_19474:				; XREF: Obj75_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_1947E
		bra.w	BossDefeated
; ===========================================================================

loc_1947E:
		addq.b	#2,$25(a0)
		clr.w	$12(a0)
		bset	#0,$22(a0)
		bclr	#7,$22(a0)
		clr.w	$10(a0)
		move.w	#-1,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_194A8
		move.b	#1,($FFFFF7A7).w

loc_194A8:
		bra.w	loc_19202
; ===========================================================================

loc_194AC:				; XREF: Obj75_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_194BC
		bpl.s	loc_194C2
		addi.w	#$18,$12(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194BC:
		clr.w	$12(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194C2:
		cmpi.w	#$20,$3C(a0)
		bcs.s	loc_194DA
		beq.s	loc_194E0
		cmpi.w	#$2A,$3C(a0)
		bcs.s	loc_194EE
		addq.b	#2,$25(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194DA:
		subq.w	#8,$12(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194E0:
		clr.w	$12(a0)
		move.b	($FFFFF75D).w,d0	; store level music
		jsr	(PlaySound).l	; play CCZ music

loc_194EE:
		bra.w	loc_191F2
; ===========================================================================

loc_194F2:				; XREF: Obj75_ShipIndex
		move.w	#$400,$10(a0)
		move.w	#-$40,$12(a0)
		cmpi.w	#$2D40,($FFFFF72A).w
		bcc.s	loc_1950C
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_19512
; ===========================================================================

loc_1950C:
		tst.b	1(a0)
		bpl.s	Obj75_ShipDelete

loc_19512:
		bsr.w	BossMove
		bra.w	loc_191DE
; ===========================================================================

Obj75_ShipDelete:
		jmp	DeleteObject
; ===========================================================================

Obj75_FaceMain:				; XREF: Obj75_Index
		moveq	#1,d1
		movea.l	$34(a0),a1
		moveq	#0,d0
		move.b	$25(a1),d0
		move.w	off_19546(pc,d0.w),d0
		jsr	off_19546(pc,d0.w)
		move.b	d1,$1C(a0)
		move.b	(a0),d0
		cmp.b	(a1),d0
		bne.s	Obj75_FaceDelete
		bra.s	loc_195BE
; ===========================================================================

Obj75_FaceDelete:
		jmp	DeleteObject
; ===========================================================================
off_19546:	dc.w loc_19574-off_19546, loc_19574-off_19546
		dc.w loc_1955A-off_19546, loc_19552-off_19546
		dc.w loc_19552-off_19546, loc_19556-off_19546
; ===========================================================================

loc_19552:				; XREF: off_19546
		moveq	#$A,d1
		rts	
; ===========================================================================

loc_19556:				; XREF: off_19546
		moveq	#6,d1
		rts	
; ===========================================================================

loc_1955A:				; XREF: off_19546
		moveq	#0,d0
		move.b	$28(a1),d0
		move.w	off_19568(pc,d0.w),d0
		jmp	off_19568(pc,d0.w)
; ===========================================================================
off_19568:	dc.w loc_19570-off_19568, loc_19572-off_19568
		dc.w loc_19570-off_19568, loc_19570-off_19568
; ===========================================================================

loc_19570:				; XREF: off_19568
		bra.s	loc_19574
; ===========================================================================

loc_19572:				; XREF: off_19568
		moveq	#6,d1

loc_19574:				; XREF: off_19546
		tst.b	$20(a1)
		bne.s	loc_1957E
		moveq	#5,d1
		rts	
; ===========================================================================

loc_1957E:
		cmpi.b	#4,($FFFFB024).w
		bcs.s	locret_19588
		moveq	#4,d1

locret_19588:
		rts	
; ===========================================================================

Obj75_FlameMain:			; XREF: Obj75_Index
		move.b	#7,$1C(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,$25(a1)
		bne.s	loc_195AA
		move.b	#$B,$1C(a0)
		tst.b	1(a0)
		bpl.s	Obj75_FlameDelete
		bra.s	loc_195B6
; ===========================================================================

loc_195AA:
		tst.w	$10(a1)
		beq.s	loc_195B6
		move.b	#8,$1C(a0)

loc_195B6:
		bra.s	loc_195BE
; ===========================================================================

Obj75_FlameDelete:
		jmp	DeleteObject
; ===========================================================================

loc_195BE:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)

loc_195DA:
		move.b	$22(a1),$22(a0)
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#$FC,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj75_SpikeMain:			; XREF: Obj75_Index
		move.l	#Map_BossItems,4(a0)
		move.w	#$246C,2(a0)
		move.b	#5,$1A(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,$25(a1)
		bne.s	loc_1961C
		tst.b	1(a0)
		bpl.s	Obj75_SpikeDelete

loc_1961C:
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		move.w	$3C(a0),d0
		cmpi.b	#4,$25(a1)
		bne.s	loc_19652
		cmpi.b	#6,$28(a1)
		beq.s	loc_1964C
		tst.b	$28(a1)
		bne.s	loc_19658
		cmpi.w	#$94,d0
		bge.s	loc_19658
		addq.w	#7,d0
		bra.s	loc_19658
; ===========================================================================

loc_1964C:
		tst.w	$3C(a1)
		bpl.s	loc_19658

loc_19652:
		tst.w	d0
		ble.s	loc_19658
		subq.w	#5,d0

loc_19658:
		move.w	d0,$3C(a0)
		asr.w	#2,d0
		add.w	d0,$C(a0)
		move.b	#8,$14(a0)
		move.b	#$C,$16(a0)
		clr.b	$20(a0)
		movea.l	$34(a0),a1
		tst.b	$20(a1)
		beq.s	loc_19688
		tst.b	$29(a1)
		bne.s	loc_19688
		move.b	#$84,$20(a0)

loc_19688:
		bra.w	loc_195DA
; ===========================================================================

Obj75_SpikeDelete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 76 - blocks that Eggman picks up (CCZ)
; ---------------------------------------------------------------------------

Obj76:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj76_Index(pc,d0.w),d1
		jmp	Obj76_Index(pc,d1.w)
; ===========================================================================
Obj76_Index:	dc.w Obj76_Main-Obj76_Index
		dc.w Obj76_Action-Obj76_Index
		dc.w loc_19762-Obj76_Index
; ===========================================================================

Obj76_Main:				; XREF: Obj76_Index
		moveq	#0,d4
		move.w	#$2C10,d5
		moveq	#9,d6
		lea	(a0),a1
		bra.s	Obj76_MakeBlock
; ===========================================================================

Obj76_Loop:
		jsr	SingleObjLoad
		bne.s	Obj76_ExitLoop

Obj76_MakeBlock:			; XREF: Obj76_Main
		move.b	#$76,(a1)
		move.l	#Map_obj76,4(a1)
		move.w	#$4000,2(a1)
		move.b	#4,1(a1)
		move.b	#$10,$14(a1)
		move.b	#$10,$16(a1)
		move.w	#$180,$18(a1)
		move.w	d5,8(a1)	; set x-position
		move.w	#$582,$C(a1)
		move.w	d4,$28(a1)
		addi.w	#$101,d4
		addi.w	#$20,d5		; add $20 to next x-position
		addq.b	#2,$24(a1)
		dbf	d6,Obj76_Loop	; repeat sequence 9 more times

Obj76_ExitLoop:
		rts	
; ===========================================================================

Obj76_Action:				; XREF: Obj76_Index
		move.b	$29(a0),d0
		cmp.b	$28(a0),d0
		beq.s	Obj76_Solid
		tst.b	d0
		bmi.s	loc_19718

loc_19712:
		bsr.w	Obj76_Break
		bra.s	Obj76_Display
; ===========================================================================

loc_19718:
		movea.l	$34(a0),a1
		tst.b	$21(a1)
		beq.s	loc_19712
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		addi.w	#$2C,$C(a0)
		cmpa.w	a0,a1
		bcs.s	Obj76_Display
		move.w	$12(a1),d0
		ext.l	d0
		asr.l	#8,d0
		add.w	d0,$C(a0)
		bra.s	Obj76_Display
; ===========================================================================

Obj76_Solid:				; XREF: Obj76_Action
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		jsr	SolidObject

Obj76_Display:				; XREF: Obj76_Action
		jmp	DisplaySprite
; ===========================================================================

loc_19762:				; XREF: Obj76_Index
		tst.b	1(a0)
		bpl.s	Obj76_Delete
		jsr	ObjectFall
		jmp	DisplaySprite
; ===========================================================================

Obj76_Delete:
		jmp	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj76_Break:				; XREF: Obj76_Action
		lea	Obj76_FragSpeed(pc),a4
		lea	Obj76_FragPos(pc),a5
		moveq	#1,d4
		moveq	#3,d1
		moveq	#$38,d2
		addq.b	#2,$24(a0)
		move.b	#8,$14(a0)
		move.b	#8,$16(a0)
		lea	(a0),a1
		bra.s	Obj76_MakeFrag
; ===========================================================================

Obj76_LoopFrag:
		jsr	SingleObjLoad2
		bne.s	loc_197D4

Obj76_MakeFrag:
		lea	(a0),a2
		lea	(a1),a3
		moveq	#3,d3

loc_197AA:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d3,loc_197AA

		move.w	(a4)+,$10(a1)
		move.w	(a4)+,$12(a1)
		move.w	(a5)+,d3
		add.w	d3,8(a1)
		move.w	(a5)+,d3
		add.w	d3,$C(a1)
		move.b	d4,$1A(a1)
		addq.w	#1,d4
		dbf	d1,Obj76_LoopFrag ; repeat sequence 3 more times

loc_197D4:
		move.w	#$59,d0
		jmp	(PlaySound_Special).l ;	play smashing sound
; End of function Obj76_Break

; ===========================================================================
Obj76_FragSpeed:dc.w $FE80, $FE00
		dc.w $180, $FE00
		dc.w $FF00, $FF00
		dc.w $100, $FF00
Obj76_FragPos:	dc.w $FFF8, $FFF8
		dc.w $10, 0
		dc.w 0,	$10
		dc.w $10, $10
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	Eggman picks up (CCZ)
; ---------------------------------------------------------------------------
Map_obj76:
	include "_maps\obj76.asm"

; ===========================================================================

loc_1982C:				; XREF: loc_19C62; loc_19C80
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 82 - Eggman (ABZ2)
; ---------------------------------------------------------------------------

Obj82:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj82_Index(pc,d0.w),d1
		jmp	Obj82_Index(pc,d1.w)
; ===========================================================================
Obj82_Index:	dc.w Obj82_Main-Obj82_Index
		dc.w Obj82_Eggman-Obj82_Index
		dc.w Obj82_Switch-Obj82_Index

Obj82_ObjData:	dc.b 2,	0, 3		; routine number, animation, priority
		dc.b 4,	0, 3
; ===========================================================================

Obj82_Main:				; XREF: Obj82_Index
		lea	Obj82_ObjData(pc),a2
		move.w	#$2160,8(a0)
		move.w	#$5A4,$C(a0)
		move.b	#$F,$20(a0)
		move.b	#$10,$21(a0)
		bclr	#0,$22(a0)
		clr.b	$25(a0)
		move.b	(a2)+,$24(a0)
		move.b	(a2)+,$1C(a0)
		move.b	(a2)+,$18(a0)
		move.w 	$18(a0),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a0)
		move.l	#Map_obj82,4(a0)
		move.w	#$400,2(a0)
		move.b	#4,1(a0)
		bset	#7,1(a0)
		move.b	#$20,$14(a0)
		jsr	SingleObjLoad2
		bne.s	Obj82_Eggman
		move.l	a0,$34(a1)
		move.b	#$82,(a1)	; load switch object
		move.w	#$2130,8(a1)
		move.w	#$5BC,$C(a1)
		clr.b	$25(a0)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,$1C(a1)
		move.b	(a2)+,$18(a1)
		move.w 	$18(a1),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a1)
		move.l	#Map_obj32,4(a1)
		move.w	#$4A4,2(a1)
		move.b	#4,1(a1)
		bset	#7,1(a1)
		move.b	#$10,$14(a1)
		move.b	#0,$1A(a1)

Obj82_Eggman:				; XREF: Obj82_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj82_EggIndex(pc,d0.w),d1
		jsr	Obj82_EggIndex(pc,d1.w)
		lea	Ani_obj82(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================
Obj82_EggIndex:	dc.w Obj82_ChkSonic-Obj82_EggIndex
		dc.w Obj82_PreLeap-Obj82_EggIndex
		dc.w Obj82_Leap-Obj82_EggIndex
		dc.w loc_19934-Obj82_EggIndex
; ===========================================================================

Obj82_ChkSonic:				; XREF: Obj82_EggIndex
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		cmpi.w	#128,d0		; is Sonic within 128 pixels of	Eggman?
		bcc.s	loc_19934	; if not, branch
		addq.b	#2,$25(a0)
		move.w	#180,$3C(a0)	; set delay to 3 seconds
		move.b	#1,$1C(a0)

loc_19934:				; XREF: Obj82_EggIndex
		jmp	SpeedToPos
; ===========================================================================

Obj82_PreLeap:				; XREF: Obj82_EggIndex
		subq.w	#1,$3C(a0)	; subtract 1 from time delay
		bne.s	loc_19954	; if time remains, branch
		addq.b	#2,$25(a0)
		move.b	#2,$1C(a0)
		addq.w	#4,$C(a0)
		move.w	#15,$3C(a0)

loc_19954:
		bra.s	loc_19934
; ===========================================================================

Obj82_Leap:				; XREF: Obj82_EggIndex
		subq.w	#1,$3C(a0)
		bgt.s	loc_199D0
		bne.s	loc_1996A
		move.w	#-$FC,$10(a0)	; make Eggman leap
		move.w	#-$3C0,$12(a0)

loc_1996A:
		cmpi.w	#$2132,8(a0)
		bgt.s	loc_19976
		clr.w	$10(a0)

loc_19976:
		addi.w	#$24,$12(a0)
		tst.w	$12(a0)
		bmi.s	Obj82_FindBlocks
		cmpi.w	#$595,$C(a0)
		bcs.s	Obj82_FindBlocks
		move.w	#$5357,$28(a0)
		cmpi.w	#$59B,$C(a0)
		bcs.s	Obj82_FindBlocks
		move.w	#$59B,$C(a0)
		clr.w	$12(a0)

Obj82_FindBlocks:
		move.w	$10(a0),d0
		or.w	$12(a0),d0
		bne.s	loc_199D0
		lea	($FFFFB000).w,a1 ; start at the	first object RAM
		moveq	#$3E,d0
		moveq	#$40,d1

Obj82_FindLoop:	
		adda.w	d1,a1		; jump to next object RAM
		cmpi.b	#$83,(a1)	; is object a block? (object $83)
		dbeq	d0,Obj82_FindLoop ; if not, repeat (max	$3E times)

		bne.s	loc_199D0
		move.w	#$474F,$28(a1)	; set block to disintegrate
		addq.b	#2,$25(a0)
		move.b	#1,$1C(a0)

loc_199D0:
		bra.w	loc_19934
; ===========================================================================

Obj82_Switch:				; XREF: Obj82_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj82_SwIndex(pc,d0.w),d0
		jmp	Obj82_SwIndex(pc,d0.w)
; ===========================================================================
Obj82_SwIndex:	dc.w loc_199E6-Obj82_SwIndex
		dc.w Obj82_SwDisplay-Obj82_SwIndex
; ===========================================================================

loc_199E6:				; XREF: Obj82_SwIndex
		movea.l	$34(a0),a1
		cmpi.w	#$5357,$28(a1)
		bne.s	Obj82_SwDisplay
		move.b	#1,$1A(a0)
		addq.b	#2,$25(a0)

Obj82_SwDisplay:			; XREF: Obj82_SwIndex
		jmp	DisplaySprite
; ===========================================================================
Ani_obj82:
	include "_anim\obj82.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Eggman (ABZ2)
; ---------------------------------------------------------------------------
Map_obj82:
	include "_maps\obj82.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 83 - blocks that disintegrate Eggman	presses	a switch (ABZ2)
; ---------------------------------------------------------------------------

Obj83:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj83_Index(pc,d0.w),d1
		jmp	Obj83_Index(pc,d1.w)
; ===========================================================================
Obj83_Index:	dc.w Obj83_Main-Obj83_Index
		dc.w Obj83_ChkBreak-Obj83_Index
		dc.w loc_19C36-Obj83_Index
		dc.w loc_19C62-Obj83_Index
		dc.w loc_19C72-Obj83_Index
		dc.w loc_19C80-Obj83_Index
; ===========================================================================

Obj83_Main:				; XREF: Obj83_Index
		move.w	#$2080,8(a0)
		move.w	#$5D0,$C(a0)
		move.b	#$80,$14(a0)
		move.b	#$10,$16(a0)
		move.b	#4,1(a0)
		bset	#7,1(a0)
		moveq	#0,d4
		move.w	#$2010,d5
		moveq	#7,d6
		lea	$30(a0),a2

Obj83_MakeBlock:
		jsr	SingleObjLoad
		bne.s	Obj83_ExitMake
		move.w	a1,(a2)+
		move.b	#$83,(a1)	; load block object
		move.l	#Map_obj83,4(a1)
		move.w	#$4518,2(a1)
		move.b	#4,1(a1)
		move.b	#$10,$14(a1)
		move.b	#$10,$16(a1)
		move.w	#$180,$18(a1)
		move.w	d5,8(a1)	; set X	position
		move.w	#$5D0,$C(a1)
		addi.w	#$20,d5		; add $20 for next X position
		move.b	#8,$24(a1)
		dbf	d6,Obj83_MakeBlock ; repeat sequence 7 more times

Obj83_ExitMake:
		addq.b	#2,$24(a0)
		rts	
; ===========================================================================

Obj83_ChkBreak:				; XREF: Obj83_Index
		cmpi.w	#$474F,$28(a0)	; is object set	to disintegrate?
		bne.s	Obj83_Solid	; if not, branch
		clr.b	$1A(a0)
		addq.b	#2,$24(a0)	; next subroutine

Obj83_Solid:
		moveq	#0,d0
		move.b	$1A(a0),d0
		neg.b	d0
		ext.w	d0
		addq.w	#8,d0
		asl.w	#4,d0
		move.w	#$2100,d4
		sub.w	d0,d4
		move.b	d0,$14(a0)
		move.w	d4,8(a0)
		moveq	#$B,d1
		add.w	d0,d1
		moveq	#$10,d2
		moveq	#$11,d3
		jmp	SolidObject
; ===========================================================================

loc_19C36:				; XREF: Obj83_Index
		subi.b	#$E,$23(a0)
		bcc.s	Obj83_Solid2
		moveq	#-1,d0
		move.b	$1A(a0),d0
		ext.w	d0
		add.w	d0,d0
		move.w	$30(a0,d0.w),d0
		movea.l	d0,a1
		move.w	#$474F,$28(a1)
		addq.b	#1,$1A(a0)
		cmpi.b	#8,$1A(a0)
		beq.s	loc_19C62

Obj83_Solid2:
		bra.s	Obj83_Solid
; ===========================================================================

loc_19C62:				; XREF: Obj83_Index
		bclr	#3,$22(a0)
		bclr	#3,($FFFFB022).w
		bra.w	loc_1982C
; ===========================================================================

loc_19C72:				; XREF: Obj83_Index
		cmpi.w	#$474F,$28(a0)	; is object set	to disintegrate?
		beq.s	Obj83_Break	; if yes, branch
		jmp	DisplaySprite
; ===========================================================================

loc_19C80:				; XREF: Obj83_Index
		tst.b	1(a0)
		bpl.w	loc_1982C
		jsr	ObjectFall
		jmp	DisplaySprite
; ===========================================================================

Obj83_Break:				; XREF: loc_19C72
		lea	Obj83_FragSpeed(pc),a4
		lea	Obj83_FragPos(pc),a5
		moveq	#1,d4
		moveq	#3,d1
		moveq	#$38,d2
		addq.b	#2,$24(a0)
		move.b	#8,$14(a0)
		move.b	#8,$16(a0)
		lea	(a0),a1
		bra.s	Obj83_MakeFrag
; ===========================================================================

Obj83_LoopFrag:
		jsr	SingleObjLoad2
		bne.s	Obj83_BreakSnd

Obj83_MakeFrag:				; XREF: Obj83_Break
		lea	(a0),a2
		lea	(a1),a3
		moveq	#3,d3

loc_19CC4:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d3,loc_19CC4

		move.w	(a4)+,$12(a1)
		move.w	(a5)+,d3
		add.w	d3,8(a1)
		move.w	(a5)+,d3
		add.w	d3,$C(a1)
		move.b	d4,$1A(a1)
		addq.w	#1,d4
		dbf	d1,Obj83_LoopFrag ; repeat sequence 3 more times

Obj83_BreakSnd:
		move.w	#$59,d0
		jsr	(PlaySound_Special).l ;	play smashing sound
		jmp	DisplaySprite
; ===========================================================================
Obj83_FragSpeed:dc.w $80, 0
		dc.w $120, $C0
Obj83_FragPos:	dc.w $FFF8, $FFF8
		dc.w $10, 0
		dc.w 0,	$10
		dc.w $10, $10
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	disintegrate when Eggman presses a switch
; ---------------------------------------------------------------------------
Map_obj83:
	include "_maps\obj83.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 85 - Eggman (FZ)
; ---------------------------------------------------------------------------

Obj85_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj85:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj85_Index(pc,d0.w),d0
		jmp	Obj85_Index(pc,d0.w)
; ===========================================================================
Obj85_Index:	dc.w Obj85_Main-Obj85_Index
		dc.w Obj85_Eggman-Obj85_Index
		dc.w loc_1A38E-Obj85_Index
		dc.w loc_1A346-Obj85_Index
		dc.w loc_1A2C6-Obj85_Index
		dc.w loc_1A3AC-Obj85_Index
		dc.w loc_1A264-Obj85_Index

Obj85_ObjData:	dc.w $100, $100, $470	; X pos, Y pos,	VRAM setting
		dc.l Map_obj82		; mappings pointer
		dc.w $25B0, $590, $300
		dc.l Map_obj84
		dc.w $26E0, $596, $3A0
		dc.l Map_FZBoss
		dc.w $26E0, $596, $470
		dc.l Map_obj82
		dc.w $26E0, $596, $400
		dc.l Map_Eggman
		dc.w $26E0, $596, $400
		dc.l Map_Eggman

Obj85_ObjData2:	dc.b 2,	0, 4, $20, $19	; routine num, animation, sprite priority, width, height
		dc.b 4,	0, 1, $12, 8
		dc.b 6,	0, 3, 0, 0
		dc.b 8,	0, 3, 0, 0
		dc.b $A, 0, 3, $20, $20
		dc.b $C, 0, 3, 0, 0
; ===========================================================================

Obj85_Main:				; XREF: Obj85_Index
		lea	Obj85_ObjData(pc),a2
		lea	Obj85_ObjData2(pc),a3
		movea.l	a0,a1
		moveq	#5,d1
		bra.s	Obj85_LoadBoss
; ===========================================================================

Obj85_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_19E20

Obj85_LoadBoss:				; XREF: Obj85_Main
		move.b	#$85,(a1)
		move.w	(a2)+,8(a1)
		move.w	(a2)+,$C(a1)
		move.w	(a2)+,2(a1)
		move.l	(a2)+,4(a1)
		move.b	(a3)+,$24(a1)
		move.b	(a3)+,$1C(a1)
		move.b	(a3)+,$18(a1)
		move.w 	$18(a1),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a1)
		move.b	(a3)+,$17(a1)
		move.b	(a3)+,$16(a1)
		move.b	#4,1(a1)
		bset	#7,1(a0)
		move.l	a0,$34(a1)
		dbf	d1,Obj85_Loop

loc_19E20:
		lea	$36(a0),a2
		jsr	SingleObjLoad
		bne.s	loc_19E5A
		move.b	#$86,(a1)	; load energy ball object
		move.w	a1,(a2)
		move.l	a0,$34(a1)
		lea	$38(a0),a2
		moveq	#0,d2
		moveq	#3,d1

loc_19E3E:
		jsr	SingleObjLoad2
		bne.s	loc_19E5A
		move.w	a1,(a2)+
		move.b	#$84,(a1)	; load crushing	cylinder object
		move.l	a0,$34(a1)
		move.b	d2,$28(a1)
		addq.w	#2,d2
		dbf	d1,loc_19E3E

loc_19E5A:
		move.w	#0,$34(a0)
		move.b	#8,$21(a0)	; set number of	hits to	8
		move.w	#-1,$30(a0)

Obj85_Eggman:				; XREF: Obj85_Index
		moveq	#0,d0
		move.b	$34(a0),d0
		move.w	off_19E80(pc,d0.w),d0
		jsr	off_19E80(pc,d0.w)
		jmp	DisplaySprite
; ===========================================================================
off_19E80:	dc.w loc_19E90-off_19E80, loc_19EA8-off_19E80
		dc.w loc_19FE6-off_19E80, loc_1A02A-off_19E80
		dc.w loc_1A074-off_19E80, loc_1A112-off_19E80
		dc.w loc_1A192-off_19E80, loc_1A1D4-off_19E80
; ===========================================================================

loc_19E90:				; XREF: off_19E80
		tst.l	($FFFFF680).w
		bne.s	loc_19EA2
		cmpi.w	#$2450,($FFFFF700).w
		bcs.s	loc_19EA2
		addq.b	#2,$34(a0)
		move.b	#$20,d0
		move.b	#$34,($FFFFB080).w ; load title	card object
		move.b	d0,($FFFFB09A).w
		jmp	(PlaySound).l

loc_19EA2:
		addq.l	#1,($FFFFF636).w
		rts	
; ===========================================================================

loc_19EA8:				; XREF: off_19E80
		tst.w	$30(a0)
		bpl.s	loc_19F10
		clr.w	$30(a0)
		jsr	(RandomNumber).l
		andi.w	#$C,d0
		move.w	d0,d1
		addq.w	#2,d1
		tst.l	d0
		bpl.s	loc_19EC6
		exg	d1,d0

loc_19EC6:
		lea	word_19FD6(pc),a1
		move.w	(a1,d0.w),d0
		move.w	(a1,d1.w),d1
		move.w	d0,$30(a0)
		moveq	#-1,d2
		move.w	$38(a0,d0.w),d2
		movea.l	d2,a1
		move.b	#-1,$29(a1)
		move.w	#-1,$30(a1)
		move.w	$38(a0,d1.w),d2
		movea.l	d2,a1
		move.b	#1,$29(a1)
		move.w	#0,$30(a1)
		move.w	#1,$32(a0)
		clr.b	$35(a0)
		move.w	#$6F,d0
		jsr	(PlaySound_Special).l ;	play rumbling sound

loc_19F10:
		tst.w	$32(a0)
		bmi.w	loc_19FA6
		bclr	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcs.s	loc_19F2E
		bset	#0,$22(a0)

loc_19F2E:
		move.w	#$2B,d1
		move.w	#$14,d2
		move.w	#$14,d3
		move.w	8(a0),d4
		jsr	SolidObject
		tst.w	d4
		bgt.s	loc_19F50

loc_19F48:
		tst.b	$35(a0)
		bne.s	loc_19F88
		bra.s	loc_19F96
; ===========================================================================

loc_19F50:
		addq.w	#7,($FFFFF636).w
		cmpi.b	#2,($FFFFB01C).w
		bne.s	loc_19F48
		move.w	#$300,d0
		btst	#0,$22(a0)
		bne.s	loc_19F6A
		neg.w	d0

loc_19F6A:
		move.w	d0,($FFFFB010).w
		tst.b	$35(a0)
		bne.s	loc_19F88
		subq.b	#1,$21(a0)
		move.b	#$64,$35(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound

loc_19F88:
		subq.b	#1,$35(a0)
		beq.s	loc_19F96
		move.b	#3,$1C(a0)
		bra.s	loc_19F9C
; ===========================================================================

loc_19F96:
		move.b	#1,$1C(a0)

loc_19F9C:
		lea	Ani_obj82(pc),a1
		jmp	AnimateSprite
; ===========================================================================

loc_19FA6:
		tst.b	$21(a0)
		beq.s	loc_19FBC
		addq.b	#2,$34(a0)
		move.w	#-1,$30(a0)
		clr.w	$32(a0)
		rts	
; ===========================================================================

loc_19FBC:
		move.b	#6,$34(a0)
		move.w	#$25C0,8(a0)
		move.w	#$53C,$C(a0)
		move.b	#$14,$16(a0)
		rts	
; ===========================================================================
word_19FD6:	dc.w 0,	2, 2, 4, 4, 6, 6, 0
; ===========================================================================

loc_19FE6:				; XREF: off_19E80
		moveq	#-1,d0
		move.w	$36(a0),d0
		movea.l	d0,a1
		tst.w	$30(a0)
		bpl.s	loc_1A000
		clr.w	$30(a0)
		move.b	#-1,$29(a1)
		bsr.s	loc_1A020

loc_1A000:
		moveq	#$F,d0
		and.w	($FFFFFE0E).w,d0
		bne.s	loc_1A00A
		bsr.s	loc_1A020

loc_1A00A:
		tst.w	$32(a0)
		beq.s	locret_1A01E
		subq.b	#2,$34(a0)
		move.w	#-1,$30(a0)
		clr.w	$32(a0)

locret_1A01E:
		rts	
; ===========================================================================

loc_1A020:
		move.w	#$79,d0
		jmp	(PlaySound_Special).l ;	play electricity sound
; ===========================================================================

loc_1A02A:				; XREF: off_19E80
		move.b	#$30,$17(a0)
		bset	#0,$22(a0)
		jsr	SpeedToPos
		move.b	#6,$1A(a0)
		addi.w	#$10,$12(a0)
		cmpi.w	#$59C,$C(a0)
		bcs.s	loc_1A070
		move.w	#$59C,$C(a0)
		addq.b	#2,$34(a0)
		move.b	#$20,$17(a0)
		move.w	#$100,$10(a0)
		move.w	#-$100,$12(a0)
		addq.b	#2,($FFFFF742).w

loc_1A070:
		bra.w	loc_1A166
; ===========================================================================

loc_1A074:				; XREF: off_19E80
		bset	#0,$22(a0)
		move.b	#4,$1C(a0)
		jsr	SpeedToPos
		addi.w	#$10,$12(a0)
		cmpi.w	#$5A3,$C(a0)
		bcs.s	loc_1A09A
		move.w	#-$40,$12(a0)

loc_1A09A:
		move.w	#$400,$10(a0)
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		bpl.s	loc_1A0B4
		move.w	#$500,$10(a0)
		bra.w	loc_1A0F2
; ===========================================================================

loc_1A0B4:
		subi.w	#$70,d0
		bcs.s	loc_1A0F2
		subi.w	#$100,$10(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$100,$10(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,$10(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,$10(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,$10(a0)
		subi.w	#$38,d0
		bcs.s	loc_1A0F2
		clr.w	$10(a0)

loc_1A0F2:
		cmpi.w	#$26A0,8(a0)
		bcs.s	loc_1A110
		move.w	#$26A0,8(a0)
		move.w	#$240,$10(a0)
		move.w	#-$4C0,$12(a0)
		addq.b	#2,$34(a0)

loc_1A110:
		bra.s	loc_1A15C
; ===========================================================================

loc_1A112:				; XREF: off_19E80
		jsr	SpeedToPos
		cmpi.w	#$26E0,8(a0)
		bcs.s	loc_1A124
		clr.w	$10(a0)

loc_1A124:
		addi.w	#$34,$12(a0)
		tst.w	$12(a0)
		bmi.s	loc_1A142
		cmpi.w	#$592,$C(a0)
		bcs.s	loc_1A142
		move.w	#$592,$C(a0)
		clr.w	$12(a0)

loc_1A142:
		move.w	$10(a0),d0
		or.w	$12(a0),d0
		bne.s	loc_1A15C
		addq.b	#2,$34(a0)
		move.w	#-$180,$12(a0)
		move.b	#1,$21(a0)

loc_1A15C:
		lea	Ani_obj82(pc),a1
		jsr	AnimateSprite

loc_1A166:
		cmpi.w	#$2700,($FFFFF72A).w
		bge.s	loc_1A172
		addq.w	#2,($FFFFF72A).w

loc_1A172:
		cmpi.b	#$C,$34(a0)
		bge.s	locret_1A190
		move.w	#$1B,d1
		move.w	#$70,d2
		move.w	#$71,d3
		move.w	8(a0),d4
		jmp	SolidObject
; ===========================================================================

locret_1A190:
		rts	
; ===========================================================================

loc_1A192:				; XREF: off_19E80
		move.l	#Map_Eggman,4(a0)
		move.w	#$400,2(a0)
		move.b	#0,$1C(a0)
		bset	#0,$22(a0)
		jsr	SpeedToPos
		cmpi.w	#$544,$C(a0)
		bcc.s	loc_1A1D0
		move.w	#$180,$10(a0)
		move.w	#-$18,$12(a0)
		move.b	#$F,$20(a0)
		addq.b	#2,$34(a0)

loc_1A1D0:
		bra.w	loc_1A15C
; ===========================================================================

loc_1A1D4:				; XREF: off_19E80
		bset	#0,$22(a0)
		jsr	SpeedToPos
		tst.w	$30(a0)
		bne.s	loc_1A1FC
		tst.b	$20(a0)
		bne.s	loc_1A216
		move.w	#$1E,$30(a0)
		move.w	#$6E,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound

loc_1A1FC:
		subq.w	#1,$30(a0)
		bne.s	loc_1A216
		tst.b	$22(a0)
		bpl.s	loc_1A210
		move.w	#$60,$12(a0)
		bra.s	loc_1A216
; ===========================================================================

loc_1A210:
		move.b	#$F,$20(a0)

loc_1A216:
		cmpi.w	#$2790,($FFFFB008).w
		blt.s	loc_1A23A
		move.b	#1,($FFFFF7CC).w
		move.w	#0,($FFFFF602).w
		clr.w	($FFFFB014).w
		tst.w	$12(a0)
		bpl.s	loc_1A248
		move.w	#$100,($FFFFF602).w

loc_1A23A:
		cmpi.w	#$27E0,($FFFFB008).w
		blt.s	loc_1A248
		move.w	#$27E0,($FFFFB008).w

loc_1A248:
		cmpi.w	#$2900,8(a0)
		bcs.s	loc_1A260
		tst.b	1(a0)
		bmi.s	loc_1A260
		move.b	#$18,($FFFFF600).w
		bra.w	Obj85_Delete
; ===========================================================================

loc_1A260:
		bra.w	loc_1A15C
; ===========================================================================

loc_1A264:				; XREF: Obj85_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.w	Obj85_Delete
		move.b	#7,$1C(a0)
		cmpi.b	#$C,$34(a1)
		bge.s	loc_1A280
		bra.s	loc_1A2A6
; ===========================================================================

loc_1A280:
		tst.w	$10(a1)
		beq.s	loc_1A28C
		move.b	#$B,$1C(a0)

loc_1A28C:
		lea	Ani_Eggman(pc),a1
		jsr	AnimateSprite

loc_1A296:
		movea.l	$34(a0),a1
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)

loc_1A2A6:
		movea.l	$34(a0),a1
		move.b	$22(a1),$22(a0)
		moveq	#3,d0
		and.b	$22(a0),d0
		andi.b	#-4,1(a0)
		or.b	d0,1(a0)
		jmp	DisplaySprite
; ===========================================================================

loc_1A2C6:				; XREF: Obj85_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.w	Obj85_Delete
		cmpi.l	#Map_Eggman,4(a1)
		beq.s	loc_1A2E4
		move.b	#$A,$1A(a0)
		bra.s	loc_1A2A6
; ===========================================================================

loc_1A2E4:
		move.b	#1,$1C(a0)
		tst.b	$21(a1)
		ble.s	loc_1A312
		move.b	#6,$1C(a0)
		move.l	#Map_Eggman,4(a0)
		move.w	#$400,2(a0)
		lea	Ani_Eggman(pc),a1
		jsr	AnimateSprite
		bra.w	loc_1A296
; ===========================================================================

loc_1A312:
		tst.b	1(a0)
		bpl.w	Obj85_Delete
		bsr.w	BossDefeated
		move.b	#2,$18(a0)
		move.b	#0,$1C(a0)
		move.l	#Map_Eggman2,4(a0)
		move.w	#$3A0,2(a0)
		lea	Ani_obj85(pc),a1
		jsr	AnimateSprite
		bra.w	loc_1A296
; ===========================================================================

loc_1A346:				; XREF: Obj85_Index
		bset	#0,$22(a0)
		movea.l	$34(a0),a1
		cmpi.l	#Map_Eggman,4(a1)
		beq.s	loc_1A35E
		bra.w	loc_1A2A6
; ===========================================================================

loc_1A35E:
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		tst.b	$23(a0)
		bne.s	loc_1A376
		move.b	#$14,$23(a0)

loc_1A376:
		subq.b	#1,$23(a0)
		bgt.s	loc_1A38A
		addq.b	#1,$1A(a0)
		cmpi.b	#2,$1A(a0)
		bgt.w	Obj85_Delete

loc_1A38A:
		bra.w	loc_1A296
; ===========================================================================

loc_1A38E:				; XREF: Obj85_Index
		move.b	#$B,$1A(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcs.s	loc_1A3A6
		tst.b	1(a0)
		bpl.w	Obj85_Delete

loc_1A3A6:
		jmp	DisplaySprite
; ===========================================================================

loc_1A3AC:				; XREF: Obj85_Index
		move.b	#0,$1A(a0)
		bset	#0,$22(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$C,$34(a1)
		bne.s	loc_1A3D0
		cmpi.l	#Map_Eggman,4(a1)
		beq.w	Obj85_Delete

loc_1A3D0:
		bra.w	loc_1A2A6
; ===========================================================================
Ani_obj85:
	include "_anim\obj85.asm"

Map_Eggman2:
	include "_maps\Eggman2.asm"

Map_FZBoss:
	include "_maps\FZ boss.asm"

; ===========================================================================

Obj84_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 84 - cylinder Eggman	hides in (FZ)
; ---------------------------------------------------------------------------

Obj84:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj84_Index(pc,d0.w),d0
		jmp	Obj84_Index(pc,d0.w)
; ===========================================================================
Obj84_Index:	dc.w Obj84_Main-Obj84_Index
		dc.w loc_1A4CE-Obj84_Index
		dc.w loc_1A57E-Obj84_Index

Obj84_PosData:	dc.w $24D0, $620
		dc.w $2550, $620
		dc.w $2490, $4C0
		dc.w $2510, $4C0
; ===========================================================================

Obj84_Main:				; XREF: Obj84_Index
		lea	Obj84_PosData(pc),a1
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		adda.w	d0,a1
		move.b	#4,1(a0)
		bset	#7,1(a0)
		bset	#4,1(a0)
		move.w	#$300,2(a0)
		move.l	#Map_obj84,4(a0)
		move.w	(a1)+,8(a0)
		move.w	(a1),$C(a0)
		move.w	(a1)+,$38(a0)
		move.b	#$20,$16(a0)
		move.b	#$60,$17(a0)
		move.b	#$20,$14(a0)
		move.b	#$60,$16(a0)
		move.w	#$180,$18(a0)
		addq.b	#2,$24(a0)

loc_1A4CE:				; XREF: Obj84_Index
		cmpi.b	#2,$28(a0)
		ble.s	loc_1A4DC
		bset	#1,1(a0)

loc_1A4DC:
		clr.l	$3C(a0)
		tst.b	$29(a0)
		beq.s	loc_1A4EA
		addq.b	#2,$24(a0)

loc_1A4EA:
		move.l	$3C(a0),d0
		move.l	$38(a0),d1
		add.l	d0,d1
		swap	d1
		move.w	d1,$C(a0)
		cmpi.b	#4,$24(a0)
		bne.s	loc_1A524
		tst.w	$30(a0)
		bpl.s	loc_1A524
		moveq	#-$A,d0
		cmpi.b	#2,$28(a0)
		ble.s	loc_1A514
		moveq	#$E,d0

loc_1A514:
		add.w	d0,d1
		movea.l	$34(a0),a1
		move.w	d1,$C(a1)
		move.w	8(a0),8(a1)

loc_1A524:
		move.w	#$2B,d1
		move.w	#$60,d2
		move.w	#$61,d3
		move.w	8(a0),d4
		jsr	SolidObject
		moveq	#0,d0
		move.w	$3C(a0),d1
		bpl.s	loc_1A550
		neg.w	d1
		subq.w	#8,d1
		bcs.s	loc_1A55C
		addq.b	#1,d0
		asr.w	#4,d1
		add.w	d1,d0
		bra.s	loc_1A55C
; ===========================================================================

loc_1A550:
		subi.w	#$27,d1
		bcs.s	loc_1A55C
		addq.b	#1,d0
		asr.w	#4,d1
		add.w	d1,d0

loc_1A55C:
		move.b	d0,$1A(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bmi.s	loc_1A578
		subi.w	#$140,d0
		bmi.s	loc_1A578
		tst.b	1(a0)
		bpl.w	Obj84_Delete

loc_1A578:
		jmp	DisplaySprite
; ===========================================================================

loc_1A57E:				; XREF: Obj84_Index
		moveq	#0,d0
		move.b	$28(a0),d0
		move.w	off_1A590(pc,d0.w),d0
		jsr	off_1A590(pc,d0.w)
		bra.w	loc_1A4EA
; ===========================================================================
off_1A590:	dc.w loc_1A598-off_1A590
		dc.w loc_1A598-off_1A590
		dc.w loc_1A604-off_1A590
		dc.w loc_1A604-off_1A590
; ===========================================================================

loc_1A598:				; XREF: off_1A590
		tst.b	$29(a0)
		bne.s	loc_1A5D4
		movea.l	$34(a0),a1
		tst.b	$21(a1)
		bne.s	loc_1A5B4
		bsr.w	BossDefeated
		subi.l	#$10000,$3C(a0)

loc_1A5B4:
		addi.l	#$20000,$3C(a0)
		bcc.s	locret_1A602
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,$24(a0)
		rts	
; ===========================================================================

loc_1A5D4:
		cmpi.w	#-$10,$3C(a0)
		bge.s	loc_1A5E4
		subi.l	#$28000,$3C(a0)

loc_1A5E4:
		subi.l	#$8000,$3C(a0)
		cmpi.w	#-$A0,$3C(a0)
		bgt.s	locret_1A602
		clr.w	$3E(a0)
		move.w	#-$A0,$3C(a0)
		clr.b	$29(a0)

locret_1A602:
		rts	
; ===========================================================================

loc_1A604:				; XREF: off_1A590
		bset	#1,1(a0)
		tst.b	$29(a0)
		bne.s	loc_1A646
		movea.l	$34(a0),a1
		tst.b	$21(a1)
		bne.s	loc_1A626
		bsr.w	BossDefeated
		addi.l	#$10000,$3C(a0)

loc_1A626:
		subi.l	#$20000,$3C(a0)
		bcc.s	locret_1A674
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,$24(a0)
		rts	
; ===========================================================================

loc_1A646:
		cmpi.w	#$10,$3C(a0)
		blt.s	loc_1A656
		addi.l	#$28000,$3C(a0)

loc_1A656:
		addi.l	#$8000,$3C(a0)
		cmpi.w	#$A0,$3C(a0)
		blt.s	locret_1A674
		clr.w	$3E(a0)
		move.w	#$A0,$3C(a0)
		clr.b	$29(a0)

locret_1A674:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - cylinders Eggman hides in (FZ)
; ---------------------------------------------------------------------------
Map_obj84:
	include "_maps\obj84.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 86 - energy balls (FZ)
; ---------------------------------------------------------------------------

Obj86:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj86_Index(pc,d0.w),d0
		jmp	Obj86_Index(pc,d0.w)
; ===========================================================================
Obj86_Index:	dc.w Obj86_Main-Obj86_Index
		dc.w Obj86_Generator-Obj86_Index
		dc.w Obj86_MakeBalls-Obj86_Index
		dc.w loc_1A962-Obj86_Index
		dc.w loc_1A982-Obj86_Index
; ===========================================================================

Obj86_Main:				; XREF: Obj86_Index
		move.w	#$2588,8(a0)
		move.w	#$53C,$C(a0)
		move.w	#$300,2(a0)
		move.l	#Map_obj86,4(a0)
		move.b	#0,$1C(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$17(a0)
		move.b	#8,$16(a0)
		move.b	#4,1(a0)
		bset	#7,1(a0)
		addq.b	#2,$24(a0)

Obj86_Generator:			; XREF: Obj86_Index
		movea.l	$34(a0),a1
		cmpi.b	#6,$34(a1)
		bne.s	loc_1A850
		move.b	#$3F,(a0)
		move.b	#0,$24(a0)
		jmp	DisplaySprite
; ===========================================================================

loc_1A850:
		move.b	#0,$1C(a0)
		tst.b	$29(a0)
		beq.s	loc_1A86C
		addq.b	#2,$24(a0)
		move.b	#1,$1C(a0)
		move.b	#$3E,$28(a0)

loc_1A86C:
		move.w	#$13,d1
		move.w	#8,d2
		move.w	#$11,d3
		move.w	8(a0),d4
		jsr	SolidObject
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bmi.s	loc_1A89A
		subi.w	#$140,d0
		bmi.s	loc_1A89A
		tst.b	1(a0)
		bpl.w	Obj84_Delete

loc_1A89A:
		lea	Ani_obj86(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj86_MakeBalls:			; XREF: Obj86_Index
		tst.b	$29(a0)
		beq.w	loc_1A954
		clr.b	$29(a0)
		add.w	$30(a0),d0
		andi.w	#$1E,d0
		adda.w	d0,a2
		addq.w	#4,$30(a0)
		clr.w	$32(a0)
		moveq	#3,d2

Obj86_Loop:
		jsr	SingleObjLoad2
		bne.w	loc_1A954
		move.b	#$86,(a1)
		move.w	8(a0),8(a1)
		move.w	#$53C,$C(a1)
		move.b	#8,$24(a1)
		move.w	#$2300,2(a1)
		move.l	#Map_obj86a,4(a1)
		move.b	#$C,$16(a1)
		move.b	#$C,$17(a1)
		move.b	#0,$20(a1)
		move.w	#$180,$18(a1)
		move.w	#$3E,$28(a1)
		move.b	#4,1(a1)
		bset	#7,1(a1)
		move.l	a0,$34(a1)
		jsr	(RandomNumber).l
		move.w	$32(a0),d1
		muls.w	#-$4F,d1
		addi.w	#$2578,d1
		andi.w	#$1F,d0
		subi.w	#$10,d0
		add.w	d1,d0
		move.w	d0,$30(a1)
		addq.w	#1,$32(a0)
		move.w	$32(a0),$38(a0)
		dbf	d2,Obj86_Loop	; repeat sequence 3 more times

loc_1A954:
		tst.w	$32(a0)
		bne.s	loc_1A95E
		addq.b	#2,$24(a0)

loc_1A95E:
		bra.w	loc_1A86C
; ===========================================================================

loc_1A962:				; XREF: Obj86_Index
		move.b	#2,$1C(a0)
		tst.w	$38(a0)
		bne.s	loc_1A97E
		move.b	#2,$24(a0)
		movea.l	$34(a0),a1
		move.w	#-1,$32(a1)

loc_1A97E:
		bra.w	loc_1A86C
; ===========================================================================

loc_1A982:				; XREF: Obj86_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj86_Index2(pc,d0.w),d0
		jsr	Obj86_Index2(pc,d0.w)
		lea	Ani_obj86a(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================
Obj86_Index2:	dc.w loc_1A9A6-Obj86_Index2
		dc.w loc_1A9C0-Obj86_Index2
		dc.w loc_1AA1E-Obj86_Index2
; ===========================================================================

loc_1A9A6:				; XREF: Obj86_Index2
		move.w	$30(a0),d0
		sub.w	8(a0),d0
		asl.w	#4,d0
		move.w	d0,$10(a0)
		move.w	#$B4,$28(a0)
		addq.b	#2,$25(a0)
		rts	
; ===========================================================================

loc_1A9C0:				; XREF: Obj86_Index2
		tst.w	$10(a0)
		beq.s	loc_1A9E6
		jsr	SpeedToPos
		move.w	8(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_1A9E6
		clr.w	$10(a0)
		add.w	d0,8(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)

loc_1A9E6:
		move.b	#0,$1C(a0)
		subq.w	#1,$28(a0)
		bne.s	locret_1AA1C
		addq.b	#2,$25(a0)
		move.b	#1,$1C(a0)
		move.w	#$B4,$28(a0)
		moveq	#0,d0
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		move.w	d0,$10(a0)
		move.w	#$140,$12(a0)
		move.b	#$9A,$20(a0)
		bset	#5,$2B(a0)

locret_1AA1C:
		rts	
; ===========================================================================

loc_1AA1E:				; XREF: Obj86_Index2
		jsr	SpeedToPos
		cmpi.w	#$5E0,$C(a0)
		bcc.s	loc_1AA34
		subq.w	#1,$28(a0)
		beq.s	loc_1AA34
		rts	
; ===========================================================================

loc_1AA34:
		movea.l	$34(a0),a1
		subq.w	#1,$38(a1)
		bra.w	Obj84_Delete
; ===========================================================================
Ani_obj86:
	include "_anim\obj86.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - energy ball	launcher (FZ)
; ---------------------------------------------------------------------------
Map_obj86:
	include "_maps\obj86.asm"

Ani_obj86a:
	include "_anim\obj86a.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - energy balls (FZ)
; ---------------------------------------------------------------------------
Map_obj86a:
	include "_maps\obj86a.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3E - prison capsule
; ---------------------------------------------------------------------------

Obj3E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3E_Index(pc,d0.w),d1
		jsr	Obj3E_Index(pc,d1.w)
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj3E_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj3E_Done	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj3E_Delete

Obj3E_Done:
		jmp	DisplaySprite
; ===========================================================================

Obj3E_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj3E_Index:	dc.w Obj3E_Main-Obj3E_Index
		dc.w Obj3E_BodyMain-Obj3E_Index
		dc.w Obj3E_Switched-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_Animals-Obj3E_Index
		dc.w Obj3E_EndAct-Obj3E_Index

Obj3E_Var:	dc.b 2,	$20, 6,	0	; routine, width, priority, frame
		dc.b 4,	$C, 5, 6
; ===========================================================================

Obj3E_Main:				; XREF: Obj3E_Index
		move.l	#Map_obj3E,4(a0)
		move.w	#$39D,2(a0)
		move.b	#4,1(a0)
		move.w	$C(a0),$30(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsl.w	#2,d0
		lea	Obj3E_Var(pc,d0.w),a1
		move.b	(a1)+,$24(a0)
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$18(a0)
		move.w 	$18(a0),d1
		lsr.w 	#1,d1
		andi.w 	#$380,d1
		move.w 	d1,$18(a0)
		move.b	(a1)+,$1A(a0)
		cmpi.w	#8,d0		; is object type number	02?
		bne.s	Obj3E_Not02	; if not, branch
		move.b	#6,$20(a0)
		move.b	#8,$21(a0)
		rts

Obj3E_Not02:
		tst.b	$28(a0)
		bne.s	Obj3E_Return
		moveq	#0,d2
		move.w	$C(a0),d2
		subi.w	#$28,d2
		jsr	SingleObjLoad
		bne.s	Obj3E_Return
		move.b	#$3E,0(a1)	; load button object
		move.b	#1,$28(a1)
		move.w	8(a0),8(a1)
		move.w	d2,$C(a1)
		moveq	#$11,d0
		jmp	LoadPLC	; load signpost	patterns

Obj3E_Return:
		rts	
; ===========================================================================

Obj3E_BodyMain:				; XREF: Obj3E_Index
		cmpi.b	#2,($FFFFF7A7).w
		beq.s	Obj3E_ChkOpened
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	8(a0),d4
		jmp	SolidObject
; ===========================================================================

Obj3E_ChkOpened:
		tst.b	$25(a0)		; has the prison been opened?
		beq.s	Obj3E_DoOpen	; if yes, branch
		clr.b	$25(a0)
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

Obj3E_DoOpen:
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	8(a0),d4
		lea	(Ani_obj3E).l,a1
		jsr	AnimateSprite
		jmp	SolidObject
; ===========================================================================

Obj3E_Switched:				; XREF: Obj3E_Index
		move.w	#$17,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	8(a0),d4
		jsr	SolidObject
		move.w	$30(a0),$C(a0)
		tst.b	$25(a0)
		beq.s	locret_1AC60
		addq.w	#8,$C(a0)
		move.b	#$A,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		clr.b	($FFFFF7AA).w	; lock screen position
		moveq	#$3D,d0
		jmp	PlaySound

locret_1AC60:
		rts	
; ===========================================================================

Obj3E_MakeAnimal:
		move.b	#2,($FFFFF7A7).w
		move.b	#$C,$24(a0)	; replace explosions with animals
		move.w	#$96,$32(a0)
		moveq	#7,d6
		move.w	#$9A,d5
		moveq	#-$1C,d4

Obj3E_Loop:
		jsr	SingleObjLoad
		bne.s	locret_1ACF8
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		add.w	d4,8(a1)
		addq.w	#7,d4
		move.w	d5,$36(a1)
		subq.w	#8,d5
		dbf	d6,Obj3E_Loop	; repeat 7 more	times

locret_1ACF8:
		rts	
; ===========================================================================

Obj3E_Animals:				; XREF: Obj3E_Index
		moveq	#7,d0
		and.b	($FFFFFE0F).w,d0
		bne.s	loc_1AD38
		jsr	SingleObjLoad
		bne.s	loc_1AD38
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		subq.w	#6,d0
		tst.w	d1
		bpl.s	loc_1AD2E
		neg.w	d0

loc_1AD2E:
		add.w	d0,8(a1)
		move.w	#$C,$36(a1)

loc_1AD38:
		subq.w	#1,$32(a0)
		bne.s	locret_1AD48
		addq.b	#2,$24(a0)
		move.w	#180,$32(a0)

locret_1AD48:
		rts	
; ===========================================================================

Obj3E_EndAct:				; XREF: Obj3E_Index
		moveq	#$3E,d0
		moveq	#$28,d1
		moveq	#$40,d2
		lea	($FFFFB040).w,a1 ; load	object RAM

Obj3E_FindObj28:
		cmp.b	(a1),d1		; is object $28	(animal) loaded?
		beq.s	Obj3E_Obj28Found ; if yes, branch
		adda.w	d2,a1		; next object RAM
		dbf	d0,Obj3E_FindObj28 ; repeat $3E	times
	;	tst.w	($FFFFFE08).w	; is debug mode	on?
	;	bne.s	Obj3E_Obj28Found	; if yes, branch
	;	btst	#1,($FFFFB022).w	; is Sonic's in-air flag set?
	;	bne.s 	Obj3E_Obj28Found
		jsr	GotThroughAct
		jmp	DeleteObject
; ===========================================================================

Obj3E_Obj28Found:
		rts	
; ===========================================================================
Ani_obj3E:
	include "_anim\obj3E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - prison capsule
; ---------------------------------------------------------------------------
Map_obj3E:
	include "_maps\obj3E.asm"
	even

; ---------------------------------------------------------------------------
; Object touch response	subroutine - $20(a0) in	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TouchResponse:				; XREF: Obj01
		nop
		jsr	(Touch_Rings).l
		move.w	8(a0),d2	; load Sonic's x-axis value
		move.w	$C(a0),d3	; load Sonic's y-axis value
		subq.w	#8,d2
		moveq	#0,d5
		move.b	$16(a0),d5	; load Sonic's height
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$39,$1A(a0)	; is Sonic ducking?
		bne.s	Touch_NoDuck	; if not, branch
		addi.w	#$C,d3
		moveq	#$A,d5

Touch_NoDuck:
		move.w	#$10,d4
		add.w	d5,d5
		lea	($FFFFB800).w,a1 ; begin checking the object RAM
		move.w	#$5F,d6

Touch_Loop:
		tst.b	1(a1)
		bpl.s	Touch_NextObj
		move.b	$20(a1),d0	; load touch response number
		bne.s	Touch_Height	; if touch response is not 0, branch

Touch_NextObj:
		lea	$40(a1),a1	; next object RAM
		dbf	d6,Touch_Loop	; repeat $5F more times

		moveq	#0,d0
		rts	
; ===========================================================================
Touch_Sizes:	dc.b  $14, $14		; width, height
		dc.b   $C, $14
		dc.b  $14,  $C
		dc.b	4, $10
		dc.b   $C, $12
		dc.b  $10, $10
		dc.b	6,   6
		dc.b  $18,  $C
		dc.b   $C, $10
		dc.b  $10,  $C
		dc.b	8,   8
		dc.b  $14, $10
		dc.b  $14,   8
		dc.b   $E,  $E
		dc.b  $18, $18
		dc.b  $28, $10
		dc.b  $10, $18
		dc.b	8, $10
		dc.b  $20, $70
		dc.b  $40, $20
		dc.b  $80, $20
		dc.b  $20, $20
		dc.b	8,   8
		dc.b	4,   4
		dc.b  $20,   8
		dc.b   $C,  $C
		dc.b	8,   4
		dc.b  $18,   4
		dc.b  $28,   4
		dc.b	4,   8
		dc.b	4, $18
		dc.b	4, $28
		dc.b	4, $20
		dc.b  $18, $18
		dc.b   $C, $18
		dc.b  $48,   8
; ===========================================================================

Touch_Height:				; XREF: TouchResponse
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Touch_Sizes-2(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	8(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_1AE98
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	Touch_Width
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AE98:
		cmp.w	d4,d0
		bhi.w	Touch_NextObj

Touch_Width:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	$C(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_1AEB6
		add.w	d1,d1
		add.w	d0,d1
		bcs.s	Touch_ChkValue
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AEB6:
		cmp.w	d5,d0
		bhi.w	Touch_NextObj

Touch_ChkValue:
		move.b	$20(a1),d1	; load touch response number
		andi.b	#$C0,d1		; is touch response $40	or higher?
		beq.w	Touch_Enemy	; if not, branch
		cmpi.b	#$C0,d1		; is touch response $C0	or higher?
		beq.w	Touch_Special	; if yes, branch
		tst.b	d1		; is touch response $80-$BF ?
		bmi.w	Touch_ChkHurt	; if yes, branch

; touch	response is $40-$7F

		move.b	$20(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0		; is touch response $46	?
		beq.s	Touch_Monitor	; if yes, branch
		cmpi.w	#$5A,$30(a0)
		bcc.w	locret_1AEF2
		cmpi.b	#$12,d0		; is STouch response $46	?
		bne.s	Touch_SSRing	; if yes, branch
		btst	#7,$22(a0)
		bne.s	locret_1AEF2

Touch_SSRing:
		addq.b	#2,$24(a1)	; advance the object's routine counter

locret_1AEF2:
		rts	
; ===========================================================================

Touch_Monitor:
		tst.w	$12(a0)		; is Sonic moving upwards?
		bpl.s	loc_1AF1E	; if not, branch
		move.w	$C(a0),d0
		subi.w	#$10,d0
		cmp.w	$C(a1),d0
		bcs.s	locret_1AF2E
		neg.w	$12(a0)		; reverse Sonic's y-motion
		move.w	#-$180,$12(a1)
		tst.b	$25(a1)
		bne.s	locret_1AF2E
		addq.b	#4,$25(a1)	; advance the monitor's routine counter
		rts	
; ===========================================================================

loc_1AF1E:
		neg.w	$12(a0)		; reverse Sonic's y-motion
		addq.b	#2,$24(a1)	; advance the monitor's routine counter

locret_1AF2E:
		rts	
; ===========================================================================

Touch_Enemy:				; XREF: Touch_ChkValue
		btst	#1,($FFFFFE2C).w	; is Sonic invincible?
		bne.s	loc_1AF40	; if yes, branch
		cmpi.b	#2,($FFFFB000).w
		beq.w	Touch_ChkHurt
		cmpi.b	#2,$1C(a0)	; is Sonic rolling?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#9,$1C(a0)	; is Sonic Spin Dashing?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$B,$1C(a0)	; is Sonic somersaulting?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$C,$1C(a0)	; is Sonic falling?
		bne.w	Touch_ChkHurt	; if not, branch

loc_1AF40:
		tst.b	$21(a1)
		beq.s	Touch_KillEnemy
		neg.w	$10(a0)
		neg.w	$12(a0)
		asr	$10(a0)
		asr	$12(a0)
		move.b	#0,$20(a1)
		subq.b	#1,$21(a1)
		bne.s	locret_1AF68
		bset	#7,$22(a1)

locret_1AF68:
		rts	
; ===========================================================================

Touch_KillEnemy:
		bset	#7,$22(a1)
		moveq	#0,d0
		move.w	($FFFFF7D0).w,d0
		addq.w	#2,($FFFFF7D0).w ; add 2 to item bonus counter
		cmpi.w	#6,d0
		bcs.s	loc_1AF82
		moveq	#6,d0

loc_1AF82:
		move.w	d0,$3E(a1)
		move.w	Enemy_Points(pc,d0.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 enemies been destroyed?
		bcs.s	loc_1AF9C	; if not, branch
		move.w	#1000,d0	; fix bonus to 10000
		move.w	#$A,$3E(a1)

loc_1AF9C:
		bsr.w	AddPoints
		move.b	#$27,0(a1)	; change object	to points
		move.b	#0,$24(a1)
		tst.w	$12(a0)
		bmi.s	loc_1AFC2
		move.w	$C(a0),d0
		cmp.w	$C(a1),d0
		bcc.s	loc_1AFCA
		neg.w	$12(a0)
		rts	
; ===========================================================================

loc_1AFC2:
		addi.w	#$100,$12(a0)
		rts	
; ===========================================================================

loc_1AFCA:
		subi.w	#$100,$12(a0)
		rts	
; ===========================================================================
Enemy_Points:	dc.w 10, 20, 50, 100
; ===========================================================================

loc_1AFDA:				; XREF: Touch_CatKiller
		bset	#7,$22(a1)

Touch_ChkHurt:				; XREF: Touch_ChkValue
		move.b	($FFFFFE2C).w,d0
		andi.b	#$73,d0					; Does player have any shields or is invincible?
		beq.s	Touch_ChkHurt_NoPowerUp			; If not, branch
		and.b	$2B(a1),d0			; Does one of the player's shields grant immunity to this object??
		bne.s	Touch_ChkHurt_Return			; If so, branch
		btst	#0,($FFFFFE2C).w	; Does the player have a shield (strange time to ask)
		bne.s	Touch_ChkHurt_HaveShield		; If so, branch

Touch_ChkHurt2:
		btst	#1,($FFFFFE2C).w	; Is player invincible?
		beq.s	Touch_Hurt				; If not, branch

Touch_ChkHurt_Return:
		moveq	#-1,d0
		rts
; ===========================================================================

Touch_ChkHurt_NoPowerUp:
		; Note that this check could apply to the Insta-Shield,
		; but the check that branches to this requires the player not be invincible.
		; The Insta-Shield grants temporary invincibility. See the problem?
		cmpi.b	#1,$29(a0)			; Is player Insta-Shield-attacking (Sonic), flying (Tails) or gliding (Knuckles)?
		bne.s	Touch_ChkHurt2				; If not, branch

Touch_ChkHurt_HaveShield:
		move.b	$2B(a1),d0
		andi.b	#8,d0					; Should the object be bounced away by a shield?
		beq.s	Touch_ChkHurt2				; If not, branch

Touch_ChkHurt_Bounce_Projectile:
		move.w	8(a0),d1
		move.w	$C(a0),d2
		sub.w	8(a1),d1
		sub.w	$C(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$800,d1
		asr.l	#8,d1
		move.w	d1,$10(a1)
		muls.w	#-$800,d0
		asr.l	#8,d0
		move.w	d0,$12(a1)
		clr.b	$20(a1)
		bra.s	Touch_ChkHurt_Return

Touch_Hurt:				; XREF: Touch_ChkHurt
		nop	
		tst.w	$30(a0)
		bne.s	Touch_ChkHurt_Return
		movea.l	a1,a2

; End of function TouchResponse
; continue straight to HurtSonic

; ---------------------------------------------------------------------------
; Hurting Sonic	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HurtSonic:
		btst	#7,$22(a0)
		bne.s	Hurt_2p
		btst	#0,($FFFFFE2C).w	; does Sonic have a shield?
		bne.s	Hurt_Shield	; if yes, branch
		tst.w	($FFFFFE20).w	; does Sonic have any rings?
		beq.w	Hurt_NoRings	; if not, branch
		jsr	SingleObjLoad
		bne.s	Hurt_Shield
		move.b	#$37,0(a1)	; load bouncing	multi rings object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Hurt_Shield:
		andi.b	#$8E,($FFFFFE2C).w

Hurt_2P:
		move.b	#4,$24(a0)
		jsr	Player_ResetOnFloor
		bset	#1,$22(a0)
		move.w	#-$400,$12(a0)	; make Sonic bounce away from the object
		move.w	#-$200,$10(a0)
		btst	#6,$22(a0)
		beq.s	Hurt_Reverse
		move.w	#-$200,$12(a0)
		move.w	#-$100,$10(a0)

Hurt_Reverse:
		move.w	8(a0),d0
		cmp.w	8(a2),d0
		bcs.s	Hurt_ChkSpikes	; if Sonic is left of the object, branch
		neg.w	$10(a0)		; if Sonic is right of the object, reverse

Hurt_ChkSpikes:
		move.b	#0,$39(a0)	; clear Spin Dash flag
		move.w	#0,$20(a0)
		move.b	#$1A,$1C(a0)
		move.w	#$78,$30(a0)
		move.w	#$35,d0		; load normal damage sound
		cmpi.b	#$36,(a2)	; was damage caused by spikes?
		beq.s	Hurt_SetSpikeSound	; if not, branch
		cmpi.b	#$16,(a2)	; was damage caused by TJZ harpoon?
		bne.s	Hurt_Sound	; if not, branch

Hurt_SetSpikeSound:
		move.w	#$37,d0		; load spikes damage sound

Hurt_Sound:
		jsr	(PlaySound_Special).l
		moveq	#-1,d0
		rts	
; ===========================================================================

Hurt_NoRings:
		tst.w	($FFFFFFFA).w	; is debug mode	cheat on?
		bne.w	Hurt_Shield	; if yes, branch
; End of function HurtSonic

; ---------------------------------------------------------------------------
; Subroutine to	kill Sonic
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


KillSonic:
		tst.w	($FFFFFE08).w	; is debug mode	active?
		bne.s	Kill_NoDeath	; if yes, branch
		btst	#7,$22(a0)
		bne.s	Kill_NoDeath
		move.w	#0,($FFFFFE20).w ; clear rings
		clr.b	($FFFFFE2C).w
		clr.l 	($FFFFF608).w
		move.b	#6,$24(a0)
		jsr	Player_ResetOnFloor
		bset	#1,$22(a0)
		move.w	#-$700,$12(a0)
		move.w	#0,$10(a0)
		move.w	#0,$20(a0)
		move.w	$C(a0),$38(a0)
		move.b	#$18,$1C(a0)
		bset	#7,2(a0)
		move.w	#$35,d0		; play normal death sound
		cmpi.b	#$36,(a2)	; check	if you were killed by spikes
		bne.s	Kill_Sound
		move.w	#$37,d0		; play spikes death sound

Kill_Sound:
		jsr	PlaySound
		move.w	#$E1,d0
		jsr	PlaySound

Kill_NoDeath:
		moveq	#-1,d0
		rts	
; End of function KillSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Touch_Special:				; XREF: Touch_ChkValue
		move.b	$20(a1),d1
		andi.b	#$3F,d1
		cmpi.b	#$B,d1		; is touch response $CB	?
		beq.s	Touch_CatKiller	; if yes, branch
		cmpi.b	#$C,d1		; is touch response $CC	?
		beq.s	Touch_Yadrin	; if yes, branch
		cmpi.b	#$17,d1		; is touch response $D7	?
		beq.s	Touch_D7orE1	; if yes, branch
		cmpi.b	#$21,d1		; is touch response $E1	?
		beq.s	Touch_D7orE1	; if yes, branch
		rts	
; ===========================================================================

Touch_CatKiller:			; XREF: Touch_Special
		bra.w	loc_1AFDA
; ===========================================================================

Touch_Yadrin:				; XREF: Touch_Special
		sub.w	d0,d5
		cmpi.w	#8,d5
		bcc.s	loc_1B144
		move.w	8(a1),d0
		subq.w	#4,d0
		btst	#0,$22(a1)
		beq.s	loc_1B130
		subi.w	#$10,d0

loc_1B130:
		sub.w	d2,d0
		bcc.s	loc_1B13C
		addi.w	#$18,d0
		bcs.s	loc_1B140
		bra.s	loc_1B144
; ===========================================================================

loc_1B13C:
		cmp.w	d4,d0
		bhi.s	loc_1B144

loc_1B140:
		bra.w	Touch_ChkHurt
; ===========================================================================

loc_1B144:
		bra.w	Touch_Enemy
; ===========================================================================

Touch_D7orE1:				; XREF: Touch_Special
		addq.b	#1,$21(a1)
		rts	
; End of function Touch_Special

; ---------------------------------------------------------------------------
; Subroutine to	show the special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_ShowLayout:				; XREF: SpecialStage
		bsr.w	SS_AniWallsRings
		bsr.w	SS_AniItems
		move.w	d5,-(sp)
		lea	($FFFF8000).w,a1
		move.b	($FFFFF780).w,d0
		jsr	(CalcSine).l
		move.w	d0,d4
		move.w	d1,d5
		muls.w	#$18,d4
		muls.w	#$18,d5
		moveq	#0,d2
		move.w	($FFFFF700).w,d2
		divu.w	#$18,d2
		swap	d2
		neg.w	d2
		addi.w	#-$B4,d2
		moveq	#0,d3
		move.w	($FFFFF704).w,d3
		divu.w	#$18,d3
		swap	d3
		neg.w	d3
		addi.w	#-$B4,d3
		move.w	#$F,d7

loc_1B19E:
		movem.w	d0-d2,-(sp)
		movem.w	d0-d1,-(sp)
		neg.w	d0
		muls.w	d2,d1
		muls.w	d3,d0
		move.l	d0,d6
		add.l	d1,d6
		movem.w	(sp)+,d0-d1
		muls.w	d2,d0
		muls.w	d3,d1
		add.l	d0,d1
		move.l	d6,d2
		move.w	#$F,d6

loc_1B1C0:
		move.l	d2,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		move.l	d1,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		add.l	d5,d2
		add.l	d4,d1
		dbf	d6,loc_1B1C0

		movem.w	(sp)+,d0-d2
		addi.w	#$18,d3
		dbf	d7,loc_1B19E

		move.w	(sp)+,d5
		lea	($FF0000).l,a0
		moveq	#0,d0
		move.w	($FFFFF704).w,d0
		divu.w	#$18,d0
		mulu.w	#$80,d0
		adda.l	d0,a0
		moveq	#0,d0
		move.w	($FFFFF700).w,d0
		divu.w	#$18,d0
		adda.w	d0,a0
		lea	($FFFF8000).w,a4
		move.w	#$F,d7

loc_1B20C:
		move.w	#$F,d6

loc_1B210:
		moveq	#0,d0
		move.b	(a0)+,d0
		beq.s	loc_1B268
		cmpi.b	#$4E,d0
		bhi.s	loc_1B268
		move.w	(a4),d3
		addi.w	#$120,d3
		cmpi.w	#$70,d3
		bcs.s	loc_1B268
		cmpi.w	#$1D0,d3
		bcc.s	loc_1B268
		move.w	2(a4),d2
		addi.w	#$F0,d2
		cmpi.w	#$70,d2
		bcs.s	loc_1B268
		cmpi.w	#$170,d2
		bcc.s	loc_1B268
		lea	($FF4000).l,a5
		lsl.w	#3,d0
		lea	(a5,d0.w),a5
		movea.l	(a5)+,a1
		move.w	(a5)+,d1
		add.w	d1,d1
		adda.w	(a1,d1.w),a1
		movea.w	(a5)+,a3
		moveq	#0,d1
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_1B268
		jsr	sub_D762

loc_1B268:
		addq.w	#4,a4
		dbf	d6,loc_1B210

		lea	$70(a0),a0
		dbf	d7,loc_1B20C

		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_1B288
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_1B288:
		move.b	#0,-5(a2)
		rts	
; End of function SS_ShowLayout

; ---------------------------------------------------------------------------
; Subroutine to	animate	walls and rings	in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_AniWallsRings:			; XREF: SS_ShowLayout
		lea	($FF4005).l,a1
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_1B2C8
		move.b	#7,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#3,($FFFFFEC3).w

loc_1B2C8:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_1B2E4
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		andi.b	#1,($FFFFFEC5).w

loc_1B2E4:
		move.b	($FFFFFEC5).w,d0
		move.b	d0,$138(a1)
		move.b	d0,$148(a1)
		move.b	d0,$150(a1)
		move.b	d0,$1D8(a1)
		move.b	d0,$1E0(a1)
		move.b	d0,$1E8(a1)
		move.b	d0,$1F0(a1)
		move.b	d0,$1F8(a1)
		move.b	d0,$200(a1)
		subq.b	#1,($FFFFFEC6).w
		bpl.s	loc_1B326
		move.b	#4,($FFFFFEC6).w
		addq.b	#1,($FFFFFEC7).w
		andi.b	#3,($FFFFFEC7).w

loc_1B326:
		move.b	($FFFFFEC7).w,d0
		move.b	d0,$160(a1)
		move.b	d0,$168(a1)
		move.b	d0,$170(a1)
		move.b	d0,$178(a1)
		move.b	d0,$180(a1)
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_1B350
		move.b	#7,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_1B350:
		lea	($FF4016).l,a1
		lea	(SS_WaRiVramSet).l,a0
		moveq	#0,d0
		move.b	($FFFFFEC1).w,d0
		add.w	d0,d0
		lea	(a0,d0.w),a0
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		rts	

SS_LoadWalls:
		moveq	#0,d0
		move.b	($FFFFF780).w,d0	; get the Special Stage angle
		lsr.b	#1,d0			; modify so it can be used as a frame ID
		andi.w	#$1F,d0
		cmp.b	($FFFFF743).w,d0	; does the modified angle match the recorded value?
		beq.s	SS_LoadRings			; if so, branch

		lea	($C00000).l,a6
		lea	(Nem_SSWalls).l,a1	; load wall art
		move.w	d0,d1
		lsl.w	#8,d1
		add.w	d1,d1
		add.w	d1,a1

		move.l	#$68400000,($C00004).l

		move.w	#$F,d1			; number of 8x8 tiles
		jsr	LoadTiles
		move.b	d0,($FFFFF743).w	; record the modified angle for comparison

SS_LoadRings:
		movea.l	#RingDynPLC,a2	; get DPLC location
		move.w	#$D800,d4		; offset in VRAM to store art
		move.l	#Art_Ring,d6	; get art location
		moveq	#0,d0
		move.b	($FFFFFEC1).w,d0	; load frame number
		jmp 	Load_DPLC
; End of function SS_AniWallsRings

; ===========================================================================
SS_WaRiVramSet:	dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
; ---------------------------------------------------------------------------
; Subroutine to	remove items when you collect them in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_RemoveCollectedItem:			; XREF: Obj09_ChkItems
		lea	($FF4400).l,a2
		move.w	#$1F,d0

loc_1B4C4:
		tst.b	(a2)
		beq.s	locret_1B4CE
		addq.w	#8,a2
		dbf	d0,loc_1B4C4

locret_1B4CE:
		rts	
; End of function SS_RemoveCollectedItem

; ---------------------------------------------------------------------------
; Subroutine to	animate	special	stage items when you touch them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_AniItems:				; XREF: SS_ShowLayout
		lea	($FF4400).l,a0
		move.w	#$1F,d7

loc_1B4DA:
		moveq	#0,d0
		move.b	(a0),d0
		beq.s	loc_1B4E8
		lsl.w	#2,d0
		movea.l	SS_AniIndex-4(pc,d0.w),a1
		jsr	(a1)

loc_1B4E8:
		addq.w	#8,a0

loc_1B4EA:
		dbf	d7,loc_1B4DA

		rts	
; End of function SS_AniItems

; ===========================================================================
SS_AniIndex:	dc.l SS_AniRingSparks
		dc.l SS_AniBumper
		dc.l SS_Ani1Up
		dc.l SS_AniReverse
		dc.l SS_AniEmeraldSparks
		dc.l SS_AniGlassBlock
		dc.l SS_AniBlock
; ===========================================================================

SS_AniRingSparks:			; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B530
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniRingData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B530
		clr.l	(a0)
		clr.l	4(a0)

locret_1B530:
		rts	
; ===========================================================================
SS_AniRingData:	dc.b $42, $43, $44, $45, 0, 0
; ===========================================================================

SS_AniBumper:				; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B566
		move.b	#7,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniBumpData(pc,d0.w),d0
		bne.s	loc_1B564
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#$25,(a1)
		rts	
; ===========================================================================

loc_1B564:
		move.b	d0,(a1)

locret_1B566:
		rts	
; ===========================================================================
SS_AniBumpData:	dc.b $32, $33, $32, $33, 0, 0
; ===========================================================================

SS_Ani1Up:				; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B596
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_Ani1UpData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B596
		clr.l	(a0)
		clr.l	4(a0)

locret_1B596:
		rts	
; ===========================================================================
SS_Ani1UpData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

SS_AniReverse:				; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B5CC
		move.b	#7,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniRevData(pc,d0.w),d0
		bne.s	loc_1B5CA
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#$2B,(a1)
		rts	
; ===========================================================================

loc_1B5CA:
		move.b	d0,(a1)

locret_1B5CC:
		rts	
; ===========================================================================
SS_AniRevData:	dc.b $2B, $31, $2B, $31, 0, 0
; ===========================================================================

SS_AniEmeraldSparks:			; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B60C
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniEmerData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B60C
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#4,($FFFFB024).w
		move.w	#$6A,d0
		jsr	(PlaySound_Special).l ;	play special stage GOAL	sound

locret_1B60C:
		rts	
; ===========================================================================
SS_AniEmerData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

SS_AniGlassBlock:			; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B640
		move.b	#1,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniGlassData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B640
		move.b	4(a0),(a1)
		clr.l	(a0)
		clr.l	4(a0)

locret_1B640:
		rts		
; ===========================================================================
SS_AniGlassData:dc.b $4F, $50, $51, $4F, $50, $51, $4F, $50, $51, $4F, $50, $51

SS_AniBlock:			; XREF: SS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B640
		move.b	#1,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	SS_AniBlockData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret2_1B640
		move.b	4(a0),(a1)
		clr.l	(a0)
		clr.l	4(a0)

locret2_1B640:
		rts		
; ===========================================================================
SS_AniBlockData:dc.b $4B, $4C, $4D, $4B, $4C, $4D, $4B, $4C, $4D, $4B, $4C, $4D
; ---------------------------------------------------------------------------
; Special stage	layout pointers
; ---------------------------------------------------------------------------
SS_LayoutIndex:
	include "_inc\Special stage layout pointers.asm"

; ---------------------------------------------------------------------------
; Special stage	start locations
; ---------------------------------------------------------------------------
SS_StartLoc:	incbin	misc\sloc_ss.bin
		even

; ---------------------------------------------------------------------------
; Subroutine to	load special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_Load:	; XREF: SpecialStage
  		move.b ($FFFFFE16).w,d0
  		cmpi.b #5,d0 ; Does sonic have 5 emeralds?
  		bls.s SS_LoadData ; If lower or same, branch
  		move.b #0,($FFFFFE16).w ; reset if higher than 6

SS_LoadData:
		lsl.w	#2,d0
		lea	SS_StartLoc(pc,d0.w),a1
		move.w	(a1)+,($FFFFB008).w
		move.w	(a1)+,($FFFFB00C).w
		movea.l	SS_LayoutIndex(pc,d0.w),a0
		lea	($FF4000).l,a1
		move.w	#0,d0
		jsr	(EniDec).l
		lea	($FF0000).l,a1
		move.w	#$FFF,d0

SS_ClrRAM3:
		clr.l	(a1)+
		dbf	d0,SS_ClrRAM3

		lea	($FF1020).l,a1
		lea	($FF4000).l,a0
		moveq	#$3F,d1

loc_1B6F6:
		moveq	#$3F,d2

loc_1B6F8:
		move.b	(a0)+,(a1)+
		dbf	d2,loc_1B6F8

		lea	$40(a1),a1
		dbf	d1,loc_1B6F6

		lea	($FF4008).l,a1
		lea	(SS_MapIndex).l,a0
		moveq	#$50,d1

loc_1B714:
		move.l	(a0)+,(a1)+
		move.w	#0,(a1)+
		move.b	-4(a0),-1(a1)
		move.w	(a0)+,(a1)+
		dbf	d1,loc_1B714

		lea	($FF4400).l,a1
		move.w	#$3F,d1

loc_1B730:

		clr.l	(a1)+
		dbf	d1,loc_1B730

		rts	
; End of function SS_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Special stage	mappings and VRAM pointers
; ---------------------------------------------------------------------------
SS_MapIndex:
	include "_inc\Special stage mappings and VRAM pointers.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "R" block
; ---------------------------------------------------------------------------
Map_SS_R:
	include "_maps\SSRblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage breakable glass blocks and red-white blocks
; ---------------------------------------------------------------------------
Map_SS_Glass:
	include "_maps\SSglassblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "UP" block
; ---------------------------------------------------------------------------
Map_SS_Up:
	include "_maps\SSUPblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "DOWN" block
; ---------------------------------------------------------------------------
Map_SS_Down:
	include "_maps\SSDOWNblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage block
; ---------------------------------------------------------------------------
Map_SS_RedWhi:
	include "_maps\SSRedWhi.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage chaos	emeralds
; ---------------------------------------------------------------------------
Map_SS_Chaos1:	dc.w byte_1B96C-Map_SS_Chaos1
		dc.w byte_1B97E-Map_SS_Chaos1
Map_SS_Chaos2:	dc.w byte_1B972-Map_SS_Chaos2
		dc.w byte_1B97E-Map_SS_Chaos2
Map_SS_Chaos3:	dc.w byte_1B978-Map_SS_Chaos3
		dc.w byte_1B97E-Map_SS_Chaos3
byte_1B96C:	dc.b 1
		dc.b $F8, 5, 0,	0, $F8
byte_1B972:	dc.b 1
		dc.b $F8, 5, 0,	4, $F8
byte_1B978:	dc.b 1
		dc.b $F8, 5, 0,	8, $F8
byte_1B97E:	dc.b 1
		dc.b $F8, 5, 0,	$C, $F8
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 09 - Sonic (special stage)
; ---------------------------------------------------------------------------

Obj09:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj09_Normal	; if not, branch
		bsr.w	SS_FixCamera
		bra.w	DebugMode
; ===========================================================================

Obj09_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj09_Index(pc,d0.w),d1
		jmp	Obj09_Index(pc,d1.w)
; ===========================================================================
Obj09_Index:	dc.w Obj09_Main-Obj09_Index
		dc.w Obj09_ChkDebug-Obj09_Index
		dc.w Obj09_ExitStage-Obj09_Index
		dc.w Obj09_Exit2-Obj09_Index
; ===========================================================================

Obj09_Main:				; XREF: Obj09_Index
		addq.b	#2,$24(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.l	#Map_Sonic,4(a0)
		tst.w	(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Shadow,4(a0)
		cmpi.w	#1,(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Silver,4(a0)
		cmpi.w	#2,(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Tails,4(a0)
		move.b	#$96,($FFFFB3C0).w ; load Obj05 (Tails' Tails)
		move.w	a0,($FFFFB3F2).w ; set its parent object to this

Obj09_Main2:
		move.w	#$780,2(a0)
		move.b	#4,1(a0)
		move.w	#0,$18(a0)
		move.b	#2,$1C(a0)
		bset	#2,$22(a0)
		bset	#1,$22(a0)

Obj09_ChkDebug:				; XREF: Obj09_Index
		tst.w	($FFFFFFFA).w	; is debug mode	cheat enabled?
		beq.s	Obj09_NoDebug	; if not, branch
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Obj09_NoDebug	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring

Obj09_NoDebug:
		move.b	#0,$30(a0)
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#2,d0
		move.w	Obj09_Modes(pc,d0.w),d1
		jsr	Obj09_Modes(pc,d1.w)
		jsr	LoadSCharacterDynPLC
		jmp	DisplaySprite
; ===========================================================================
Obj09_Modes:	dc.w Obj09_OnWall-Obj09_Modes
		dc.w Obj09_InAir-Obj09_Modes
; ===========================================================================

Obj09_OnWall:				; XREF: Obj09_Modes
		bsr.w	Obj09_Jump
		bsr.w	Obj09_Move
		bsr.w	Obj09_Fall
		bra.s	Obj09_Display
; ===========================================================================

Obj09_InAir:				; XREF: Obj09_Modes
		bsr.w	Obj09_JumpHeight
		bsr.w	Obj09_Move
		bsr.w	Obj09_Fall

Obj09_Display:				; XREF: Obj09_OnWall
		bsr.w	Obj09_ChkItems
		bsr.w	Obj09_ChkItems2
		jsr	SpeedToPos
		bsr.w	SS_FixCamera
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		tst.w	(Current_Character).w
		beq.w	JMP_SonicAnimate
		cmpi.w	#1,(Current_Character).w
		beq.w	JMP_ShadowAnimate
		cmpi.w	#2,(Current_Character).w
		beq.w	JMP_SilverAnimate
		jmp	Tails_Animate

JMP_SonicAnimate:
		jmp	Sonic_Animate
JMP_ShadowAnimate:
		jmp	Shadow_Animate
JMP_SilverAnimate:
		jmp	Silver_Animate

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Move:				; XREF: Obj09_OnWall; Obj09_InAir
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj09_ChkRight	; if not, branch
		bsr.w	Obj09_MoveLeft

Obj09_ChkRight:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_1BA78	; if not, branch
		bsr.w	Obj09_MoveRight

loc_1BA78:
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0
		bne.s	loc_1BAA8
		move.w	$14(a0),d0
		beq.s	loc_1BAA8
		bmi.s	loc_1BA9A
		subi.w	#$C,d0
		bcc.s	loc_1BA94
		move.w	#0,d0

loc_1BA94:
		move.w	d0,$14(a0)
		bra.s	loc_1BAA8
; ===========================================================================

loc_1BA9A:
		addi.w	#$C,d0
		bcc.s	loc_1BAA4
		move.w	#0,d0

loc_1BAA4:
		move.w	d0,$14(a0)

loc_1BAA8:
		move.b	($FFFFF780).w,d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		neg.b	d0
		jsr	(CalcSine).l
		muls.w	$14(a0),d1
		add.l	d1,8(a0)
		muls.w	$14(a0),d0
		add.l	d0,$C(a0)
		movem.l	d0-d1,-(sp)
		move.l	$C(a0),d2
		move.l	8(a0),d3
		bsr.w	sub_1BCE8
		beq.s	loc_1BAF2
		movem.l	(sp)+,d0-d1
		sub.l	d1,8(a0)
		sub.l	d0,$C(a0)
		move.w	#0,$14(a0)
		rts	
; ===========================================================================

loc_1BAF2:
		movem.l	(sp)+,d0-d1
		rts	
; End of function Obj09_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveLeft:				; XREF: Obj09_Move
		bset	#0,$22(a0)
		move.w	$14(a0),d0
		beq.s	loc_1BB06
		bpl.s	loc_1BB1A

loc_1BB06:
		subi.w	#$C,d0
		cmpi.w	#-$800,d0
		bgt.s	loc_1BB14
		move.w	#-$800,d0

loc_1BB14:
		move.w	d0,$14(a0)
		rts	
; ===========================================================================

loc_1BB1A:
		subi.w	#$40,d0
		bcc.s	loc_1BB22
		nop	

loc_1BB22:
		move.w	d0,$14(a0)
		rts	
; End of function Obj09_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveRight:			; XREF: Obj09_Move
		bclr	#0,$22(a0)
		move.w	$14(a0),d0
		bmi.s	loc_1BB48
		addi.w	#$C,d0
		cmpi.w	#$800,d0
		blt.s	loc_1BB42
		move.w	#$800,d0

loc_1BB42:
		move.w	d0,$14(a0)
		bra.s	locret_1BB54
; ===========================================================================

loc_1BB48:
		addi.w	#$40,d0
		bcc.s	loc_1BB50
		nop	

loc_1BB50:
		move.w	d0,$14(a0)

locret_1BB54:
		rts	
; End of function Obj09_MoveRight


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Jump:				; XREF: Obj09_OnWall
		move.b	($FFFFF603).w,d0
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.s	Obj09_NoJump	; if not, branch
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$680,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#$680,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		bset	#1,$22(a0)
		move.w	#$60,d0
		jsr	(PlaySound_Special).l ;	play jumping sound

Obj09_NoJump:
		rts	
; End of function Obj09_Jump

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to limit Sonic's upward vertical speed
; ---------------------------------------------------------------------------
 
Obj09_JumpHeight:			; XREF: Obj09_InAir
		move.b	($FFFFF602).w,d0	; is the jump button up?
		andi.b	#$70,d0
		bne.s	locret_1BBB4		; if not, branch to return
		btst	#7,$22(a0)		; did Sonic jump or is he just falling or hit by a bumper?
		beq.s	locret_1BBB4		; if not, branch to return
		move.b	($FFFFF780).w,d0	; get SS angle
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l			
		move.w	$12(a0),d2		; get Y speed
		muls.w	d2,d0			; multiply Y speed by sin
		asr.l	#8,d0			; find the new Y speed
		move.w	$10(a0),d2		; get X speed
		muls.w	d2,d1			; multiply X speed by cos
		asr.l	#8,d1			; find the new X speed
		add.w	d0,d1			; combine the two speeds
		cmpi.w	#$400,d1		; compare the combined speed with the jump release speed
		ble.s	locret_1BBB4		; if it's less, branch to return
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$400,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#$400,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)		; set the speed to the jump release speed
		bclr	#7,$22(a0)		; clear "Sonic has jumped" flag
 
locret_1BBB4:
		rts
; ---------------------------------------------------------------------------
; Subroutine to	fix the	camera on Sonic's position (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_FixCamera:				; XREF: Obj09
		move.w	$C(a0),d2
		move.w	8(a0),d3
		move.w	($FFFFF700).w,d0
		subi.w	#$A0,d3
		bcs.s	loc_1BBCE
		sub.w	d3,d0
		sub.w	d0,($FFFFF700).w

loc_1BBCE:
		move.w	($FFFFF704).w,d0
		subi.w	#$70,d2
		bcs.s	locret_1BBDE
		sub.w	d2,d0
		sub.w	d0,($FFFFF704).w

locret_1BBDE:
		rts	
; End of function SS_FixCamera

; ===========================================================================

Obj09_ExitStage:			; XREF: Obj09_Index
		move.b	#$E1,d0
		jsr	PlaySound
		addi.w	#$40,($FFFFF782).w
		cmpi.w	#$1800,($FFFFF782).w
		bne.s	loc_1BBF4
		move.b	#$C,($FFFFF600).w

loc_1BBF4:
		cmpi.w	#$3000,($FFFFF782).w
		blt.s	loc_1BC12
		move.w	#0,($FFFFF782).w
		move.w	#$4000,($FFFFF780).w
		addq.b	#2,$24(a0)
		move.w	#$3C,$38(a0)

loc_1BC12:
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		bsr.w	SS_FixCamera
		jmp	DisplaySprite
; ===========================================================================

Obj09_Exit2:				; XREF: Obj09_Index
		subq.w	#1,$38(a0)
		bne.s	loc_1BC40
		move.b	#$C,($FFFFF600).w

loc_1BC40:
		bsr.w	SS_FixCamera
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Fall:				; XREF: Obj09_OnWall; Obj09_InAir
		move.l	$C(a0),d2
		move.l	8(a0),d3
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		jsr	(CalcSine).l
		move.w	$10(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d0
		add.l	d4,d0
		move.w	$12(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d1
		add.l	d4,d1
		add.l	d0,d3
		bsr.w	sub_1BCE8
		beq.s	loc_1BCB0
		sub.l	d0,d3
		moveq	#0,d0
		move.w	d0,$10(a0)
		bclr	#1,$22(a0)
		add.l	d1,d2
		bsr.w	sub_1BCE8
		beq.s	loc_1BCC6
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_1BCB0:
		add.l	d1,d2
		bsr.w	sub_1BCE8
		beq.s	loc_1BCD4
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,$12(a0)
		bclr	#1,$22(a0)

loc_1BCC6:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,$10(a0)
		move.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_1BCD4:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,$10(a0)
		move.w	d1,$12(a0)
		bset	#1,$22(a0)
		rts	
; End of function Obj09_Fall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1BCE8:				; XREF: Obj09_Move; Obj09_Fall
		lea	($FF0000).l,a1
		moveq	#0,d4
		swap	d2
		move.w	d2,d4
		swap	d2
		addi.w	#$44,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		swap	d3
		move.w	d3,d4
		swap	d3
		addi.w	#$14,d4
		divu.w	#$18,d4
		adda.w	d4,a1
		moveq	#0,d5
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		adda.w	#$7E,a1
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		tst.b	d5
		rts	
; End of function sub_1BCE8


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1BD30:				; XREF: sub_1BCE8
		beq.s	locret_1BD44
		cmpi.b	#$28,d4
		beq.s	locret_1BD44
		cmpi.b	#$3A,d4
		bcs.s	loc_1BD46
		cmpi.b	#$4B,d4
		bcc.s	loc_1BD46

locret_1BD44:
		rts	
; ===========================================================================

loc_1BD46:
		move.b	d4,$30(a0)
		move.l	a1,$32(a0)
		moveq	#-1,d5
		rts	
; End of function sub_1BD30


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ChkItems:				; XREF: Obj09_Display
		lea	($FF0000).l,a1
		moveq	#0,d4
		move.w	$C(a0),d4
		addi.w	#$50,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		move.w	8(a0),d4
		addi.w	#$20,d4
		divu.w	#$18,d4
		adda.w	d4,a1
		move.b	(a1),d4
		bne.s	Obj09_ChkCont
		tst.b	$3A(a0)
		bne.w	Obj09_MakeGhostSolid
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkCont:
		cmpi.b	#$3A,d4		; is the item a	ring?
		bne.s	Obj09_Chk1Up
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_GetCont
		move.b	#1,(a2)
		move.l	a1,4(a2)

Obj09_GetCont:
		jsr	CollectRing
		addi.w 	#4,($FFFFF782).w
		tst.w	($FFFFF782).w
		bgt.s	Obj09_Increased
		subi.w 	#8,($FFFFF782).w

Obj09_Increased:
		cmpi.w	#100,($FFFFFE20).w ; check if you have 50 rings
		bcs.s	Obj09_NoCont
		bset	#0,($FFFFFE1B).w
		bne.s	Obj09_NoCont
		move.w	#$6E,d0
		jsr	(PlaySound).l	; play extra continue sound

Obj09_NoCont:
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_Chk1Up:
		cmpi.b	#$28,d4		; is the item an extra life?
		bne.s	Obj09_ChkEmer
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_Get1Up
		move.b	#3,(a2)
		move.l	a1,4(a2)

Obj09_Get1Up:
		addq.b	#1,($FFFFFE12).w ; add 1 to number of lives
		addq.b	#1,($FFFFFE1C).w ; add 1 to lives counter
		move.b	#$2A,d0
		jsr	(PlaySound).l	; play extra life music
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkEmer:
		cmpi.b	#$3B,d4		; is the item an emerald?
		bcs.s	Obj09_ChkGhost
		cmpi.b	#$40,d4
		bhi.s	Obj09_ChkGhost
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_GetEmer
		move.b	#5,(a2)
		move.l	a1,4(a2)

Obj09_GetEmer:
		cmpi.b	#6,($FFFFFE57).w ; do you have all the emeralds?
		beq.s	Obj09_NoEmer	; if yes, branch
		subi.b	#$3B,d4
		moveq	#0,d0
		move.b	($FFFFFE57).w,d0
		lea	($FFFFFE58).w,a2
		move.b	d4,(a2,d0.w)
		addq.b	#1,($FFFFFE57).w ; add 1 to number of emeralds

Obj09_NoEmer:
		moveq	#$1A,d0
		jsr	(PlaySound_Special).l ;	play emerald music
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkGhost:
		cmpi.b	#$41,d4		; is the item a	ghost block?
		bne.s	Obj09_ChkGhostTag
		move.b	#1,$3A(a0)	; mark the ghost block as "passed"

Obj09_ChkGhostTag:
		cmpi.b	#$4A,d4		; is the item a	switch for ghost blocks?
		bne.s	Obj09_NoGhost
		cmpi.b	#1,$3A(a0)	; have the ghost blocks	been passed?
		bne.s	Obj09_NoGhost	; if not, branch
		move.b	#2,$3A(a0)	; mark the ghost blocks	as "solid"

Obj09_NoGhost:
		moveq	#-1,d4
		rts	
; ===========================================================================

Obj09_MakeGhostSolid:
		cmpi.b	#2,$3A(a0)	; is the ghost marked as "solid"?
		bne.s	Obj09_GhostNotSolid ; if not, branch
		lea	($FF1020).l,a1
		moveq	#$3F,d1

Obj09_GhostLoop2:
		moveq	#$3F,d2

Obj09_GhostLoop:
		cmpi.b	#$41,(a1)	; is the item a	ghost block?
		bne.s	Obj09_NoReplace	; if not, branch
		move.b	#$2C,(a1)	; replace ghost	block with a solid block

Obj09_NoReplace:
		addq.w	#1,a1
		dbf	d2,Obj09_GhostLoop
		lea	$40(a1),a1
		dbf	d1,Obj09_GhostLoop2

Obj09_GhostNotSolid:
		clr.b	$3A(a0)
		moveq	#0,d4
		rts	
; End of function Obj09_ChkItems


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ChkItems2:			; XREF: Obj09_Display
		move.b	$30(a0),d0
		bne.s	Obj09_ChkBumper
		subq.b	#1,$36(a0)
		bpl.s	loc_1BEA0
		move.b	#0,$36(a0)

loc_1BEA0:
		subq.b	#1,$37(a0)
		bpl.s	locret_1BEAC
		move.b	#0,$37(a0)

locret_1BEAC:
		rts	
; ===========================================================================

Obj09_ChkBumper:
		cmpi.b	#$25,d0		; is the item a	bumper?
		bne.s	Obj09_GOAL
		move.l	$32(a0),d1
		subi.l	#$FF0001,d1
		move.w	d1,d2
		andi.w	#$7F,d1
		mulu.w	#$18,d1
		subi.w	#$14,d1
		lsr.w	#7,d2
		andi.w	#$7F,d2
		mulu.w	#$18,d2
		subi.w	#$44,d2
		sub.w	8(a0),d1
		sub.w	$C(a0),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		bset	#1,$22(a0)
		bclr	#7,$22(a0)	; clear "Sonic has jumped" flag
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_BumpSnd
		move.b	#2,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,4(a2)

Obj09_BumpSnd:
		move.w	#$AA,d0
		jmp	(PlaySound_Special).l ;	play bumper sound
; ===========================================================================

Obj09_GOAL:
		cmpi.b	#$27,d0		; is the item a	"GOAL"?
		bne.s	Obj09_UPblock
		addq.b	#2,$24(a0)	; run routine "Obj09_ExitStage"
		move.w	#$6A,d0		; change item
		jsr	(PlaySound_Special).l ;	play "GOAL" sound
		rts	
; ===========================================================================

Obj09_UPblock:
		cmpi.b	#$29,d0		; is the item an "UP" block?
		bne.s	Obj09_DOWNblock
		tst.b	$36(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$36(a0)
	;	btst	#6,($FFFFF783).w
	;	beq.s	Obj09_UPsnd
		addi.w 	#$20,($FFFFF782).w	; increase stage rotation speed
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.b	#$2A,(a1)	; change item to a "DOWN" block

Obj09_UPsnd:
		move.w	#$6B,d0
		jmp	(PlaySound_Special).l ;	play up/down sound
; ===========================================================================

Obj09_DOWNblock:
		cmpi.b	#$2A,d0		; is the item a	"DOWN" block?
		bne.s	Obj09_Rblock
		tst.b	$36(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$36(a0)
	;	btst	#6,($FFFFF783).w
	;	bne.s	Obj09_DOWNsnd
		subi.w 	#$20,($FFFFF782).w	; increase stage rotation speed
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.b	#$29,(a1)	; change item to an "UP" block

Obj09_DOWNsnd:
		move.w	#$6B,d0
		jmp	(PlaySound_Special).l ;	play up/down sound
; ===========================================================================

Obj09_Rblock:
		cmpi.b	#$2B,d0		; is the item an "R" block?
		bne.s	Obj09_ChkGlass
		tst.b	$37(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$37(a0)
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_RevStage
		move.b	#4,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,4(a2)

Obj09_RevStage:
		neg.w	($FFFFF782).w	; reverse stage	rotation
		move.w	#$AD,d0
		jmp	(PlaySound_Special).l ;	play sound
; ===========================================================================

Obj09_ChkGlass:
		cmpi.b	#$2D,d0		; is the item a	glass block?
		beq.s	Obj09_Glass	; if yes, branch
		cmpi.b	#$2E,d0
		beq.s	Obj09_Glass
		cmpi.b	#$2F,d0
		beq.s	Obj09_Glass
		cmpi.b	#$30,d0
		bne.s	Obj09_Block	; if not, branch

Obj09_Glass:
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_GlassSnd
		move.b	#6,(a2)
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.l	a1,4(a2)
		move.b	(a1),d0
		addq.b	#1,d0		; change glass type when touched
		cmpi.b	#$30,d0
		bls.s	Obj09_GlassUpdate ; if glass is	still there, branch
		clr.b	d0		; remove the glass block when it's destroyed

Obj09_GlassUpdate:
		move.b	d0,$4(a2)	; update the stage layout

Obj09_GlassSnd:
		move.w	#$B5,d0
		jmp	(PlaySound_Special).l ;	play glass block sound
; ===========================================================================

Obj09_Block:
		cmpi.b	#$24,d0		; is the item a	block?
		bhi.s	Obj09_NoGlass	; if yes, branch
		bsr.w	SS_RemoveCollectedItem
		bne.s	Obj09_BlockSnd
		move.b	#7,(a2)
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.l	a1,4(a2)
		move.b	(a1),d0
		cmpi.b	#$1C,d0		; is the item a	block?
		beq.s	Obj09_BlockGreen	; if yes, branch
		cmpi.b	#$A,d0		; is the item a	block?
		beq.s	Obj09_BlockYellow	; if yes, branch
		cmpi.b	#$13,d0		; is the item a	block?
		beq.s	Obj09_BlockPurple	; if yes, branch
		bra.s	Obj09_NoGlass

Obj09_BlockGreen:
		move.w	#$A,d0
		bra.s	Obj09_BlockUpdate

Obj09_BlockYellow:
		move.w	#$13,d0
		bra.s	Obj09_BlockUpdate

Obj09_BlockPurple:
		move.b	#$27,d0		; remove the glass block when it's destroyed

Obj09_BlockUpdate:
		move.b	d0,$4(a2)	; update the stage layout

Obj09_BlockSnd:
		move.w	#$AE,d0
		jmp	(PlaySound_Special).l ;	play glass block sound

Obj09_NoGlass:
		rts	
; End of function Obj09_ChkItems2

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 10 - Egg Copter (WOZ)
; ---------------------------------------------------------------------------

Obj10:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj10_Index(pc,d0.w),d1
		jmp	Obj10_Index(pc,d1.w)
; ===========================================================================
Obj10_Index:	dc.w Obj10_Main-Obj10_Index
		dc.w Obj10_Action-Obj10_Index
		dc.w Obj10_Propeller-Obj10_Index
		dc.w Obj10_Chain-Obj10_Index
; ===========================================================================

Obj10_Main:				; XREF: Obj55_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj10,4(a0)
		move.w	#$2330,2(a0)
		move.b	#4,1(a0)
		move.b	#$10,$16(a0)
		move.w	#$100,$18(a0)
		move.b	#$E,$20(a0)
		move.b	#$1E,$14(a0)

Obj10_SetLength:
		jsr	SingleObjLoad
		bne.s	Obj10_SetLength2
		move.b	#4,$24(a1)
		move.b	#$10,0(a1)	; load swinging	object
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		move.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#$20,$14(a1)
		move.w	a0,$30(a1)
		move.b	#$9B,$20(a1)

Obj10_SetLength2:
		moveq	#0,d1
		moveq	#3,d1

Obj10_MakeChain:
		jsr	SingleObjLoad
		bne.s	loc2_7A92
		move.b	#$10,0(a1)	; load swinging	object
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		move.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#8,$14(a1)
		move.b	#5,$1A(a1)
		move.w	a0,$30(a1)
		move.b	#6,$24(a1)

loc2_7A8E:
		dbf	d1,Obj10_MakeChain ; repeat d1 times (chain length)

loc2_7A92:
		jmp	DisplaySprite

Obj10_Action:				; XREF: Obj55_Index
		moveq	#0,d0
		move.b	$25(a0),d0
		move.w	Obj10_Index2(pc,d0.w),d1
		jsr	Obj10_Index2(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
Obj10_Index2:	dc.w Obj10_ChkDrop-Obj10_Index2
		dc.w Obj10_PlaySnd-Obj10_Index2
; ===========================================================================

Obj10_ChkDrop:				; XREF: Obj10_Index2
		move.w	#$80,d2
		bsr.w	Obj10_ChkSonic
		bcc.s	Obj10_NoDrop
		move.w	($FFFFB00C).w,d0
		move.w	d0,$36(a0)
		sub.w	$C(a0),d0
		bcs.s	Obj10_NoDrop
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	basaran?
		bcc.s	Obj10_NoDrop	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	Obj10_NoDrop	; if yes, branch
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	Obj10_NoDrop
		move.b	#1,$1C(a0)
		addq.b	#2,$25(a0)

Obj10_NoDrop:
		rts	
; ===========================================================================

Obj10_ChkDel:				; XREF: Obj10_DropFly
		tst.b	1(a0)
		bpl.w	Obj10_DeleteObject
		rts	

Obj10_DeleteObject:
		jmp	DeleteObject
; ===========================================================================

Obj10_PlaySnd:				; XREF: Obj10_Index2
		move.w	#$C,d1	; horizontal
		move.w	($FFFFB008).w,d0
		cmp.w	8(a0),d0
		bcc.s	Obj10_a1
		bclr	#0,$22(a0)
		neg.w	d1
		bmi.s	Obj10_a2
		add.w	d1,d1
		add.w	d1,d1
		bra.s	Obj10_a2

Obj10_a1:
		bset	#0,$22(a0)
		tst.w	$10(a0)
		bpl.s	Obj10_a2
		add.w	d1,d1
		add.w	d1,d1

Obj10_a2:
		add.w	d1,$10(a0)
		move.w	#$10,d1	; vertical
		move.w	($FFFFB00C).w,d0
		cmp.w	$C(a0),d0
		bcc.s	Obj10_a3
		neg.w	d1
		tst.w	$12(a0)
		bmi.s	Obj10_a4
		add.w	d1,d1
		add.w	d1,d1
		bra.s	Obj10_a4

Obj10_a3:
		tst.w	$12(a0)
		bpl.s	Obj10_a4
		add.w	d1,d1
		add.w	d1,d1

Obj10_a4:
		add.w	d1,$12(a0)
		jsr	SpeedToPos
		tst.b	$21(a0)		; has Sonic touched the	bumper?
		beq.s	locret_101C62	; if not, branch
		clr.b	$21(a0)
		lea	($FFFFB000).w,a1
		move.w	8(a0),d1
		move.w	$C(a0),d2
		sub.w	8(a1),d1
		sub.w	$C(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,$10(a1)	; bounce Sonic away
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,$12(a1)	; bounce Sonic away
		bset	#1,$22(a1)
		bclr	#4,$22(a1)
		bclr	#5,$22(a1)
		clr.b	$3C(a1)
		move.b	#1,$1C(a0)
		move.w	#$AA,d0
		jsr	(PlaySound_Special).l ;	play bumper sound

locret_101C62:
		rts	
; ===========================================================================

Obj10_ChkSonic:				; XREF: Obj10_ChkDrop
		move.w	#$100,d1
		bset	#0,$22(a0)
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_102142
		neg.w	d0
		neg.w	d1
		bclr	#0,$22(a0)

loc_102142:
		cmp.w	d2,d0
		rts	

Obj10_Propeller:
		movea.w	$30(a0),a1
		cmpi.b	#$10,0(a1) ; does parent object still exist?
		bne.w	Obj10_DeleteObject	; if not, delete
		move.w	8(a1),8(a0)
		move.w	$C(a1),d0
		sub.w	#$10,d0
		move.w	d0,$C(a0)
		move.b	#$6D,d0
		jsr	(PlaySound_Special).l
		lea	(Ani_obj10).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite

Obj10_Chain:
		movea.w	$30(a0),a1
		cmpi.b	#$10,0(a1) ; does parent object still exist?
		bne.w	Obj10_DeleteObject	; if not, delete
		move.w	8(a1),8(a0)
		move.w	$C(a1),$C(a0)
		jmp	DisplaySprite

; ===========================================================================
Ani_Obj10:
	include "_anim\Obj10.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Basaran enemy (DDZ)
; ---------------------------------------------------------------------------
Map_Obj10:
	include "_maps\Obj10.asm"
	even

; ----------------------------------------------------------------------------
; Object 03 - Collision plane/layer switcher
; ----------------------------------------------------------------------------
; Sprite_1FCDC:
Obj03:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	PSwapper_Index(pc,d0.w),d1
		jsr	PSwapper_Index(pc,d1.w)
		tst.w	($FFFFFFE2).w
		bne.s	Obj03_MarkObjGone
		; like RememberState, but doesn't display (Sonic 2's MarkObjGone3)
		move.w	8(a0),d0	; get object position
		andi.w	#$FF80,d0	; round down to nearest $80
		move.w	($FFFFF700).w,d1 ; get screen position
		subi.w	#128,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0		; approx distance between object and screen
		cmpi.w	#128+320+192,d0
		bhi.s	@offscreen
		rts

	@offscreen:
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	@delete		; if it's zero, don't remember object
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn table entry, so object can be loaded again

	@delete:
		jmp	DeleteObject

Obj03_MarkObjGone:
		jmp	MarkObjGone
; ===========================================================================
; off_1FCF0:
PSwapper_Index:
		dc.w PSwapper_Init-PSwapper_Index	; 0
		dc.w PSwapper_MainX-PSwapper_Index	; 2
		dc.w PSwapper_MainY-PSwapper_Index	; 4
; ===========================================================================
; loc_1FCF6:
PSwapper_Init:
		addq.b	#2,$24(a0) ; => PSwapper_MainX
		move.l	#Map_PathSwapper,4(a0)
		move.w	#$26C0,2(a0)
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$280,$18(a0)
		move.b	$28(a0),d0
		btst	#2,d0
		beq.s	PSwapper_Init_CheckX
;PSwapper_Init_CheckY:
		addq.b	#2,$24(a0) ; => PSwapper_MainY
		andi.w	#7,d0
		move.b	d0,$1A(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),$32(a0)
		move.w	$C(a0),d1
		lea	($FFFFB000).w,a1 ; a1=character
		cmp.w	$C(a1),d1
		bhs.w	PSwapper_MainY
		move.b	#1,$34(a0)
		bra.w	PSwapper_MainY
; ===========================================================================
word_1FD68:
	dc.w   $20
	dc.w   $40	; 1
	dc.w   $80	; 2
	dc.w  $100	; 3
; ===========================================================================
; loc_1FD70:
PSwapper_Init_CheckX:
		andi.w	#3,d0
		move.b	d0,$1A(a0)
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),$32(a0)
		move.w	8(a0),d1
		lea	($FFFFB000).w,a1 ; a1=character
		cmp.w	8(a1),d1
		bhs.s	@jump
		move.b	#1,$34(a0)
@jump:

; loc_1FDA4:
PSwapper_MainX:
		tst.w	($FFFFFE08).w
		bne.w	@locret
		move.w	8(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1 ; a1=character
		tst.b	(a2)+
		bne.w	PSwapper_MainX_Alt
		cmp.w	8(a1),d1
		bhi.s	@locret
		move.b	#1,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		blt.s	@locret
		cmp.w	d3,d4
		bge.s	@locret
		move.b	$28(a0),d0
		bpl.s	@jump
		btst	#1,$22(a1)
		bne.s	@locret
@jump:
		btst	#0,1(a0)
		bne.s	@jump2
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		btst	#3,d0
		beq.s	@jump2
		move.b	#$E,($FFFFFFD8).w	; MJ: set collision to 2nd
		move.b	#$F,($FFFFFFD9).w	; MJ: set collision to 2nd
@jump2:
		andi.w	#$7FFF,2(a1)
		btst	#5,d0
		beq.s	@jump3
		ori.w	#(1<<15),2(a1)
@jump3:
		tst.b	($FFFFFFE2).w
		beq.s	@locret
		move.b	#$63,d0
		jmp	PlaySound_Special
@locret:
		rts
; ===========================================================================
; loc_1FE38:
PSwapper_MainX_Alt:
		cmp.w	8(a1),d1
		bls.s	@locret
		move.b	#0,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		blt.s	@locret
		cmp.w	d3,d4
		bge.s	@locret
		move.b	$28(a0),d0
		bpl.s	@jump
		btst	#1,$22(a1)
		bne.s	@locret
@jump:
		btst	#0,1(a0)
		bne.s	@jump2
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		btst	#4,d0
		beq.s	@jump2
		move.b	#$E,($FFFFFFD8).w	; MJ: set collision to 2nd
		move.b	#$F,($FFFFFFD9).w	; MJ: set collision to 2nd
@jump2:
		andi.w	#$7FFF,2(a1)
		btst	#6,d0
		beq.s	@jump3
		ori.w	#(1<<15),2(a1)
@jump3:
		tst.b	($FFFFFFE2).w
		beq.s	@locret
		move.b	#$63,d0
		jmp	PlaySound_Special
@locret:
		rts
; ===========================================================================

PSwapper_MainY:
		tst.w	($FFFFFE08).w
		bne.w	@locret
		move.w	$C(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1 ; a1=character
		tst.b	(a2)+
		bne.s	PSwapper_MainY_Alt
		cmp.w	$C(a1),d1
		bhi.s	@locret
		move.b	#1,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		blt.s	@locret
		cmp.w	d3,d4
		bge.s	@locret
		move.b	$28(a0),d0
		bpl.s	@jump
		btst	#1,$22(a1)
		bne.s	@locret
@jump:
		btst	#0,1(a0)
		bne.s	@jump2
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		btst	#3,d0
		beq.s	@jump2
		move.b	#$E,($FFFFFFD8).w	; MJ: set collision to 2nd
		move.b	#$F,($FFFFFFD9).w	; MJ: set collision to 2nd
@jump2:
		andi.w	#$7FFF,2(a1)
		btst	#5,d0
		beq.s	@jump3
		ori.w	#(1<<15),2(a1)
@jump3:
		tst.b	($FFFFFE08).w
		beq.s	@locret
		move.b	#$63,d0
		jmp	PlaySound_Special

@locret:
		rts
; ===========================================================================
; loc_1FF42:
PSwapper_MainY_Alt:
		cmp.w	$C(a1),d1
		bls.s	@locret
		move.b	#0,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		blt.s	@locret
		cmp.w	d3,d4
		bge.s	@locret
		move.b	$28(a0),d0
		bpl.s	@jump
		btst	#1,$22(a1)
		bne.s	@locret
@jump:
		btst	#0,1(a0)
		bne.s	@jump2
		move.b	#$C,($FFFFFFD8).w	; MJ: set collision to 1st
		move.b	#$D,($FFFFFFD9).w	; MJ: set collision to 1st
		btst	#4,d0
		beq.s	@jump2
		move.b	#$E,($FFFFFFD8).w	; MJ: set collision to 2nd
		move.b	#$F,($FFFFFFD9).w	; MJ: set collision to 2nd
@jump2:
		andi.w	#$7FFF,2(a1)
		btst	#6,d0
		beq.s	@jump3
		ori.w	#(1<<15),2(a1)
@jump3:
		tst.b	($FFFFFFE2).w
		beq.s	@locret
		move.b	#$63,d0
		jmp	PlaySound_Special
@locret:
		rts
; ===========================================================================
; -------------------------------------------------------------------------------
; sprite mappings
; -------------------------------------------------------------------------------
Map_PathSwapper:	include "_maps\obj03.asm"
; ===========================================================================

;=============================================================================== 
; Object 04 - Speed Booster						
;===============================================================================				  
Obj04: ; Offset_0x016468:
		moveq   #0,d0
		move.b  $24(a0),d0
		move.w  Offset_0x016476(pc,d0),d1
		jmp	 Offset_0x016476(pc,d1)

Offset_0x016476:
		dc.w	Offset_0x01647E-Offset_0x016476
		dc.w	Offset_0x0164B4-Offset_0x016476  

Offset_0x01647A:
		dc.w	$1000,$0A00

Offset_0x01647E:
		addq.b  #2,$24(a0)
		move.w  #$51C,$2(a0)
		move.l  #Map_Obj04,4(a0) ; Offset_0x01658A
		ori.b   #4,$1(a0)
		move.b  #$20,$14(a0)
		move.w  #$300,$18(a0)
		move.b  $28(a0),d0
		andi.w  #2,d0
		move.w  Offset_0x01647A(pc,d0),$30(a0)

Offset_0x0164B4:
		move.w  $8(a0),d0
		move.w  d0,d1
		subi.w  #$10,d0
		addi.w  #$10,d1
		move.w  $C(a0),d2
		move.w  d2,d3
		subi.w  #$10,d2
		addi.w  #$10,d3
		lea	 ($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s   Offset_0x016540
		move.w  $8(a1),d4
		cmp.w   d0,d4
		bcs	 Offset_0x016540
		cmp.w   d1,d4
		bcc	 Offset_0x016540
		move.w  $C(a1),d4
		cmp.w   d2,d4
		bcs	 Offset_0x016540
		cmp.w   d3,d4
		bcc	 Offset_0x016540
		move.w  d0,-(a7)
		bsr	 Offset_0x016544
		move.w  (a7)+,d0

Offset_0x016540:
		lea (Ani_obj04).l,a1
		jsr AnimateSprite
		jmp	MarkObjGone

Offset_0x016544:
		move.w  $30(a0),$10(a1)
		bclr	#0,$22(a1)
		btst	#0,$22(a0)
		beq.s   Offset_0x016562
		bset	#0,$22(a1)
		neg.w   $10(a1)

Offset_0x016562:
	;	move.w  #$F, $2E(a1)
		move.w  $10(a1),$20(a1)
		bclr	#5,$22(a0)
		bclr	#6,$22(a0)
		bclr	#5,$22(a1)
		move.w  #$B1,d0
		jmp	 PlaySound			  ; Offset_0x0014C6

Map_Obj04: include "_maps\obj04.asm"
		even
Ani_Obj04: include "_anim\obj04.asm"
		even

; ----------------------------------------------------------------------------
; Object 06 - Diagonally moving lift from HTZ
; ----------------------------------------------------------------------------
; Sprite_21DAC:
Obj06:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj06_Index(pc,d0.w),d1
	jmp	Obj06_Index(pc,d1.w)
; ===========================================================================
; off_21DBA:
Obj06_Index:
		dc.w Obj06_Init-Obj06_Index	; 0
		dc.w Obj06_Main-Obj06_Index	; 2
; ===========================================================================
; loc_21DBE:
Obj06_Init:
	addq.b	#2,$24(a0)
	move.l	#Map_obj06,4(a0)
	move.w	#$4384,2(a0)
	ori.b	#4,1(a0)
	move.b	#$20,$14(a0)
	move.b	#0,4(a0)
	move.w	#$80,$18(a0)
	move.w	8(a0),$30(a0)
	move.w	$C(a0),$32(a0)
	move.b	#$40,$16(a0)
	bset	#4,1(a0)
	moveq	#0,d0
	move.b	$28(a0),d0
	lsl.w	#3,d0
	move.w	d0,$34(a0)
; loc_21E10:
Obj06_Main:
	move.w	8(a0),-(sp)
	bsr.w	Obj06_RunSecondaryRoutine
	moveq	#0,d1
	move.b	$14(a0),d1
	move.w	#-$28,d3
	move.w	(sp)+,d4
	bclr	#1,1(a0)
	jsr	(PlatformObjectS2).l
	jmp	(MarkObjGone).l
; ===========================================================================
; loc_21E2C:
Obj06_RunSecondaryRoutine:
	moveq	#0,d0
	move.b	$25(a0),d0
	move.w	Obj06_Main_States(pc,d0.w),d1
	jmp	Obj06_Main_States(pc,d1.w)
; ===========================================================================
; off_21E3A:
Obj06_Main_States:
	dc.w Obj06_Wait-Obj06_Main_States	; 0
	dc.w Obj06_Slide-Obj06_Main_States	; 2
	dc.w Obj06_Fall-Obj06_Main_States	; 4
; ===========================================================================
; loc_21E40:
Obj06_Wait:
	move.b	$22(a0),d0	; get the status flags
	andi.b	#8,d0	; is one of the players standing on it?
	beq.s	Obj06_Wait2		; if not, branch
	addq.b	#2,$25(a0)
	move.w	#$200,$10(a0)
	btst	#0,$22(a0)
	beq.s	Obj06_Wait1
	neg.w	$10(a0)

Obj06_Wait1:
	move.w	#$100,$12(a0)
	btst	#1,$22(a0)
	beq.s	Obj06_Wait2
	neg.w	$10(a0)
	neg.w	$12(a0)

Obj06_Wait2:
	rts
; ===========================================================================
; loc_21E68:
Obj06_Slide:
	move.w	($FFFFFE04).w,d0
	andi.w	#$F,d0	; play the sound only every 16 frames
	bne.s	Obj06_Slide1
	move.w	#$55,d0
	jsr	(PlaySound).l

Obj06_Slide1:
	jsr	(SpeedToPos).l
	subq.w	#1,$34(a0)
	bne.s	Obj06_Slide2	; rts
	addq.b	#2,$25(a0)
	move.b	#2,4(a0)
	move.w	#0,$10(a0)
	move.w	#0,$12(a0)
	move.b	#2,$1A(a0)
	jsr	(SingleObjLoad2).l
	bne.s	Obj06_Slide2	; rts
	move.b	#$1C,0(a1) ; load obj1C
	move.w	8(a0),8(a1)
	move.w	$C(a0),$C(a1)
	move.b	1(a0),1(a1)
	move.b	#2,$28(a1)

Obj06_Slide2:
	rts
; ===========================================================================
; loc_21EC2:
Obj06_Fall:
	jsr	(SpeedToPos).l
	addi.w	#$38,$12(a0)
	move.w	($FFFFF72E).w,d0
	addi.w	#$E0,d0
	cmp.w	$C(a0),d0
	bhs.s	Obj06_Fall2	; rts
	move.b	$22(a0),d0
	andi.b	#8,d0
	beq.s	Obj06_Fall1
	bclr	#3,$22(a0)
	beq.s	Obj06_Fall1
	bclr	#3,($FFFFB022).w
	bset	#1,($FFFFB022).w

Obj06_Fall1:
	move.w	#$4000,8(a0)

Obj06_Fall2:
	rts
; -------------------------------------------------------------------------------
; Waterfall Mappings
; -------------------------------------------------------------------------------
Map_obj06:				; DATA XREF: h+9C40o h+9CDCo ...
	include 	"_maps\obj06.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 07 - A sprite that	you can	hold on	to, like the rails in WFZ
; ----------------------------------------------------------------------------

Obj07:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_2C93A(pc,d0.w),d1
		jmp	off_2C93A(pc,d1.w)
; ===========================================================================
off_2C93A:	dc.w loc_2C93E-off_2C93A; 0 ; DATA XREF: h+159C6o h+159C8o
		dc.w loc_2C954-off_2C93A; 1
; ===========================================================================

loc_2C93E:				; DATA XREF: h+159C6o
		addq.b	#2,$24(a0)
		move.b	#4,1(a0)
		move.b	#$18,$14(a0)
		move.w	#$200,$18(a0)

loc_2C954:				; DATA XREF: h+159C6o
		lea	$30(a0),a2
		lea	($FFFFB000).w,a1
		move.w	($FFFFF604).w,d0
		addq.w	#1,a2
		bsr.s	loc_2C972
		bra.w	JmpTo7_MarkObjGone3
; ===========================================================================

loc_2C972:				; CODE XREF: h+159ECp h+159F8p
		tst.b	(a2)
		beq.s	loc_2C9A0
		andi.b	#$70,d0	; 'p'
		beq.w	locret_2CA08
		clr.b	$3E(a1)
		clr.b	(a2)
		move.b	#$12,2(a2)
		andi.w	#$F00,d0
		beq.s	loc_2C996
		move.b	#$3C,2(a2) ; '<'

loc_2C996:				; CODE XREF: h+15A1Aj
		move.w	#-$300,$12(a1)
		bra.w	locret_2CA08
; ===========================================================================

loc_2C9A0:
		tst.b	2(a2)
		beq.s	loc_2C9AE
		subq.b	#1,2(a2)
		bne.w	locret_2CA08

loc_2C9AE:				; CODE XREF: h+15A30j
		move.w	8(a1),d0
		sub.w	8(a0),d0
		addi.w	#$18,d0
		cmpi.w	#$30,d0	; '0'
		bcc.w	locret_2CA08
		move.w	$C(a1),d1
		sub.w	$C(a0),d1
		cmpi.w	#$10,d1
		bcc.w	locret_2CA08
		tst.b	$3E(a1)
		bmi.s	locret_2CA08
		cmpi.b	#6,$24(a1)
		bcc.s	locret_2CA08
		tst.w	($FFFFFE08).w
		bne.s	locret_2CA08
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$20(a1)
		move.w	$C(a0),$C(a1)
		move.b	#$14,$1C(a1)
		move.b	#1,$3E(a1)
		move.b	#1,(a2)

locret_2CA08:				; CODE XREF: h+15A06j h+15A28j ...
		rts	
; ===========================================================================
		nop	

JmpTo7_MarkObjGone3: 
	jmp	MarkObjGone3
; ===========================================================================
		dc.b   0 ;  
		dc.b   0 ;
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	animate	level graphics
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_Load:				; XREF: Demo_Time; loc_F54
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	AniArt_Pause	; if yes, branch
		lea	($C00000).l,a6
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	AniArt_Index(pc,d0.w),d0
		jmp	AniArt_Index(pc,d0.w)
; ===========================================================================

AniArt_Pause:
		rts	
; End of function AniArt_Load

; ===========================================================================
AniArt_Index:	dc.w AniArt_WOZ-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_KVZ-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Green Hill
; ---------------------------------------------------------------------------

AniArt_WOZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.w	locret_1C10C
		move.b	#8,($FFFFF7B1).w
		moveq	#0,d1
		move.b	($FFFFF7B0).w,d1
		addq.b	#1,($FFFFF7B0).w
		cmpi.b	#3,($FFFFF7B0).w
		bne.s	loc_1C0E8
		move.b	#0,($FFFFF7B0).w

loc_1C0E8:
		move.b	byte_1C10E(pc,d1.w),d1
		mulu.w	#$C0,d1
		lea	(Art_WOZTorch).l,a0 ; load pulsing patterns
		add.l	a0,d1
		move.w	#$20,d2
		move.w	#$60,d3
		jsr	(QueueDMATransfer).l

locret_1C10C:
		rts	
; ===========================================================================
byte_1C10E:	dc.b 2,	1, 0, 0
; ===========================================================================

; ---------------------------------------------------------------------------
; Animated pattern routine - Star Light
; ---------------------------------------------------------------------------

AniArt_KVZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.w	locret2_1C10C
		move.b	#8,($FFFFF7B1).w
		moveq	#0,d1
		move.b	($FFFFF7B0).w,d1
		addq.b	#1,($FFFFF7B0).w
		andi.b	#$F,($FFFFF7B0).w
		move.b	byte2_1C10E(pc,d1.w),d1
		mulu.w	#$100,d1
		lea	(Art_KVZFlower).l,a0 ; load pulsing patterns
		add.l	a0,d1
		move.w	#$20,d2
		move.w	#$80,d3
		jsr	(QueueDMATransfer).l

locret2_1C10C:
		rts	
; ===========================================================================
byte2_1C10E:	dc.b 0,	0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1
; ===========================================================================

AniArt_none:				; XREF: AniArt_Index
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load (d1 - 1) 8x8 tiles
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTiles:
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		dbf	d1,LoadTiles
		rts	
; End of function LoadTiles

; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - more Marble Zone
; ---------------------------------------------------------------------------
AniArt_DDZextra:	dc.w loc_1C3EE-AniArt_DDZextra, loc_1C3FA-AniArt_DDZextra
		dc.w loc_1C410-AniArt_DDZextra, loc_1C41E-AniArt_DDZextra
		dc.w loc_1C434-AniArt_DDZextra, loc_1C442-AniArt_DDZextra
		dc.w loc_1C458-AniArt_DDZextra, loc_1C466-AniArt_DDZextra
		dc.w loc_1C47C-AniArt_DDZextra, loc_1C48A-AniArt_DDZextra
		dc.w loc_1C4A0-AniArt_DDZextra, loc_1C4AE-AniArt_DDZextra
		dc.w loc_1C4C4-AniArt_DDZextra, loc_1C4D2-AniArt_DDZextra
		dc.w loc_1C4E8-AniArt_DDZextra, loc_1C4FA-AniArt_DDZextra
; ===========================================================================

loc_1C3EE:				; XREF: AniArt_DDZextra
		move.l	(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C3EE
		rts	
; ===========================================================================

loc_1C3FA:				; XREF: AniArt_DDZextra
		move.l	2(a1),d0
		move.b	1(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C3FA
		rts	
; ===========================================================================

loc_1C410:				; XREF: AniArt_DDZextra
		move.l	2(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C410
		rts	
; ===========================================================================

loc_1C41E:				; XREF: AniArt_DDZextra
		move.l	4(a1),d0
		move.b	3(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C41E
		rts	
; ===========================================================================

loc_1C434:				; XREF: AniArt_DDZextra
		move.l	4(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C434
		rts	
; ===========================================================================

loc_1C442:				; XREF: AniArt_DDZextra
		move.l	6(a1),d0
		move.b	5(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C442
		rts	
; ===========================================================================

loc_1C458:				; XREF: AniArt_DDZextra
		move.l	6(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C458
		rts	
; ===========================================================================

loc_1C466:				; XREF: AniArt_DDZextra
		move.l	8(a1),d0
		move.b	7(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C466
		rts	
; ===========================================================================

loc_1C47C:				; XREF: AniArt_DDZextra
		move.l	8(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C47C
		rts	
; ===========================================================================

loc_1C48A:				; XREF: AniArt_DDZextra
		move.l	$A(a1),d0
		move.b	9(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C48A
		rts	
; ===========================================================================

loc_1C4A0:				; XREF: AniArt_DDZextra
		move.l	$A(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4A0
		rts	
; ===========================================================================

loc_1C4AE:				; XREF: AniArt_DDZextra
		move.l	$C(a1),d0
		move.b	$B(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4AE
		rts	
; ===========================================================================

loc_1C4C4:				; XREF: AniArt_DDZextra
		move.l	$C(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4C4
		rts	
; ===========================================================================

loc_1C4D2:				; XREF: AniArt_DDZextra
		move.l	$C(a1),d0
		rol.l	#8,d0
		move.b	0(a1),d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4D2
		rts	
; ===========================================================================

loc_1C4E8:				; XREF: AniArt_DDZextra
		move.w	$E(a1),(a6)
		move.w	0(a1),(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4E8
		rts	
; ===========================================================================

loc_1C4FA:				; XREF: AniArt_DDZextra
		move.l	0(a1),d0
		move.b	$F(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	$10(a1),a1
		dbf	d1,loc_1C4FA
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 21 - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------

Obj21:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj21_Index(pc,d0.w),d1
		jmp	Obj21_Index(pc,d1.w)
; ===========================================================================
Obj21_Index:	dc.w Obj21_Main-Obj21_Index
		dc.w Obj21_Display-Obj21_Index
; ===========================================================================

Obj21_Main:				; XREF: Obj21_Main
		addq.b	#2,$24(a0)
		move.w	#$84,8(a0)
		move.w	#$104,$A(a0)
		move.l	#Map_obj21,4(a0)
		move.w	#$86C0,2(a0)
		move.b	#0,1(a0)
		move.w	#0,$18(a0)
		move.l	#Art_SonLives,d1
		tst.w	(Current_Character).w
		beq.s	Obj21_Main2
		move.l	#Art_ShaLives,d1
		cmpi.w	#1,(Current_Character).w
		beq.s	Obj21_Main2
		move.l	#Art_SilLives,d1

Obj21_Main2:
		move.w	#$FA80,d2
		move.w	#$40,d3
		jsr	(QueueDMATransfer).l

Obj21_Display:
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------
Map_obj21:
	include "_maps\obj21.asm"

; ---------------------------------------------------------------------------
; Add points subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AddPoints:
		move.b	#1,($FFFFFE1F).w ; set score counter to	update
		lea	($FFFFFFC0).w,a2
		lea	($FFFFFE26).w,a3
		add.l	d0,(a3)		; add d0*10 to the score
		move.l	#999999,d1
		cmp.l	(a3),d1		; is #999999 higher than the score?
		bhi.w	loc_1C6AC	; if yes, branch
		move.l	d1,(a3)		; reset	score to #999999
		move.l	d1,(a2)

loc_1C6AC:
		move.l	(a3),d0
		cmp.l	(a2),d0
		bcs.w	locret_1C6B6
		move.l	d0,(a2)

locret_1C6B6:
		rts	
; End of function AddPoints

; ---------------------------------------------------------------------------
; Subroutine to	update the HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudUpdate:
		tst.w	($FFFFFFFA).w	; is debug mode	on?
		bne.w	HudDebug	; if yes, branch
		tst.b	($FFFFFE1F).w	; does the score need updating?
		beq.s	Hud_ChkRings	; if not, branch
		clr.b	($FFFFFE1F).w
		move.l	#$5C800003,d0	; set VRAM address
		move.l	($FFFFFE26).w,d1 ; load	score
		bsr.w	Hud_Score

Hud_ChkRings:
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	Hud_ChkTime	; if not, branch
		bpl.s	loc_1C6E4
		bsr.w	Hud_LoadZero

loc_1C6E4:
		clr.b	($FFFFFE1D).w
		move.l	#$5F400003,d0	; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr.w	Hud_Rings

Hud_ChkTime:
		tst.b	($FFFFFE1E).w	; does the time	need updating?
		beq.w	Hud_ChkLives	; if not, branch
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.w	Hud_ChkLives	; if yes, branch
		lea	($FFFFFE22).w,a1
		cmpi.l	#$93B63,(a1)+	; is the time 9'59"99?
		beq.w	TimeOver	; if yes, branch	;Mercury HUD In Special Stage (bsr.s => bsr.w)
		move.b	($FFFFFE2D).w,d1
		addi.b	#1,d1
		cmpi.b	#3,d1
		bne.s	Hud_ChkTime_skip
		move.b	#0,d1
		
Hud_ChkTime_skip:
		move.b	d1,($FFFFFE2D).w
		cmpi.b	#2,d1
		beq.s	Hud_ChkTime_skip2
		addi.b	#1,d1
		
Hud_ChkTime_skip2:
		add.b	d1,-(a1)
		cmpi.b	#100,(a1)
		bcs.s	Hud_DoCent
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#60,(a1)
		bcs.s	loc_1C734
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#9,(a1)
		bcs.s	loc_1C734
		move.b	#9,(a1)

loc_1C734:
		move.l	#$5E400003,d0
		moveq	#0,d1
		move.b	($FFFFFE23).w,d1 ; load	minutes
		bsr.w	Hud_Mins
		move.l	#$5EC00003,d0
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1 ; load	seconds
		bsr.w	Hud_Secs

Hud_DoCent:
		move.l	#$5BC00003,d0	;Mercury Macros
		moveq	#0,d1
		move.b	($FFFFFE25).w,d1 ; load	seconds
		bsr.w	Hud_Secs

Hud_ChkLives:
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	Hud_ChkBonus	; if not, branch
		clr.b	($FFFFFE1C).w
		bsr.w	Hud_Lives

Hud_ChkBonus:
		tst.b	($FFFFF7D6).w	; do time/ring bonus counters need updating?
		beq.s	Hud_End		; if not, branch
		clr.b	($FFFFF7D6).w
		move.l	#$6E000002,($C00004).l
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr.w	Hud_TimeRingBonus

Hud_End:
		rts	
; ===========================================================================

TimeOver:				; XREF: Hud_ChkTime
		clr.b	($FFFFFE1E).w
		lea	($FFFFB000).w,a0
		movea.l	a0,a2
		bsr.w	KillSonic
		move.b	#1,($FFFFFE1A).w
		rts	
; ===========================================================================

HudDebug:				; XREF: HudUpdate
		bsr.w	HudDb_XY
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	HudDb_ObjCount	; if not, branch
		bpl.s	HudDb_Rings
		bsr.w	Hud_LoadZero

HudDb_Rings:
		clr.b	($FFFFFE1D).w
		move.l	#$5F400003,d0	; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr.w	Hud_Rings

HudDb_ObjCount:
		move.l	#$5EC00003,d0	; set VRAM address
		moveq	#0,d1
		move.b	($FFFFF62C).w,d1 ; load	"number	of objects" counter
		bsr.w	Hud_Secs
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	HudDb_ChkBonus	; if not, branch
		clr.b	($FFFFFE1C).w
		bsr.w	Hud_Lives

HudDb_ChkBonus:
		tst.b	($FFFFF7D6).w	; does the ring/time bonus counter need	updating?
		beq.s	HudDb_End	; if not, branch
		clr.b	($FFFFF7D6).w
		move.l	#$6E000002,($C00004).l ; set VRAM address
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr.w	Hud_TimeRingBonus

HudDb_End:
		rts	
; End of function HudUpdate

; ---------------------------------------------------------------------------
; Subroutine to	load "0" on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadZero:				; XREF: HudUpdate
		move.l	#$5F400003,($C00004).l
		lea	Hud_TilesZero(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadZero

; ---------------------------------------------------------------------------
; Subroutine to	load " on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadMarks:				; XREF: HUD_Update
		move.l	#$5B800003,($C00004).l
		lea	Hud_TilesMarks(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadMarks

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Base:				; XREF: Level; SS_EndLoop; EndingSequence
		lea	($C00000).l,a6
		bsr.w	Hud_Lives
		bsr.s	Hud_LoadMarks
		move.l	#$5C400003,($C00004).l
		lea	Hud_TilesBase(pc),a2
		move.w	#$E,d2

loc_1C83E:				; XREF: Hud_LoadZero
		lea	Art_Hud(pc),a1

loc_1C842:
		move.w	#$F,d1
		move.b	(a2)+,d0
		bmi.s	loc_1C85E
		ext.w	d0
		lsl.w	#5,d0
		lea	(a1,d0.w),a3

loc_1C852:
		move.l	(a3)+,(a6)
		dbf	d1,loc_1C852

loc_1C858:
		dbf	d2,loc_1C842

		rts	
; ===========================================================================

loc_1C85E:
		move.l	#0,(a6)
		dbf	d1,loc_1C85E

		bra.s	loc_1C858
; End of function Hud_Base

; ===========================================================================
Hud_TilesMarks:	dc.b $16, 0, 0, 0
Hud_TilesBase:	dc.b $16, $FF, $FF, $FF, $FF, $FF, $FF,	0, 0, $14, 0, 0
Hud_TilesZero:	dc.b $FF, $FF, 0, 0
; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY:				; XREF: HudDebug
		move.l	#$5C400003,($C00004).l ; set VRAM address
		move.w	($FFFFF700).w,d1 ; load	camera x-position
		swap	d1
		move.w	($FFFFB008).w,d1 ; load	Sonic's x-position
		bsr.s	HudDb_XY2
		move.w	($FFFFF704).w,d1 ; load	camera y-position
		swap	d1
		move.w	($FFFFB00C).w,d1 ; load	Sonic's y-position
; End of function HudDb_XY


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY2:
		moveq	#7,d6
		lea	(Art_Text).l,a1

HudDb_XYLoop:
		rol.w	#4,d1
		move.w	d1,d2
		andi.w	#$F,d2
		cmpi.w	#$A,d2
		bcs.s	loc_1C8B2
		addq.w	#7,d2

loc_1C8B2:
		lsl.w	#5,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		swap	d1
		dbf	d6,HudDb_XYLoop	; repeat 7 more	times

		rts	
; End of function HudDb_XY2

; ---------------------------------------------------------------------------
; Subroutine to	load rings numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Rings:				; XREF: HudUpdate
		lea	(Hud_100).l,a2
		moveq	#2,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_RingLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc2_1C8EC:
		sub.l	d3,d1
		bcs.s	loc2_1C8F4
		addq.w	#1,d2
		bra.s	loc2_1C8EC
; ===========================================================================

loc2_1C8F4:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc2_1C8FE
		move.w	#1,d4

loc2_1C8FE:
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc2_1C92C:
		addi.l	#$400000,d0
		dbf	d6,Hud_RingLoop

		rts	
; End of function Hud_Rings

; ---------------------------------------------------------------------------
; Subroutine to	load score numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Score:				; XREF: HudUpdate
		lea	(Hud_100000).l,a2
		moveq	#5,d6

Hud_LoadArt:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_ScoreLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C8EC:
		sub.l	d3,d1
		bcs.s	loc_1C8F4
		addq.w	#1,d2
		bra.s	loc_1C8EC
; ===========================================================================

loc_1C8F4:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C8FE
		move.w	#1,d4

loc_1C8FE:
		tst.w	d4
		beq.s	loc_1C92C
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1C92C:
		addi.l	#$400000,d0
		dbf	d6,Hud_ScoreLoop

		rts	
; End of function Hud_Score

; ---------------------------------------------------------------------------
; Subroutine to	load countdown numbers on the continue screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ContScrCounter:				; XREF: ContinueScreen
		move.l	#$5F800003,($C00004).l ; set VRAM address
		lea	($C00000).l,a6
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1 ; load numbers patterns

ContScr_Loop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C95A:
		sub.l	d3,d1
		bcs.s	loc_1C962
		addq.w	#1,d2
		bra.s	loc_1C95A
; ===========================================================================

loc_1C962:
		add.l	d3,d1
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		dbf	d6,ContScr_Loop	; repeat 1 more	time

		rts	
; End of function ContScrCounter

; ===========================================================================
; ---------------------------------------------------------------------------
; HUD counter sizes
; ---------------------------------------------------------------------------
Hud_100000:	dc.l 100000		; XREF: Hud_Score
Hud_10000:	dc.l 10000
Hud_1000:	dc.l 1000		; XREF: Hud_TimeRingBonus
Hud_100:	dc.l 100		; XREF: Hud_Rings
Hud_10:		dc.l 10			; XREF: ContScrCounter; Hud_Secs; Hud_Lives
Hud_1:		dc.l 1			; XREF: Hud_Mins

; ---------------------------------------------------------------------------
; Subroutine to	load time numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Mins:				; XREF: Hud_ChkTime
		lea	(Hud_1).l,a2
		moveq	#0,d6
		bra.s	loc_1C9BA
; End of function Hud_Mins


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Secs:				; XREF: Hud_ChkTime
		lea	(Hud_10).l,a2
		moveq	#1,d6

loc_1C9BA:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_TimeLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C9C4:
		sub.l	d3,d1
		bcs.s	loc_1C9CC
		addq.w	#1,d2
		bra.s	loc_1C9C4
; ===========================================================================

loc_1C9CC:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C9D6
		move.w	#1,d4

loc_1C9D6:
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		addi.l	#$400000,d0
		dbf	d6,Hud_TimeLoop

		rts	
; End of function Hud_Secs

; ---------------------------------------------------------------------------
; Subroutine to	load time/ring bonus numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_TimeRingBonus:			; XREF: Hud_ChkBonus
		lea	(Hud_1000).l,a2
		moveq	#3,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_BonusLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA1E:
		sub.l	d3,d1
		bcs.s	loc_1CA26
		addq.w	#1,d2
		bra.s	loc_1CA1E
; ===========================================================================

loc_1CA26:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CA30
		move.w	#1,d4

loc_1CA30:
		tst.w	d4
		beq.s	Hud_ClrBonus
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1CA5A:
		dbf	d6,Hud_BonusLoop ; repeat 3 more times

		rts	
; ===========================================================================

Hud_ClrBonus:
		moveq	#$F,d5

Hud_ClrBonusLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrBonusLoop

		bra.s	loc_1CA5A
; End of function Hud_TimeRingBonus

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed lives	counter	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Lives:				; XREF: Hud_ChkLives
		move.l	#$7B000003,d0	; set VRAM address
		moveq	#0,d1
		move.b	($FFFFFE12).w,d1 ; load	number of lives
		tst.b 	d1
		beq.w 	Hud_LivesCont
		subi.b 	#1,d1

Hud_LivesCont:
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_LivesLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA90:
		sub.l	d3,d1
		bcs.s	loc_1CA98
		addq.w	#1,d2
		bra.s	loc_1CA90
; ===========================================================================

loc_1CA98:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CAA2
		move.w	#1,d4

loc_1CAA2:
		tst.w	d4
		beq.s	Hud_ClrLives

loc_1CAA6:
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1CABC:
		addi.l	#$400000,d0
		dbf	d6,Hud_LivesLoop ; repeat 1 more time

		rts
; ===========================================================================

Hud_ClrLives:
		tst.w	d6
		beq.s	loc_1CAA6
		moveq	#7,d5

Hud_ClrLivesLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrLivesLoop
		bra.s	loc_1CABC
; End of function Hud_Lives

; ===========================================================================
Art_Hud:	incbin	artunc\HUD.bin		; 8x16 pixel numbers on HUD
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; When debug mode is currently in use
; ---------------------------------------------------------------------------

DebugMode:				; XREF: Obj01; Obj09
		moveq	#0,d0
		move.b	($FFFFFE08).w,d0
		move.w	Debug_Index(pc,d0.w),d1
		jmp	Debug_Index(pc,d1.w)
; ===========================================================================
Debug_Index:	dc.w Debug_Main-Debug_Index
		dc.w Debug_Skip-Debug_Index
; ===========================================================================

Debug_Main:				; XREF: Debug_Index
		addq.b	#2,($FFFFFE08).w
		move.w	($FFFFF72C).w,($FFFFFEF0).w ; buffer level x-boundary
		move.w	($FFFFF726).w,($FFFFFEF2).w ; buffer level y-boundary
		move.w	#0,($FFFFF72C).w
		move.w	#$720,($FFFFF726).w
		andi.w	#$7FF,($FFFFB00C).w
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		move.b	#0,$1A(a0)
		move.b	#0,$1C(a0)
		clr.w	$10(a0)
		clr.w	$12(a0)
		clr.w	$20(a0)
		btst	#3,$22(a0)	; is Sonic standing on an object?	;Mercury Constants
		beq.s	@setpos		; if not, branch
		bclr	#3,$22(a0)	; clear Sonic's standing flag	;Mercury Constants
		moveq	#0,d0
		move.b	$3D(a0),d0	; get object id	;Mercury Constants
		clr.b	$3D(a0)	; clear object id	;Mercury Constants
		lsl.w	#6,d0
		addi.l	#$FFFFD000&$FFFFFF,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)	; clear object's standing flag	;Mercury Constants
		clr.b	$25(a2)

@setpos:
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)?
		bne.s	Debug_Zone	; if not, branch
		move.w	#0,($FFFFF782).w ; stop	special	stage rotating
		move.w	#0,($FFFFF780).w ; make	special	stage "upright"
		moveq	#6,d0		; use 6th debug	item list
		bra.s	Debug_UseList
; ===========================================================================

Debug_Zone:
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

Debug_UseList:
		lea	(DebugList).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		cmp.b	($FFFFFE06).w,d6
		bhi.s	loc_1CF9E
		move.b	#0,($FFFFFE06).w

loc_1CF9E:
		bsr.w	Debug_ShowItem
		move.b	#$C,($FFFFFE0A).w
		move.b	#1,($FFFFFE0B).w

Debug_Skip:				; XREF: Debug_Index
		moveq	#6,d0
		cmpi.b	#$10,($FFFFF600).w
		beq.s	loc_1CFBE
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

loc_1CFBE:
		lea	(DebugList).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		bsr.w	Debug_Control
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_Control:
		moveq	#0,d4
		move.w	#1,d1
		move.b	($FFFFF605).w,d4
		andi.w	#$F,d4		; is up/down/left/right	pressed?
		bne.s	loc_1D018	; if yes, branch
		move.b	($FFFFF604).w,d0
		andi.w	#$F,d0
		bne.s	loc_1D000
		move.b	#$C,($FFFFFE0A).w
		move.b	#$F,($FFFFFE0B).w
		bra.w	Debug_BackItem
; ===========================================================================

loc_1D000:
		subq.b	#1,($FFFFFE0A).w
		bne.s	loc_1D01C
		move.b	#1,($FFFFFE0A).w
		addq.b	#1,($FFFFFE0B).w
		bne.s	loc_1D018
		move.b	#-1,($FFFFFE0B).w

loc_1D018:
		move.b	($FFFFF604).w,d4

loc_1D01C:
		moveq	#0,d1
		move.b	($FFFFFE0B).w,d1
		addq.w	#1,d1
		swap	d1
		asr.l	#4,d1
		move.l	$C(a0),d2
		move.l	8(a0),d3
		btst	#0,d4		; is up	being pressed?
		beq.s	loc_1D03C	; if not, branch
		sub.l	d1,d2
		bcc.s	loc_1D03C
		moveq	#0,d2

loc_1D03C:
		btst	#1,d4		; is down being	pressed?
		beq.s	loc_1D052	; if not, branch
		add.l	d1,d2
		cmpi.l	#$7FF0000,d2
		bcs.s	loc_1D052
		move.l	#$7FF0000,d2

loc_1D052:
		btst	#2,d4
		beq.s	loc_1D05E
		sub.l	d1,d3
		bcc.s	loc_1D05E
		moveq	#0,d3

loc_1D05E:
		btst	#3,d4
		beq.s	loc_1D066
		add.l	d1,d3

loc_1D066:
		move.l	d2,$C(a0)
		move.l	d3,8(a0)

Debug_BackItem:
		btst	#6,($FFFFF604).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_NextItem	; if not, branch
		subq.b	#1,($FFFFFE06).w ; go back 1 item
		bcc.s	Debug_NoLoop
		add.b	d6,($FFFFFE06).w
		bra.s	Debug_NoLoop
; ===========================================================================

Debug_NextItem:
		btst	#6,($FFFFF605).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		addq.b	#1,($FFFFFE06).w ; go forwards 1 item
		cmp.b	($FFFFFE06).w,d6
		bhi.s	Debug_NoLoop
		move.b	#0,($FFFFFE06).w ; loop	back to	first item

Debug_NoLoop:
		bra.w	Debug_ShowItem
; ===========================================================================

Debug_MakeItem:
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_Exit	; if not, branch
		jsr	SingleObjLoad
		bne.s	Debug_Exit
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	4(a0),0(a1)	; create object
		move.b	1(a0),1(a1)
		move.b	1(a0),$22(a1)
		andi.b	#$7F,$22(a1)
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.b	4(a2,d0.w),$28(a1)
		rts	
; ===========================================================================

Debug_Exit:
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Debug_DoNothing	; if not, branch
		moveq	#0,d0
		move.w	d0,($FFFFFE08).w ; deactivate debug mode
		move.l	#Map_Sonic,($FFFFB004).w
		move.w	#$780,($FFFFB002).w
		move.b	d0,($FFFFB01C).w
		move.w	d0,$A(a0)
		move.w	d0,$E(a0)
		move.w	($FFFFFEF0).w,($FFFFF72C).w ; restore level boundaries
		move.w	($FFFFFEF2).w,($FFFFF726).w
		cmpi.b	#$10,($FFFFF600).w ; are you in	the special stage?
		bne.s	Debug_DoNothing	; if not, branch
		clr.w	($FFFFF780).w
		move.w	#$40,($FFFFF782).w ; set new level rotation speed
		move.l	#Map_Sonic,($FFFFB004).w
		move.w	#$780,($FFFFB002).w
		move.b	#2,($FFFFB01C).w
		bset	#2,($FFFFB022).w
		bset	#1,($FFFFB022).w

Debug_DoNothing:
		rts	
; End of function Debug_Control


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_ShowItem:				; XREF: Debug_Main
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.l	(a2,d0.w),4(a0)	; load mappings	for item
		move.w	6(a2,d0.w),2(a0) ; load	VRAM setting for item
		move.b	5(a2,d0.w),$1A(a0) ; load frame	number for item
		rts	
; End of function Debug_ShowItem

; ===========================================================================
; ---------------------------------------------------------------------------
; Debug	list pointers
; ---------------------------------------------------------------------------
DebugList:
	include "_inc\Debug list pointers.asm"

; ---------------------------------------------------------------------------
; Debug	list - Green Hill
; ---------------------------------------------------------------------------
Debug_WOZ:
	include "_inc\Debug list - WOZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Labyrinth
; ---------------------------------------------------------------------------
Debug_TJZ:
	include "_inc\Debug list - TJZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Marble
; ---------------------------------------------------------------------------
Debug_DDZ:
	include "_inc\Debug list - DDZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Star Light
; ---------------------------------------------------------------------------
Debug_KVZ:
	include "_inc\Debug list - KVZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Spring Yard
; ---------------------------------------------------------------------------
Debug_CCZ:
	include "_inc\Debug list - CCZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Scrap Brain
; ---------------------------------------------------------------------------
Debug_ABZ:
	include "_inc\Debug list - ABZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - ending sequence / special stage
; ---------------------------------------------------------------------------
Debug_Ending:
	include "_inc\Debug list - Ending and SS.asm"

; ---------------------------------------------------------------------------
; Debug	list - Special Stage
; ---------------------------------------------------------------------------
Debug_SSZ:
	include "_inc\Debug list - SSZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - White Acropolis
; ---------------------------------------------------------------------------
Debug_WAZ:
	include "_inc\Debug list - WAZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Flame Core
; ---------------------------------------------------------------------------
Debug_FCZ:
	include "_inc\Debug list - FCZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Radical Train
; ---------------------------------------------------------------------------
Debug_RTZ:
	include "_inc\Debug list - RTZ.asm"

; ---------------------------------------------------------------------------
; Debug	list - Soleanna
; ---------------------------------------------------------------------------
Debug_SZ:
	include "_inc\Debug list - SZ.asm"

; ---------------------------------------------------------------------------
; Main level load blocks
; ---------------------------------------------------------------------------
MainLoadBlocks:
	include "_inc\Main level load blocks.asm"

; ---------------------------------------------------------------------------
; Pattern load cues
; ---------------------------------------------------------------------------
ArtLoadCues:
	include "_inc\Pattern load cues.asm"

Nem_SegaLogo:	incbin	artnem\segalogo.bin	; large Sega logo
		even
Eni_SegaLogo:	incbin	mapeni\segalogo.bin	; large Sega logo (mappings)
		even
Nem_TitleFg:	incbin	artnem\titlefor.bin	; title screen foreground
		even
Nem_Title:	incbin	artnem\title.bin	; Sonic on title screen
		even
Nem_TitleTM:	incbin	artnem\titletm.bin	; TM on title screen
		even
Options_Mappings:	incbin  'mapeni\options.bin'
		even
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic
; ---------------------------------------------------------------------------
Map_Sonic:
	include "_maps\Sonic.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Shadow
; ---------------------------------------------------------------------------
Map_Shadow:
	include "_maps\Shadow.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Silver
; ---------------------------------------------------------------------------
Map_Silver:
	include "_maps\Silver.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Tails
; ---------------------------------------------------------------------------
Map_Tails:
	include "_maps\Tails.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Tails' tails
; ---------------------------------------------------------------------------
Map_TailsTails:
	include "_maps\TailsTails.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Sonic
; ---------------------------------------------------------------------------
SonicDynPLC:
	include "_inc\Sonic dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Shadow
; ---------------------------------------------------------------------------
ShadowDynPLC:
	include "_inc\Shadow dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
SilverDynPLC:
	include "_inc\Silver dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
TailsDynPLC:
	include "_inc\Tails dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
TailsTailsDynPLC:
	include "_inc\Tails Tails dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Lightning Shield
; ---------------------------------------------------------------------------
LShieldDynPLC:
	include "_inc\Lightning Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Bubble Shield
; ---------------------------------------------------------------------------
BShieldDynPLC:
	include "_inc\Bubble Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Flame Shield
; ---------------------------------------------------------------------------
FShieldDynPLC:
	include "_inc\Flame Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Big Ring
; ---------------------------------------------------------------------------
SSRingDynPLC:
	include "_inc\SS Ring dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for rings
; ---------------------------------------------------------------------------
RingDynPLC:	
	include	"_inc\Ring DPLCs.asm"	; rings

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for rings
; ---------------------------------------------------------------------------
DDZBallDynPLC:	
	include	"_inc\DDZ Ball DPLC.asm"	; rings

; ---------------------------------------------------------------------------
; Uncompressed graphics	- Powerups
; ---------------------------------------------------------------------------
UnC_LightningShield:	incbin		artunc/shield.bin
		even
UnC_BubbleShield:	incbin		artunc/shieldbubble.bin
		even
UnC_FlameShield:	incbin		artunc/shieldflame.bin
		even
UnC_Stars:	incbin		artunc/stars.bin	; invincibility stars
		even
Art_Ring:	incbin	artunc\rings.bin	; rings
		even
Art_SonLives:	incbin	artunc\lifeiconson.bin	; life counter icon
		even
Art_ShaLives:	incbin	artunc\lifeiconsha.bin	; life counter icon
		even
Art_SilLives:	incbin	artunc\lifeiconsil.bin	; life counter icon
		even
; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
Nem_Smoke:	incbin	artnem\xxxsmoke.bin	; unused smoke
		even
Nem_CCZSparkle:	incbin	artnem\xxxstars.bin	; unused stars
		even
Nem_TJZSonic:	incbin	artnem\xxxTJZson.bin	; unused TJZ Sonic holding his breath
		even
Nem_UnkFire:	incbin	artnem\xxxfire.bin	; unused fireball
		even
Nem_Warp:	incbin	artnem\xxxflash.bin	; unused entry to special stage flash
		even
Nem_Goggle:	incbin	artnem\xxxgoggl.bin	; unused goggles
		even
Nem_Booster: 	incbin  artnem\booster.bin 	; speed booster
		even
; ---------------------------------------------------------------------------
; Sprite mappings - walls of the special stage
; ---------------------------------------------------------------------------
Map_SSWalls:
	include "_maps\SSwalls.asm"
; ---------------------------------------------------------------------------
; Compressed graphics - special stage
; ---------------------------------------------------------------------------
Nem_SSWalls:	incbin	artunc\sswalls.bin	; special stage walls
		even
Eni_SSBg:	incbin	mapeni\ssbg.bin	; special stage background (mappings)
		even
Nem_SSBg:	incbin	artnem\ssbg.bin	; special stage clouds background
		even
Eni_SSFg:	incbin	mapeni\ssfg.bin	; special stage foregrond (mappings)
		even
Nem_SSFg:	incbin	artnem\ssfg.bin	; special stage clouds foreground
		even
Nem_SSGOAL:	incbin	artnem\ssgoal.bin	; special stage GOAL block
		even
Nem_SSRBlock:	incbin	artnem\ssr.bin		; special stage R block
		even
Nem_SS1UpBlock:	incbin	artnem\ss1up.bin	; special stage 1UP block
		even
Nem_SSEmStars:	incbin	artnem\ssemstar.bin	; special stage stars from a collected emerald
		even
Nem_SSRedWhite:	incbin	artnem\ssredwhi.bin	; special stage red/white block
		even
Nem_SSZone1:	incbin	artnem\sszone1.bin	; special stage ZONE1 block
		even
Nem_SSZone2:	incbin	artnem\sszone2.bin	; ZONE2 block
		even
Nem_SSZone3:	incbin	artnem\sszone3.bin	; ZONE3 block
		even
Nem_SSZone4:	incbin	artnem\sszone4.bin	; ZONE4 block
		even
Nem_SSZone5:	incbin	artnem\sszone5.bin	; ZONE5 block
		even
Nem_SSZone6:	incbin	artnem\sszone6.bin	; ZONE6 block
		even
Nem_SSUpDown:	incbin	artnem\ssupdown.bin	; special stage UP/DOWN block
		even
Nem_SSEmerald:	incbin	artnem\ssemeral.bin	; special stage chaos emeralds
		even
Nem_SSGhost:	incbin	artnem\ssghost.bin	; special stage ghost block
		even
Nem_SSWBlock:	incbin	artnem\ssw.bin		; special stage W block
		even
Nem_SSGlass:	incbin	artnem\ssglass.bin	; special stage destroyable glass block
		even
Nem_ResultEm:	incbin	artnem\ssresems.bin	; chaos emeralds on special stage results screen
		even
; ---------------------------------------------------------------------------
; Compressed graphics - WOZ stuff
; ---------------------------------------------------------------------------
Nem_Stalk:	incbin	artnem\WOZstalk.bin	; WOZ flower stalk
		even
Nem_Swing:	incbin	artnem\WOZswing.bin	; WOZ swinging platform
		even
Nem_Bridge:	incbin	artnem\WOZbridg.bin	; WOZ bridge
		even
Nem_WOZUnkBlock:incbin	artnem\xxxWOZbl.bin	; unused WOZ block
		even
Nem_Spikes:	incbin	artnem\spikes.bin	; spikes
		even
Nem_WOZLog:	incbin	artnem\xxxWOZlo.bin	; unused WOZ log
		even
Nem_SpikePole:	incbin	artnem\WOZlog.bin	; WOZ spiked log
		even
Nem_PplRock:	incbin	artnem\WOZrock.bin	; WOZ purple rock
		even
Nem_WOZWall1:	incbin	artnem\WOZwall1.bin	; WOZ destroyable wall
		even
Nem_WOZWall2:	incbin	artnem\WOZwall2.bin	; WOZ normal wall
		even
Nem_WOZDoor:	incbin	artnem\WOZdoor.bin	; WOZ small vertical door
		even
Nem_Waterfall:	incbin	artnem\WOZwaterfall.bin	; WOZ waterfall
		even
Nem_Lift:	incbin	artnem\WOZlift.bin	; WOZ lift
		even
Nem_Carrier:	incbin	artnem\WOZeggcarrier.bin	; WOZ background ship
		even
Nem_WOZPlatform:	incbin	artnem\WOZptfm.bin	; WOZ platform
		even
; ---------------------------------------------------------------------------
; Compressed graphics - TJZ stuff
; ---------------------------------------------------------------------------
Nem_Water:	incbin	artnem\TJZwater.bin	; TJZ water surface
Nem_Splash:	incbin	artnem\TJZsplash.bin	; TJZ waterfalls and splashes
		even
Nem_TJZSpikeBall:incbin	artnem\TJZspball.bin	; TJZ spiked ball on chain
		even
Nem_FlapDoor:	incbin	artnem\TJZflapdo.bin	; TJZ flapping door
		even
Nem_Bubbles:	incbin	artnem\TJZbubble.bin	; TJZ bubbles and countdown numbers
		even
Nem_TJZBlock3:	incbin	artnem\TJZblock3.bin	; TJZ 32x16 block
		even
Nem_TJZDoor1:	incbin	artnem\TJZvdoor.bin	; TJZ vertical door
		even
Nem_Harpoon:	incbin	artnem\TJZharpoo.bin	; TJZ harpoon
		even
Nem_TJZPole:	incbin	artnem\TJZpole.bin	; TJZ pole that breaks
		even
Nem_TJZDoor2:	incbin	artnem\TJZhdoor.bin	; TJZ large horizontal door
		even
Nem_TJZWheel:	incbin	artnem\TJZwheel.bin	; TJZ wheel from corner of conveyor belt
		even
Nem_Gargoyle:	incbin	artnem\TJZgargoy.bin	; TJZ gargoyle head and spitting fire
		even
Nem_TJZBlock2:	incbin	artnem\TJZblock2.bin	; TJZ blocks
		even
Nem_TJZPlatfm:	incbin	artnem\TJZptform.bin	; TJZ rising platforms
		even
Nem_Cork:	incbin	artnem\TJZcork.bin	; TJZ cork block
		even
Nem_TJZBlock1:	incbin	artnem\TJZblock1.bin	; TJZ 32x32 block
		even
; ---------------------------------------------------------------------------
; Compressed graphics - DDZ stuff
; ---------------------------------------------------------------------------
Nem_DDZMetal:	incbin	artnem\DDZmetal.bin	; DDZ metal blocks
		even
Nem_DDZSwitch:	incbin	artnem\DDZswitch.bin	; DDZ switch
		even
Nem_DDZGlass:	incbin	artnem\DDZglassy.bin	; DDZ green glassy block
		even
Nem_WOZGrass:	incbin	artnem\xxxgrass.bin	; unused grass (WOZ or DDZ?)
		even
Nem_DDZFire:	incbin	artnem\DDZfire.bin	; DDZ fireballs
		even
Nem_Lava:	incbin	artnem\DDZlava.bin	; DDZ lava
		even
Nem_DDZBlock:	incbin	artnem\DDZblock.bin	; DDZ green pushable block
		even
Nem_DDZUnkBlock:	incbin	artnem\xxxDDZblo.bin	; DDZ unused background block
		even
; ---------------------------------------------------------------------------
; Compressed graphics - KVZ stuff
; ---------------------------------------------------------------------------
Nem_Seesaw:	incbin	artnem\KVZseesa.bin	; KVZ seesaw
		even
Nem_KVZSpike:	incbin	artnem\KVZspike.bin	; KVZ spikeball that sits on a seesaw
		even
Nem_Fan:	incbin	artnem\KVZfan.bin	; KVZ fan
		even
Nem_KVZWall:	incbin	artnem\KVZwall.bin	; KVZ smashable wall
		even
Nem_Pylon:	incbin	artnem\KVZpylon.bin	; KVZ foreground pylon
		even
Nem_KVZSwing:	incbin	artnem\KVZswing.bin	; KVZ swinging platform
		even
Nem_KVZBlock:	incbin	artnem\KVZblock.bin	; KVZ 32x32 block
		even
Nem_KVZCannon:	incbin	artnem\KVZcanno.bin	; KVZ fireball launcher cannon
		even
; ---------------------------------------------------------------------------
; Compressed graphics - CCZ stuff
; ---------------------------------------------------------------------------
Nem_Bumper:	incbin	artnem\CCZbumpe.bin	; CCZ bumper
		even
Nem_CCZSpike2:	incbin	artnem\CCZsspik.bin	; CCZ small spikeball
		even
Nem_TJZSwitch:	incbin	artnem\switch.bin	; TJZ/CCZ/ABZ switch
		even
Nem_CCZSpike1:	incbin	artnem\CCZlspik.bin	; CCZ/ABZ large spikeball
		even
; ---------------------------------------------------------------------------
; Compressed graphics - ABZ stuff
; ---------------------------------------------------------------------------
Nem_ABZWheel1:	incbin	artnem\ABZwhee1.bin	; ABZ spot on rotating wheel that Sonic runs around
		even
Nem_ABZWheel2:	incbin	artnem\ABZwhee2.bin	; ABZ wheel that grabs Sonic
		even
Nem_Cutter:	incbin	artnem\ABZcutte.bin	; ABZ pizza cutter
		even
Nem_Stomper:	incbin	artnem\ABZstomp.bin	; ABZ stomper
		even
Nem_ABZPform:	incbin	artnem\ABZpform.bin	; ABZ spinning platform
		even
Nem_TrapDoor:	incbin	artnem\ABZtrapd.bin	; ABZ trapdoor
		even
Nem_ABZFloor:	incbin	artnem\ABZfloor.bin	; ABZ collapsing floor
		even
Nem_Electric:	incbin	artnem\ABZshock.bin	; ABZ electric shock orb
		even
Nem_ABZBlock:	incbin	artnem\ABZvanis.bin	; ABZ vanishing block
		even
Nem_FlamePipe:	incbin	artnem\ABZflame.bin	; ABZ flaming pipe
		even
Nem_ABZDoor1:	incbin	artnem\ABZvdoor.bin	; ABZ small vertical door
		even
Nem_SlideFloor:	incbin	artnem\ABZslide.bin	; ABZ floor that slides away
		even
Nem_ABZDoor2:	incbin	artnem\ABZhdoor.bin	; ABZ large horizontal door
		even
Nem_Girder:	incbin	artnem\ABZgirde.bin	; ABZ crushing girder
		even
; ---------------------------------------------------------------------------
; Compressed graphics - enemies
; ---------------------------------------------------------------------------
Nem_BallHog:	incbin	artnem\ballhog.bin	; ball hog
		even
Nem_Crabmeat:	incbin	artnem\crabmeat.bin	; crabmeat
		even
Nem_WOZCopter:	incbin	artnem\WOZcopter.bin	; copter
		even
Nem_Buzz:	incbin	artnem\buzzbomb.bin	; buzz bomber
		even
Nem_CCZBuzz:	incbin	artnem\CCZbuzzbomb.bin	; CCZ buzz bomber
		even
Nem_UnkExplode:	incbin	artnem\xxxexplo.bin	; unused explosion
		even
Nem_Burrobot:	incbin	artnem\burrobot.bin	; burrobot
		even
Nem_Chopper:	incbin	artnem\chopper.bin	; chopper
		even
Nem_Jaws:	incbin	artnem\jaws.bin		; jaws
		even
Nem_Roller:	incbin	artnem\roller.bin	; roller
		even
Nem_Motobug:	incbin	artnem\motobug.bin	; moto bug
		even
Nem_Newtron:	incbin	artnem\newtron.bin	; newtron
		even
Nem_Yadrin:	incbin	artnem\yadrin.bin	; yadrin
		even
Nem_Basaran:	incbin	artnem\basaran.bin	; basaran
		even
Nem_Splats:	incbin	artnem\splats.bin	; splats
		even
Nem_Bomb:	incbin	artnem\bomb.bin		; bomb
		even
Nem_Orbinaut:	incbin	artnem\orbinaut.bin	; orbinaut
		even
Nem_Cater:	incbin	artnem\caterkil.bin	; caterkiller
		even
Nem_Coconuts:	incbin	artnem\coconuts.bin	; moto bug
		even
; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
Nem_TitleCard:	incbin	artnem\ttlcards.bin	; title cards
		even
Nem_Hud:	incbin	artnem\hud.bin		; HUD (rings, time, score)
		even
Nem_Ring:	incbin	artnem\rings.bin	; rings
		even
Nem_Monitors:	incbin	artnem\monitors.bin	; monitors
		even
Nem_Explode:	incbin	artnem\explosio.bin	; explosion
		even
Nem_Points:	incbin	artnem\points.bin	; points from destroyed enemy or object
		even
Nem_GameOver:	incbin	artnem\gameover.bin	; game over / time over
		even
Nem_HSpring:	incbin	artnem\springh.bin	; horizontal spring
		even
Nem_VSpring:	incbin	artnem\springv.bin	; vertical spring
		even
Nem_DSpring:	incbin	artnem\springd.bin	; diagonal spring
		even
Nem_SignPost:	incbin	artnem\signpost.bin	; end of level signpost
		even
Nem_Lamp:	incbin	artnem\lamppost.bin	; lamppost
		even
Nem_BigFlash:	incbin	artnem\rngflash.bin	; flash from giant ring
		even
Nem_Bonus:	incbin	artnem\bonus.bin	; hidden bonuses at end of a level
		even
; ---------------------------------------------------------------------------
; Compressed graphics - continue screen
; ---------------------------------------------------------------------------
Nem_ContSonic:	incbin	artnem\cntsonic.bin	; Sonic on continue screen
		even
Nem_MiniSonic:	incbin	artnem\cntother.bin	; mini Sonic and text on continue screen
		even
; ---------------------------------------------------------------------------
; Compressed graphics - animals
; ---------------------------------------------------------------------------
Nem_Rabbit:	incbin	artnem\rabbit.bin	; rabbit
		even
Nem_Chicken:	incbin	artnem\chicken.bin	; chicken
		even
Nem_BlackBird:	incbin	artnem\blackbrd.bin	; blackbird
		even
Nem_Seal:	incbin	artnem\seal.bin		; seal
		even
Nem_Pig:	incbin	artnem\pig.bin		; pig
		even
Nem_Flicky:	incbin	artnem\flicky.bin	; flicky
		even
Nem_Squirrel:	incbin	artnem\squirrel.bin	; squirrel
		even
Nem_Fish:	incbin	artnem\fish.bin	; fish
		even
; ---------------------------------------------------------------------------
; Compressed graphics - primary patterns and block mappings
; ---------------------------------------------------------------------------

Nem_TIT:	incbin	artnem\8x8tit1.bin	; Title primary patterns
		even
Blk16_TIT:	incbin	map16\title.bin
		even
Blk256_TIT:	incbin	map256\title.bin
		even
Blk16_WOZ:	incbin	map16\WOZ.bin
		even
Kos_WOZ:	incbin	artkos\8x8WOZ.bin	; WOZ primary patterns
		even
Blk256_WOZ:	incbin	map256\WOZ.bin
		even
Blk16_TJZ:	incbin	map16\TJZ.bin
		even
Kos_TJZ:		incbin	artkos\8x8TJZ.bin	; TJZ primary patterns
		even
Blk256_TJZ:	incbin	map256\TJZ.bin
		even
Blk16_DDZ:	incbin	map16\DDZ.bin
		even
Kos_DDZ:		incbin	artkos\8x8DDZ.bin	; DDZ primary patterns
		even
Blk256_DDZ:	incbin	map256\DDZ.bin
		even
Blk16_KVZ:	incbin	map16\KVZ.bin
		even
Kos_KVZ:	incbin	artkos\8x8KVZ.bin	; KVZ primary patterns
		even
Blk256_KVZ:	incbin	map256\KVZ.bin
		even
Blk16_CCZ:	incbin	map16\CCZ.bin
		even
Kos_CCZ:	incbin	artkos\8x8CCZ.bin	; CCZ primary patterns
		even
Blk256_CCZ:	incbin	map256\CCZ.bin
		even
Blk16_ABZ:	incbin	map16\ABZ.bin
		even
Kos_ABZ:	incbin	artkos\8x8ABZ.bin	; ABZ primary patterns
		even
Blk256_ABZ:	incbin	map256\ABZ.bin
		even
Blk16_SSZ:	incbin	map16\ssz.bin
		even
Kos_SSZ:	incbin	artkos\8x8ssz.bin	; SSZ primary patterns
		even
Blk256_SSZ:	incbin	map256\ssz.bin
		even
Blk16_WAZ:	incbin	map16\waz.bin
		even
Kos_WAZ:	incbin	artkos\8x8waz.bin	; WAZ primary patterns
		even
Blk256_WAZ:	incbin	map256\waz.bin
		even
Blk16_FCZ:	incbin	map16\fcz.bin
		even
Kos_FCZ:	incbin	artkos\8x8fcz.bin	; FCZ primary patterns
		even
Blk256_FCZ:	incbin	map256\fcz.bin
		even
Blk16_RTZ:	incbin	map16\rtz.bin
		even
Kos_RTZ:	incbin	artkos\8x8rtz.bin	; RTZ primary patterns
		even
Blk256_RTZ:	incbin	map256\rtz.bin
		even
Blk16_SZ:	incbin	map16\sz.bin
		even
Kos_SZ:	incbin	artkos\8x8sz.bin	; SZ primary patterns
		even
Blk256_SZ:	incbin	map256\sz.bin
		even
Nem_Card1:	incbin	artnem\waveoceancard.bin	; ABZ primary patterns
		even
; ---------------------------------------------------------------------------
; Compressed graphics - bosses and ending sequence
; ---------------------------------------------------------------------------
Nem_Eggman:	incbin	artnem\bossmain.bin	; boss main patterns
		even
Nem_Weapons:	incbin	artnem\bossxtra.bin	; boss add-ons and weapons
		even
Nem_Prison:	incbin	artnem\prison.bin	; prison capsule
		even
Nem_ABZ2Eggman:	incbin	artnem\ABZ2boss.bin	; Eggman in ABZ2 and FZ
		even
Nem_FzBoss:	incbin	artnem\fzboss.bin	; FZ boss
		even
Nem_FzEggman:	incbin	artnem\fzboss2.bin	; Eggman after the FZ boss
		even
Nem_Exhaust:	incbin	artnem\bossflam.bin	; boss exhaust flame
		even
Nem_EndEm:	incbin	artnem\endemera.bin	; ending sequence chaos emeralds
		even
Nem_EndSonic:	incbin	artnem\endsonic.bin	; ending sequence Sonic
		even
Nem_TryAgain:	incbin	artnem\tryagain.bin	; ending "try again" screen
		even
Nem_EndEggman:	incbin	artnem\xxxend.bin	; unused boss sequence on ending
		even
Kos_EndFlowers:	incbin	artkos\flowers.bin	; ending sequence animated flowers
		even
Nem_EndFlower:	incbin	artnem\endflowe.bin	; ending sequence flowers
		even
Nem_CreditText:	incbin	artnem\credits.bin	; credits alphabet
		even
Nem_EndStH:	incbin	artnem\endtext.bin	; ending sequence "Sonic the Hedgehog" text
		even
; ---------------------------------------------------------------------------
; Collision data
; ---------------------------------------------------------------------------
AngleMap:	incbin	collide\anglemap.bin	; floor angle map
		even
AngleMap3K:	incbin	collide\anglemap3K.bin	; Sonic 3K's floor angle map
		even
AngleMap2:	incbin	collide\anglemap2.bin	; Sonic 2's floor angle map
		even
AngleMapCD:	incbin	collide\anglemapCD.bin	; Sonic CD's floor angle map
		even
CollArray1:	incbin	collide\carray_n.bin	; normal collision array
		even
CollArray2:	incbin	collide\carray_r.bin	; rotated collision array
		even
CollArray3K1:	incbin	collide\carray3K_n.bin	; normal collision array
		even
CollArray3K2:	incbin	collide\carray3K_r.bin	; rotated collision array
		even
CollArray21:	incbin	collide\carray2_n.bin	; normal collision array
		even
CollArray22:	incbin	collide\carray2_r.bin	; rotated collision array
		even
CollArrayCD1:	incbin	collide\carrayCD_n.bin	; normal collision array
		even
CollArrayCD2:	incbin	collide\carrayCD_r.bin	; rotated collision array
		even
Col_WOZ_1:	incbin	collide\WOZ1.bin	; WOZ index 1
		even
Col_WOZ_2:	incbin	collide\WOZ2.bin	; WOZ index 2
		even
Col_TJZ_1:	incbin	collide\TJZ1.bin		; TJZ index 1
		even
Col_TJZ_2:	incbin	collide\TJZ2.bin		; TJZ index 2
		even
Col_DDZ_1:	incbin	collide\DDZ1.bin		; DDZ index 1
		even
Col_DDZ_2:	incbin	collide\DDZ2.bin		; DDZ index 2
		even
Col_KVZ_1:	incbin	collide\KVZ1.bin	; KVZ index 1
		even
Col_KVZ_2:	incbin	collide\KVZ2.bin	; KVZ index 2
		even
Col_CCZ_1:	incbin	collide\CCZ1.bin	; CCZ index 1
		even
Col_CCZ_2:	incbin	collide\CCZ2.bin	; CCZ index 2
		even
Col_ABZ_1:	incbin	collide\ABZ1.bin	; ABZ index 1
		even
Col_ABZ_2:	incbin	collide\ABZ2.bin	; ABZ index 2
		even
Col_END_1:	incbin	collide\end1.bin	; Ending index 1
		even
Col_END_2:	incbin	collide\end2.bin	; Ending index 2
		even
Col_SSZ_1:	incbin	collide\SSZ1.bin	; SSZ index 1
		even
Col_SSZ_2:	incbin	collide\SSZ2.bin	; SSZ index 2
		even
Col_WAZ_1:	incbin	collide\WAZ1.bin	; WAZ index 1
		even
Col_WAZ_2:	incbin	collide\WAZ2.bin	; WAZ index 2
		even
Col_FCZ_1:	incbin	collide\FCZ1.bin	; FCZ index 1
		even
Col_FCZ_2:	incbin	collide\FCZ2.bin	; FCZ index 2
		even
Col_RTZ_1:	incbin	collide\RTZ1.bin	; RTZ index 1
		even
Col_RTZ_2:	incbin	collide\RTZ2.bin	; RTZ index 2
		even
Col_SZ_1:	incbin	collide\SZ1.bin	; SZ index 1
		even
Col_SZ_2:	incbin	collide\SZ2.bin	; SZ index 2
		even
; ---------------------------------------------------------------------------
; Special layouts
; ---------------------------------------------------------------------------
SS_1:		incbin	sslayout\1.bin
		even
SS_2:		incbin	sslayout\2.bin
		even
SS_3:		incbin	sslayout\3.bin
		even
SS_4:		incbin	sslayout\4.bin
		even
SS_5:		incbin	sslayout\5.bin
		even
SS_6:		incbin	sslayout\6.bin
		even
; ---------------------------------------------------------------------------
; Animated uncompressed graphics
; ---------------------------------------------------------------------------
Art_WOZTorch:	incbin 	artunc\WOZtorch.bin ; WOZ torch background
		even
Art_KVZFlower:	incbin	artunc\KVZflower.bin	; ABZ water in background
		even

; ---------------------------------------------------------------------------
; Level	layout index
; ---------------------------------------------------------------------------
Level_Index:	dc.l Level_WOZ1, byte_68F88, byte_68F88	; MJ: Table needs to be read in long-word as the layouts are now bigger
		dc.l Level_WOZ2, byte_68F88, byte_68F88
		dc.l Level_WOZ3, byte_68F88, byte_68F88
		dc.l Level_WOZ4, byte_68F88, byte_68F88
		dc.l Level_TJZ1, byte_68F88, byte_68F88
		dc.l Level_TJZ2, byte_68F88, byte_68F88
		dc.l Level_TJZ3, byte_68F88, byte_68F88
		dc.l Level_TJZ4, byte_68F88, byte_68F88
		dc.l Level_DDZ1, byte_68F88, byte_68F88
		dc.l Level_DDZ2, byte_68F88, byte_68F88
		dc.l Level_DDZ3, byte_68F88, byte_68F88
		dc.l Level_DDZ4, byte_68F88, byte_68F88
		dc.l Level_KVZ1, byte_68F88, byte_68F88
		dc.l Level_KVZ2, byte_68F88, byte_68F88
		dc.l Level_KVZ3, byte_68F88, byte_68F88
		dc.l Level_KVZ4, byte_68F88, byte_68F88
		dc.l Level_CCZ1, byte_68F88, byte_68F88
		dc.l Level_CCZ2, byte_68F88, byte_68F88
		dc.l Level_CCZ3, byte_68F88, byte_68F88
		dc.l Level_CCZ4, byte_68F88, byte_68F88
		dc.l Level_ABZ1, byte_68F88, byte_68F88
		dc.l Level_ABZ2, byte_68F88, byte_68F88
		dc.l Level_ABZ3, byte_68F88, byte_68F88
		dc.l Level_ABZ4, byte_68F88, byte_68F88
		dc.l Level_End, byte_68F88, byte_68F88
		dc.l Level_End, byte_68F88, byte_68F88
		dc.l byte_68F88, byte_68F88, byte_68F88
		dc.l byte_68F88, byte_68F88, byte_68F88
		dc.l Level_SSZ1, byte_68F88, byte_68F88
		dc.l Level_SSZ2, byte_68F88, byte_68F88
		dc.l Level_SSZ3, byte_68F88, byte_68F88
		dc.l Level_SSZ4, byte_68F88, byte_68F88
		dc.l Level_WAZ1, byte_68F88, byte_68F88
		dc.l Level_WAZ2, byte_68F88, byte_68F88
		dc.l Level_WAZ3, byte_68F88, byte_68F88
		dc.l Level_WAZ4, byte_68F88, byte_68F88
		dc.l Level_FCZ1, byte_68F88, byte_68F88
		dc.l Level_FCZ2, byte_68F88, byte_68F88
		dc.l Level_FCZ3, byte_68F88, byte_68F88
		dc.l Level_FCZ4, byte_68F88, byte_68F88
		dc.l Level_RTZ1, byte_68F88, byte_68F88
		dc.l Level_RTZ2, byte_68F88, byte_68F88
		dc.l Level_RTZ3, byte_68F88, byte_68F88
		dc.l Level_RTZ4, byte_68F88, byte_68F88
		dc.l Level_SZ1, byte_68F88, byte_68F88
		dc.l Level_SZ2, byte_68F88, byte_68F88
		dc.l Level_SZ3, byte_68F88, byte_68F88
		dc.l Level_SZ4, byte_68F88, byte_68F88

Title_Index:	dc.l Level_TIT, byte_68F88, byte_68F88

Level_TIT:	incbin	levels\title.bin
		even
Level_WOZ1:	incbin	levels\WOZ1.bin
		even
Level_WOZ2:	incbin	levels\WOZ2.bin
		even
Level_WOZ3:	incbin	levels\WOZ3.bin
		even
Level_WOZ4:	incbin	levels\WOZ3.bin
		even

Level_TJZ1:	incbin	levels\TJZ1.bin
		even
Level_TJZ2:	incbin	levels\TJZ2.bin
		even
Level_TJZ3:	incbin	levels\TJZ3.bin
		even
Level_TJZ4:	incbin	levels\TJZ4.bin
		even

Level_DDZ1:	incbin	levels\DDZ1.bin
		even
Level_DDZ2:	incbin	levels\DDZ2.bin
		even
Level_DDZ3:	incbin	levels\DDZ3.bin
		even
Level_DDZ4:	incbin	levels\DDZ4.bin
		even

Level_KVZ1:	incbin	levels\KVZ1.bin
		even
Level_KVZ2:	incbin	levels\KVZ2.bin
		even
Level_KVZ3:	incbin	levels\KVZ3.bin
		even
Level_KVZ4:	incbin	levels\KVZ4.bin
		even

Level_CCZ1:	incbin	levels\CCZ1.bin
		even
Level_CCZ2:	incbin	levels\CCZ2.bin
		even
Level_CCZ3:	incbin	levels\CCZ3.bin
		even
Level_CCZ4:	incbin	levels\CCZ4.bin
		even

Level_ABZ1:	incbin	levels\ABZ1.bin
		even
Level_ABZ2:	incbin	levels\ABZ2.bin
		even
Level_ABZ3:	incbin	levels\ABZ3.bin
		even
Level_ABZ4:	incbin	levels\ABZ4.bin
		even
Level_End:	incbin	levels\ending.bin
		even

Level_SSZ1:	incbin	levels\ssz1.bin
		even
Level_SSZ2:	incbin	levels\ssz2.bin
		even
Level_SSZ3:	incbin	levels\ssz3.bin
		even
Level_SSZ4:	incbin	levels\ssz4.bin
		even

Level_WAZ1:	incbin	levels\waz1.bin
		even
Level_WAZ2:	incbin	levels\waz2.bin
		even
Level_WAZ3:	incbin	levels\waz3.bin
		even
Level_WAZ4:	incbin	levels\waz4.bin
		even

Level_FCZ1:	incbin	levels\fcz1.bin
		even
Level_FCZ2:	incbin	levels\fcz2.bin
		even
Level_FCZ3:	incbin	levels\fcz3.bin
		even
Level_FCZ4:	incbin	levels\fcz4.bin
		even

Level_RTZ1:	incbin	levels\rtz1.bin
		even
Level_RTZ2:	incbin	levels\rtz2.bin
		even
Level_RTZ3:	incbin	levels\rtz3.bin
		even
Level_RTZ4:	incbin	levels\rtz4.bin
		even

Level_SZ1:	incbin	levels\sz1.bin
		even
Level_SZ2:	incbin	levels\sz2.bin
		even
Level_SZ3:	incbin	levels\sz3.bin
		even
Level_SZ4:	incbin	levels\sz4.bin
		even
byte_68F88:	dc.b 0,	0, 0, 0

; ---------------------------------------------------------------------------
; Animated uncompressed giant ring graphics
; ---------------------------------------------------------------------------
Art_BigRing:	incbin	artunc\bigring.bin
		even

; ---------------------------------------------------------------------------
; Ring locations index
; ---------------------------------------------------------------------------
RingPos_Index:	dc.w RingPos_WOZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WOZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WOZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WOZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_TJZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_TJZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_TJZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_TJZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_KVZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_KVZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_KVZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_KVZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_ABZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_ABZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_ABZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_ABZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_End-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_End-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_End-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_End-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WAZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_wAZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WAZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_WAZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FCZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FCZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FCZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FCZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_RTZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_RTZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_RTZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_RTZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SZ4-RingPos_Index, RingPos_Null-RingPos_Index
RingPos_WOZ1:	incbin	rings\WOZ1_INDIVIDUAL.bin
		even
RingPos_WOZ2:	incbin	rings\WOZ2_INDIVIDUAL.bin
		even
RingPos_WOZ3:	incbin	rings\WOZ3_INDIVIDUAL.bin
		even
RingPos_WOZ4:	incbin	rings\WOZ4_INDIVIDUAL.bin
		even
RingPos_TJZ1:	incbin	rings\TJZ1_INDIVIDUAL.bin
		even
RingPos_TJZ2:	incbin	rings\TJZ2_INDIVIDUAL.bin
		even
RingPos_TJZ3:	incbin	rings\TJZ3_INDIVIDUAL.bin
		even
RingPos_TJZ4:	incbin	rings\TJZ4_INDIVIDUAL.bin
		even
RingPos_DDZ1:	incbin	rings\DDZ1_INDIVIDUAL.bin
		even
RingPos_DDZ2:	incbin	rings\DDZ2_INDIVIDUAL.bin
		even
RingPos_DDZ3:	incbin	rings\DDZ3_INDIVIDUAL.bin
		even
RingPos_DDZ4:	incbin	rings\DDZ4_INDIVIDUAL.bin
		even
RingPos_KVZ1:	incbin	rings\KVZ1_INDIVIDUAL.bin
		even
RingPos_KVZ2:	incbin	rings\KVZ2_INDIVIDUAL.bin
		even
RingPos_KVZ3:	incbin	rings\KVZ3_INDIVIDUAL.bin
		even
RingPos_KVZ4:	incbin	rings\KVZ4_INDIVIDUAL.bin
		even
RingPos_CCZ1:	incbin	rings\CCZ1_INDIVIDUAL.bin
		even
RingPos_CCZ2:	incbin	rings\CCZ2_INDIVIDUAL.bin
		even
RingPos_CCZ3:	incbin	rings\CCZ3_INDIVIDUAL.bin
		even
RingPos_CCZ4:	incbin	rings\CCZ4_INDIVIDUAL.bin
		even
RingPos_ABZ1:	incbin	rings\ABZ1_INDIVIDUAL.bin
		even
RingPos_ABZ2:	incbin	rings\ABZ2_INDIVIDUAL.bin
		even
RingPos_ABZ3:	incbin	rings\ABZ3_INDIVIDUAL.bin
		even
RingPos_ABZ4:	incbin	rings\ABZ4_INDIVIDUAL.bin
		even
RingPos_End:	incbin	rings\ending.bin
		even
RingPos_SSZ1:	incbin	rings\SSZ1_INDIVIDUAL.bin
		even
RingPos_SSZ2:	incbin	rings\SSZ2_INDIVIDUAL.bin
		even
RingPos_SSZ3:	incbin	rings\SSZ3_INDIVIDUAL.bin
		even
RingPos_SSZ4:	incbin	rings\SSZ4_INDIVIDUAL.bin
		even
RingPos_WAZ1:	incbin	rings\WAZ1_INDIVIDUAL.bin
		even
RingPos_WAZ2:	incbin	rings\WAZ2_INDIVIDUAL.bin
		even
RingPos_WAZ3:	incbin	rings\WAZ3_INDIVIDUAL.bin
		even
RingPos_WAZ4:	incbin	rings\WAZ4_INDIVIDUAL.bin
		even
RingPos_FCZ1:	incbin	rings\FCZ1_INDIVIDUAL.bin
		even
RingPos_FCZ2:	incbin	rings\FCZ2_INDIVIDUAL.bin
		even
RingPos_FCZ3:	incbin	rings\FCZ3_INDIVIDUAL.bin
		even
RingPos_FCZ4:	incbin	rings\FCZ4_INDIVIDUAL.bin
		even
RingPos_RTZ1:	incbin	rings\RTZ1_INDIVIDUAL.bin
		even
RingPos_RTZ2:	incbin	rings\RTZ2_INDIVIDUAL.bin
		even
RingPos_RTZ3:	incbin	rings\RTZ3_INDIVIDUAL.bin
		even
RingPos_RTZ4:	incbin	rings\RTZ4_INDIVIDUAL.bin
		even
RingPos_SZ1:	incbin	rings\SZ1_INDIVIDUAL.bin
		even
RingPos_SZ2:	incbin	rings\SZ2_INDIVIDUAL.bin
		even
RingPos_SZ3:	incbin	rings\SZ3_INDIVIDUAL.bin
		even
RingPos_SZ4:	incbin	rings\SZ4_INDIVIDUAL.bin
		even
RingPos_Null:	dc.b $FF, $FF, 0, 0

; ---------------------------------------------------------------------------
; Sprite locations index
; ---------------------------------------------------------------------------
ObjPos_Index:	dc.w ObjPos_WOZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WOZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WOZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WOZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_TJZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_TJZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_TJZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_TJZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_KVZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_KVZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_KVZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_KVZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_ABZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_ABZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_ABZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_ABZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WAZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WAZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WAZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_WAZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FCZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FCZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FCZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FCZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_RTZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_RTZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_RTZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_RTZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index

ObjPos_TJZxpf_Index:
		dc.w ObjPos_TJZ1pf1-ObjPos_Index, ObjPos_TJZ1pf2-ObjPos_Index
		dc.w ObjPos_TJZ2pf1-ObjPos_Index, ObjPos_TJZ2pf2-ObjPos_Index
		dc.w ObjPos_TJZ3pf1-ObjPos_Index, ObjPos_TJZ3pf2-ObjPos_Index
		dc.w ObjPos_TJZ1pf1-ObjPos_Index, ObjPos_TJZ1pf2-ObjPos_Index

ObjPos_ABZ1pf_Index:
		dc.w ObjPos_ABZ1pf1-ObjPos_Index, ObjPos_ABZ1pf2-ObjPos_Index
		dc.w ObjPos_ABZ1pf3-ObjPos_Index, ObjPos_ABZ1pf4-ObjPos_Index
		dc.w ObjPos_ABZ1pf5-ObjPos_Index, ObjPos_ABZ1pf6-ObjPos_Index
		dc.w ObjPos_ABZ1pf1-ObjPos_Index, ObjPos_ABZ1pf2-ObjPos_Index
		dc.b $FF, $FF, 0, 0, 0,	0
ObjPos_WOZ1:	incbin	objpos\WOZ1.bin
		even
ObjPos_WOZ2:	incbin	objpos\WOZ2.bin
		even
ObjPos_WOZ3:	incbin	objpos\WOZ3.bin
		even
ObjPos_WOZ4:	incbin	objpos\WOZ4.bin
		even
ObjPos_TJZ1:	incbin	objpos\TJZ1.bin
		even
ObjPos_TJZ2:	incbin	objpos\TJZ2.bin
		even
ObjPos_TJZ3:	incbin	objpos\TJZ3.bin
		even
ObjPos_TJZ4:	incbin	objpos\TJZ4.bin
		even
ObjPos_TJZ1pf1:	incbin	objpos\TJZ1pf1.bin
		even
ObjPos_TJZ1pf2:	incbin	objpos\TJZ1pf2.bin
		even
ObjPos_TJZ2pf1:	incbin	objpos\TJZ2pf1.bin
		even
ObjPos_TJZ2pf2:	incbin	objpos\TJZ2pf2.bin
		even
ObjPos_TJZ3pf1:	incbin	objpos\TJZ3pf1.bin
		even
ObjPos_TJZ3pf2:	incbin	objpos\TJZ3pf2.bin
		even
ObjPos_DDZ1:	incbin	objpos\DDZ1.bin
		even
ObjPos_DDZ2:	incbin	objpos\DDZ2.bin
		even
ObjPos_DDZ3:	incbin	objpos\DDZ3.bin
		even
ObjPos_DDZ4:	incbin	objpos\DDZ4.bin
		even
ObjPos_KVZ1:	incbin	objpos\KVZ1.bin
		even
ObjPos_KVZ2:	incbin	objpos\KVZ2.bin
		even
ObjPos_KVZ3:	incbin	objpos\KVZ3.bin
		even
ObjPos_KVZ4:	incbin	objpos\KVZ4.bin
		even
ObjPos_CCZ1:	incbin	objpos\CCZ1.bin
		even
ObjPos_CCZ2:	incbin	objpos\CCZ2.bin
		even
ObjPos_CCZ3:	incbin	objpos\CCZ3.bin
		even
ObjPos_CCZ4:	incbin	objpos\CCZ4.bin
		even
ObjPos_ABZ1:	incbin	objpos\ABZ1.bin
		even
ObjPos_ABZ2:	incbin	objpos\ABZ2.bin
		even
ObjPos_ABZ3:	incbin	objpos\ABZ3.bin
		even
ObjPos_ABZ4:	incbin	objpos\ABZ4.bin
		even
ObjPos_ABZ1pf1:	incbin	objpos\ABZ1pf1.bin
		even
ObjPos_ABZ1pf2:	incbin	objpos\ABZ1pf2.bin
		even
ObjPos_ABZ1pf3:	incbin	objpos\ABZ1pf3.bin
		even
ObjPos_ABZ1pf4:	incbin	objpos\ABZ1pf4.bin
		even
ObjPos_ABZ1pf5:	incbin	objpos\ABZ1pf5.bin
		even
ObjPos_ABZ1pf6:	incbin	objpos\ABZ1pf6.bin
		even
ObjPos_End:	incbin	objpos\ending.bin
		even
ObjPos_SSZ1:	incbin	objpos\SSZ1.bin
		even
ObjPos_SSZ2:	incbin	objpos\SSZ2.bin
		even
ObjPos_SSZ3:	incbin	objpos\SSZ3.bin
		even
ObjPos_SSZ4:	incbin	objpos\SSZ4.bin
		even
ObjPos_WAZ1:	incbin	objpos\WAZ1.bin
		even
ObjPos_WAZ2:	incbin	objpos\WAZ2.bin
		even
ObjPos_WAZ3:	incbin	objpos\WAZ3.bin
		even
ObjPos_WAZ4:	incbin	objpos\WAZ4.bin
		even
ObjPos_FCZ1:	incbin	objpos\FCZ1.bin
		even
ObjPos_FCZ2:	incbin	objpos\FCZ2.bin
		even
ObjPos_FCZ3:	incbin	objpos\FCZ3.bin
		even
ObjPos_FCZ4:	incbin	objpos\FCZ4.bin
		even
ObjPos_RTZ1:	incbin	objpos\RTZ1.bin
		even
ObjPos_RTZ2:	incbin	objpos\RTZ2.bin
		even
ObjPos_RTZ3:	incbin	objpos\RTZ3.bin
		even
ObjPos_RTZ4:	incbin	objpos\RTZ4.bin
		even
ObjPos_SZ1:	incbin	objpos\SZ1.bin
		even
ObjPos_SZ2:	incbin	objpos\SZ2.bin
		even
ObjPos_SZ3:	incbin	objpos\SZ3.bin
		even
ObjPos_SZ4:	incbin	objpos\SZ4.bin
		even
ObjPos_Null:	dc.b $FF, $FF, 0, 0, 0,	0                
                        
	include "LANG.ASM"
	include "smps2asm.ASM"

drv:
zbank:
Driver_Data:
	z80prog 0
	include "SMPS.ASM"
drvsz:
	z80prog
Driver_Data_End:                 

; ===========================================================================
; macro to create multiple pointers with macro below
Driver_Pointers:                
Z80PtrROMBank	macro addr
	rept narg
		dw ((\addr-z80BankAddr)&$7FFF)+$8000
		shift
	endr
    endm

; ===========================================================================
; declares start of a bank, and sets some variables
Z80Bank_Start	macro	name
	align $8000
z80BankAddr =	(*&$FF8000)
z80BankName 	equs \name
	obj $8000
    endm

; macro to do everything needed for end of bank.
; also warns if the bank overflows
Z80Bank_End	macro
	objend
	if *>z80BankAddr+$8000
		inform 1,"Z80 bank %s is too large! Its size is $%h, $%h bytes larger than max.", "\z80BankName", *-z80BankAddr, (*-z80BankAddr)-$8000
	else
		inform 0,"Z80 bank %s has $%h free bytes.", "\z80BankName", $8000-(*-z80BankAddr)
	endif
    endm
Driver_Pointers_End:

; ===========================================================================
; special macro for including a DAC. This not only includes the file,
; but also creates the length and pointer information for later use in DAC_Setup
incDAC		macro name, ext
DAC_\name\_Inc =	(*&$7FFF)+z80BankAddr
	incbin 'DAC/\name\.\ext'
DAC_\name\_Ptr = DAC_\name\_Inc&$7FFF|$8000
DAC_\name\_Len = *-DAC_\name\_Ptr
    endm

; ===========================================================================
; macro used to set up a DAC definition (pitch, length, pointer)
DAC_Setup macro rate, dacptr
	dc.b	\rate
	dw DAC_\dacptr\_Len, DAC_\dacptr\_Ptr
    endm

DACBank_Defs	macro	id
	Z80Bank_Start	"DAC0\id"
	dw DAC_81_Setup\id, DAC_82_Setup\id, DAC_83_Setup\id, DAC_84_Setup\id
	dw DAC_85_Setup\id, DAC_86_Setup\id, DAC_87_Setup\id, DAC_88_Setup\id
	dw DAC_89_Setup\id, DAC_8A_Setup\id, DAC_8B_Setup\id, DAC_8C_Setup\id
	dw DAC_8D_Setup\id, DAC_8E_Setup\id, DAC_8F_Setup\id

	dw DAC_90_Setup\id, DAC_91_Setup\id, DAC_92_Setup\id, DAC_93_Setup\id
	dw DAC_94_Setup\id, DAC_95_Setup\id, DAC_96_Setup\id, DAC_97_Setup\id
	dw DAC_98_Setup\id, DAC_99_Setup\id, DAC_9A_Setup\id, DAC_9B_Setup\id
	dw DAC_9C_Setup\id, DAC_9D_Setup\id, DAC_9E_Setup\id, DAC_9F_Setup\id

	dw DAC_A0_Setup\id, DAC_A1_Setup\id, DAC_A2_Setup\id, DAC_A3_Setup\id
	dw DAC_A4_Setup\id, DAC_A5_Setup\id, DAC_A6_Setup\id, DAC_A7_Setup\id
	dw DAC_A8_Setup\id, DAC_A9_Setup\id, DAC_AA_Setup\id, DAC_AB_Setup\id
	dw DAC_AC_Setup\id, DAC_AD_Setup\id, DAC_AE_Setup\id, DAC_AF_Setup\id

	dw DAC_B0_Setup\id, DAC_B1_Setup\id, DAC_B2_Setup\id, DAC_B3_Setup\id
	dw DAC_B4_Setup\id, DAC_B5_Setup\id, DAC_B6_Setup\id, DAC_B7_Setup\id
	dw DAC_B8_B9_Setup\id, DAC_B8_B9_Setup\id, DAC_BA_Setup\id, DAC_BB_Setup\id
	dw DAC_BC_Setup\id, DAC_BD_Setup\id, DAC_BE_Setup\id, DAC_BF_Setup\id

	dw DAC_C0_Setup\id, DAC_C1_Setup\id, DAC_C2_Setup\id, DAC_C3_Setup\id
	dw DAC_C4_Setup\id
; ===========================================================================

DAC_81_Setup\id:	DAC_Setup $04,81
DAC_82_Setup\id:	DAC_Setup $0E,82_85
DAC_83_Setup\id:	DAC_Setup $14,82_85
DAC_84_Setup\id:	DAC_Setup $1A,82_85
DAC_85_Setup\id:	DAC_Setup $20,82_85
DAC_86_Setup\id:	DAC_Setup $04,86
DAC_87_Setup\id:	DAC_Setup $04,87
DAC_88_Setup\id:	DAC_Setup $04,88
DAC_89_Setup\id:	DAC_Setup $0A,89
DAC_8A_Setup\id:	DAC_Setup $14,8A_8B
DAC_8B_Setup\id:	DAC_Setup $1B,8A_8B
DAC_8C_Setup\id:	DAC_Setup $08,8C
DAC_8D_Setup\id:	DAC_Setup $0B,8D_8E
DAC_8E_Setup\id:	DAC_Setup $11,8D_8E
DAC_8F_Setup\id:	DAC_Setup $08,8F
DAC_90_Setup\id:	DAC_Setup $03,90_93
DAC_91_Setup\id:	DAC_Setup $07,90_93
DAC_92_Setup\id:	DAC_Setup $0A,90_93
DAC_93_Setup\id:	DAC_Setup $0E,90_93
DAC_94_Setup\id:	DAC_Setup $06,94_97
DAC_95_Setup\id:	DAC_Setup $0A,94_97
DAC_96_Setup\id:	DAC_Setup $0D,94_97
DAC_97_Setup\id:	DAC_Setup $12,94_97
DAC_98_Setup\id:	DAC_Setup $08,98_9A
DAC_99_Setup\id:	DAC_Setup $13,98_9A
DAC_9A_Setup\id:	DAC_Setup $16,98_9A
DAC_9B_Setup\id:	DAC_Setup $16,9B
DAC_A2_Setup\id:	DAC_Setup $0A,A2
DAC_A3_Setup\id:	DAC_Setup $18,A3
DAC_A4_Setup\id:	DAC_Setup $18,A4
DAC_A5_Setup\id:	DAC_Setup $0C,A5
DAC_A6_Setup\id:	DAC_Setup $09,A6
DAC_A7_Setup\id:	DAC_Setup $18,A7
DAC_A8_Setup\id:	DAC_Setup $18,A8
DAC_A9_Setup\id:	DAC_Setup $0C,A9
DAC_AA_Setup\id:	DAC_Setup $0A,AA
DAC_AB_Setup\id:	DAC_Setup $0D,AB
DAC_AC_Setup\id:	DAC_Setup $06,AC
DAC_AD_Setup\id:	DAC_Setup $10,AD_AE
DAC_AE_Setup\id:	DAC_Setup $18,AD_AE
DAC_AF_Setup\id:	DAC_Setup $09,AF_B0
DAC_B0_Setup\id:	DAC_Setup $12,AF_B0
DAC_B1_Setup\id:	DAC_Setup $18,B1
DAC_B2_Setup\id:	DAC_Setup $16,B2_B3_S3
DAC_B3_Setup\id:	DAC_Setup $20,B2_B3_S3
DAC_B4_Setup\id:	DAC_Setup $0C,B4C1_C4
DAC_B5_Setup\id:	DAC_Setup $0C,B5
DAC_B6_Setup\id:	DAC_Setup $0C,B6
DAC_B7_Setup\id:	DAC_Setup $18,B7
DAC_B8_B9_Setup\id:	DAC_Setup $0C,B8_B9
DAC_BA_Setup\id:	DAC_Setup $18,BA
DAC_BB_Setup\id:	DAC_Setup $18,BB
DAC_BC_Setup\id:	DAC_Setup $18,BC
DAC_BD_Setup\id:	DAC_Setup $0C,BD
DAC_BE_Setup\id:	DAC_Setup $0C,BE
DAC_BF_Setup\id:	DAC_Setup $1C,BF
DAC_C0_Setup\id:	DAC_Setup $0B,C0
DAC_C1_Setup\id:	DAC_Setup $0F,B4C1_C4
DAC_C2_Setup\id:	DAC_Setup $11,B4C1_C4
DAC_C3_Setup\id:	DAC_Setup $12,B4C1_C4
DAC_C4_Setup\id:	DAC_Setup $0B,B4C1_C4
DAC_9C_Setup\id:	DAC_Setup $0A,9C
DAC_9D_Setup\id:	DAC_Setup $18,9D
DAC_9E_Setup\id:	DAC_Setup $18,9E
DAC_9F_Setup\id:	DAC_Setup $0C,9F
DAC_A0_Setup\id:	DAC_Setup $0C,A0
DAC_A1_Setup\id:	DAC_Setup $0A,A1
    endm

	opt w-
	opt ae-

; ===========================================================================
	DACBank_Defs 0	; create ROM pointers and setup information about DACs
	incDAC 9B, bin
	incDAC 9C, bin
	incDAC 9D, bin
	incDAC 9E, bin
	incDAC 9F, bin
	incDAC A0, bin
	incDAC A1, bin
	incDAC A2, bin
	incDAC A3, bin
	incDAC A4, bin
	incDAC A5, bin
	incDAC A6, bin
	incDAC A7, bin
	incDAC A8, bin
	incDAC A9, bin
	incDAC AA, bin
	Z80Bank_End

; ===========================================================================
	DACBank_Defs 1	; create ROM pointers and setup information about DACs
	incDAC AB, bin
	incDAC AC, bin
	incDAC AD_AE, bin
	incDAC AF_B0, bin
	incDAC B0_Unused, bin
	incDAC B1, bin
	incDAC B2_B3_S3, bin
	incDAC B4C1_C4, bin
	incDAC B5, bin
	incDAC B6, bin
	incDAC B7, bin
	incDAC B8_B9, bin
	incDAC BA, bin
	incDAC BB, bin
	incDAC BC, bin
	incDAC BD, bin
	incDAC BE, bin
	incDAC BF, bin
	incDAC C0, bin
	Z80Bank_End
; ===========================================================================

	DACBank_Defs 2	; create ROM pointers and setup information about DACs
	incDAC 86, bin
	incDAC 81, bin
	incDAC 82_85, bin
	incDAC 94_97, bin
	incDAC 90_93, bin
	incDAC 88, bin
	incDAC 8A_8B, bin
	incDAC 8C, bin
	incDAC 8D_8E, bin
	incDAC 87, bin
	incDAC 8F, bin
	incDAC 89, bin
	incDAC 98_9A, bin
	Z80Bank_End


		Z80Bank_Start	"Music 1"
MTitle:	include "sound/Title.asm"
MMenu:	include "sound/Menu.asm"
MWO1:	include "sound/WO1.asm"
MWO2:	include "sound/WO2.asm"
MDD1:	include "sound/DD1.asm"
MDD2:	include "sound/DD2.asm"
MWA1:	include "sound/WA1.asm"
MWA2:	include "sound/WA2.asm"
MCC1:	include "sound/CC1.asm"
MCC2:	include "sound/CC2.asm"
MFC1:	include "sound/FC1.asm"
MFC2:	include "sound/FC2.asm"
MRT1:	include "sound/RT1.asm"
MRT2:	include "sound/RT2.asm"
MTJ1:	include "sound/TJ1.asm"
MTJ2:	include "sound/TJ2.asm"
	Z80Bank_End
musbnk:

		Z80Bank_Start	"Music 2"
MKV1:	include "sound/KV1.asm"
MKV2:	include "sound/KV2.asm"
MAB1:	include "sound/AB1.asm"
MAB2:	include "sound/AB2.asm"
MBossE:	include "sound/BossE.asm"
MBossC:	include "sound/BossC.asm"
MBossM:	include "sound/BossM.asm"
MBonus:	include	"sound/Bonus.asm"    
MSpecial:	include	"sound/Special.asm"       
MInvincible:		include	"sound/Invincible.asm"
MOutro:		include	"sound/Outro.asm"
MResults:		include	"sound/Results.asm"
MGameOver:		include	"sound/Game Over.asm"
MEnd:		   include	"sound/End of the World.asm"
MFinalBoss1:		include	"sound/Final Boss 1.asm"
MFinalBoss2:		include	"sound/Final Boss 2.asm"
MCredits1:		include	"sound/Credits 1.asm"
MCredits2:		include	"sound/Credits 2.asm"
MCredits3:		include	"sound/Credits 3.asm"
MCredits4:		include "sound/Credits 4.asm"
M1UP:		include	"sound/1UP.asm"
	Z80Bank_End
musbnk2:
		Z80Bank_Start	"SFX"
SEGA_PCM:	incbin "sound/sega.bin"
	align 2
Sfx_33:		include	"sound/33.asm"
Sfx_34:		include	"sound/34.asm"
Sfx_35:		include	"sound/35.asm"
Sfx_36:		include	"sound/36.asm"
Sfx_37:		include	"sound/37.asm"
Sfx_38:		include	"sound/38.asm"
Sfx_39:		include	"sound/39.asm"
Sfx_3A:		include	"sound/3A.asm"
Sfx_3B:		include	"sound/3B.asm"
Sfx_3C:		include	"sound/3C.asm"
Sfx_3D:		include	"sound/3D.asm"
Sfx_3E:		include	"sound/3E.asm"
Sfx_3F:		include	"sound/3F.asm"
Sfx_40:		include	"sound/40.asm"
Sfx_41:		include	"sound/41.asm"
Sfx_42:		include	"sound/42.asm"
Sfx_43:		include	"sound/43.asm"
Sfx_44:		include	"sound/44.asm"
Sfx_45:		include	"sound/45.asm"
Sfx_46:		include	"sound/46.asm"
Sfx_47:		include	"sound/47.asm"
Sfx_48:		include	"sound/48.asm"
Sfx_49:		include	"sound/49.asm"
Sfx_4A:		include	"sound/4A.asm"
Sfx_4B:		include	"sound/4B.asm"
Sfx_4C:		include	"sound/4C.asm"
Sfx_4D:		include	"sound/4D.asm"
Sfx_4E:		include	"sound/4E.asm"
Sfx_4F:		include	"sound/4F.asm"
Sfx_50:		include	"sound/50.asm"
Sfx_51:		include	"sound/51.asm"
Sfx_52:		include	"sound/52.asm"
Sfx_53:		include	"sound/53.asm"
Sfx_54:		include	"sound/54.asm"
Sfx_55:		include	"sound/55.asm"
Sfx_56:		include	"sound/56.asm"
Sfx_57:		include	"sound/57.asm"
Sfx_58:		include	"sound/58.asm"
Sfx_59:		include	"sound/59.asm"
Sfx_5A:		include	"sound/5A.asm"
Sfx_5B:		include	"sound/5B.asm"
Sfx_5C:		include	"sound/5C.asm"
Sfx_5D:		include	"sound/5D.asm"
Sfx_5E:		include	"sound/5E.asm"
Sfx_5F:		include	"sound/5F.asm"
Sfx_60:		include	"sound/DC.asm"
Sfx_61:		include	"sound/61.asm"
Sfx_62:		include	"sound/62.asm"
Sfx_63:		include	"sound/63.asm"
Sfx_64:		include	"sound/64.asm"
Sfx_65:		include	"sound/65.asm"
Sfx_66:		include	"sound/66.asm"
Sfx_67:		include	"sound/67.asm"
Sfx_68:		include	"sound/68.asm"
Sfx_69:		include	"sound/69.asm"
Sfx_6A:		include	"sound/6A.asm"
Sfx_6B:		include	"sound/6B.asm"
Sfx_6C:		include	"sound/6C.asm"
Sfx_6D:		include	"sound/6D.asm"
Sfx_6E:		include	"sound/6E.asm"
Sfx_6F:		include	"sound/6F.asm"
Sfx_70:		include	"sound/70.asm"
Sfx_71:		include	"sound/71.asm"
Sfx_72:		include	"sound/72.asm"
Sfx_73:		include	"sound/73.asm"
Sfx_74:		include	"sound/74.asm"
Sfx_75:		include	"sound/75.asm"
Sfx_76:		include	"sound/76.asm"
Sfx_77:		include	"sound/77.asm"
Sfx_78:		include	"sound/78.asm"
Sfx_79:		include	"sound/79.asm"
Sfx_7A:		include	"sound/7A.asm"
Sfx_7B:		include	"sound/7B.asm"
Sfx_7C:		include	"sound/7C.asm"
Sfx_7D:		include	"sound/7D.asm"
Sfx_7E:		include	"sound/7E.asm"
Sfx_7F:		include	"sound/7F.asm"
Sfx_80:		include	"sound/80.asm"
Sfx_81:		include	"sound/81.asm"
Sfx_82:		include	"sound/82.asm"
Sfx_83:		include	"sound/83.asm"
Sfx_84:		include	"sound/84.asm"
Sfx_85:		include	"sound/85.asm"
Sfx_86:		include	"sound/86.asm"
Sfx_87:		include	"sound/87.asm"
Sfx_88:		include	"sound/88.asm"
Sfx_89:		include	"sound/89.asm"
Sfx_8A:		include	"sound/8A.asm"
Sfx_8B:		include	"sound/8B.asm"
Sfx_8C:		include	"sound/8C.asm"
Sfx_8D:		include	"sound/8D.asm"
Sfx_8E:		include	"sound/8E.asm"
Sfx_8F:		include	"sound/8F.asm"
Sfx_90:		include	"sound/90.asm"
Sfx_91:		include	"sound/91.asm"
Sfx_92:		include	"sound/92.asm"
Sfx_93:		include	"sound/93.asm"
Sfx_94:		include	"sound/94.asm"
Sfx_95:		include	"sound/95.asm"
Sfx_96:		include	"sound/96.asm"
Sfx_97:		include	"sound/97.asm"
Sfx_98:		include	"sound/98.asm"
Sfx_99:		include	"sound/99.asm"
Sfx_9A:		include	"sound/9A.asm"
Sfx_9B:		include	"sound/9B.asm"
Sfx_9C:		include	"sound/9C.asm"
Sfx_9D:		include	"sound/DE.asm"
Sfx_9E:		include	"sound/9E.asm"
Sfx_9F:		include	"sound/9F.asm"
Sfx_A0:		include	"sound/A0.asm"
Sfx_A1:		include	"sound/A1.asm"
Sfx_A2:		include	"sound/A2.asm"
Sfx_A3:		include	"sound/A3.asm"
Sfx_A4:		include	"sound/A4.asm"
Sfx_A5:		include	"sound/A5.asm"
Sfx_A6:		include	"sound/A6.asm"
Sfx_A7:		include	"sound/A7.asm"
Sfx_A8:		include	"sound/A8.asm"
Sfx_A9:		include	"sound/DD.asm"
Sfx_AA:		include	"sound/AA.asm"
Sfx_AB:		include	"sound/AB.asm"
Sfx_AC:		include	"sound/AC.asm"
Sfx_AD:		include	"sound/AD.asm"
Sfx_AE:		include	"sound/AE.asm"
Sfx_AF:		include	"sound/AF.asm"
Sfx_B0:		include	"sound/B0.asm"
Sfx_B1:		include	"sound/B1.asm"
Sfx_B2:		include	"sound/B2.asm"
Sfx_B3:		include	"sound/B3.asm"
Sfx_B4:		include	"sound/B4.asm"
Sfx_B5:		include	"sound/B5.asm"
Sfx_B6:		include	"sound/B6.asm"
Sfx_B7:		include	"sound/B7.asm"
Sfx_B8:		include	"sound/B8.asm"
Sfx_B9:		include	"sound/B9.asm"
Sfx_BA:		include	"sound/BA.asm"
Sfx_BB:		include	"sound/BB.asm"
Sfx_BC:		include	"sound/BC.asm"
Sfx_BD:		include	"sound/BD.asm"
Sfx_BE:		include	"sound/BE.asm"
Sfx_BF:		include	"sound/BF.asm"
Sfx_C0:		include	"sound/C0.asm"
Sfx_C1:		include	"sound/C1.asm"
Sfx_C2:		include	"sound/C2.asm"
Sfx_C3:		include	"sound/C3.asm"
Sfx_C4:		include	"sound/C4.asm"
Sfx_C5:		include	"sound/C5.asm"
Sfx_C6:		include	"sound/C6.asm"
Sfx_C7:		include	"sound/C7.asm"
Sfx_C8:		include	"sound/C8.asm"
Sfx_C9:		include	"sound/C9.asm"
Sfx_CA:		include	"sound/CA.asm"
Sfx_CB:		include	"sound/CB.asm"
Sfx_CC:		include	"sound/CC.asm"
Sfx_CD:		include	"sound/CD.asm"
Sfx_CE:		include	"sound/CE.asm"
Sfx_CF:		include	"sound/CF.asm"
Sfx_D0:		include	"sound/D0.asm"
Sfx_D1:		include	"sound/D1.asm"
Sfx_D2:		include	"sound/D2.asm"
Sfx_D3:		include	"sound/D3.asm"
Sfx_D4:		include	"sound/D4.asm"
Sfx_D5:		include	"sound/D5.asm"
Sfx_D6:		include	"sound/D6.asm"
Sfx_D7:		include	"sound/D7.asm"
Sfx_D8:		include	"sound/D8.asm"
Sfx_D9:		include	"sound/D9.asm"
Sfx_DA:		include	"sound/DA.asm"
Sfx_DB:		include	"sound/DB.asm"
	Z80Bank_End
sndbnk:
MNull:

; ===========================================================================
		align 2
Art_Dust:	incbin	"artunc\spindust.bin"
ART_SEGA:		incbin	"artnem\splash.bin"
MAPS_SEGA:		incbin	"mapeni\splash.bin"
			even
Pal_SEGANew:		incbin	"pallet\splash.bin"
Eni_Card1:		incbin	"mapeni\waveoceancard.bin"
			even
Pal_Card1:		incbin	"pallet\waveoceancard.bin"
; ===============================================================
; ---------------------------------------------------------------
; Vladikcomper's Parallax Engine
; Version 0.50
; ---------------------------------------------------------------
; 2014, Vladikcomper
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Main routine that runs the script
; ---------------------------------------------------------------
; INPUT:
;	a1	Script
; ---------------------------------------------------------------

ExecuteParallaxScript:
	lea	($FFFFE000).w,a0

	move	($FFFFF700).w,d0			; d0 = BG Position
	swap	d0
	clr.w	d0
	moveq	#0,d7
	
@ProcessBlock:
	move.b	(a1)+,d7			; load scrolling mode for the current block in script
	bmi.s	@Return				; if end of list reached, branch
	move.w	@ParallaxRoutines(pc,d7),d6
	move.b	(a1)+,d7			; load scrolling mode parameter
	jmp	@ParallaxRoutines(pc,d6)

@Return:
	rts

; ---------------------------------------------------------------
@ParallaxRoutines:
	dc.w	@Parallax_Normal-@ParallaxRoutines
	dc.w	@Parallax_Moving-@ParallaxRoutines  
	dc.w	@Parallax_Linear-@ParallaxRoutines
	dc.w	@Parallax_Ripple-@ParallaxRoutines

; ---------------------------------------------------------------
; Scrolling routine: Static solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

@Parallax_Normal:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	move.w	($FFFFF700).w,d1
	neg.w	d1
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N    
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	jmp	@0(pc,d6)

	; Main functional block (2 bytes per loop)
@0	rept	32
	move.l	d1,(a0)+
	endr
	dbf	d5,@0

	jmp	@ProcessBlock			; process next bloku!
	
; ---------------------------------------------------------------
; Scrolling routine: Moving solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

@Parallax_Moving:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	move.w	($FFFFF700).w,d1
	neg.w	d1
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef
	
	; Add frame factor
	move.w	($FFFFFE04).w,d3
	lsr.w	d7,d3
	sub.w	d3,d1

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N    
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	jmp	@0(pc,d6)


; ---------------------------------------------------------------
; Scrolling routine: Linear Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

@Parallax_Linear:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	move.w	($FFFFF700).w,d3
	neg.w	d3
	swap	d3

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N    
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	@1(pc,d6)

	; Main functional block (10 bytes per loop)
@1	rept	16
	swap	d1
	move.w	d1,d3
	move.l	d3,(a0)+
	swap	d1
	add.l	d2,d1
	endr
	dbf	d5,@1

	jmp	@ProcessBlock			; process next bloku!

; ---------------------------------------------------------------
; Scrolling routine: Ripple Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

@Parallax_Ripple:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	move.w	($FFFFFE04).w,d3
	andi.w	#7,d3
	bne.s	@3
	subq.w	#1,($FFFFA800).w
@3
	move.w	($FFFFA800).w,d3
	andi.w	#$1F,d3
	lea	(SwScrl_RippleData2).l,a2
	lea	(a2,d3.w),a2

	move.w	($FFFFF700).w,d3
	neg.w	d3
	swap	d3

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N    
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	@2(pc,d6)

	; Main functional block (10 bytes per loop)
@2	rept	16
	move.l	d2,d1
	swap	d1
	move.b	(a2)+,d4
	ext.w	d4
	add.w	d4,d1
	move.w	d1,d3
	move.l	d3,(a0)+
	swap	d1
	endr
	dbf	d5,@2

	jmp	@ProcessBlock			; process next bloku!

; ---------------------------------------------------------------------------
; Uncompressed graphics	- Silver
; ---------------------------------------------------------------------------
Art_Silver:	incbin	artunc\silver.bin	; Silver
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Art_Sonic:	incbin	artunc\sonic.bin	; Sonic
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Art_Sonic2:	incbin	artunc\sonic2.bin	; Sonic
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Shadow
; ---------------------------------------------------------------------------
Art_Shadow:	incbin	artunc\shadow.bin	; Shadow
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Shadow
; ---------------------------------------------------------------------------
Art_Shadow2:	incbin	artunc\shadow2.bin	; Shadow
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Tails
; ---------------------------------------------------------------------------
Art_Tails:	incbin	artunc\tails.bin	; Tails
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Tails' Tails
; ---------------------------------------------------------------------------
Art_TailsTails:	incbin	artunc\tailstails.bin	; Tails
		even
;-------------------------------------------------------------------------------
Menu_Font:
                incbin  'data\menu\menufont.nem'
Menu_Box:
                incbin  'data\menu\menubox.nem'
Level_Icons:
                incbin  'data\menu\levelico.nem'  
Menu_Mappings:
                incbin  'data\menu\menubg.eni'
Icons_Mappings:
                incbin  'data\menu\iconsmap.eni'
Sonic_Miles_Spr:                                         
                incbin  'data\menu\soncmils.dat'
; ---------------------------------------------------------------------------
; Sprite mappings - zone title cards
; ---------------------------------------------------------------------------

Map_obj34:
  	include "_maps\obj34.asm"  
; ===============================================================
; ---------------------------------------------------------------
; Error handling module
; ---------------------------------------------------------------
 
BusError:   jsr ErrorHandler(pc)
        dc.b    "BUS ERROR",0           ; text
        dc.b    1               ; extended stack frame
        even
 
AddressError:   jsr ErrorHandler(pc)
        dc.b    "ADDRESS ERROR",0       ; text
        dc.b    1               ; extended stack frame
        even
 
IllegalInstr:   jsr ErrorHandler(pc)
        dc.b    "ILLEGAL INSTRUCTION",0     ; text
        dc.b    0               ; extended stack frame
        even
 
ZeroDivide: jsr ErrorHandler(pc)
        dc.b    "ZERO DIVIDE",0         ; text
        dc.b    0               ; extended stack frame
        even
 
ChkInstr:   jsr ErrorHandler(pc)
        dc.b    "CHK INSTRUCTION",0         ; text
        dc.b    0               ; extended stack frame
        even
 
TrapvInstr: jsr ErrorHandler(pc)
        dc.b    "TRAPV INSTRUCTION",0       ; text
        dc.b    0               ; extended stack frame
        even
 
PrivilegeViol:  jsr ErrorHandler(pc)
        dc.b    "PRIVILEGE VIOLATION",0     ; text
        dc.b    0               ; extended stack frame
        even
 
Trace:      jsr ErrorHandler(pc)
        dc.b    "TRACE",0           ; text
        dc.b    0               ; extended stack frame
        even
 
Line1010Emu:    jsr ErrorHandler(pc)
        dc.b    "LINE 1010 EMULATOR",0      ; text
        dc.b    0               ; extended stack frame
        even
 
Line1111Emu:    jsr ErrorHandler(pc)
        dc.b    "LINE 1111 EMULATOR",0      ; text
        dc.b    0               ; extended stack frame
        even
 
ErrorExcept:    jsr ErrorHandler(pc)
        dc.b    "ERROR EXCEPTION",0         ; text
        dc.b    0               ; extended stack frame
        even
 
ErrorHandler:   incbin  "ErrorHandler.bin"
EndOfRom:
		END

; /=========================================================================\
; ยบ	This file is generated by The Interactive Disassembler (IDA)		ยบ
; ยบ	Copyright (c) 2003 by DataRescue sa/nv,	<ida.datarescue.com>		ยบ
; \=========================================================================/
;
; Disassembly created by Hivebrain
; thanks to drx and Stealth

; Processor:		68000
; Target Assembler: 680x0 Assembler in MRI compatible mode
; This file should be compiled with "as	-M"

Main		SECTION org(0)
		opt l.			; local label symbol is .

		include 	"macros.asm"
		include "AMPS/lang.asm"
		include "AMPS/code/macro.asm"
		include "error/debugger.asm"

StartOfRom:
Vectors:	dc.l $FFFFFE00, EntryPoint, BusError, AddressError
		dc.l IllegalInstr, ZeroDivide, ChkInstr, TrapvInstr
		dc.l PrivilegeViol, Trace, Line1010Emu,	Line1111Emu
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorTrap, ErrorTrap,	ErrorTrap
		dc.l HIntJump,	ErrorTrap, VIntJump, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
MEGADRIVE:	dc.b 'SEGA MEGA DRIVE ' ; Hardware system ID
Date:		dc.b '(C)SEGA 2021.AAA' ; Release date
Title_Local:	dc.b 'SONIC NEXT GENESIS                              ' ; Domestic name
Title_Int:	dc.b 'SONIC NEXT GENESIS                              ' ; International name
Serial:		dc.b 'GM 00001009-00'   ; Serial/version number
Checksum:	dc.w 0
		dc.b 'J               ' ; I/O support
RomStartLoc:	dc.l StartOfRom		; ROM start
RomEndLoc:	dc.l EndOfRom-1		; ROM end
RamStartLoc:	dc.l $FF0000		; RAM start
RamEndLoc:	dc.l $FFFFFF		; RAM end
SRAMSupport:	dc.b "RA",$F8,$20		; change to $5241E020 to create	SRAM
		dc.l $20202020		; SRAM start
		dc.l $20202020		; SRAM end
Notes:		dc.b '                                                    '
Region:		dc.b 'JUE             ' ; Region
EndOfHeader:

; ===========================================================================

;ErrorTrap:
;		nop
;		nop	
;		bra.s	ErrorTrap
; ===========================================================================

EntryPoint:
		tst.l	($A10008).l	; test port A control
		bne.s	PortA_Ok
		tst.w	($A1000C).l	; test port C control

PortA_Ok:
		bne.s	PortC_Ok
		lea	SetupValues(pc),a5
		movem.w	(a5)+,d5-d7
		movem.l	(a5)+,a0-a4
		move.b	-$10FF(a1),d0	; get hardware version
		andi.b	#$F,d0
		beq.s	SkipSecurity
		move.l	MEGADRIVE.w,$2F00(a1)

SkipSecurity:
		move.w	(a4),d0		; check	if VDP works
		moveq	#0,d0
		movea.l	d0,a6
		move.l	a6,usp		; set usp to $0
		moveq	#$17,d1

VDPInitLoop:
		move.b	(a5)+,d5	; add $8000 to value
		move.w	d5,(a4)		; move value to	VDP register
		add.w	d7,d5		; next register
		dbf	d1,VDPInitLoop
		move.l	(a5)+,(a4)
		move.w	d0,(a3)		; clear	the screen
		move.w	d7,(a1)		; stop the Z80
		move.w	d7,(a2)		; reset	the Z80

WaitForZ80:
		btst	d0,(a1)		; has the Z80 stopped?
		bne.s	WaitForZ80	; if not, branch
		moveq	#endinit-initz80-1,d2

Z80InitLoop:
		move.b	(a5)+,(a0)+
		dbf	d2,Z80InitLoop
		move.w	d0,(a2)
		move.w	d0,(a1)		; start	the Z80
		move.w	d7,(a2)		; reset	the Z80

ClrRAMLoop:
		move.l	d0,-(a6)
		dbf	d6,ClrRAMLoop	; clear	the entire RAM
		move.l	(a5)+,(a4)	; set VDP display mode and increment
		move.l	(a5)+,(a4)	; set VDP to CRAM write
		moveq	#$1F,d3

ClrCRAMLoop:
		move.l	d0,(a3)
		dbf	d3,ClrCRAMLoop	; clear	the CRAM
		move.l	(a5)+,(a4)
		moveq	#$13,d4

ClrVDPStuff:
		move.l	d0,(a3)
		dbf	d4,ClrVDPStuff
		moveq	#3,d5

PSGInitLoop:
		move.b	(a5)+,$11(a3)	; reset	the PSG
		dbf	d5,PSGInitLoop
		move.w	d0,(a2)
		movem.l	(a6),d0-a6	; clear	all registers
		move	#$2700,sr	; set the sr

PortC_Ok:
		bra.s	GameProgram
; ===========================================================================
SetupValues:	dc.w $8000		; XREF: PortA_Ok
		dc.w $3FFF
		dc.w $100

		dc.l $A00000		; start	of Z80 RAM
		dc.l $A11100		; Z80 bus request
		dc.l $A11200		; Z80 reset
		dc.l $C00000
		dc.l $C00004		; address for VDP registers

		dc.b 4,	$14, $30, $3C	; values for VDP registers
		dc.b 7,	$6C, 0,	0
		dc.b 0,	0, $FF,	0
		dc.b $81, $37, 0, 1
		dc.b 1,	0, 0, $FF
		dc.b $FF, 0, 0,	$80

		dc.l $40000080

initz80	z80prog 0
		di
		im	1
		ld	hl,YM_Buffer1			; we need to clear from YM_Buffer1
		ld	de,(YM_BufferEnd-YM_Buffer1)/8	; to end of Z80 RAM, setting it to 0FFh

.loop
		ld	a,0FFh				; load 0FFh to a
		rept 8
			ld	(hl),a			; save a to address
			inc	hl			; go to next address
		endr

		dec	de				; decrease loop counter
		ld	a,d				; load d to a
		zor	e				; check if both d and e are 0
		jr	nz, .loop			; if no, clear more memoty
.pc		jr	.pc				; trap CPU execution
	z80prog
		even
endinit

		dc.w $8104		; value	for VDP	display	mode
		dc.w $8F02		; value	for VDP	increment
		dc.l $C0000000		; value	for CRAM write mode
		dc.l $40000010

		dc.b $9F, $BF, $DF, $FF	; values for PSG channel volumes
; ===========================================================================

GameProgram:

GameInit:
		move.w	#$4EF9,(VIntJump).w	; machine code for jmp
		move.l	#VInt,(VIntAddr).w
		move.w	#$4EF9,(HIntJump).w
		move.l	#HInt_S3Water,(HIntAddr).w
		lea	($C00000).l,a6
		move.l	a6,usp
		lea	($FF0000).l,a6
		moveq	#0,d7
		move.w	#$3F7F,d6

GameClrRAM:
		move.l	d7,(a6)+
		dbf	d6,GameClrRAM	; fill RAM ($0000-$FDFF) with $0
		bsr.w	VDPSetupGame
		jsr	LoadDualPCM
		bsr.w	JoypadInit
		move.b	#0,($FFFFF600).w ; set Game Mode to Sega Screen

MainGameLoop:
		move.b	($FFFFF600).w,d0 ; load	Game Mode
		andi.w	#$3C,d0
		jsr	GameModeArray(pc,d0.w) ; jump to apt location in ROM
		bra.s	MainGameLoop
; ===========================================================================
; ---------------------------------------------------------------------------
; Main game mode array
; ---------------------------------------------------------------------------

GameModeArray:
		bra.w	SegaScreen	; Sega Screen ($00)
; ===========================================================================
		bra.w	TitleScreen	; Title	Screen ($04)
; ===========================================================================
		bra.w	Level		; Demo Mode ($08)
; ===========================================================================
		bra.w	Level		; Normal Level ($0C)
; ===========================================================================
		bra.w	BonusStage	; Bonus Stage	($10)
; ===========================================================================
		bra.w	SpecialStage	; Special Stage ($14)
; ===========================================================================
		bra.w	SegaScreen	; Unused ($18)
; ===========================================================================
		bra.w	SegaScreen	; Unused ($1C)
; ===========================================================================
		bra.w	SSRGScreen	; SSRG Screen ($20)
; ===========================================================================
		bra.w	SegaScreen	; Unused ($24)
; ===========================================================================
		bra.w	Segascreen	; Unused ($28)
; ===========================================================================
		bra.w	Options	; Level Select ($2C)
; ===========================================================================
		rts	
; ===========================================================================

loc_43A:
		addq.w	#2,sp
		move.l	(sp)+,($FFFFFC40).w
		addq.w	#2,sp
		movem.l	d0-a7,($FFFFD600).w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA
		move.l	($FFFFFC40).w,d0
		bsr.w	sub_5BA
		bra.s	loc_478
; ===========================================================================

loc_462:
		move	#$2700,sr
		movem.l	d0-a7,($FFFFD600).w
		bsr.w	ShowErrorMsg
		move.l	2(sp),d0
		bsr.w	sub_5BA

loc_478:
		bsr.w	ErrorWaitForC
		movem.l	($FFFFD600).w,d0-a7
		move	#$2300,sr
		rte	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowErrorMsg:				; XREF: loc_43A; loc_462
		lea	($C00000).l,a6
		move.l	#$78000003,($C00004).l
		lea	(Art_Text).l,a0
		move.w	#$27F,d1

Error_LoadGfx:
		move.w	(a0)+,(a6)
		dbf	d1,Error_LoadGfx
		moveq	#0,d0		; clear	d0
		move.b	($FFFFFC44).w,d0 ; load	error code
		move.w	ErrorText(pc,d0.w),d0
		lea	ErrorText(pc,d0.w),a0
		move.l	#$46040003,($C00004).l ; position
		moveq	#$12,d1		; number of characters

Error_LoopChars:
		moveq	#0,d0
		move.b	(a0)+,d0
		addi.w	#$790,d0
		move.w	d0,(a6)
		dbf	d1,Error_LoopChars ; repeat for	number of characters
		rts	
; End of function ShowErrorMsg

; ===========================================================================
ErrorText:	dc.w asc_4E8-ErrorText,	asc_4FB-ErrorText ; XREF: ShowErrorMsg
		dc.w asc_50E-ErrorText,	asc_521-ErrorText
		dc.w asc_534-ErrorText,	asc_547-ErrorText
		dc.w asc_55A-ErrorText,	asc_56D-ErrorText
		dc.w asc_580-ErrorText,	asc_593-ErrorText
		dc.w asc_5A6-ErrorText
asc_4E8:	dc.b 'ERROR EXCEPTION	'
asc_4FB:	dc.b 'BUS ERROR		  '
asc_50E:	dc.b 'ADDRESS ERROR	  '
asc_521:	dc.b 'ILLEGAL INSTRUCTION'
asc_534:	dc.b '.ERO DIVIDE		'
asc_547:	dc.b 'CHK INSTRUCTION	'
asc_55A:	dc.b 'TRAPV INSTRUCTION  '
asc_56D:	dc.b 'PRIVILEGE VIOLATION'
asc_580:	dc.b 'TRACE			  '
asc_593:	dc.b 'LINE 1010 EMULATOR '
asc_5A6:	dc.b 'LINE 1111 EMULATOR '
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5BA:				; XREF: loc_43A; loc_462
		move.w	#$7CA,(a6)
		moveq	#7,d2

loc_5C0:
		rol.l	#4,d0
		bsr.s	sub_5CA
		dbf	d2,loc_5C0
		rts	
; End of function sub_5BA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_5CA:				; XREF: sub_5BA
		move.w	d0,d1
		andi.w	#$F,d1
		cmpi.w	#$A,d1
		bcs.s	loc_5D8
		addq.w	#7,d1

loc_5D8:
		addi.w	#$7C0,d1
		move.w	d1,(a6)
		rts	
; End of function sub_5CA


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ErrorWaitForC:				; XREF: loc_478
		bsr.w	ReadJoypads
		cmpi.b	#$20,($FFFFF605).w ; is	button C pressed?
		bne.w	ErrorWaitForC	; if not, branch
		rts	
; End of function ErrorWaitForC

; ===========================================================================

Art_Text:	incbin	artunc\menutext.bin	; text used in level select and debug mode
		even
Art_TextS2:	incbin	artunc\menutexts2.bin	; text used in level select and debug mode
		even
Art_MText:	incbin	artunc\musictext.bin	; text used in level select and debug mode
		even

; ===========================================================================

VInt:				; XREF: Vectors
		movem.l	d0-a6,-(sp)
		tst.b	($FFFFF62A).w
		beq.s	loc_B88
		move.w	($C00004).l,d0
		move.l	#$40000010,($C00004).l
		move.l	($FFFFF616).w,($C00000).l
		btst	#6,($FFFFFFF8).w
		beq.s	loc_B42
		move.w	#$700,d0

loc_B3E:
		dbf	d0,loc_B3E

loc_B42:
		move.b	($FFFFF62A).w,d0
		move.b	#0,($FFFFF62A).w
		move.w	#1,($FFFFF644).w
		andi.w	#$3E,d0
		move.w	off_B6E(pc,d0.w),d0
		jsr	off_B6E(pc,d0.w)

loc_B5E:				; XREF: loc_B88
		jsr	UpdateAMPS

loc_B64:				; XREF: loc_D50
		addq.l	#1,($FFFFFE0C).w
		movem.l	(sp)+,d0-a6
		rte	
; ===========================================================================
off_B6E:	dc.w loc_B88-off_B6E, loc_C32-off_B6E
		dc.w loc_C44-off_B6E, loc_C5E-off_B6E
		dc.w loc_C6E-off_B6E, loc_DA6-off_B6E
		dc.w loc_E72-off_B6E, loc_F8A-off_B6E
		dc.w loc_C64-off_B6E, loc_F9A-off_B6E
		dc.w loc_C36-off_B6E, loc_FA6-off_B6E
		dc.w loc_E72-off_B6E
; ===========================================================================

loc_B88:				; XREF: loc_B10; off_B6E
		cmpi.b	#$8C,($FFFFF600).w
		beq.s	loc_B9A
		cmpi.b	#$C,($FFFFF600).w
		bne.w	loc_B5E

loc_B9A:
		tst.b	(Water_flag).w
		beq.w	loc_B5E ; if not, branch
		move.w	($C00004).l,d0
		btst	#6,($FFFFFFF8).w
		beq.s	loc_BBA
		move.w	#$700,d0

loc_BB6:
		dbf	d0,loc_BB6

loc_BBA:
		move.w	#1,($FFFFF644).w
		tst.b	($FFFFF64E).w
		bne.s	loc_BFE
		lea	($C00004).l,a5
		move.l	#$94009340,(a5)
		move.l	#$96FD9580,(a5)
		move.w	#$977F,(a5)
		move.w	#$C000,(a5)
		move.w	#$80,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)
		bra.s	loc_C22
; ===========================================================================

loc_BFE:				; XREF: loc_BC8
		lea	($C00004).l,a5
		move.l	#$94009340,(a5)
		move.l	#$96FD9540,(a5)
		move.w	#$977F,(a5)
		move.w	#$C000,(a5)
		move.w	#$80,($FFFFF640).w
		move.w	($FFFFF640).w,(a5)

loc_C22:				; XREF: loc_BC8
		move.w	($FFFFF624).w,(a5)
		bra.w	loc_B5E
; ===========================================================================

loc_C32:				; XREF: off_B6E
		bsr.w	sub_106E

loc_C36:				; XREF: off_B6E
		tst.w	($FFFFF614).w
		beq.w	locret_C42
		subq.w	#1,($FFFFF614).w

locret_C42:
		rts	
; ===========================================================================

loc_C44:				; XREF: off_B6E
		move.w	#$E0,(HIntCounter).w
		bsr.w	sub_106E
		jsr	sub_6886
		bsr.w	sub_1642
		tst.w	($FFFFF614).w
		beq.w	locret_C5C
		subq.w	#1,($FFFFF614).w

locret_C5C:
		rts	
; ===========================================================================

loc_C5E:				; XREF: off_B6E
		bsr.w	sub_106E
		rts	
; ===========================================================================

loc_C64:				; XREF: off_B6E
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)	?
		beq.w	loc_DA6		; if yes, branch

loc_C6E:				; XREF: off_B6E
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	VInt_8_UW
		writeCRAM	$FFFFFB00,$80,0
		bra.s	VInt_8_Load

VInt_8_UW:
		writeCRAM	$FFFFFA80,$80,0

VInt_8_Load:
		move.w	($FFFFF624).w,(a5)

VInt_8_Cont:
		writeVRAM	$FFFFE000,$380,$FC00
		writeVRAM	$FFFFF800,$280,$F800

		jsr	(ProcessDMAQueue).l

loc_D50:
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w
		cmpi.b	#$60,($FFFFF625).w
		bcc.s	Demo_Time
		move.b	#1,($FFFFF64F).w
		addq.l	#4,sp
		bra.w	loc_B64

; ---------------------------------------------------------------------------
; Subroutine to	run a demo for an amount of time
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Demo_Time:				; XREF: loc_D50; PalToCRAM
		jsr	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_165E
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.w	Demo_TimeEnd	; if not, branch
		subq.w	#1,($FFFFF614).w ; subtract 1 from time	left

Demo_TimeEnd:
		rts	
; End of function Demo_Time

; ===========================================================================

loc_DA6:				; XREF: off_B6E
		bsr.w	ReadJoypads
		writeCRAM	$FFFFFB00,$80,0
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		jsr	(ProcessDMAQueue).l

loc_E64:
		cmpi.b	#96,($FFFFF625).w
		bcc.s	loc_E64update
		bra.w	locret_E70

loc_E64update:
		jsr	BS_LoadWalls
		jsr	HUD_Update_SS
		tst.w	($FFFFF614).w
		beq.w	locret_E70
		subq.w	#1,($FFFFF614).w

locret_E70:
		rts	
; ===========================================================================

loc_E72:				; XREF: off_B6E
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_EB4
		writeCRAM	$FFFFFB00,$80,0
		bra.s	loc_ED8
; ===========================================================================

loc_EB4:				; XREF: loc_E7A
		writeCRAM	$FFFFFA80,$80,0

loc_ED8:				; XREF: loc_E7A
		move.w	($FFFFF624).w,(a5)
		lea	($C00004).l,a5

loc_EEE:
		writeVRAM	$FFFFE000,$380,$FC00
		writeVRAM	$FFFFF800,$280,$F800
		jsr	(ProcessDMAQueue).l

loc_F54:
		movem.l	($FFFFF700).w,d0-d7
		movem.l	d0-d7,($FFFFFF10).w
		movem.l	($FFFFF754).w,d0-d1
		movem.l	d0-d1,($FFFFFF30).w
		jsr	LoadTilesAsYouMove
		jsr	AniArt_Load
		jsr	HudUpdate
		bsr.w	sub_1642
		rts	
; ===========================================================================

loc_F8A:				; XREF: off_B6E
		bsr.w	sub_106E
		addq.b	#1,($FFFFF628).w
		move.b	#$E,($FFFFF62A).w
		rts	
; ===========================================================================

loc_F9A:				; XREF: off_B6E
		bsr.w	sub_106E
		move.w	($FFFFF624).w,(a5)
		bra.w	sub_1642
; ===========================================================================

loc_FA6:				; XREF: off_B6E
		bsr.w	ReadJoypads
		writeCRAM	$FFFFFB00,$80,0
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		jsr	(ProcessDMAQueue).l

loc_1060:
		cmpi.b	#96,($FFFFF625).w
		bcc.s	loc_1060update
		bra.w	locret_106C

loc_1060update:
		jsr	BS_LoadWalls
		jsr	HUD_Update_SS
		tst.w	($FFFFF614).w
		beq.w	locret_106C
		subq.w	#1,($FFFFF614).w

locret_106C:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_106E:				; XREF: loc_C32; et al
		bsr.w	ReadJoypads
		tst.b	($FFFFF64E).w
		bne.s	loc_10B0
		writeCRAM	$FFFFFB00,$80,0
		bra.s	loc_10D4
; ===========================================================================

loc_10B0:				; XREF: sub_106E
		writeCRAM	$FFFFFA80,$80,0
loc_10D4:				; XREF: sub_106E
		move.w	($FFFFF624).w,(a5)
		writeVRAM	$FFFFF800,$280,$F800
		writeVRAM	$FFFFE000,$380,$FC00
		rts	
; End of function sub_106E

; ---------------------------------------------------------------------------
; Subroutine to	move pallets from the RAM to CRAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HInt_S3Water:
		move	#$2700,sr
		tst.w	($FFFFF644).w
		beq.s	locret_119C
		move.w	#0,($FFFFF644).w
		movem.l	d0-d1/a0-a2,-(sp)

		lea	($C00000).l,a1
		move.w	#$8AFF,4(a1)		; Reset HInt timing
		stopZ80
		movea.l	($FFFFF610).w,a2
		moveq	#$C,d0
.HIntA:
		dbf	d0,.HIntA	; waste a few cycles here

		move.w	(a2)+,d1
		move.b	($FFFFF625).w,d0
		subi.b	#200,d0	; is H-int occuring below line 200?
		bcs.s	.transferColors	; if it is, branch
		sub.b	d0,d1
		bcs.s	.skipTransfer

.transferColors:
		move.w	(a2)+,d0
		lea	($FFFFFA80).w,a0
		adda.w	d0,a0
		addi.w	#$C000,d0
		swap	d0
		move.l	d0,4(a1)	; write to CRAM at appropriate address
		move.l	(a0)+,(a1)	; transfer two colors
		move.w	(a0)+,(a1)	; transfer the third color
		nop
		nop
		moveq	#$24,d0

.wasteSomeCycles:
		dbf	d0,.wasteSomeCycles
		dbf	d1,.transferColors	; repeat for number of colors

.skipTransfer:
		startz80
		movem.l	(sp)+,d0-d1/a0-a2
		tst.b	($FFFFF64F).w
		bne.s	loc_119E

locret_119C:
		rte
; ---------------------------------------------------------------------------
; ===========================================================================

HInt_S1Water:
		move	#$2700,sr
		tst.w	($FFFFF644).w
		beq.s	locret2_119C
		move.w	#0,($FFFFF644).w
		movem.l	a0-a1,-(sp)
		lea	($C00000).l,a1
		lea	($FFFFFA80).w,a0 ; load	pallet from RAM
		move.l	#$C0000000,4(a1) ; set VDP to CRAM write
		move.l	(a0)+,(a1)	; move pallet to CRAM
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.l	(a0)+,(a1)
		move.w	#$8ADF,4(a1)
		movem.l	(sp)+,a0-a1
		tst.b	($FFFFF64F).w
		bne.s	loc_119E

locret2_119C:
		rte	
; ---------------------------------------------------------------------------
; ===========================================================================

loc_119E:				; XREF: PalToCRAM
		clr.b	($FFFFF64F).w
		movem.l	d0-a6,-(sp)
		bsr.w	Demo_Time
		jsr	UpdateAMPS
 		movem.l	(sp)+,d0-a6
		rte	
; ===========================================================================

HInt_Title:
		move.w d0,-(sp)
		move.w (HIntCounter).w,d0
		dbf  d0,.executeHblank
		move.w (sp)+,d0
		rte

	.executeHblank:
		movem.l	d1/a0-a1,-(sp)
		move.w d0,(HIntCounter).w
		move.l	usp,a1
		add.w	d0,d0
		lea	(Pal_TitleGrad).w,a0
		move.w	(a0,d0.w),d1
		add.b	($FFFFFE04).w,d0
		andi.w	#6,d0
		lea	(Pal_TitleGrad2).w,a0
		sub.w	(a0,d0.w),d1
		move.l	#$C0020000,4(a1) ; set VDP to CRAM write
		move.w	d1,(a1)	; move pallet to CRAM
		movem.l	(sp)+,d1/a0-a1
		move.w (sp)+,d0
	;	tst.b	($FFFFF64F).w
	;	bne.s	loc_119E

locret3_119C:
		rte
; End of function PalToCRAM

; ---------------------------------------------------------------------------
; Subroutine to	initialise joypads
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


JoypadInit:				; XREF: GameClrRAM
		moveq	#$40,d0
		move.b	d0,($A10009).l	; init port 1 (joypad 1)
		move.b	d0,($A1000B).l	; init port 2 (joypad 2)
		move.b	d0,($A1000D).l	; init port 3 (extra)
		rts	
; End of function JoypadInit

; ---------------------------------------------------------------------------
; Subroutine to	read joypad input, and send it to the RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ReadJoypads:
		lea	($FFFFF604).w,a0 ; address where joypad	states are written
		lea	($A10003).l,a1	; first	joypad port
		bsr.s	Joypad_Read	; do the first joypad
		addq.w	#2,a1		; do the second	joypad

Joypad_Read:
		move.b	#0,(a1)
		nop	
		nop	
		move.b	(a1),d0
		lsl.b	#2,d0
		andi.b	#$C0,d0
		move.b	#$40,(a1)
		nop	
		nop	
		move.b	(a1),d1
		andi.b	#$3F,d1
		or.b	d1,d0
		not.b	d0
		move.b	(a0),d1
		eor.b	d0,d1
		move.b	d0,(a0)+
		and.b	d0,d1
		move.b	d1,(a0)+
		rts	
; End of function ReadJoypads


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


VDPSetupGame:				; XREF: GameClrRAM; ChecksumError
		lea	($C00004).l,a0
		lea	($C00000).l,a1
		lea	(VDPSetupArray).l,a2
		moveq	#$12,d7

VDP_Loop:
		move.w	(a2)+,(a0)
		dbf	d7,VDP_Loop	; set the VDP registers

		move.w	(VDPSetupArray+2).l,d0
		move.w	d0,($FFFFF60C).w
		move.w	#$8ADF,($FFFFF624).w
		moveq	#0,d0
		move.l	#$C0000000,($C00004).l ; set VDP to CRAM write
		move.w	#$3F,d7

VDP_ClrCRAM:
		move.w	d0,(a1)
		dbf	d7,VDP_ClrCRAM	; clear	the CRAM

		clr.l	($FFFFF616).w
		clr.l	($FFFFF61A).w
		move.l	d1,-(sp)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$94FF93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000080,(a5)
		move.w	#0,($C00000).l	; clear	the screen

loc_128E:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_128E

		move.w	#$8F02,(a5)
		move.l	(sp)+,d1
		rts	
; End of function VDPSetupGame

; ===========================================================================
VDPSetupArray:	dc.w $8004, $8134, $8230, $8328	; XREF: VDPSetupGame
		dc.w $8407, $857C, $8600, $8700
		dc.w $8800, $8900, $8A00, $8B00
		dc.w $8C81, $8D3F, $8E00, $8F02
		dc.w $9001, $9100, $9200

; ---------------------------------------------------------------------------
; Subroutine to	clear the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearScreen:
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000083,(a5)
		move.w	#0,($C00000).l

loc_12E6:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_12E6

		move.w	#$8F02,(a5)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$60000083,(a5)
		move.w	#0,($C00000).l

loc_1314:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_1314

		move.w	#$8F02,(a5)
		move.l	#0,($FFFFF616).w
		move.l	#0,($FFFFF61A).w
		lea	($FFFFF800).w,a1
		moveq	#0,d0
		move.w	#$A0,d1

loc_133A:
		move.l	d0,(a1)+
		dbf	d1,loc_133A

		lea	($FFFFE000).w,a1
		moveq	#0,d0
		move.w	#$100,d1

loc_134A:
		move.l	d0,(a1)+
		dbf	d1,loc_134A
		rts	
; End of function ClearScreen

; ---------------------------------------------------------------------------
; Subroutine to	pause the game
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PauseGame:				; XREF: Level_MainLoop; et al
		nop
		tst.w	($FFFFF63A).w ;is the game already paused?
		bne.s	PauseGame_AlreadyPaused ;if yes, branch
		move.b	($FFFFF605).w,d0 ;did you press start
		or.b	($FFFFF607).w,d0		 ;on either controller?
		andi.b	#$80,d0
		beq	Pause_DoNothing		 ;if not, branch
		lea	($C00000).l,a6
		move.l	#Art_MText,d1
		move.w	#(ArtTile_Explode*$20),d2
		move.w	#$4FF,d3
		jsr	(QueueDMATransfer).l

	.LoadText:
		move.w	(a5)+,(a6)
		dbf	d1,.LoadText ; load uncompressed text patterns

PauseGame_AlreadyPaused:	
		move.w	#1,($FFFFF63A).w ;unpause the game
		AMPS_MUSPAUSE			; pause music

PauseGameLoop:
		move.b	#$10,($FFFFF62A).w ;re-pause the game (used in slow-mo and frame advance)
		jsr	DelayProgram ;wait...
		cmpi.b	#1,($FFFFF746).w
		beq.s	.noslowmo
		btst	#4,($FFFFF604).w ;did you press a?
		bne.w	Pause_SlowMo ;if so, branch
		btst	#5,($FFFFF605).w ;did you press b?
		bne.w	Pause_SlowMo ;if so, branch

	.noslowmo:
		move.b	#-1,($FFFFF5C0).w
		lea	($FFFFB000).w,a0 ; a0=object
		moveq	#$7F,d7 ; run the first $80 objects out of levels
		jsr		RunObjectsWhilePaused
		jsr		BuildSprites
		move.b	($FFFFF605).w,d0  ;on controller 1?
		or.b	($FFFFF607).w,d0		  ;or 2?
		andi.b	#$80,d0				 ;if not, no change
		beq.s	PauseGameLoop   ;in other words, don't pause
		move.b	($FFFFF746).w,d1
		cmpi.b	#1,d1
		ble.s	.continuelevel
		cmpi.b	#2,d1
		beq.s	.checkpoint
		cmpi.b	#3,d1
		beq.s	.resetlevel
		move.b	#4,($FFFFF600).w ; set game mode to 4 (title screen)
		bra.s	PauseGame1

	.resetlevel:
		move.b	#0,($FFFFFE30).w ; clear lamppost counter

	.checkpoint:
		move.w	#1,($FFFFFE02).w ; restart the level
		clr.w	($FFFFFE2C).w
	;	bra.s	PauseGame1

	.continuelevel:
	;	tst.b	($FFFFF746).w
	;	beq.s	PauseGame1
	;	move.b	($FFFFF5FA),d0
	;	move.b	d0,mQueue+2.w

PauseGame1:
		move.b	#0,($FFFFF5C0).w
		lea	($FFFFB000).w,a0 ; a0=object
		moveq	#$7F,d7 ; run the first $80 objects out of levels
		jsr		RunObjectDisplayOnly
		jsr		BuildSprites
		move.w	#0,($FFFFF63A).w ;unpause the game
		AMPS_MUSUNPAUSE			; unpause music
		lea	($C00000).l,a6
		move.l	#Art_Explode,d1
		move.w	#(ArtTile_Explode*$20),d2
		move.w	#$4FF,d3
		jsr	(QueueDMATransfer).l

Pause_DoNothing:
		rts

Pause_SlowMo:
		move.b	#0,($FFFFF5C0).w
		move.w	#1,($FFFFF63A).w ;unpause the music for a frame	
		AMPS_MUSUNPAUSE			; unpause music
		rts
; End of function PauseGame

; ---------------------------------------------------------------------------
; Subroutine to	display	patterns via the VDP
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowVDPGraphics:			; XREF: SegaScreen; TitleScreen; BS_BGLoad
		lea	($C00000).l,a6
		move.l	#$800000,d4

loc_142C:
		move.l	d0,4(a6)
		move.w	d1,d3

loc_1432:
		move.w	(a1)+,(a6)
		dbf	d3,loc_1432
		add.l	d4,d0
		dbf	d2,loc_142C
		rts	
; End of function ShowVDP
; ---------------------------------------------------------------------------
; Subroutine for queueing VDP commands (seems to only queue transfers to VRAM),
; to be issued the next time ProcessDMAQueue is called.
; Can be called a maximum of 18 times before the buffer needs to be cleared
; by issuing the commands (this subroutine DOES check for overflow)
; ---------------------------------------------------------------------------
; In case you wish to use this queue system outside of the spin dash, this is the
; registers in which it expects data in:
; d1.l: Address to data (In 68k address space)
; d2.w: Destination in VRAM
; d3.w: Length of data
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
 
; sub_144E: DMA_68KtoVRAM: QueueCopyToVRAM: QueueVDPCommand: Add_To_DMA_Queue:
QueueDMATransfer:
		movea.l	($FFFFDCFC).w,a1
		cmpa.w	#-$2304,a1
		beq.s	QueueDMATransfer_Done
		move.w	#-$6D00,d0
		move.b	d3,d0
		move.w	d0,(a1)+
		move.w	#-$6C00,d0
		lsr.w	#8,d3
		move.b	d3,d0
		move.w	d0,(a1)+
		move.w	#-$6B00,d0
		lsr.l	#1,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		move.w	#-$6A00,d0
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		move.w	#-$6900,d0
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+
		andi.l	#$FFFF,d2
		lsl.l	#2,d2
		lsr.w	#2,d2
		swap	d2
		ori.l	#$40000080,d2
		move.l	d2,(a1)+
		move.l	a1,($FFFFDCFC).w
		cmpa.w	#-$2304,a1
		beq.s	QueueDMATransfer_Done
		move.w	#0,(a1)
; return_14AA:
QueueDMATransfer_Done:
		rts
; End of function QueueDMATransfer
 
 
; ---------------------------------------------------------------------------
; Subroutine for issuing all VDP commands that were queued
; (by earlier calls to QueueDMATransfer)
; Resets the queue when it's done
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
 
; sub_14AC: CopyToVRAM: IssueVDPCommands: Process_DMA: Process_DMA_Queue:
ProcessDMAQueue:
		lea	($C00004).l,a5
		lea	($FFFFDC00).w,a1
; loc_14B6:
ProcessDMAQueue_Loop:
		move.w	(a1)+,d0
		beq.s	ProcessDMAQueue_Done ; branch if we reached a stop token
		; issue a set of VDP commands...
		move.w	d0,(a5)		; transfer length
		move.w	(a1)+,(a5)	; transfer length
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; destination
		move.w	(a1)+,(a5)	; destination
		cmpa.w	#-$2304,a1
		bne.s	ProcessDMAQueue_Loop ; loop if we haven't reached the end of the buffer
; loc_14CE:
ProcessDMAQueue_Done:
		move.w	#0,($FFFFDC00).w
		move.l	#-$2400,($FFFFDCFC).w
		rts
; End of function ProcessDMAQueue

; ==============================================================================
; ------------------------------------------------------------------------------
; Nemesis decompression routine
; ------------------------------------------------------------------------------
; Optimized by vladikcomper
; ------------------------------------------------------------------------------
 
NemDec_RAM:
		movem.l d0-a1/a3-a6,-(sp)
		lea	 NemDec_WriteRowToRAM(pc),a3
		bra.s   NemDec_Main
 
; ------------------------------------------------------------------------------
NemDec:
		movem.l d0-a1/a3-a6,-(sp)
		lea	 $C00000,a4			  ; load VDP Data Port	
		lea	 NemDec_WriteRowToVDP(pc),a3
 
NemDec_Main:
		lea	 $FFFFAA00,a1			; load Nemesis decompression buffer
		move.w  (a0)+,d2				; get number of patterns
		bpl.s   .0					  ; are we in Mode 0?
		lea	 $A(a3),a3			   ; if not, use Mode 1
	.0:	
		lsl.w   #3,d2
		movea.w d2,a5
		moveq   #7,d3
		moveq   #0,d2
		moveq   #0,d4
		bsr.w   NemDec4
		move.b  (a0)+,d5				; get first byte of compressed data
		asl.w   #8,d5				   ; shift up by a byte
		move.b  (a0)+,d5				; get second byte of compressed data
		move.w  #$10,d6				 ; set initial shift value
		bsr.s   NemDec2
		movem.l (sp)+,d0-a1/a3-a6
		rts
 
; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, processes the actual compressed data
; ---------------------------------------------------------------------------
 
NemDec2:
		move.w  d6,d7
		subq.w  #8,d7				   ; get shift value
		move.w  d5,d1
		lsr.w   d7,d1				   ; shift so that high bit of the code is in bit position 7
		cmpi.b  #%11111100,d1		   ; are the high 6 bits set?
		bcc.s   NemDec_InlineData	   ; if they are, it signifies inline data
		andi.w  #$FF,d1
		add.w   d1,d1
		sub.b   (a1,d1.w),d6			; ~~ subtract from shift value so that the next code is read next time around
		cmpi.w  #9,d6				   ; does a new byte need to be read?
		bcc.s   .0					  ; if not, branch
		addq.w  #8,d6
		asl.w   #8,d5
		move.b  (a0)+,d5				; read next byte
	.0:	
		move.b  1(a1,d1.w),d1
		move.w  d1,d0
		andi.w  #$F,d1				  ; get palette index for pixel
		andi.w  #$F0,d0
 
NemDec_GetRepeatCount:
		lsr.w   #4,d0				   ; get repeat count
 
NemDec_WritePixel:
		lsl.l   #4,d4				   ; shift up by a nybble
		or.b	d1,d4				   ; write pixel
		dbf	 d3,NemDec_WritePixelLoop; ~~
		jmp	 (a3)					; otherwise, write the row to its destination
; ---------------------------------------------------------------------------
 
NemDec3:
		moveq   #0,d4				   ; reset row
		moveq   #7,d3				   ; reset nybble counter
 
NemDec_WritePixelLoop:
		dbf	 d0,NemDec_WritePixel
		bra.s   NemDec2
; ---------------------------------------------------------------------------
 
NemDec_InlineData:
		subq.w  #6,d6				   ; 6 bits needed to signal inline data
		cmpi.w  #9,d6
		bcc.s   .0
		addq.w  #8,d6
		asl.w   #8,d5
		move.b  (a0)+,d5
	.0:	
		subq.w  #7,d6				   ; and 7 bits needed for the inline data itself
		move.w  d5,d1
		lsr.w   d6,d1				   ; shift so that low bit of the code is in bit position 0
		move.w  d1,d0
		andi.w  #$F,d1				  ; get palette index for pixel
		andi.w  #$70,d0				 ; high nybble is repeat count for pixel
		cmpi.w  #9,d6
		bcc.s   NemDec_GetRepeatCount
		addq.w  #8,d6
		asl.w   #8,d5
		move.b  (a0)+,d5
		bra.s   NemDec_GetRepeatCount
 
; ---------------------------------------------------------------------------
; Subroutines to output decompressed entry
; Selected depending on current decompression mode
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToVDP:
loc_1502:
		move.l  d4,(a4)				 ; write 8-pixel row
		subq.w  #1,a5
		move.w  a5,d4				   ; have all the 8-pixel rows been written?
		bne.s   NemDec3				 ; if not, branch
		rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToVDP_XOR:
		eor.l   d4,d2				   ; XOR the previous row by the current row
		move.l  d2,(a4)				 ; and write the result
		subq.w  #1,a5
		move.w  a5,d4
		bne.s   NemDec3
		rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToRAM:
		move.l  d4,(a4)+				; write 8-pixel row
		subq.w  #1,a5
		move.w  a5,d4				   ; have all the 8-pixel rows been written?
		bne.s   NemDec3				 ; if not, branch
		rts
; ---------------------------------------------------------------------------
 
NemDec_WriteRowToRAM_XOR:
		eor.l   d4,d2				   ; XOR the previous row by the current row
		move.l  d2,(a4)+				; and write the result
		subq.w  #1,a5
		move.w  a5,d4
		bne.s   NemDec3
		rts
 
; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, builds the code table (in RAM)
; ---------------------------------------------------------------------------
 
NemDec4:
		move.b  (a0)+,d0				; read first byte
 
.ChkEnd:
		cmpi.b  #$FF,d0				 ; has the end of the code table description been reached?
		bne.s   .NewPalIndex			; if not, branch
		rts
; ---------------------------------------------------------------------------
 
.NewPalIndex:
		move.w  d0,d7
 
.ItemLoop:
		move.b  (a0)+,d0				; read next byte
		bmi.s   .ChkEnd				 ; ~~
		move.b  d0,d1
		andi.w  #$F,d7				  ; get palette index
		andi.w  #$70,d1				 ; get repeat count for palette index
		or.w	d1,d7				   ; combine the two
		andi.w  #$F,d0				  ; get the length of the code in bits
		move.b  d0,d1
		lsl.w   #8,d1
		or.w	d1,d7				   ; combine with palette index and repeat count to form code table entry
		moveq   #8,d1
		sub.w   d0,d1				   ; is the code 8 bits long?
		bne.s   .ItemShortCode		  ; if not, a bit of extra processing is needed
		move.b  (a0)+,d0				; get code
		add.w   d0,d0				   ; each code gets a word-sized entry in the table
		move.w  d7,(a1,d0.w)			; store the entry for the code
		bra.s   .ItemLoop			   ; repeat
; ---------------------------------------------------------------------------
 
.ItemShortCode:
		move.b  (a0)+,d0				; get code
		lsl.w   d1,d0				   ; shift so that high bit is in bit position 7
		add.w   d0,d0				   ; get index into code table
		moveq   #1,d5
		lsl.w   d1,d5
		subq.w  #1,d5				   ; d5 = 2^d1 - 1
		lea	 (a1,d0.w),a6			; ~~
 
.ItemShortCodeLoop:
		move.w  d7,(a6)+				; ~~ store entry
		dbf	 d5,.ItemShortCodeLoop   ; repeat for required number of entries
		bra.s   .ItemLoop

; ---------------------------------------------------------------------------
; Subroutine to load the art for the animals for the current zone
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadAnimalPLC:
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		cmpi.w	#7,d0
		bhs.s	LoadAnimalPLC_New
		addi.w	#$15,d0
		bra.s	LoadPLC
; ---------------------------------------------------------------------------

LoadAnimalPLC_New:
		subi.w	#7,d0
		; multiply d0 by 3
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		; add $22 (this is the index of the animal PLC for the first added zone)
		addi.w	#$20,d0
		; bra.s	LoadPLC
; End of function LoadAnimalPLC

; ---------------------------------------------------------------------------
; Subroutine to	load pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		lea	($FFFFF680).w,a2

loc_1598:
		tst.l	(a2)
		beq.s	loc_15A0
		addq.w	#6,a2
		bra.s	loc_1598
; ===========================================================================

loc_15A0:				; XREF: LoadPLC
		move.w	(a1)+,d0
		bmi.s	loc_15AC

loc_15A4:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15A4

loc_15AC:
		movem.l	(sp)+,a1-a2
		rts	
; End of function LoadPLC


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadPLC2:
		movem.l	a1-a2,-(sp)
		lea	(ArtLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		bsr.s	ClearPLC
		lea	($FFFFF680).w,a2
		move.w	(a1)+,d0
		bmi.s	loc_15D8

loc_15D0:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		dbf	d0,loc_15D0

loc_15D8:
		movem.l	(sp)+,a1-a2
		rts	
; End of function LoadPLC2

; ---------------------------------------------------------------------------
; Subroutine to	clear the pattern load cues
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearPLC:				; XREF: LoadPLC2
		lea	($FFFFF680).w,a2
		moveq	#$1F,d0

ClearPLC_Loop:
		clr.l	(a2)+
		dbf	d0,ClearPLC_Loop
		rts	
; End of function ClearPLC

; ---------------------------------------------------------------------------
; Subroutine to	use graphics listed in a pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_RAM:				; XREF: Pal_FadeTo
		tst.l	($FFFFF680).w
		beq.s	locret_1640
		tst.w	($FFFFF6F8).w
		bne.s	locret_1640
		movea.l	($FFFFF680).w,a0
		lea	(loc_1502).l,a3
		lea	($FFFFAA00).w,a1
		move.w	(a0)+,d2
		bpl.s	loc_160E
		adda.w	#$A,a3

loc_160E:
		andi.w	#$7FFF,d2
		move.w	d2,($FFFFF6F8).w
		bsr.w	NemDec4
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5
		moveq	#$10,d6
		moveq	#0,d0
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d0,($FFFFF6E8).w
		move.l	d0,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w

locret_1640:
		rts	
; End of function RunPLC_RAM


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1642:				; XREF: loc_C44; loc_F54; loc_F9A
		tst.w	($FFFFF6F8).w
		beq.w	locret_16DA
		move.w	#9,($FFFFF6FA).w
		moveq	#0,d0
		move.w	($FFFFF684).w,d0
		addi.w	#$120,($FFFFF684).w
		bra.s	loc_1676
; End of function sub_1642


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_165E:				; XREF: Demo_Time
		tst.w	($FFFFF6F8).w
		beq.s	locret_16DA
		move.w	#3,($FFFFF6FA).w
		moveq	#0,d0
		move.w	($FFFFF684).w,d0
		addi.w	#$60,($FFFFF684).w

loc_1676:				; XREF: sub_1642
		lea	($C00004).l,a4
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,(a4)
		subq.w	#4,a4
		movea.l	($FFFFF680).w,a0
		movea.l	($FFFFF6E0).w,a3
		move.l	($FFFFF6E4).w,d0
		move.l	($FFFFF6E8).w,d1
		move.l	($FFFFF6EC).w,d2
		move.l	($FFFFF6F0).w,d5
		move.l	($FFFFF6F4).w,d6
		lea	($FFFFAA00).w,a1

loc_16AA:				; XREF: sub_165E
		movea.w	#8,a5
		bsr.w	NemDec3
		subq.w	#1,($FFFFF6F8).w
		beq.s	loc_16DC
		subq.w	#1,($FFFFF6FA).w
		bne.s	loc_16AA
		move.l	a0,($FFFFF680).w
		move.l	a3,($FFFFF6E0).w
		move.l	d0,($FFFFF6E4).w
		move.l	d1,($FFFFF6E8).w
		move.l	d2,($FFFFF6EC).w
		move.l	d5,($FFFFF6F0).w
		move.l	d6,($FFFFF6F4).w

locret_16DA:				; XREF: sub_1642
		rts	
; ===========================================================================

loc_16DC:			; XREF: sub_165E
		lea	($FFFFF680).w,a0
		lea	6(a0),a1
		moveq	#$E,d0		; do $F cues

loc_16E2:				; XREF: sub_165E
		move.l	(a1)+,(a0)+
		move.w	(a1)+,(a0)+
		dbf	d0,loc_16E2

		moveq	#0,d0
		move.l	d0,(a0)+	; clear the last cue to avoid overcopying it
		move.w	d0,(a0)+	;
		rts

; End of function sub_165E

; ---------------------------------------------------------------------------
; Subroutine to	execute	the pattern load cue
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RunPLC_ROM:
		lea	(ArtLoadCues).l,a1 ; load the PLC index
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		move.w	(a1)+,d1	; load number of entries in the	PLC

RunPLC_Loop:
		movea.l	(a1)+,a0	; get art pointer
		moveq	#0,d0
		move.w	(a1)+,d0	; get VRAM address
		lsl.l	#2,d0		; divide address by $20
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,($C00004).l	; put the VRAM address into VDP
		bsr.w	NemDec		; decompress
		dbf	d1,RunPLC_Loop	; loop for number of entries
		rts	
; End of function RunPLC_ROM

; ---------------------------------------------------------------------------
; Enigma decompression algorithm
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


EniDec:
		movem.l	d0-d7/a1-a5,-(sp)
		movea.w	d0,a3
		move.b	(a0)+,d0
		ext.w	d0
		movea.w	d0,a5
		move.b	(a0)+,d4
		lsl.b	#3,d4
		movea.w	(a0)+,a2
		adda.w	a3,a2
		movea.w	(a0)+,a4
		adda.w	a3,a4
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5
		moveq	#$10,d6

loc_173E:				; XREF: loc_1768
		moveq	#7,d0
		move.w	d6,d7
		sub.w	d0,d7
		move.w	d5,d1
		lsr.w	d7,d1
		andi.w	#$7F,d1
		move.w	d1,d2
		cmpi.w	#$40,d1
		bcc.s	loc_1758
		moveq	#6,d0
		lsr.w	#1,d2

loc_1758:
		bsr.w	sub_188C
		andi.w	#$F,d2
		lsr.w	#4,d1
		add.w	d1,d1
		jmp	loc_17B4(pc,d1.w)
; End of function EniDec

; ===========================================================================

loc_1768:				; XREF: loc_17B4
		move.w	a2,(a1)+
		addq.w	#1,a2
		dbf	d2,loc_1768
		bra.s	loc_173E
; ===========================================================================

loc_1772:				; XREF: loc_17B4
		move.w	a4,(a1)+
		dbf	d2,loc_1772
		bra.s	loc_173E
; ===========================================================================

loc_177A:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_177E:
		move.w	d1,(a1)+
		dbf	d2,loc_177E
		bra.s	loc_173E
; ===========================================================================

loc_1786:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_178A:
		move.w	d1,(a1)+
		addq.w	#1,d1
		dbf	d2,loc_178A
		bra.s	loc_173E
; ===========================================================================

loc_1794:				; XREF: loc_17B4
		bsr.w	loc_17DC

loc_1798:
		move.w	d1,(a1)+
		subq.w	#1,d1
		dbf	d2,loc_1798
		bra.s	loc_173E
; ===========================================================================

loc_17A2:				; XREF: loc_17B4
		cmpi.w	#$F,d2
		beq.s	loc_17C4

loc_17A8:
		bsr.w	loc_17DC
		move.w	d1,(a1)+
		dbf	d2,loc_17A8
		bra.s	loc_173E
; ===========================================================================

loc_17B4:				; XREF: EniDec
		bra.s	loc_1768
; ===========================================================================
		bra.s	loc_1768
; ===========================================================================
		bra.s	loc_1772
; ===========================================================================
		bra.s	loc_1772
; ===========================================================================
		bra.s	loc_177A
; ===========================================================================
		bra.s	loc_1786
; ===========================================================================
		bra.s	loc_1794
; ===========================================================================
		bra.s	loc_17A2
; ===========================================================================

loc_17C4:				; XREF: loc_17A2
		subq.w	#1,a0
		cmpi.w	#$10,d6
		bne.s	loc_17CE
		subq.w	#1,a0

loc_17CE:
		move.w	a0,d0
		lsr.w	#1,d0
		bcc.s	loc_17D6
		addq.w	#1,a0

loc_17D6:
		movem.l	(sp)+,d0-d7/a1-a5
		rts	
; ===========================================================================

loc_17DC:				; XREF: loc_17A2
		move.w	a3,d3
		move.b	d4,d1
		add.b	d1,d1
		bcc.s	loc_17EE
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_17EE
		ori.w	#-$8000,d3

loc_17EE:
		add.b	d1,d1
		bcc.s	loc_17FC
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_17FC
		addi.w	#$4000,d3

loc_17FC:
		add.b	d1,d1
		bcc.s	loc_180A
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_180A
		addi.w	#$2000,d3

loc_180A:
		add.b	d1,d1
		bcc.s	loc_1818
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_1818
		ori.w	#$1000,d3

loc_1818:
		add.b	d1,d1
		bcc.s	loc_1826
		subq.w	#1,d6
		btst	d6,d5
		beq.s	loc_1826
		ori.w	#$800,d3

loc_1826:
		move.w	d5,d1
		move.w	d6,d7
		sub.w	a5,d7
		bcc.s	loc_1856
		move.w	d7,d6
		addi.w	#$10,d6
		neg.w	d7
		lsl.w	d7,d1
		move.b	(a0),d5
		rol.b	d7,d5
		add.w	d7,d7
		and.w	word_186C-2(pc,d7.w),d5
		add.w	d5,d1

loc_1844:				; XREF: loc_1868
		move.w	a5,d0
		add.w	d0,d0
		and.w	word_186C-2(pc,d0.w),d1
		add.w	d3,d1
		move.b	(a0)+,d5
		lsl.w	#8,d5
		move.b	(a0)+,d5
		rts	
; ===========================================================================

loc_1856:				; XREF: loc_1826
		beq.s	loc_1868
		lsr.w	d7,d1
		move.w	a5,d0
		add.w	d0,d0
		and.w	word_186C-2(pc,d0.w),d1
		add.w	d3,d1
		move.w	a5,d0
		bra.s	sub_188C
; ===========================================================================

loc_1868:				; XREF: loc_1856
		moveq	#$10,d6

loc_186A:
		bra.s	loc_1844
; ===========================================================================
word_186C:	dc.w 1,	3, 7, $F, $1F, $3F, $7F, $FF, $1FF, $3FF, $7FF
		dc.w $FFF, $1FFF, $3FFF, $7FFF,	$FFFF	; XREF: loc_1856

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_188C:				; XREF: EniDec
		sub.w	d0,d6
		cmpi.w	#9,d6
		bcc.s	locret_189A
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5

locret_189A:
		rts	
; End of function sub_188C

; ===========================================================================
; ---------------------------------------------------------------------------
; Kosinski decompression routine
;
; Created by vladikcomper
; Special thanks to flamewing and MarkeyJester
; ---------------------------------------------------------------------------

KosDec:
		moveq   #7,d7
		moveq   #0,d0
		moveq   #0,d1
		lea	 KosDec_ByteMap(pc),a4
		move.b  (a0)+,d0						; get desc field low-byte
		move.b  (a0)+,d1						; get desc field hi-byte
		move.b  (a4,d0.w),d0					; reload converted desc. bitfield from a LUT
		move.b  (a4,d1.w),d1					;
		moveq   #7,d2						   ; set repeat count to 8
		moveq   #-1,d3						  ; d3 will be desc field switcher
		clr.w   d3							  ;
		bra.s   KosDec_FetchNewCode
 
KosDec_FetchCodeLoop:
		; code 1 (Uncompressed byte)
		_Kos_RunBitStream
		move.b  (a0)+,(a1)+
 
KosDec_FetchNewCode:
		add.b   d0,d0						   ; get a bit from the bitstream
		bcs.s   KosDec_FetchCodeLoop			; if code = 0, branch
 
		; codes 00 and 01
		_Kos_RunBitStream
		moveq   #0,d4						   ; d4 will contain copy count
		add.b   d0,d0						   ; get a bit from the bitstream
		bcs.s   KosDec_Code_01
 
		; code 00 (Dictionary ref. short)
		_Kos_RunBitStream
		add.b   d0,d0						   ; get a bit from the bitstream
		addx.w  d4,d4
		_Kos_RunBitStream
		add.b   d0,d0						   ; get a bit from the bitstream
		addx.w  d4,d4
		_Kos_RunBitStream
		moveq   #-1,d5
		move.b  (a0)+,d5						; d5 = displacement
 
KosDec_StreamCopy:
		lea	 (a1,d5),a3
		move.b  (a3)+,(a1)+					 ; do 1 extra copy (to compensate for +1 to copy counter)
 
KosDec_copy:
		move.b  (a3)+,(a1)+
		dbf	 d4,KosDec_copy
		bra.w   KosDec_FetchNewCode
; ---------------------------------------------------------------------------
KosDec_Code_01:
		; code 01 (Dictionary ref. long / special)
		_Kos_RunBitStream
		move.b  (a0)+,d6						; d6 = %LLLLLLLL
		move.b  (a0)+,d4						; d4 = %HHHHHCCC
		moveq   #-1,d5
		move.b  d4,d5						   ; d5 = %11111111 HHHHHCCC
		lsl.w   #5,d5						   ; d5 = %111HHHHH CCC00000
		move.b  d6,d5						   ; d5 = %111HHHHH LLLLLLLL
		and.w   d7,d4						   ; d4 = %00000CCC
		bne.s   KosDec_StreamCopy			   ; if CCC=0, branch
 
		; special mode (extended counter)
		move.b  (a0)+,d4						; read cnt
		beq.s   KosDec_Quit					 ; if cnt=0, quit decompression
		subq.b  #1,d4
		beq.w   KosDec_FetchNewCode			 ; if cnt=1, fetch a new code
 
		lea	 (a1,d5),a3
		move.b  (a3)+,(a1)+					 ; do 1 extra copy (to compensate for +1 to copy counter)
		move.w  d4,d6
		not.w   d6
		and.w   d7,d6
		add.w   d6,d6
		lsr.w   #3,d4
		jmp	 KosDec_largecopy(pc,d6.w)
 
KosDec_largecopy:
		rept 8
		move.b  (a3)+,(a1)+
		endr
		dbf	 d4,KosDec_largecopy
		bra.w   KosDec_FetchNewCode
 
KosDec_Quit:
		rts
 
; ---------------------------------------------------------------------------
; A look-up table to invert bits order in desc. field bytes
; ---------------------------------------------------------------------------
 
KosDec_ByteMap:
		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF

; ===============================================================
; ---------------------------------------------------------------
; COMPER Decompressor
; ---------------------------------------------------------------
; INPUT:
;	a0	- Source Offset
;	a1	- Destination Offset
; ---------------------------------------------------------------

CompDec

.newblock
	move.w	(a0)+,d0		; fetch description field
	moveq	#15,d3			; set bits counter to 16

.mainloop
	add.w	d0,d0			; roll description field
	bcs.s	.flag			; if a flag issued, branch
	move.w	(a0)+,(a1)+		; otherwise, do uncompressed data
	dbf	d3,.mainloop		; if bits counter remains, parse the next word
	bra.s	.newblock		; start a new block

; ---------------------------------------------------------------
.flag	moveq	#-1,d1			; init displacement
	move.b	(a0)+,d1		; load displacement
	add.w	d1,d1
	moveq	#0,d2			; init copy count
	move.b	(a0)+,d2		; load copy length
	beq.s	.end			; if zero, branch
	lea	(a1,d1),a2		; load start copy address

.loop	move.w	(a2)+,(a1)+		; copy given sequence
	dbf	d2,.loop		; repeat
	dbf	d3,.mainloop		; if bits counter remains, parse the next word
	bra.s	.newblock		; start a new block

.end	rts

; ---------------------------------------------------------------------------
; Pallet cycling routine loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Load:				; XREF: Demo; Level_MainLoop; End_MainLoop
		moveq	#0,d2
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0 ; get level number
		add.w	d0,d0		; multiply by 2
		move.w	PalCycle(pc,d0.w),d0 ; load animated pallets offset index into d0
		jmp	PalCycle(pc,d0.w) ; jump to PalCycle + offset index
; End of function PalCycle_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet cycling routines
; ---------------------------------------------------------------------------
PalCycle:	dc.w PalCycle_AAZ-PalCycle
		dc.w PalCycle_BBZ-PalCycle
		dc.w PalCycle_CCZ-PalCycle
		dc.w PalCycle_DDZ-PalCycle
		dc.w PalCycle_EEZ-PalCycle
		dc.w PalCycle_FFZ-PalCycle
		dc.w PalCycle_GGZ-PalCycle
		dc.w PalCycle_SSZ-PalCycle

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Title:				; XREF: TitleScreen
		rts	
; End of function PalCycle_Title

; ===========================================================================

PalCycle_BBZ:				; XREF: PalCycle
		lea	(Pal_BBZCyc).l,a0

loc_196A:				; XREF: PalCycle_Title
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1990
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB42).w,a1
		lea	($FFFFFAC2).w,a2
		move.l	(a0,d0.w),(a1)+
		move.l	(a0,d0.w),(a2)+
		move.l	4(a0,d0.w),(a1)
		move.l	4(a0,d0.w),(a2)

locret_1990:
		rts	
; End of function PalCycle_BBZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_EEZ:				; XREF: PalCycle
		lea	(Pal_BBZCyc).l,a0
		subq.w	#1,($FFFFF634).w
		bpl.s	PalCycle_EEZ2
		move.w	#5,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB44).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

PalCycle_EEZ2:
		rts	

PalCycle_AAZ:				; XREF: PalCycle
		rts
		subq.w	#1,($FFFFF634).w
		bpl.s	locret7_1990
		move.w	#5,($FFFFF634).w
		lea	(Pal_AAZCyc).l,a0
		move.w	($FFFFF632).w,d0
		subq.w	#2,($FFFFF632).w
		tst.w	($FFFFF632).w
		bgt.s	.AAZ
		move.w	#6,($FFFFF632).w

.AAZ:
		lea	($FFFFFB42).w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	4(a0,d0.w),(a1)

locret7_1990:
		rts	

PalCycle_FFZ:				; XREF: PalCycle
		lea	(Pal_BBZCyc).l,a0
		subq.w	#1,($FFFFF634).w
		bpl.s	locret3_1990
		move.w	#3,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		subq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB44).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		lea	($FFFFFAC4).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

locret3_1990:
		rts	
; End of function PalCycle_FFZ

PalCycle_SSZ:
		rts

PalCycle_CCZ:
		rts

PalCycle_GGZ:
		rts

PalCycle_DDZ:
		rts

; ===========================================================================
Pal_BBZCyc:	incbin	pallet\c_BBZ.bin
Pal_AAZCyc:	incbin	pallet\c_AAZ.bin

; ---------------------------------------------------------------------------
; Subroutine to	fade out and fade in
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_FadeTo:
		move.w	#$3F,($FFFFF626).w
 
Pal_FadeTo2:
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		moveq	#0,d1
		move.b	($FFFFF627).w,d0
 
Pal_ToBlack:
		move.w	d1,(a0)+
		dbf	d0,Pal_ToBlack	; fill pallet with $000	(black)
		moveq	#$0E,d4					; MJ: prepare maximum colour check
		moveq	#$00,d6					; MJ: clear d6
 
loc_1DCE:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1DCE				; MJ: if null, delay a frame
		bsr.s	Pal_FadeIn
		subq.b	#$02,d4					; MJ: decrease colour check
		bne	loc_1DCE				; MJ: if it has not reached null, branch
		move.b	#$12,($FFFFF62A).w			; MJ: wait for V-blank again (so colours transfer)
		bra	DelayProgram				; MJ: ''
 
; End of function Pal_FadeTo
 
; ---------------------------------------------------------------------------
; Pallet fade-in subroutine
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeIn:				; XREF: Pal_FadeTo
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		lea	($FFFFFB80).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1DFA:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1DFA
		cmpi.b	#1,($FFFFFE10).w
		beq.s	.BBZ
		tst.b 	(Water_Flag).w
		beq.s	locret_1E24

	.BBZ:
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1E1E:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1E1E
 
locret_1E24:
		rts	
; End of function Pal_FadeIn
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_AddColor:				; XREF: Pal_FadeIn
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bhi	FCI_NoBlue				; MJ: if not, branch
		addi.w	#$0200,d3				; MJ: increase blue
 
FCI_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bhi	FCI_NoGreen				; MJ: if not, branch
		addi.b	#$20,d3					; MJ: increase green
 
FCI_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bhi	FCI_NoRed				; MJ: if not, branch
		addq.b	#$02,d3					; MJ: increase red
 
FCI_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return
 
; End of function Pal_AddColor
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeFrom:
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6
 
loc_1E5C:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1E5C				; MJ: if null, delay a frame
		bsr.s	Pal_FadeOut
		dbf	d4,loc_1E5C
		rts	
; End of function Pal_FadeFrom
 
; ---------------------------------------------------------------------------
; Pallet fade-out subroutine
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_FadeOut:				; XREF: Pal_FadeFrom
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1E82:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E82
 
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1E98:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E98
		rts	
; End of function Pal_FadeOut
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Pal_DecColor:				; XREF: Pal_FadeOut
		move.w	(a0),d5					; MJ: load colour
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		beq	FCO_NoBlue				; MJ: if blue is finished, branch
		subi.w	#$0200,d5				; MJ: decrease blue
 
FCO_NoBlue:
		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		beq	FCO_NoGreen				; MJ: if green is finished, branch
		subi.b	#$20,d5					; MJ: decrease green
 
FCO_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		beq	FCO_NoRed				; MJ: if red is finished, branch
		subq.b	#$02,d5					; MJ: decrease red
 
FCO_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return
 
; End of function Pal_DecColor

; ---------------------------------------------------------------------------
; Subroutine to	fill the pallet	with white (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeWhite:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.w	#$EEE,d1
		move.b	($FFFFF627).w,d0
 
PalWhite_Loop:
		move.w	d1,(a0)+
		dbf	d0,PalWhite_Loop	; fill pallet with $000	(black)
		moveq	#$0E,d4					; MJ: prepare maximum colour check
		moveq	#$00,d6					; MJ: clear d6
 
loc_1EF4:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1EF4				; MJ: if null, delay a frame
		bsr.s	Pal_WhiteToBlack
		subq.b	#$02,d4					; MJ: decrease colour check
		bne	loc_1EF4				; MJ: if it has not reached null, branch
		move.b	#$12,($FFFFF62A).w			; MJ: wait for V-blank again (so colours transfer)
		bra	DelayProgram				; MJ: ''
; End of function Pal_MakeWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_WhiteToBlack:			; XREF: Pal_MakeWhite
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		lea	($FFFFFB80).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1F20:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F20
		cmpi.b	#1,($FFFFFE10).w
		beq.s	.BBZ
		tst.b 	(Water_Flag).w
		beq.s	locret_1F4A

	.BBZ:
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0
 
loc_1F44:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F44
 
locret_1F4A:
		rts	
; End of function Pal_WhiteToBlack


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_DecColor2:				; XREF: Pal_WhiteToBlack
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bls	FCI2_NoBlue				; MJ: if not, branch
		subi.w	#$0200,d3				; MJ: dencrease blue
 
FCI2_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bls	FCI2_NoGreen				; MJ: if not, branch
		subi.b	#$20,d3					; MJ: dencrease green
 
FCI2_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bls	FCI2_NoRed				; MJ: if not, branch
		subq.b	#$02,d3					; MJ: dencrease red
 
FCI2_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return
; End of function Pal_DecColor2

; ---------------------------------------------------------------------------
; Subroutine to	make a white flash when	you enter a special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_MakeFlash:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6
 
loc_1F86:
		bsr.w	RunPLC_RAM
		move.b	#$12,($FFFFF62A).w
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1F86				; MJ: if null, delay a frame
		bsr.s	Pal_ToWhite
		dbf	d4,loc_1F86
		rts	
; End of function Pal_MakeFlash


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_ToWhite:				; XREF: Pal_MakeFlash
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1FAC:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FAC
 
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0
 
loc_1FC2:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FC2
		rts		
; End of function Pal_ToWhite


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Pal_AddColor2:				; XREF: Pal_ToWhite
		move.w	(a0),d5					; MJ: load colour
		cmpi.w	#$EEE,d5
		beq.s	FCO2_NoRed
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		cmpi.w	#$0E00,d1
		beq	FCO2_NoBlue				; MJ: if blue is finished, branch
		addi.w	#$0200,d5				; MJ: increase blue
 
FCO2_NoBlue:
		andi.w	#$00E0,d2				; MJ: get only green (needs to be word)
		cmpi.w	#$00E0,d2
		beq	FCO2_NoGreen				; MJ: if green is finished, branch
		addi.b	#$20,d5					; MJ: increase green
 
FCO2_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		cmpi.b	#$0E,d3
		beq	FCO2_NoRed				; MJ: if red is finished, branch
		addq.b	#$02,d5					; MJ: increase red
 
FCO2_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return
; End of function Pal_AddColor2

; ---------------------------------------------------------------------------
; Subroutines to load pallets
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad1:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		adda.w	#$80,a3
		move.w	(a1)+,d7

loc_2110:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2110
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad2:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		move.w	(a1)+,d7

loc_2128:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2128
		rts	
; End of function PalLoad2

; ---------------------------------------------------------------------------
; Underwater pallet loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad3_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$100,a3
		move.w	(a1)+,d7

loc_2144:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2144
		rts	
; End of function PalLoad3_Water


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad4_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$80,a3
		move.w	(a1)+,d7

loc_2160:
		move.l	(a2)+,(a3)+
		dbf	d7,loc_2160
		rts	
; End of function PalLoad4_Water
; ===========================================================================
; ---------------------------------------------------------------------------
; Pallet pointers
; ---------------------------------------------------------------------------
PalPointers:
	dc.l Pal_SegaBG		; pallet address
	dc.w $FB00		; RAM address
	dc.w $1F		; (pallet length / 2) - 1
	dc.l Pal_Title	;1
	dc.w $FB00
	dc.w $1F
	dc.l Pal_LevelSel	;2
	dc.w $FB00
	dc.w $1F
	dc.l Pal_Sonic	;3
	dc.w $FB00
	dc.w 7
	dc.l Pal_AAZ	;4
	dc.w $FB20
	dc.w $17
	dc.l Pal_AAZ	;5
	dc.w $FB20
	dc.w $17
	dc.l Pal_CCZ	;6
	dc.w $FB20
	dc.w $17
	dc.l Pal_DDZ	;7
	dc.w $FB20
	dc.w $17
	dc.l Pal_EEZ	;8
	dc.w $FB20
	dc.w $17
	dc.l Pal_FFZ	;9
	dc.w $FB20
	dc.w $17
	dc.l Pal_Special	;A
	dc.w $FB20
	dc.w $17
	dc.l Pal_Silver	;B
	dc.w $FB00
	dc.w 7
	dc.l Pal_SilSon	;C
	dc.w $FB00
	dc.w 7
	dc.l Pal_SilKnu	;D
	dc.w $FB00
	dc.w 7
	dc.l Pal_SilSha	;E
	dc.w $FB00
	dc.w 7
	dc.l Pal_Knux	;F
	dc.w $FB00
	dc.w 7
	dc.l Pal_KnuTai	;10
	dc.w $FB00
	dc.w 7
	dc.l Pal_AAZ	;11
	dc.w $FB00
	dc.w $1F
	dc.l Pal_AAZ	;12
	dc.w $FB00
	dc.w $F
	dc.l Pal_GSilSha	;13
	dc.w $FB00
	dc.w 7
	dc.l Menu_Palette	;14
	dc.w $FB00
	dc.w $1F
	dc.l Pal_Shadow	;15
	dc.w $FB00
	dc.w 7
	dc.l Pal_ShaTai	;16
	dc.w $FB00
	dc.w 7
	dc.l Pal_ShaKnu	;17
	dc.w $FB00
	dc.w 7
	dc.l Pal_GGZ	;18
	dc.w $FB20
	dc.w $17
	dc.l Pal_SSZ	;19
	dc.w $FB20
	dc.w $17
	dc.l Pal_WSonic	;1A
	dc.w $FB00
	dc.w 7
	dc.l Pal_Eggman	;1B
	dc.w $FB20
	dc.w 7
	dc.l Pal_WSilver	;1C
	dc.w $FB00
	dc.w 7
	dc.l Pal_WSilSon	;1D
	dc.w $FB00
	dc.w 7
	dc.l Pal_WSilKnu	;1E
	dc.w $FB00
	dc.w 7
	dc.l Pal_WSilSha	;1F
	dc.w $FB00
	dc.w 7
	dc.l Pal_WKnux	;20
	dc.w $FB00
	dc.w 7
	dc.l Pal_WKnuTai	;21
	dc.w $FB00
	dc.w 7
	dc.l Pal_WShadow	;22
	dc.w $FB00
	dc.w 7
	dc.l Pal_WShaTai	;23
	dc.w $FB00
	dc.w 7
	dc.l Pal_WShaKnu	;24
	dc.w $FB00
	dc.w 7
	dc.l Pal_GSilver	;25
	dc.w $FB00
	dc.w 7
	dc.l Pal_GSilSon	;26
	dc.w $FB00
	dc.w 7
	dc.l Pal_GSilKnu	;27
	dc.w $FB00
	dc.w 7

; ---------------------------------------------------------------------------
; Pallet data
; ---------------------------------------------------------------------------
Pal_SegaBG:	incbin	pallet\sega_bg.bin
Pal_Title:	incbin	pallet\title.bin
Pal_LevelSel:	incbin	pallet\levelsel.bin
Pal_Sonic:	incbin	pallet\sonic.bin
Pal_Silver:	incbin	pallet\silver.bin
Pal_SilSon:	incbin	pallet\silversonic.bin
Pal_SilKnu:	incbin	pallet\silverknux.bin
Pal_SilSha:	incbin	pallet\silvershadow.bin
Pal_Shadow:	incbin	pallet\shadow.bin
Pal_ShaTai:	incbin	pallet\shadowtails.bin
Pal_ShaKnu:	incbin	pallet\shadowknux.bin
Pal_Knux:	incbin	pallet\knux.bin
Pal_KnuTai:	incbin	pallet\knuxtails.bin
Pal_BBZ:	incbin	pallet\BBZ.bin
Pal_BBZ2:	incbin	pallet\BBZ2.bin
Pal_EEZ:		incbin	pallet\EEZ.bin
Pal_AAZ:	incbin	pallet\AAZ.bin
Pal_FFZ:	incbin	pallet\FFZ.bin	; FFZ act 1 pallets
Pal_FFZWater:	incbin	pallet\FFZ_uw.bin	; FFZ act 2 & Final Zone pallets
Pal_Special:	incbin	pallet\special.bin	; special stage pallets
Pal_SSZ:	incbin	pallet\ssz.bin
Pal_CCZ:	incbin	pallet\CCZ.bin
Pal_GGZ:	incbin	pallet\GGZ.bin
Pal_DDZ:	incbin	pallet\DDZ.bin
Pal_Eggman:	incbin	pallet\eggman.bin
Pal_WSonic:	incbin	pallet\wsonic.bin
Pal_WSilver:	incbin	pallet\wsilver.bin
Pal_WSilSon:	incbin	pallet\wsilversonic.bin
Pal_WSilKnu:	incbin	pallet\wsilverknux.bin
Pal_WSilSha:	incbin	pallet\wsilvershadow.bin
Pal_WShadow:	incbin	pallet\wshadow.bin
Pal_WShaTai:	incbin	pallet\wshadowtails.bin
Pal_WShaKnu:	incbin	pallet\wshadowknux.bin
Pal_WKnux:	incbin	pallet\wknux.bin
Pal_WKnuTai:	incbin	pallet\wknuxtails.bin
Pal_GSilver:	incbin	pallet\gsilver.bin
Pal_GSilSon:	incbin	pallet\gsilversonic.bin
Pal_GSilKnu:	incbin	pallet\gsilverknux.bin
Pal_GSilSha:	incbin	pallet\gsilvershadow.bin
Pal_TitleGrad:	incbin	pallet\titlegrad.bin
Pal_TitleGrad2:	incbin	pallet\titlegrad2.bin

; ---------------------------------------------------------------------------
; Subroutine to	delay the program by ($FFFFF62A) frames
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DelayProgram:				; XREF: PauseGame
		move	#$2300,sr

loc_29AC:
		tst.b	($FFFFF62A).w
		bne.s	loc_29AC
		rts	
; End of function DelayProgram

; ---------------------------------------------------------------------------
; Subroutine to	generate a pseudo-random number	in d0
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


RandomNumber:
		move.l	($FFFFF636).w,d1
		bne.s	loc_29C0
		move.l	#$2A6D365A,d1

loc_29C0:
		move.l	d1,d0
		asl.l	#2,d1
		add.l	d0,d1
		asl.l	#3,d1
		add.l	d0,d1
		move.w	d1,d0
		swap	d1
		add.w	d1,d0
		move.w	d0,d1
		swap	d1
		move.l	d1,($FFFFF636).w
		rts	
; End of function RandomNumber


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcSine:
        andi.w  #$FF,d0
        addq.w  #8,d0
        add.w   d0,d0
        move.w  Sine_Data+($40*2)-16(pc,d0.w),d1
        move.w  Sine_Data-16(pc,d0.w),d0
        rts
; End of function CalcSine

; ===========================================================================

Sine_Data:	incbin	misc\sinewave.bin	; values for a 360ยบ sine wave

; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcAngle:
		movem.l	d3-d4,-(sp)
		moveq	#0,d3
		moveq	#0,d4
		move.w	d1,d3
		move.w	d2,d4
		or.w	d3,d4
		beq.s	loc_2D04
		move.w	d2,d4
		tst.w	d3
		bpl.w	loc_2CC2
		neg.w	d3

loc_2CC2:
		tst.w	d4
		bpl.w	loc_2CCA
		neg.w	d4

loc_2CCA:
		cmp.w	d3,d4
		bcc.w	loc_2CDC
		lsl.l	#8,d4
		divu.w	d3,d4
		moveq	#0,d0
		move.b	Angle_Data(pc,d4.w),d0
		bra.s	loc_2CE6
; ===========================================================================

loc_2CDC:				; XREF: CalcAngle
		lsl.l	#8,d3
		divu.w	d4,d3
		moveq	#$40,d0
		sub.b	Angle_Data(pc,d3.w),d0

loc_2CE6:
		tst.w	d1
		bpl.w	loc_2CF2
		neg.w	d0
		addi.w	#$80,d0

loc_2CF2:
		tst.w	d2
		bpl.w	loc_2CFE
		neg.w	d0
		addi.w	#$100,d0

loc_2CFE:
		movem.l	(sp)+,d3-d4
		rts	
; ===========================================================================

loc_2D04:				; XREF: CalcAngle
		move.w	#$40,d0
		movem.l	(sp)+,d3-d4
		rts	
; End of function CalcAngle

; ===========================================================================

Angle_Data:	incbin	misc\angles.bin

; ===========================================================================

; ---------------------------------------------------------------------------
; Sega screen
; ---------------------------------------------------------------------------

SegaScreen:			; XREF: GameModeArray
		lea	($FFFFFB80).w,a1
		moveq	#0,d0
		move.w	#$1F,d1

SS_Clr:
		move.l	d0,(a1)+
		dbf	d1,SS_Clr ; fill pallet with 0	(black)
		command	mus_Stop	; stop music
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8200+($C000>>10),(a6)	; set foreground nametable address
		move.w	#$8400+($E000>>13),(a6)	; set background nametable address
		move.w	#$8700,(a6)			; set background colour (palette entry 0)
		move.w	#$8B00,(a6)			; full-screen vertical scrolling
		move.w	#$8134,(a6)			; disable display
		move.w	#$8C81,(a6)
		clr.b	($FFFFF64E).w
		move	#$2700,sr
		bsr.w	ClearScreen
		vram	$20
		lea	(Nem_SegaLogo).l,a0		; load Sega logo patterns on tile #1
		bsr.w	NemDec
		lea	($FF0000).l,a1
		lea	(Eni_SegaLogo).l,a0		; load Sega logo mappings
		moveq	#1,d0				; start from tile #1
		bsr.w	EniDec
		copyTilemap	$FF0000,($E61E),((96/8)-1),((32/8)-1)

		tst.b   ($FFFFFFF8).w			; is console Japanese?
		bpl.s   .jmp0				; if yes, branch
		vram	($C634),4(a6)		; set position to write to..
		move.l	#$00310032,(a6)			; and write "TM"
.jmp0:		move.w	#$EEE,($FFFFFB82).w
		move.w	#-2,($FFFFF632).w			; minus size of an entry
		move.w	#1,($FFFFF634).w

		lea	($FFFFFB84).w,a1
		bsr	Palcycle_Sega
		move.w	#$8174,$C00004			; enable display
		bsr.w	Pal_FadeTo
		music	mus_SEGA			; play "SEGA" sound
		move.w	#3*60,($FFFFF614).w		; stay for 3 seconds

Sega_WaitEnd:
		move.b	#2,($FFFFF62A).w
		bsr.w	DelayProgram
		lea	($FFFFFB04).w,a1
		bsr	Palcycle_Sega
		tst.w	($FFFFF614).w
		beq.s	Sega_GotoTitle
		andi.b	#$80,($FFFFF605).w	; is Start button pressed?
		beq.s	Sega_WaitEnd			; if not, branch

Sega_GotoTitle:
		move.b	#$40,($FFFFFFEE).w
		move.b	#sfx_FMJump,($FFFFFFF6).w
		move.b	#4,($FFFFF600).w			; set screen mode to "SSRG Screen"
		rts

Palcycle_Sega:
		subq.w	#1,($FFFFF634).w
		bne.s	.return
		move.w	#3,($FFFFF634).w
		addq.w	#2,($FFFFF632).w
		cmpi.w	#$1C,($FFFFF632).w		; past cycle's size?
		bne.s	.jmp0				; if not, branch
		move.w	#0,($FFFFF632).w			; if yes, reset
	.jmp0:		
		move.w	($FFFFF632).w,d0
		lea	.cycle(pc,d0.w),a0
		rept	4				; repeat next line 4 times		; --> transfer 9 colors in total
			move.l	(a0)+,(a1)+		; copy 2 colors and increment pointers
		endr
		move.w	(a0),(a1)			; copy last color
	.return:	
		rts

	.cycle:		dc.w	$EC0
		dc.w	$EA0, $E80, $E60, $E40, $E20, $E00
		dc.w	$C00
		dc.w	$E00, $E20, $E40, $E60, $E80, $EA0
	.cycle_end:	; remaining half copy before loop. Making it CPU-friendly
		dc.w	$EC0
		dc.w	$EA0, $E80, $E60, $E40, $E20, $E00
		dc.w	$C00
Bcycle_size:=	.cycle_end-.cycle

	include	"SSRG/SSRG.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Title	screen
; ---------------------------------------------------------------------------

TitleScreen:				; XREF: GameModeArray
		command	mus_Stop	; stop music
		move.w	#$4EF9,(HIntJump).w
		move.l	#HInt_Title,(HIntAddr).w
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		command	mus_Reset	 ; fade reset music
		move	#$2300,sr
		lea	($C00004).l,a6
		move.w	#$8014,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		move.w	#$9200,(a6)
		move.w	#$8B03,(a6)
		move.w	#$8720,(a6)
		move.w	#$8C89,(a6)		; H res 40 cells, no interlace, S/H enabled
		move.w	#$8AFF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		move.b	#0,($FFFFF625).w ; enable water
		clr.b	($FFFFF64E).w
	;	bsr.w	ClearScreen
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Title_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Title_ClrObjRam ; fill object RAM ($D000-$EFFF) with	$0

		move	#$2700,sr
		move.l	#$40000001,($C00004).l
		lea	(Nem_TitleFg).l,a0 ; load title	screen patterns
		bsr.w	NemDec
		move.l	#$60000001,($C00004).l
		lea	(Nem_Title).l,a0 ;	load Sonic title screen	patterns
		bsr.w	NemDec
		move.l	#$62000002,($C00004).l
		lea	(Nem_TitleTM).l,a0 ; load "TM" patterns
		bsr.w	NemDec
		move.l #$40000000+(($9000&$3FFF)<<16)+(($9000&$C000)>>14),($C00004).l
		lea	(Nem_Menu).l,a0
		bsr.w	NemDec
		lea	($C00000).l,a6
		move.l	#$50000003,4(a6)
		lea	(Art_TextS2).l,a5
		move.w	#$28F,d1

Title_LoadText:
		move.w	(a5)+,(a6)
		dbf	d1,Title_LoadText ; load uncompressed text patterns

		move.b	#0,($FFFFFE30).w ; clear lamppost counter
		move.w	#0,($FFFFFE08).w ; disable debug item placement	mode
		move.w	#0,($FFFFFFF0).w ; disable debug mode
		move.w	#0,($FFFFFE10).w ; set level to	AAZ (00)
		move.w	#0,($FFFFF634).w ; disable pallet cycling
		move.b	#0,($FFFFF74F).w
		move.w	#0,($FFFFFE04).w
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		move.l	#$40000000,($C00004).l
		lea	(Nem_TIT).l,a0 ; load BBZ patterns
		bsr.w	NemDec
		lea	($FFFF9000).w,a1
		lea	(Blk16_TIT).l,a0 ; load	BBZ 16x16 mappings
		move.w	#0,d0
		bsr.w	EniDec
		lea	(Blk256_TIT).l,a0 ; load BBZ 256x256 mappings
		lea	($FF0000).l,a1
		bsr.w	KosDec
		bsr.w	LevelLayoutLoad
	;	bsr.w	Pal_FadeFrom
		move	#$2300,sr
		bsr.w	ClearScreen
		bsr.w	LoadTilesFromStart
		moveq	#1,d0		; load title screen pallet
		bsr.w	PalLoad1
		move.b	#0,($FFFFFFFA).w ; disable debug mode
		move.w	#$400,($FFFFF614).w ; run title	screen for $400	frames
		lea	($FFFFB080).w,a1
		jsr	DeleteObject2	; clear object RAM to make room for the "Press Start Button" object
		move.b	#$E,($FFFFB040).w ; load big Sonic object
		move.b	#$8F,($FFFFB080).w ; load "PRESS	START BUTTON" object
		move.b	#$8F,($FFFFB0C0).w ; load "TM" object
		move.b	#3,($FFFFB0DA).w
		move.b	#4,($FFFFF62A).w	; we can not afford to run the sound driver too
		bsr.w	DelayProgram		; late, or we will lose the YM data and break music
		music	mus_Title		; play title screen music
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		move.w	#0,($FFFFFFE4).w
		move.w	#0,($FFFFFFE6).w
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_FadeTo

loc_317C:
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		move.w	($FFFFB008).w,d0
		addq.w	#2,d0
		andi.w	#$3FFF,d0
		move.w	d0,($FFFFB008).w ; move	Sonic to the right
		subi.w	#$A0,d0
		move.w	d0,($FFFFF700).w ; move	Sonic to the right
		addi.w	#$80,($FFFFFE04).w
		cmpi.b	#$F,($FFFFB080).w
		bne.s	loc_317C
		andi.b	#$80,($FFFFF605).w ; check if Start is pressed
		beq.w	loc_317C	; if not, branch
		tst.b	($FFFFF62B).w
		bne.s	Title_ChkOptions	; branch if not a 1-player game

PlayLevel:				; XREF: ROM:00003246j ...
		move.b	#$C,($FFFFF600).w ; set	screen mode to $0C (Level)
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE16).w ; clear special stage number
		move.b	d0,($FFFFFE57).w ; clear emeralds
		move.l	d0,($FFFFFE58).w ; clear emeralds
		move.l	d0,($FFFFFE5C).w ; clear emeralds
		move.b	d0,($FFFFFE18).w ; clear continues
		move.b	#1,($FFFFFE10).w
		move.l	#$1000,(Universal_Timer).w
		move.w	#$1000,(Day_Time).w
		command	mus_FadeOut

PlayLevel_Sonic:
		rts

Title_ChkOptions:
		cmpi.b	#1,($FFFFF62B).w
		bne.s	Title_ChkLevSel	; branch if not a 1-player game
		bra.w	loc_317C

Title_ChkLevSel:
		move.w	#0,($FFFFFF82).w
		move.b	#$2C,($FFFFF600).w

Options:
		command	mus_FadeOut
		bsr.w	Pal_FadeFrom
		move	#$2700,sr
		move.w	($FFFFF60C).w,d0
		andi.b	#-$41,d0
		move.w	d0,($C00004).l
		bsr.w	ClearScreen
		lea	($C00004).l,a6
		move.w	#-$7FFC,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7BF9,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7900,(a6)
		move.w	#-$737F,(a6)
		move.w	#-$6FFF,(a6)
		lea	($FFFFAC00).w,a1
		moveq	#0,d0
		move.w	#$FF,d1

loc_8C1AA:
		move.l	d0,(a1)+
		dbf	d1,loc_8C1AA
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

loc_8C2A:
		move.l	d0,(a1)+
		dbf	d1,loc_8C2A
		clr.w	($FFFFBC00).w
		move.l	#-$2400,($FFFFBCFC).w
		move.l	#$42000000,($C00004).l
		lea	(Menu_Font).l,a0
		bsr.w	NemDec
		move.l	#$4E000000,($C00004).l
		lea	(Menu_Box).l,a0
		bsr.w	NemDec
		move.l	#$52000000,($C00004).l
		lea	(Level_Icons).l,a0
		bsr.w	NemDec
		lea	($FFFF0000).l,a1
		lea	(Menu_Mappings).l,a0
		move.w	#$6000,d0
		bsr.w	EniDec
		lea	($FFFF0000).l,a1
		move.l	#$60000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		bsr.w	ShowVDPGraphics
		bra.w	LevelSelect	; if yes, branch

word_87C6:
Anim_SonicMilesBG:	dc.w   0		; 0
; Sonic/Miles animated background
		dc.l $FF000000+Sonic_Miles_Spr
		dc.w $20
		dc.b 6
		dc.b $A
		dc.b   0,$C7		; 0
		dc.b  $A,  5		; 2
		dc.b $14,  5		; 4
		dc.b $1E,$C7		; 6
		dc.b $14,  5		; 8
		dc.b  $A,  5		; 10

;-------------------------------------------------------------------------------
LevelSelect:
	lea	($FFFF0000).l,a1
	lea	(MapEng_LevSel).l,a0	; 2 bytes per 8x8 tile, compressed
	move.w	#0,d0
	bsr.w	EniDec
	lea	($FFFF0000).l,a1
	move.l	#$40000003,d0
	moveq	#$27,d1
	moveq	#$1B,d2	; 40x28 = whole screen
	jsr	(ShowVDPGraphics).l	; display patterns
	moveq	#0,d3
	bsr.w	LevelSelect_DrawSoundNumber
	lea	($FFFF08C0).l,a1
	lea	(MapEng_LevSelIcon).l,a0
	move.w	#$90,d0
	bsr.w	EniDec
	bsr.w	LevelSelect_DrawIcon
;	clr.w	($FFFFFFEC).w
;	clr.w	($FFFFFFEE).w	; VsRSID_Act
	clr.b	($FFFFF74F).w
	clr.w	($FFFFF7F0).w
	lea	(Anim_SonicMilesBG).l,a2
	jsr	(Dynamic_Menu).l
	moveq	#$14,d0
	bsr.w	PalLoad1
	lea	($FFFFFB40).w,a1
	lea	($FFFFFBC0).w,a2

	moveq	#7,d1
.1	move.l	(a1),(a2)+
	clr.l	(a1)+
	dbf	d1,.1

	music	mus_Menu
	move.w	#$707,($FFFFF614).w
	clr.l	($FFFFF700).w
	clr.l	($FFFFF704).w
;	clr.w	(Correct_cheat_entries).w
;	clr.w	(Correct_cheat_entries_2).w
	move.b	#$16,($FFFFF62A).w
	bsr.w	DelayProgram
	move.w	($FFFFF60C).w,d0
	ori.b	#$40,d0
	move.w	d0,($C00004).l
	bsr.w	Pal_FadeTo

;loc_93AC:
LevelSelect_Main:	; routine running during level select
	move.b	#$16,($FFFFF62A).w
	bsr.w	DelayProgram
	move	#$2700,sr
	moveq	#0,d3	; palette line << 13
	bsr.w	LevelSelect_MarkFields	; unmark fields
	bsr.w	LevSelControls	; possible change selected fields
	move.w	#$6000,d3
	bsr.w	LevelSelect_MarkFields	; mark fields
	bsr.w	LevelSelect_DrawIcon
	move	#$2300,sr
	lea	(Anim_SonicMilesBG).l,a2
	jsr	(Dynamic_Menu).l
	move.b	($FFFFF605).w,d0
	or.b	($FFFFF607).w,d0
	andi.b	#$80,d0	; start pressed?
	bne.s	LevelSelect_PressStart	; yes
	bra.w	LevelSelect_Main	; no
; ===========================================================================

;loc_93F0:
LevelSelect_PressStart:
	move.w	($FFFFFF82).w,d0
	add.w	d0,d0
	move.w	LevelSelect_Order(pc,d0.w),d0
	bmi.w	LevelSelect_Return	; sound test
	cmpi.w	#$4000,d0
	bne.s	LevelSelect_StartZone

;LevelSelect_SpecialStage:
	move.b	#$10,($FFFFF600).w ; => SpecialStage
	clr.w	($FFFFFE10).w
	moveq	#0,d0
	move.w	d0,($FFFFFE20).w
	move.l	d0,($FFFFFE22).w
	move.l	d0,(Universal_Timer).w ; clear continues
;	move.l	#5000,(Next_Extra_life_score).w
;	move.w	(Player_option).w,(Player_mode).w
	rts
; ===========================================================================

;loc_944C:
LevelSelect_Return:
	move.b	#0,($FFFFF600).w ; => SegaScreen
	rts
; ===========================================================================
; -----------------------------------------------------------------------------
; Level Select Level Order

; One entry per item in the level select menu. Just set the value for the item
; you want to link to the level/act number of the level you want to load when
; the player selects that item.
; -----------------------------------------------------------------------------
;Misc_9454:
LevelSelect_Order:
	dc.w	aaz_act_1
	dc.w	aaz_act_2
	dc.w	aaz_act_3
	dc.w	aaz_act_4
	dc.w	bbz_act_1
	dc.w	bbz_act_2
	dc.w	bbz_act_3
	dc.w	bbz_act_4
	dc.w	ccz_act_1
	dc.w	ccz_act_2
	dc.w	ccz_act_3
	dc.w	ccz_act_4
	dc.w	ddz_act_1
	dc.w	ddz_act_2
	dc.w	ddz_act_3
	dc.w	ddz_act_4
	dc.w	eez_act_1
	dc.w	eez_act_2
	dc.w	eez_act_3
	dc.w	eez_act_4
	dc.w	ffz_act_1
	dc.w	ffz_act_2
	dc.w	ffz_act_3
	dc.w	ffz_act_4
	dc.w	ggz_act_1
	dc.w	ggz_act_2
	dc.w	ggz_act_3
	dc.w	ggz_act_4
	dc.w	special_stage_act_1
	dc.w	special_stage_act_2
	dc.w	special_stage_act_3
	dc.w	special_stage_act_4
	dc.w	$4000	; - bonus stage
	dc.w	$FFFF	; - sound test
; ===========================================================================

;loc_9480:
LevelSelect_StartZone:
	andi.w	#$3FFF,d0
	move.w	d0,($FFFFFE10).w
	cmpi.w	#$700,d0
	bcc.s	.StartSS
	move.b	#$C,($FFFFF600).w ; => Level (Zone play mode)
	moveq	#0,d0
	move.w	d0,($FFFFFE20).w
	move.l	d0,($FFFFFE22).w
	move.l	#$1000,(Universal_Timer).w
	move.w	#$1000,(Day_Time).w
	command	mus_FadeOut
	rts

	.StartSS:
	move.b	#$14,($FFFFF600).w
	moveq	#0,d0
	move.w	d0,($FFFFFE20).w
	move.l	d0,($FFFFFE22).w
	move.l	#$1000,(Universal_Timer).w
	move.w	#$1000,(Day_Time).w
	command	mus_FadeOut
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Change what you're selecting in the level select
; ---------------------------------------------------------------------------
; loc_94DC:
LevSelControls:
	move.b	($FFFFF605).w,d1
	andi.b	#3,d1
	bne.s	.2	; up/down pressed
	subq.w	#1,($FFFFFF80).w
	bpl.s	LevSelControls_CheckLR

.2
	move.w	#$B,($FFFFFF80).w
	move.b	($FFFFF604).w,d1
	andi.b	#3,d1
	beq.s	LevSelControls_CheckLR	; up/down not pressed, check for left & right
	move.w	($FFFFFF82).w,d0
	btst	#0,d1
	beq.s	.3
	subq.w	#1,d0	; decrease by 1
	bcc.s	.3	; >= 0?
	moveq	#$21,d0	; set to $15

.3
	btst	#1,d1
	beq.s	.4
	addq.w	#1,d0	; yes, add 1
	cmpi.w	#$22,d0
	blo.s	.4	; smaller than $16?
	moveq	#0,d0	; if not, set to 0

.4
	move.w	d0,($FFFFFF82).w
	rts
; ===========================================================================
; loc_9522:
LevSelControls_CheckLR:
	cmpi.w	#$21,($FFFFFF82).w	; are we in the sound test?
	bne.s	LevSelControls_SwitchSide	; no
	move.w	($FFFFFF84).w,d0
	move.b	($FFFFF605).w,d1
	btst	#2,d1
	beq.s	.5
	subq.b	#1,d0

.5
	btst	#3,d1
	beq.s	.6
	addq.b	#1,d0

.6
	btst	#6,d1
	beq.s	.7
	addi.b	#$10,d0

.7
	btst	#4,d1
	beq.s	.F7
	subi.b	#$10,d0
.F7

	move.w	d0,($FFFFFF84).w
	andi.w	#$20,d1
	beq.s	.8	; rts
	move.w	($FFFFFF84).w,d0
	tst.b	d0
	beq.s	.Stop
	addi.b	#mus_Title-1,d0
	move.b	d0,mQueue+1.w	; play music
	lea	(debug_cheat).l,a0
;	lea	(super_sonic_cheat).l,a2
;	lea	(Night_mode_flag).w,a1
	moveq	#1,d2	; flag to tell the routine to enable the Super Sonic cheat
	bra.w	CheckCheats

.8
	rts

.Stop
	command	mus_Stop
	rts
; ===========================================================================
; loc_958A:
LevSelControls_SwitchSide:	; not in soundtest, not up/down pressed
	move.b	($FFFFF605).w,d1
	andi.b	#$C,d1
	beq.s	.9				; no direction key pressed
	move.w	($FFFFFF82).w,d0	; left or right pressed
	move.b	LevelSelect_SwitchTable(pc,d0.w),d0 ; set selected zone according to table
	move.w	d0,($FFFFFF82).w
.9
	rts
; ===========================================================================
;byte_95A2:
LevelSelect_SwitchTable:
	dc.b $18
	dc.b $19	; 1
	dc.b $1A	; 2
	dc.b $1B	; 3
	dc.b $1C	; 4
	dc.b $1D	; 5
	dc.b $1E	; 6
	dc.b $1F	; 7
	dc.b $20	; 8
	dc.b $20	; 9
	dc.b $20	; $A
	dc.b $21	; $B
	dc.b $21	; $C
	dc.b $21	; $D
	dc.b $21	; $E
	dc.b $21	; $F
	dc.b $21	; $10
	dc.b $21	; $11
	dc.b $21	; $12
	dc.b $21	; $13
	dc.b $21	; $14
	dc.b $21	; $15
	dc.b $21	; $16
	dc.b $21	; $17
	dc.b 0		; $18
	dc.b 1		; $19
	dc.b 2		; $1A
	dc.b 3		; $1B
	dc.b 4		; $1C
	dc.b 5		; $1D
	dc.b 6		; $1E
	dc.b 7		; $1F
	dc.b 8		; $20
	dc.b $10	; $21
	even
; ===========================================================================

;loc_95B8:
LevelSelect_MarkFields:
	lea	($FFFF0000).l,a4
	lea	(LevSel_MarkTable).l,a5
	lea	($C00000).l,a6
	moveq	#0,d0
	move.w	($FFFFFF82).w,d0
	lsl.w	#2,d0
	lea	(a5,d0.w),a3
	moveq	#0,d0
	move.b	(a3),d0
	mulu.w	#$50,d0
	moveq	#0,d1
	move.b	1(a3),d1
	add.w	d1,d0
	lea	(a4,d0.w),a1
	moveq	#0,d1
	move.b	(a3),d1
	lsl.w	#7,d1
	add.b	1(a3),d1
	addi.w	#-$4000,d1
	lsl.l	#2,d1
	lsr.w	#2,d1
	ori.w	#$4000,d1
	swap	d1
	move.l	d1,4(a6)

	moveq	#$E,d2
.10	move.w	(a1)+,d0
	add.w	d3,d0
	move.w	d0,(a6)
	dbf	d2,.10

	addq.w	#2,a3
	moveq	#0,d0
	move.b	(a3),d0
	beq.s	.11
	mulu.w	#$50,d0
	moveq	#0,d1
	move.b	1(a3),d1
	add.w	d1,d0
	lea	(a4,d0.w),a1
	moveq	#0,d1
	move.b	(a3),d1
	lsl.w	#7,d1
	add.b	1(a3),d1
	addi.w	#-$4000,d1
	lsl.l	#2,d1
	lsr.w	#2,d1
	ori.w	#$4000,d1
	swap	d1
	move.l	d1,4(a6)
	move.w	(a1)+,d0
	add.w	d3,d0
	move.w	d0,(a6)

.11
	cmpi.w	#$21,($FFFFFF82).w
	bne.s	.12	; rts
	bsr.w	LevelSelect_DrawSoundNumber
.12
	rts
; ===========================================================================
;loc_965A:
LevelSelect_DrawSoundNumber:
	move.l	#$49440003,($C00004).l
	move.w	($FFFFFF84).w,d0
	move.b	d0,d2
	lsr.b	#4,d0
	bsr.s	.13
	move.b	d2,d0

.13
	andi.w	#$F,d0
	cmpi.b	#$A,d0
	blo.s	.14
	addi.b	#4,d0

.14
	addi.b	#$10,d0
	add.w	d3,d0
	move.w	d0,(a6)
	rts
; ===========================================================================

;loc_9688:
LevelSelect_DrawIcon:
	move.w	($FFFFFF82).w,d0
	lea	(LevSel_IconTable).l,a3
	lea	(a3,d0.w),a3
	lea	($FFFF08C0).l,a1
	moveq	#0,d0
	move.b	(a3),d0
	lsl.w	#3,d0
	move.w	d0,d1
	add.w	d0,d0
	add.w	d1,d0
	lea	(a1,d0.w),a1
	move.l	#$4B360003,d0
	moveq	#3,d1
	moveq	#2,d2
	jsr	(ShowVDPGraphics).l
	lea	(Pal_LevelIcons).l,a1
	moveq	#0,d0
	move.b	(a3),d0
	lsl.w	#5,d0
	lea	(a1,d0.w),a1
	lea	($FFFFFB40).w,a2

	moveq	#7,d1
.15	move.l	(a1)+,(a2)+
	dbf	d1,.15

	rts
; ===========================================================================
;byte_96D8
LevSel_IconTable:
	dc.b   0,0	;0	EHZ
	dc.b   7,7	;2	CPZ
	dc.b   8,8	;4	ARZ
	dc.b   6,6	;6	CNZ
	dc.b   2,2	;8	HTZ
	dc.b   5,5	;$A	MCZ
	dc.b   4,4	;$C	OOZ
	dc.b   1,1,1	;$E	MTZ
	dc.b   9	;$11	SCZ
	dc.b  $A	;$12	WFZ
	dc.b  $B	;$13	DEZ
	dc.b  $C	;$14	Special Stage
	dc.b  $E	;$15	Sound Test
	even
;byte_96EE:
LevSel_MarkTable:	; 4 bytes per level select entry
; line primary, 2*column ($E fields), line secondary, 2*column secondary (1 field)
	dc.b   2,  6,  2,$24	;0
	dc.b   2,  6,  3,$24
	dc.b   2,  6,  4,$24
	dc.b   2,  6,  5,$24
	dc.b   6,  6,  6,$24
	dc.b   6,  6,  7,$24
	dc.b   6,  6,  8,$24
	dc.b   6,  6,  9,$24
	dc.b   $A, 6, $A,$24
	dc.b   $A, 6, $B,$24
	dc.b   $A, 6, $C,$24
	dc.b   $A, 6, $D,$24
	dc.b  $E,  6, $E,$24
	dc.b  $E,  6, $F,$24
	dc.b  $E,  6, $10,$24
	dc.b  $E,  6, $11,$24
	dc.b  $12, 6, $12,$24
	dc.b  $12, 6, $13,$24
	dc.b  $12, 6, $14,$24
	dc.b  $12, 6, $15,$24
	dc.b  $16, 6, $16,$24
	dc.b  $16, 6, $17,$24
	dc.b  $16, 6, $18,$24
	dc.b  $16, 6, $19,$24
; --- second column ---
	dc.b   2,$2A,  2,$48
	dc.b   2,$2A,  3,$48
	dc.b   2,$2A,  4,$48
	dc.b   2,$2A,  5,$48
	dc.b   6,$2A,  6,$48
	dc.b   6,$2A,  7,$48
	dc.b   6,$2A,  8,$48
	dc.b   6,$2A,  9,$48
	dc.b  $A,$2A,  0,  0	;$14
	dc.b $12,$2A,$12,$48
; ===========================================================================
; loc_9746:
CheckCheats:	; This is called from 2 places: the options screen and the level select screen
	move.w	($FFFFFFDE).w,d0	; Get the number of correct sound IDs entered so far
	adda.w	d0,a0				; Skip to the next entry
	move.w	($FFFFFF84).w,d0		; Get the current sound test sound
	cmp.b	(a0),d0				; Compare it to the cheat
	bne.s	.16				; If they're different, branch
	addq.w	#1,($FFFFFFDE).w	; Add 1 to the number of correct entries
	tst.b	1(a0)				; Is the next entry 0?
	bne.s	.17				; If not, branch
	move.b	#1,($FFFFFFE2).w			; Enable the cheat
	sfx		sfx_RingRight
.16
	move.w	#0,($FFFFFFDE).w	; Clear the number of correct entries
;+
;	move.w	(Correct_cheat_entries_2).w,d0	; Do the same procedure with the other cheat
;	adda.w	d0,a2
;	move.w	(Sound_test_sound).w,d0
;	cmp.b	(a2),d0
;	bne.s	++
;	addq.w	#1,(Correct_cheat_entries_2).w
;	tst.b	1(a2)
;	bne.s	+++	; rts
;	tst.w	d2				; Test this to determine which cheat to enable
;	bne.s	+				; If not 0, branch
;	move.b	#$F,(Continue_count).w		; Give 15 continues
;	; The next line causes the bug where the OOZ music plays until reset.
;	; Remove "&$7F" to fix the bug.
;	move.b	#SndID_ContinueJingle&$7F,d0	; Play the continue jingle
;	jsrto	(PlayMusic).l, JmpTo_PlayMusic
;	bra.s	++
; ===========================================================================
;+
;	move.w	#7,(Got_Emerald).w		; Give 7 emeralds to the player
;	move.b	#MusID_Emerald,d0		; Play the emerald jingle
;	jsrto	(PlayMusic).l, JmpTo_PlayMusic
;+
;	move.w	#0,(Correct_cheat_entries_2).w	; Clear the number of correct entries
.17
	rts
; ===========================================================================
;level_select_cheat:	dc.b $19, $65,   9, $17,   0
;	rev02even
;continues_cheat:	dc.b   1,   1,   2,   4,   0	; byte_97B7
;	rev02even
debug_cheat:		dc.b   1,   9,   9,   2,   1,   1,   2,   4,   0
	even
;super_sonic_cheat:	dc.b   4,   1,   2,   6,   0	; byte_97C5
;	rev02even

; level select picture palettes
; byte_9880:
Pal_LevelIcons:	incbin "pallet\Level Select Icons.bin"

; level select screen mappings (Enigma compressed)
; byte_9ADE:
MapEng_LevSel:	incbin "mapeni\Level Select.bin"

; 1P and 2P level select icon mappings (Enigma compressed)
; byte_9C32:
MapEng_LevSelIcon:	incbin "mapeni\Level Select Icons.bin"

;-------------------------------------------------------------------------------							
Dynamic_Menu:						   
				subq.b  #$01, ($FFFFF7B9).w		  ; Decrementa em 1 o Tempo
				bpl.s   Exit_Dinamic_Menu			; Se for maior ou igual a 0 sai da funรงรฃo
				move.b  #$07, ($FFFFF7B9).w		  ; Inicializa o tempo de duraรงรฃo de cada frame
				move.b  ($FFFFF7B8).w, D0			; Carrega o Id do Frame Atual em D0
				addq.b  #$01, ($FFFFF7B8).w		  ; Carrega o prรณximo frame em $FFFFFFB8
				andi.w  #$003F, D0
				move.b  Sonic_Miles_Frame_Select(PC, D0), D0  ; Carrega o Id do frame em D0
			  ; muls.w  #$0140, D0				   ; Multiplica o Id pelo tamanho em bytes de cada frame
				lsl.w   #$06, D0
				lea	 ($00C00000), A6
				move.l  #$40200000, $0004(A6)
				lea	 (Sonic_Miles_Spr), A1
				lea	 $00(A1, D0), A1
				move.w  #$0009, D0				   ; Tiles-1 a serem carregados por vez 
Menu_Loop_Load_Tiles:
				move.l  (A1)+, (A6)
				move.l  (A1)+, (A6)	 
				move.l  (A1)+, (A6)	 
				move.l  (A1)+, (A6)	 
				move.l  (A1)+, (A6)	 
				move.l  (A1)+, (A6)
				move.l  (A1)+, (A6)
				move.l  (A1)+, (A6)
				dbra	D0, Menu_Loop_Load_Tiles
Exit_Dinamic_Menu:				
				rts			  
Sonic_Miles_Frame_Select:	 
				dc.b	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
				dc.b	$05, $0A
				dc.b	$0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F
				dc.b	$14, $19   
				dc.b	$1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E
				dc.b	$23, $28 
				; 0 = 0000000000  ; 1 = 0101000000  ; 2 = 1010000000 ; 3 = 1111000000
;-------------------------------------------------------------------------------   
Menu_Palette:
				incbin  'pallet\menu.bin'	

; ===========================================================================
; ---------------------------------------------------------------------------
; Level	select - level pointers
; ---------------------------------------------------------------------------
LSelectPointers:
		incbin	misc\ls_point.bin
		even
;-----------------------------------------------------------------------
; Demo mode
; ---------------------------------------------------------------------------

Demo:					; XREF: TitleScreen
		move.w	#$1E,($FFFFF614).w

loc_33B6:				; XREF: loc_33E4
		move.b	#4,($FFFFF62A).w
		bsr.w	DelayProgram
		bsr.w	DeformBgLayer
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		move.w	($FFFFB008).w,d0
		addq.w	#2,d0
		move.w	d0,($FFFFB008).w
		cmpi.w	#$1C00,d0
		bcs.s	loc_33E4
		move.b	#0,($FFFFF600).w ; set screen mode to 00 (level)
		rts	
; ===========================================================================

loc_33E4:				; XREF: Demo
		andi.b	#$80,($FFFFF605).w ; is	Start button pressed?
		bne.w	Title_ChkLevSel	; if yes, branch
		tst.w	($FFFFF614).w
		bne.w	loc_33B6
		command	mus_FadeOut
		move.w	($FFFFFFF2).w,d0 ; load	demo number
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Demo_Levels(pc,d0.w),d0	; load level number for	demo
		move.w	d0,($FFFFFE10).w
		addq.w	#1,($FFFFFFF2).w ; add 1 to demo number
		cmpi.w	#4,($FFFFFFF2).w ; is demo number less than 4?
		bcs.s	loc_3422	; if yes, branch
		move.w	#0,($FFFFFFF2).w ; reset demo number to	0

loc_3422:
		move.w	#1,($FFFFFFF0).w ; turn	demo mode on
		move.b	#8,($FFFFF600).w ; set screen mode to 08 (demo)
		cmpi.w	#$600,d0	; is level number 0600 (special	stage)?
		bne.s	Demo_Level	; if not, branch
		move.b	#$10,($FFFFF600).w ; set screen	mode to	$10 (Special Stage)
		clr.w	($FFFFFE10).w	; clear	level number
		clr.b	($FFFFFE16).w	; clear	special	stage number

Demo_Level:
		moveq	#0,d0
		move.w	d0,($FFFFFE20).w ; clear rings
		move.l	d0,($FFFFFE22).w ; clear time
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Levels used in demos
; ---------------------------------------------------------------------------
Demo_Levels:	incbin	misc\dm_ord1.bin
		even
; ---------------------------------------------------------------------------
; Music	playlist
; ---------------------------------------------------------------------------
MusicList: dc.b mus_AA1, mus_BB1, mus_CC1, mus_DD1, mus_EE1, mus_FF1, mus_GG1, mus_Bonus1
		even
; ---------------------------------------------------------------------------
; Music	playlist
; ---------------------------------------------------------------------------
MusicList2: dc.b mus_AA2, mus_BB2, mus_CC2, mus_DD2, mus_EE2, mus_FF2, mus_GG2, mus_Bonus2
		even
; ===========================================================================

; ---------------------------------------------------------------------------
; Level
; ---------------------------------------------------------------------------

Level:					; XREF: GameModeArray
		bset	#7,($FFFFF600).w ; add $80 to screen mode (for pre level sequence)
		tst.w	($FFFFFFF0).w
		bmi.s	loc_37B6
		command	mus_FadeOut

loc_37B6:
		bsr.w	ClearPLC
		bsr.w	Pal_FadeFrom
		moveq	#0,d0
		bsr.w	LoadPLC
		tst.w	($FFFFFFF0).w
		bmi.s	Level_ClrRam
		move	#$2700,sr
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	loc_37FC
		bsr.w	LoadPLC		; load level patterns

loc_37FC:
		moveq	#1,d0
		bsr.w	LoadPLC		; load standard	patterns

Level_ClrRam:
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

Level_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrObjRam ; clear object RAM

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

Level_ClrVars2:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1

Level_ClrVars3:
		move.l	d0,(a1)+
		dbf	d1,Level_ClrVars3 ; clear object variables

		move	#$2700,sr
		bsr.w	ClearScreen
		bra.s	Level_ClearWater

Level_InitWater:
		move.b	#1,(Water_flag).w
		bra.s	Level_ClrVars3_Continue

Level_ClearWater:
		move.b	#0,(Water_flag).w

Level_ClrVars3_Continue:
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8004,(a6)
		move.w	#$8730,(a6)
		move.w	#$8C89,(a6)		; H res 40 cells, no interlace, S/H enabled

loc_4262:
		move.w	#$8AFF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		clr.w	($FFFFDC00).w
		move.l	#-$2400,($FFFFDCFC).w
		cmpi.b	#1,($FFFFFE10).w
		beq.s	Level_BBZPal
		tst.b	(Water_flag).w	; does level have water
		beq.s	Level_LoadPal	;if not, branch
		move.w	#$8014,(a6)
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		ror.b	#2,d0
		lsr.w	#6,d0
		add.w	d0,d0
		lea	(WaterHeight).l,a1 ; load water	height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement
		move.b	#1,($FFFFF64C).w ; enable water
		bra.s	Level_LoadPal

Level_BBZPal:
		move.w	#$4EF9,(HIntJump).w
		move.l	#HInt_S3Water,(HIntAddr).w
		move.l	#WaterTransition_BBZ,($FFFFF610).w
		move.w	#$8014,(a6)
		move.w	#0,($FFFFF646).w ; set water heights
		move.w	#0,($FFFFF648).w
		move.w	#0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement

Level_LoadPal:
		move.w	#$1E,($FFFFFE14).w
		move	#$2300,sr
		cmpi.b	#1,($FFFFFE10).w
		beq.s	Level_WaterPal	; if so, branch
		tst.b	(Water_flag).w	; does level have water?
		beq.s	Level_LoadCol
		moveq	#$B,d0		; pallet number	$B (EEZ)

Level_WaterPal:
		tst.b	($FFFFFE30).w
		beq.s	Level_LoadCol
		move.b	($FFFFFE53).w,($FFFFF64E).w

Level_LoadCol:
		bsr.s	LoadSolids
		bra.w	Level_TtlCard

LoadSolids:
		moveq 	#0,d0
		move.b 	($FFFFFE10).w,d0
		add.w	d0,d0				; multiply d3 by x2
		add.w	d0,d0				; multiply d3 by x2 again (x4)
		move.l	CollArray1Table(pc,d0.w),($FFFFF784).w
		move.l	CollArray2Table(pc,d0.w),($FFFFF788).w
		move.l	AngleMapTable(pc,d0.w),($FFFFF78C).w 
		rts

CollArray1Table:
		dc.l	CollArray3K1	; AAZ
		dc.l	CollArray21	; BBZ
		dc.l	CollArray3K1	; CCZ
		dc.l	CollArrayCD1	; DDZ
		dc.l	CollArray21	; EEZ
		dc.l	CollArray3K1	; FFZ
		dc.l	CollArray3K1	; GGZ
		dc.l	CollArray21	; End
		dc.l	CollArray3K1	; SSZ
		
CollArray2Table:
		dc.l	CollArray3K2	; AAZ
		dc.l	CollArray22	; BBZ
		dc.l	CollArray3K2	; CCZ
		dc.l	CollArrayCD2	; DDZ
		dc.l	CollArray22	; EEZ
		dc.l	CollArray3K2	; FFZ
		dc.l	CollArray3K2	; GGZ
		dc.l	CollArray22	; End
		dc.l	CollArray3K2	; SSZ

AngleMapTable:
		dc.l	AngleMap3K	; AAZ
		dc.l	AngleMap2	; BBZ
		dc.l	AngleMap3K	; CCZ
		dc.l	AngleMapCD	; DDZ
		dc.l	AngleMap2	; EEZ
		dc.l	AngleMap3K	; FFZ
		dc.l	AngleMap3K	; GGZ
		dc.l	AngleMap2	; End
		dc.l	AngleMap3K	; SSZ

WaterTransition_BBZ:	dc.w 2
		dc.w $66
		dc.w $60
		dc.w $68

Level_TtlCard:
		move.b	#$C,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr.w	RunPLC_RAM
		move.w	($FFFFB108).w,d0
		cmp.w	($FFFFB130).w,d0 ; has title card sequence finished?
		bne.s	Level_TtlCard	; if not, branch
		tst.l	($FFFFF680).w	; are there any	items in the pattern load cue?
		bne.s	Level_TtlCard	; if yes, branch
		jsr	Hud_Base

Level_LoadCharacter:
		move.b	(Current_Character).w,d0
		move.b	(Current_Partner).w,d1
		lsl.b	#3,d0
		add.b	d1,d0
		lsl.b	#2,d0
		lea	CharacterTable(pc,d0.w),a0
		bra.w	Level_LoadCharacter2

CharacterTable: ; Object, Partner Object, Palette, Water Palette
		dc.b 1, 0, 3, $1A ; Sonic
		dc.b 1, $95, 3, $1A ; Sonic and Tails
		dc.b 1, $99, $F, $20 ; Sonic and Knuckles
		dc.b 1, $8E, $15, $22 ; Sonic and Shadow
		dc.b 1, 2, $C, $1C ; Sonic and Silver
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b $95, 1, 3, $1A ; Tails and Sonic
		dc.b $95, 0, 3, $1A ; Tails
		dc.b $95, $99, $10, $21 ; Tails and Knuckles
		dc.b $95, $8E, $16, $23 ; Tails and Shadow
		dc.b $95, 2, $B, $1C ; Tails and Silver
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b $99, 1, $F, $20 ; Knuckles and Sonic
		dc.b $99, $95, $10, $21 ; Knuckles and Tails
		dc.b $99, 0, $F, $20 ; Knuckles
		dc.b $99, $8E, $17, $24 ; Knuckles and Shadow
		dc.b $99, 2, $D, $1E ; Knuckles and Silver
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b $8E, 1, $15, $22 ; Shadow and Sonic
		dc.b $8E, $95, $16, $23 ; Shadow and Tails
		dc.b $8E, $99, $17, $24 ; Shadow and Knuckles
		dc.b $8E, 0, $15, $22 ; Shadow
		dc.b $8E, 2, $E, $1F ; Shadow and Silver
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 2, 1, $C, $1D ; Silver and Sonic
		dc.b 2, $95, $B, $1C ; Silver and Tails
		dc.b 2, $99, $D, $1E ; Silver and Knuckles
		dc.b 2, $8E, $E, $1F ; Silver and Shadow
		dc.b 2, 0, $B, $1C ; Silver
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null
		dc.b 0, 0, 0, 0 ; Null

Level_LoadCharacter2:
		move.b	(a0)+,($FFFFB000).w
		move.b	(a0)+,($FFFFB380).w
		move.b	(a0)+,d0
		andi.w	#$FF,d0
		bsr.w	PalLoad1
		move.b	(a0)+,d0
		bsr.w	PalLoad4_Water
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_3946
		move.b	#6,($FFFFB480).w ; sun object
		move.b	#0,($FFFFB4A8).w ; sun object
		move.b	#6,($FFFFB4C0).w ; sun object
		move.b	#1,($FFFFB4E8).w ; sun object

loc_3946:
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	LoadZoneTiles	; load level art
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	ColIndexLoad
		bsr.w	WaterEffects
		tst.w	($FFFFFFF0).w
		bmi.w	Level_LoadCharacter
		cmpi.b	#$18,($FFFFF600).w
		beq.s	Level_ChkDebug
		cmpi.b	#$1C,($FFFFF600).w
		move.b	#$21,($FFFFB040).w ; load HUD object
		cmpi.b	#1,($FFFFFE10).w
		bne.s	Level_ChkDebug
		move.b	#$96,($FFFFF625).w
		cmpi.b	#7,($FFFFFE10).w
		bne.s	Level_ChkDebug
		move.b	#1,($FFFFF7CA).w 
		move.b	#$97,($FFFFB440).w

Level_ChkDebug:
		bset	#7,($FFFFB3A2).w
		tst.b	($FFFFFFE2).w	; has debug cheat been entered?
		beq.s	Level_ChkWater	; if not, branch
		btst	#6,($FFFFF604).w ; is A	button pressed?
		beq.s	Level_ChkWater	; if not, branch
		move.b	#1,($FFFFFFFA).w ; enable debug	mode

Level_ChkWater:
		move.w	#0,($FFFFF602).w
		move.w	#0,($FFFFF670).w
		move.w	#0,($FFFFF604).w
		move.w	#0,($FFFFF606).w
		move.b	#0,($FFFFF74F).w
		tst.b	(Water_flag).w	; does level have water?
		beq.s	Level_LoadObj	; if not, branch
		move.b	#$1B,($FFFFB780).w ; load water	surface	object
		move.w	#$60,($FFFFB788).w
		move.b	#$1B,($FFFFB7C0).w
		move.w	#$120,($FFFFB7C8).w

Level_LoadObj:
		jsr	ObjPosLoad
		move.b	#0,($FFFFFE17).w
		jsr	RingsManager
		jsr	ObjectsLoad
		jsr	BuildSprites
		moveq	#0,d0
		tst.b	($FFFFFE30).w	; are you starting from	a lamppost?
		bne.s	loc_39E8	; if yes, branch
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE1B).w ; clear lives counter
		move.b	d0,($FFFFFE2D).w

loc_39E8:
		move.b	d0,($FFFFFE1A).w
		bclr	#1,($FFFFFE2C).w ; clear invincibility
		move.b	d0,($FFFFFE2E).w ; clear speed shoes

Level_Update:
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		move.b	d0,($FFFFFE07).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w
		lea	(Demo_Index).l,a1 ; load demo data
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	Level_Demo	; if yes, branch
		lea	(Demo_EndIndex).l,a1 ; load ending demo	data
		move.w	($FFFFFFF4).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1

Level_Demo:
		move.b	1(a1),($FFFFF792).w ; load key press duration
		subq.b	#1,($FFFFF792).w ; subtract 1 from duration
		move.w	#1800,($FFFFF614).w
		tst.w	($FFFFFFF0).w
		bpl.s	Level_ChkWaterPal
		move.w	#540,($FFFFF614).w
		cmpi.w	#4,($FFFFFFF4).w
		bne.s	Level_ChkWaterPal
		move.w	#510,($FFFFF614).w

Level_ChkWaterPal:
		moveq	#$B,d0		; pallet $1E (EEZ underwater)
; ===========================================================================

ChkWaterPal:
		bsr.w	PalLoad4_Water

Level_Delay:
		move.w	#3,d1

Level_DelayLoop:
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		dbf	d1,Level_DelayLoop

		move.w	#$3F,($FFFFF626).w
		bsr.w	Pal_FadeTo2
		tst.w	($FFFFFFF0).w
		bmi.s	Level_GetBGM
; ===========================================================================

Level_ClrCardArt:
		lea	($C00000).l,a6
		move.l	#Art_Explode,d1
		move.w	#(ArtTile_Explode*$20),d2
		move.w	#$64F,d3
		jsr	(QueueDMATransfer).l
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		addi.w	#$15,d0
; ===========================================================================

Level_GetBgm:
		bsr.w	LoadMusic

Level_LoadScene:
		cmpi.b	#1,($FFFFFE10).w
		bne.s	Level_StartGame
		move.b	#4,($FFFFB0C0).w ; load rain/snow object

Level_StartGame:
		move.b	#1,($FFFFF74F).w
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.b	#$38,($FFFFB180).w ; load "shield" object

Level_StartGame3:

InitSRAM:
        move.b  #1,($A130F1).l    ; Enable SRAM writing
        lea ($200001).l,a0      ; Load SRAM memory into a0 (Change the last digit to 0 if you're using even SRAM)
        movep.l 0(a0),d0        ; Get the existing string at the start of SRAM
        move.l  #"SRAM",d1        ; Write the string "SRAM" to d1
        cmp.l   d0,d1            ; Was it already in SRAM?
        beq.s   .Continue           ; If so, skip
        movep.l d1,0(a0)        ; Write string "SRAM"

 
.Continue:
        move.b    #0,($A130F1).l    ; Disable SRAM writing
		bclr	#7,($FFFFF600).w ; subtract 80 from screen mode

; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

Level_MainLoop:
		bsr.w	PauseGame
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		addq.l	#1,(Universal_Timer).w ; add 1 to level timer
		bsr.w	LoadMusic
		bsr.w	TimeOfDay
		bsr.w	WaterEffects
		bsr.w	WallRunning
		jsr	ObjectsLoad
		jsr	RingsManager
		tst.w	($FFFFFE02).w	; is the level set to restart?
		bne.w	Level		; if yes, branch
		cmpi.b	#$C,($FFFFF600).w
		bne.w	.locret	; if screen mode is $0C	(level), branch
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		jsr	ObjPosLoad	
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		jsr	GotThroughAct
		cmpi.b	#8,($FFFFF600).w
		beq.s	Level_ChkDemo	; if screen mode is 08 (demo), branch
		bra.s	Level_MainLoop

.locret:
		rts	
; ===========================================================================

Level_ChkDemo:				; XREF: Level_MainLoop
		tst.w	($FFFFFE02).w	; is level set to restart?
		bne.s	Level_EndDemo	; if yes, branch
		tst.w	($FFFFF614).w	; is there time	left on	the demo?
		beq.s	Level_EndDemo	; if not, branch
		cmpi.b	#8,($FFFFF600).w
		beq.w	Level_MainLoop	; if screen mode is 08 (demo), branch
		move.b	#0,($FFFFF600).w ; go to Sega screen
		rts	
; ===========================================================================

Level_EndDemo:				; XREF: Level_ChkDemo
		cmpi.b	#8,($FFFFF600).w ; is screen mode 08 (demo)?
		bne.s	loc_3B88	; if not, branch
		move.b	#0,($FFFFF600).w ; go to Sega screen
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	loc_3B88	; if yes, branch
		move.b	#$1C,($FFFFF600).w ; go	to credits

loc_3B88:
		move.w	#$3C,($FFFFF614).w
		move.w	#$3F,($FFFFF626).w

loc_3B98:
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	ObjPosLoad
		bsr.w	Pal_FadeOut

loc_3BC8:
		tst.w	($FFFFF614).w
		bne.s	loc_3B98
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	change music with the time of day
; ---------------------------------------------------------------------------

LoadMusic:
		cmpi.b	#6,($FFFFFE10).w
		bge.s	LoadMusicDone
		move.w	(Day_Time).w,d1
		cmpi.w	#$D00,d1
		blt.s	LoadMusicNight
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lea	(MusicList).l,a1	; load Music Playlist for Acts 1
		move.b	(a1,d0.w),d0	; add d0 to a1
		cmp.b	($FFFFF75D).w,d0
		beq.s	LoadMusicDone
		move.b	d0,($FFFFF75D).w	; store level music
		move.b	d0,mQueue+1.w
		rts

LoadMusicNight:
		cmpi.w	#$CC0,d1
		bgt.s	LoadMusicStop
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lea	(MusicList2).l,a1	; load Music Playlist for Acts 1
		move.b	(a1,d0.w),d0	; add d0 to a1
		cmp.b	($FFFFF75D).w,d0
		beq.s	LoadMusicDone
		move.b	d0,($FFFFF75D).w	; store level music
		move.b	d0,mQueue+1.w
		rts

LoadMusicStop:
		move.b	#mus_FadeOut,d0
		cmp.b	($FFFFF75D).w,d0
		beq.s	LoadMusicDone
		move.b	d0,($FFFFF75D).w	; store level music
		move.b	d0,mQueue.w

LoadMusicDone:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	do special water effects in Labyrinth Zone
; ---------------------------------------------------------------------------

WaterEffects:				; XREF: Level
		cmpi.b	#1,($FFFFFE10).w
		beq.s	EEZBBZ
		tst.b	(Water_flag).w
		beq.s	locret_3C28
		tst.b	($FFFFF744).w
		bne.s	MoveWater
		cmpi.b 	#6,($FFFFB024).w
		bcc.s	MoveWater
		bsr.w	WindTunnels
		bsr.w	DynamicWater

MoveWater:
		clr.b	($FFFFF64E).w
		moveq	#0,d0
		move.b	($FFFFFE60).w,d0
		lsr.w	#1,d0
		add.w	($FFFFF648).w,d0
		move.w	d0,($FFFFF646).w
		move.w	($FFFFF646).w,d0
		sub.w	($FFFFF704).w,d0
		bcc.s	loc_3C1A
		tst.w	d0
		bpl.s	loc_3C1A
		move.b	#-$21,($FFFFF625).w
		move.b	#1,($FFFFF64E).w

loc_3C1A:
		cmpi.w	#$DF,d0
		bcs.s	loc_3C24
		move.w	#$DF,d0

loc_3C24:
		move.b	d0,($FFFFF625).w

locret_3C28:
		rts	

EEZBBZ:
	;	move.b	#$97,($FFFFF625).w ; enable water
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Default water heights
; ---------------------------------------------------------------------------
WaterHeight:	
		dc.w $FFF, $FFF, $FFF, $FFF; 0
		dc.w $C00, $328, $900, $FFF; 1
		dc.w $FFF, $FFF, $FFF, $FFF; 2
		dc.w $C00, $C00, $C00, $FFF; 3
		dc.w $FFF, $FFF, $FFF, $FFF; 4
		dc.w $500, $A00, $200, $FFF; 5
		dc.w $FFF, $FFF, $FFF, $FFF; 6
; ===========================================================================

; ---------------------------------------------------------------------------
; Labyrinth dynamic water routines
; ---------------------------------------------------------------------------

DynamicWater:				; XREF: WaterEffects
		rts
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	DynWater_Index(pc,d0.w),d0
		jsr	DynWater_Index(pc,d0.w)
		moveq	#0,d1
		move.b	($FFFFF64C).w,d1
		move.w	($FFFFF64A).w,d0
		sub.w	($FFFFF648).w,d0
		beq.s	locret_3C5A
		bcc.s	loc_3C56
		neg.w	d1

loc_3C56:
		add.w	d1,($FFFFF648).w

locret_3C5A:
		rts	
; ===========================================================================
DynWater_Index:	dc.w DynWater_EEZ1-DynWater_Index
		dc.w DynWater_EEZ2-DynWater_Index
		dc.w DynWater_EEZ3-DynWater_Index
		dc.w DynWater_FFZ3-DynWater_Index
; ===========================================================================

DynWater_EEZ1:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3CD0
		move.w	#$B8,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		cmpi.w	#$200,($FFFFB00C).w
		bcs.s	loc_3CBA
		cmpi.w	#$C00,d0
		bcs.s	loc_3CB4
		move.w	#$318,d1
		cmpi.w	#$1080,d0
		bcs.s	loc_3CB4
		move.b	#-$80,($FFFFF7E5).w
		move.w	#$5C8,d1
		cmpi.w	#$1380,d0
		bcs.s	loc_3CB4
		move.w	#$3A8,d1
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3CB4
		move.b	#1,($FFFFF64D).w

loc_3CB4:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3CBA:				; XREF: DynWater_EEZ1
		cmpi.w	#$C80,d0
		bcs.s	loc_3CB4
		move.w	#$E8,d1
		cmpi.w	#$1500,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		bra.s	loc_3CB4
; ===========================================================================

loc_3CD0:				; XREF: DynWater_EEZ1
		subq.b	#1,d2
		bne.s	locret_3CF4
		cmpi.w	#$2E0,($FFFFB00C).w
		bcc.s	locret_3CF4
		move.w	#$3A8,d1
		cmpi.w	#$1300,d0
		bcs.s	loc_3CF0
		move.w	#$108,d1
		move.b	#2,($FFFFF64D).w

loc_3CF0:
		move.w	d1,($FFFFF64A).w

locret_3CF4:
		rts	
; ===========================================================================

DynWater_EEZ2:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.w	#$328,d1
		cmpi.w	#$500,d0
		bcs.s	loc_3D12
		move.w	#$3C8,d1
		cmpi.w	#$B00,d0
		bcs.s	loc_3D12
		move.w	#$428,d1

loc_3D12:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

DynWater_EEZ3:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3D5E
		move.w	#$900,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3D54
		cmpi.w	#$3C0,($FFFFB00C).w
		bcs.s	loc_3D54
		cmpi.w	#$600,($FFFFB00C).w
		bcc.s	loc_3D54
		move.w	#$4C8,d1
		move.l	#Level_EEZ3,($FFFF8000).w		; MJ: Set normal version of act 3's layout to be read
		move.b	#1,($FFFFF64D).w
		sfx		sfx_Rumble

loc_3D54:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3D5E:				; XREF: DynWater_EEZ3
		subq.b	#1,d2
		bne.s	loc_3DA8
		move.w	#$4C8,d1
		cmpi.w	#$770,d0
		bcs.s	loc_3DA2
		move.w	#$308,d1
		cmpi.w	#$1400,d0
		bcs.s	loc_3DA2
		cmpi.w	#$508,($FFFFF64A).w
		beq.s	loc_3D8E
		cmpi.w	#$600,($FFFFB00C).w
		bcc.s	loc_3D8E
		cmpi.w	#$280,($FFFFB00C).w
		bcc.s	loc_3DA2

loc_3D8E:
		move.w	#$508,d1
		move.w	d1,($FFFFF648).w
		cmpi.w	#$1770,d0
		bcs.s	loc_3DA2
		move.b	#2,($FFFFF64D).w

loc_3DA2:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DA8:
		subq.b	#1,d2
		bne.s	loc_3DD2
		move.w	#$508,d1
		cmpi.w	#$1860,d0
		bcs.s	loc_3DCC
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcc.s	loc_3DC6
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3DCC

loc_3DC6:
		move.b	#3,($FFFFF64D).w

loc_3DCC:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DD2:
		subq.b	#1,d2
		bne.s	loc_3E0E
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcs.s	loc_3E04
		move.w	#$900,d1
		cmpi.w	#$1BC0,d0
		bcs.s	loc_3E04
		move.b	#4,($FFFFF64D).w
		move.w	#$608,($FFFFF64A).w
		move.w	#$7C0,($FFFFF648).w
		move.b	#1,($FFFFF7E8).w
		rts	
; ===========================================================================

loc_3E04:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3E0E:
		cmpi.w	#$1E00,d0
		bcs.s	locret_3E1A
		move.w	#$128,($FFFFF64A).w

locret_3E1A:
		rts	
; ===========================================================================

DynWater_FFZ3:				; XREF: DynWater_Index
		move.w	#$228,d1
		cmpi.w	#$F00,($FFFFF700).w
		bcs.s	loc_3E2C
		move.w	#$4C8,d1

loc_3E2C:
		move.w	d1,($FFFFF64A).w
		rts

; ---------------------------------------------------------------------------
; Labyrinth Zone "wind tunnels"	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


WindTunnels:				; XREF: WaterEffects
		cmpi.b	#5,($FFFFFE10).w
		bra.w	locret_3EF2
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret_3F0A	; if yes, branch
		lea	(Wind_Data).l,a2
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		lsl.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1
	;	tst.b	($FFFFFE11).w
	;	bne.s	loc_3E56
	;	moveq	#1,d1
	;	subq.w	#8,a2

loc_3E56:
		lea	($FFFFB000).w,a1

Wind_Loop:
		move.w	8(a1),d0
		cmp.w	(a2),d0
		bcs.w	loc_3EF4
		cmp.w	4(a2),d0
		bcc.w	loc_3EF4
		move.w	$C(a1),d2
		cmp.w	2(a2),d2
		bcs.s	loc_3EF4
		cmp.w	6(a2),d2
		bcc.s	loc_3EF4
		move.b	($FFFFFE0F).w,d0
		andi.b	#$3F,d0
		bne.s	loc_3E90
		sfx		sfx_LightTunnel	 ;	play rushing water sound

loc_3E90:
		tst.b	($FFFFF7C9).w
		bne.w	locret_3F0A
		cmpi.b	#4,$24(a1)
		bcc.s	loc_3F06
		move.b	#1,($FFFFF7C7).w
		subi.w	#$80,d0
		cmp.w	(a2),d0
		bcc.s	Wind_Move
		moveq	#2,d0
		cmpi.b	#1,($FFFFFE11).w
		bne.s	loc_3EBA
		neg.w	d0

loc_3EBA:
		add.w	d0,$C(a1)

Wind_Move:
		addq.w	#4,8(a1)
		move.w	#$400,$10(a1)	; move Sonic horizontally
		move.w	#0,$12(a1)
		move.b	#$14,$1C(a1)	; use floating animation
		bset	#1,$22(a1)
		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	Wind_MoveDown	; if not, branch
		subq.w	#1,$C(a1)	; move Sonic up

Wind_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret_3EF2	; if not, branch
		addq.w	#1,$C(a1)	; move Sonic down

locret_3EF2:
		rts	
; ===========================================================================

loc_3EF4:				; XREF: EEZWindTunnels
		addq.w	#8,a2
		dbf	d1,Wind_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret_3F0A
		move.b	#0,$1C(a1)

loc_3F06:
		clr.b	($FFFFF7C7).w

locret_3F0A:
		rts	
; End of function WindTunnels

; ===========================================================================
Wind_Data:				; XREF: WindTunnels
		even
; ---------------------------------------------------------------------------
; Wall running subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


WallRunning:				; XREF: WaterEffects
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret2_3F0A	; if yes, branch
		lea	(WallRun_Data).l,a2
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1

WallRun_Loop:
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		cmp.w	(a2),d0
		bcs.w	loc2_3EF4
		cmp.w	4(a2),d0
		bcc.w	loc2_3EF4
		move.w	$C(a1),d2
		cmp.w	2(a2),d2
		bcs.w	loc2_3EF4
		cmp.w	6(a2),d2
		bcc.w	loc2_3EF4
		tst.b	($FFFFF7C9).w
		bne.w	locret2_3F0A
		cmpi.b	#4,$24(a1)
		bcc.w	loc2_3F06
		move.b	#1,($FFFFF7C7).w

WallRun_Move:
		cmpi.b	#$10,$1C(a1)
		beq.w	locret2_3EF2
		tst.b	$2B(a1)
		bne.w	locret2_3EF2
		move.b	$22(a1),d0
		btst	#1,d0
		beq.s	WallRun_Move2
		btst	#2,d0
		bne.w	loc2_3F06

WallRun_Move2:
		move.b	($FFFFF603).w,d0
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		bne.s	loc2_3F0A	
		move.w	$10(a1),d0	; get Sonic's speed
		cmpi.w	#2,($FFFFFE10).w
		beq.s	loc4_13A9E
		move.w	$10(a1),d0	; get Sonic's speed
		bpl.s	loc4_13A9C
		neg.w	d0
		add.w	#8,$10(a1)
		btst	#3,($FFFFF602).w ; is right being pressed?
		bne.s	loc2_3F08
		bra.s	loc4_13A9E

loc4_13A9C:
		sub.w	#8,$10(a1)
		btst	#2,($FFFFF602).w ; is left being pressed?
		bne.s	loc2_3F08

loc4_13A9E:
		cmpi.w	#$400,d0	; is Sonic at running speed?
		bcs.s	loc2_3F08	; if yes, branch
		move.w	#0,$12(a1)
		move.b	#$1D,$1C(a1)	; use floating animation
		bset	#1,$22(a1)
		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	WallRun_MoveDown	; if not, branch
		subq.w	#2,$C(a1)	; move Sonic up

WallRun_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret2_3EF2	; if not, branch
		addq.w	#2,$C(a1)	; move Sonic down

locret2_3EF2:
		rts	
; ===========================================================================

loc2_3EF4:				; XREF: WindTunnels
		addq.w	#8,a2
		dbf	d1,WallRun_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret2_3F0A
		move.b	#0,$1C(a1)

loc2_3F06:
		clr.b	($FFFFF7C7).w

locret2_3F0A:
		rts	

loc2_3F0A:
		move.b	($FFFFFFF6).w,d0
		move.b	d0,mQueue+2.w ;	play jumping sound

loc2_3F08:
		clr.b	($FFFFF7C7).w
		bset	#2,$22(a1)
		move.b	#$C,$1C(a1)  ; use falling animation
		rts
; End of function WallRunning

; ===========================================================================
WallRun_Data:
	dc.w 0, 0, 0,	0
	dc.w $1F8, $100, $580,	$200
	dc.w $1F8, $100, $580,	$200
		even

; ---------------------------------------------------------------------------
; Time of Day subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TimeOfDay:
		moveq 	#0,d0
		moveq	#0,d1
		move.w	(Universal_Timer2).w,d0
		andi.w	#$7FFF,d0
		cmpi.w	#$3000,d0
		bcs.s	TimeOfDay4

TimeOfDay3:
		move.w	#$6000,d1
		sub.w	d0,d1
		move.w	d1,d0
		tst.w	d0
		bge.s	TimeOfDay4
		clr.w	d0

TimeOfDay4:
		move.w	d0,(Day_Time).w
		cmpi.b	#1,($FFFFFE10).w
		bne.s	TimeOfDay_End
		moveq 	#0,d0
		move.w	(Day_Time).w,d0
		cmpi.w	#$F00,d0
		bcs.s	TimeOfDay5
		move.w	#$EFF,d0

TimeOfDay5:
		move.w	(Day_Time_Pal).w,d1
		move.w	d0,(Day_Time_Pal).w
		btst	#7,($FFFFF600).w
		bne.w	TimeOfDay_LoadPal
		cmp.w	d0,d1
		beq.s	TimeOfDay_End
		move.w	(Day_Time_Pal),d0
		lsr.w	#2,d0
		move.w	d0,d1
		andi.w	#$3E,d0
		andi.w	#$3FE,d1
		lea	(Pal_BBZ).l,a2
		adda.w	d1,a2
		movea.w	#$FB40,a3
		adda.w	d0,a3
		move.w	(a2),(a3)
		lea	(Pal_BBZ2).l,a2
		adda.w	d1,a2
		movea.w	#$FAC0,a3
		adda.w	d0,a3
		move.w	(a2),(a3)

TimeOfDay_End:
		rts

TimeOfDay_LoadPal:
		lea	(Pal_AAZ).l,a2
		movea.w	#$FBA0,a3
		moveq	#7,d7

	.loop1:
		move.l	(a2)+,(a3)+
		dbf	d7,.loop1

		lea	(Pal_BBZ).l,a2
		move.w	(Day_Time_Pal),d1
		lsr.w	#2,d1
		andi.w	#$FC0,d1
		adda.w	d1,a2
		move.w	#$FBC0,a3
		moveq	#$F,d7

	.loop2:
		move.l	(a2)+,(a3)+
		dbf	d7,.loop2

		lea	(Pal_BBZ2).l,a2
		move.w	(Day_Time_Pal),d1
		lsr.w	#2,d1
		andi.w	#$FC0,d1
		adda.w	d1,a2
		move.w	#$FA40,a3
		moveq	#$F,d7

	.loop4:
		move.l	(a2)+,(a3)+
		dbf	d7,.loop4
; End of function TimeOfDay


; ---------------------------------------------------------------------------
; Labyrinth Zone water slide subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


WaterSlides:				; XREF: WaterEffects
		cmpi.b	#5,($FFFFFE10).w
		bra.s	locret_3F7A
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_3F6A
		move.w	$0C(a1),d0				; MJ: Load Y position
		move.w	$08(a1),d1				; MJ: Load X position
		and.w	#$0780,d0				; MJ: keep Y position within 800 pixels (in multiples of 80)
		lsl.w	#$01,d0					; MJ: multiply by 2 (Because every 80 bytes switch from FG to BG..)
		lsr.w	#$07,d1					; MJ: divide X position by 80 (00 = 0, 80 = 1, etc)
		and.b	#$7F,d1					; MJ: keep within 4000 pixels (4000 / 80 = 80)
		add.w	d1,d0					; MJ: add together
		movea.l	($FFFF8000).w,a2			; MJ: Load address of layout
		move.b	(a2,d0.w),d0				; MJ: collect correct chunk ID based on the position of Sonic
		lea	Slide_Chunks(pc),a2
		moveq	#$00,d1					; MJ: clear d2
		bra	LoadChunk				; MJ: continue

FindChunk:
		cmp.b	d2,d0					; MJ: does the chunk match?
		beq	Slide_Move				; MJ: if so, branch
		addq.w	#$01,d1					; MJ: increase counter

LoadChunk:
		move.b	(a2)+,d2				; MJ: load chunk ID
		bne	FindChunk				; MJ: if it's not null, branch

loc_3F6A:
		tst.b	($FFFFF7CA).w
		beq.s	locret_3F7A
		move.w	#5,$2E(a1)
		clr.b	($FFFFF7CA).w

locret_3F7A:
		rts	
; ===========================================================================

Slide_Move:				; XREF: WaterSlides
		cmpi.w	#3,d1
		bcc.s	loc_3F84
		nop	

loc_3F84:
		bclr	#0,$22(a1)
		move.b	Slide_Speeds(pc,d1.w),d0
		move.b	d0,$20(a1)
		bpl.s	loc_3F9A
		bset	#0,$22(a1)

loc_3F9A:
		clr.b	$15(a1)
		move.b	#$1B,$1C(a1)	; use Sonic's "sliding" animation
		move.b	#1,($FFFFF7CA).w ; lock	controls (except jumping)
		move.b	($FFFFFE0F).w,d0
		andi.b	#$1F,d0
		bne.s	locret_3FBE
		sfx		sfx_LightTunnel ;	play water sound

locret_3FBE:
		rts	
; End of function WaterSlides

; ===========================================================================
; ---------------------------------------------------------------------------
Slide_Chunks:	dc.b	$DF,$E0,$E1,$E2
		dc.b	$E3,$E4,$E5,$E6
		dc.b	$E7,$E8
		dc.b	$00					; MJ: End marker
		even
; ---------------------------------------------------------------------------
Slide_Speeds:	dc.b	$0A,$F6,$0A,$0A				; MJ: Values for speed, format XX00 = Speed in $20(a-)
		dc.b	$F6,$F6,$0A,$0A
		dc.b	$F6,$F6
		even
; ---------------------------------------------------------------------------
; ===========================================================================
; ---------------------------------------------------------------------------
; Demo sequence	pointers
; ---------------------------------------------------------------------------
Demo_Index:

Demo_EndIndex:

		dc.b 0,	$8B, 8,	$37, 0,	$42, 8,	$5C, 0,	$6A, 8,	$5F, 0,	$2F, 8,	$2C
		dc.b 0,	$21, 8,	3, $28,	$30, 8,	8, 0, $2E, 8, $15, 0, $F, 8, $46
		dc.b 0,	$1A, 8,	$FF, 8,	$CA, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0
		even

; ---------------------------------------------------------------------------
; Collision index loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ColIndexLoad:				; XREF: Level
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#$03,d0					; MJ: multiply by 8 not 4
		move.l	ColPointers(pc,d0.w),($FFFFFFD0).w	; MJ: get first collision set
		add.w	#$04,d0					; MJ: increase to next location
		move.l	ColPointers(pc,d0.w),($FFFFFFD4).w	; MJ: get second collision set
		rts	
; End of function ColIndexLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision index pointers
; ---------------------------------------------------------------------------
ColPointers:
	dc.l Col_AAZ_1
	dc.l Col_AAZ_2
	dc.l Col_BBZ_1
	dc.l Col_BBZ_2
	dc.l Col_CCZ_1
	dc.l Col_CCZ_2
	dc.l Col_DDZ_1
	dc.l Col_DDZ_2
	dc.l Col_EEZ_1
	dc.l Col_EEZ_2
	dc.l Col_FFZ_1
	dc.l Col_FFZ_2
	dc.l Col_SSZ_1
	dc.l Col_SSZ_2

; ---------------------------------------------------------------------------
; Oscillating number subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumInit:			; XREF: Level
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data).l,a2
		moveq	#$20,d1

Osc_Loop:
		move.w	(a2)+,(a1)+
		dbf	d1,Osc_Loop
		rts	
; End of function OscillateNumInit

; ===========================================================================
Osc_Data:	dc.w $7C, $80		; baseline values
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$50F0
		dc.w $11E, $2080
		dc.w $B4, $3080
		dc.w $10E, $5080
		dc.w $1C2, $7080
		dc.w $276, $80
		dc.w 0,	$80
		dc.w 0
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumDo:				; XREF: Level
		cmpi.b	#6,($FFFFB024).w
		bcc.s	locret_41C4
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data2).l,a2
		move.w	(a1)+,d3
		moveq	#$F,d1

loc_4184:
		move.w	(a2)+,d2
		move.w	(a2)+,d4
		btst	d1,d3
		bne.s	loc_41A4
		move.w	2(a1),d0
		add.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bhi.s	loc_41BA
		bset	d1,d3
		bra.s	loc_41BA
; ===========================================================================

loc_41A4:				; XREF: OscillateNumDo
		move.w	2(a1),d0
		sub.w	d2,d0
		move.w	d0,2(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bls.s	loc_41BA
		bclr	d1,d3

loc_41BA:
		addq.w	#4,a1
		dbf	d1,loc_4184
		move.w	d3,($FFFFFE5E).w

locret_41C4:
		rts	
; End of function OscillateNumDo

; ===========================================================================
Osc_Data2:	dc.w 2,	$10		; XREF: OscillateNumDo
		dc.w 2,	$18
		dc.w 2,	$20
		dc.w 2,	$30
		dc.w 4,	$20
		dc.w 8,	8
		dc.w 8,	$40
		dc.w 4,	$40
		dc.w 2,	$50
		dc.w 2,	$50
		dc.w 2,	$20
		dc.w 3,	$30
		dc.w 5,	$50
		dc.w 7,	$70
		dc.w 2,	$10
		dc.w 2,	$10
		even

; ---------------------------------------------------------------------------
; Subroutine to	change object animation	variables (rings, giant	rings)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChangeRingFrame:			; XREF: Level
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_421C
		move.b	#$B,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_421C:
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_4232
		move.b	#3,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#7,($FFFFFEC3).w
		movea.l	#RingDynPLC,a2	; get DPLC location
		move.w	#(ArtTile_Rings*$20),d4		; offset in VRAM to store art
		move.l	#Art_Ring,d6	; get art location
		moveq	#0,d0
		move.b	($FFFFFEC3).w,d0	; load frame number
		jsr 	Load_DPLC

loc_171EC2:

loc_4232:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_4250
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		cmpi.b	#6,($FFFFFEC5).w
		bcs.s	loc_4250
		move.b	#0,($FFFFFEC5).w

loc_4250:
		tst.b	($FFFFFEC6).w
		beq.s	locret_4272
		moveq	#0,d0
		move.b	($FFFFFEC6).w,d0
		add.w	($FFFFFEC8).w,d0
		move.w	d0,($FFFFFEC8).w
		rol.w	#7,d0
		andi.w	#3,d0
		move.b	d0,($FFFFFEC7).w
		subq.b	#1,($FFFFFEC6).w

locret_4272:
		rts	
; End of function ChangeRingFrame

; ===========================================================================
Demo_BBZ:	incbin	demodata\i_BBZ.bin
Demo_DDZ:	incbin	demodata\i_DDZ.bin
Demo_CCZ:	incbin	demodata\i_CCZ.bin
Demo_SS:	incbin	demodata\i_ss.bin
; ===========================================================================

; ---------------------------------------------------------------------------
; Special Stage
; ---------------------------------------------------------------------------

SpecialStage:					; XREF: GameModeArray
		command	mus_FadeOut
		bsr.w	Pal_FadeFrom
		moveq	#0,d0
		bsr.w	LoadPLC
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

	.ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,	.ClrObjRam ; clear object RAM

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

	.ClrVars2:
		move.l	d0,(a1)+
		dbf	d1,	.ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1

	.ClrVars3:
		move.l	d0,(a1)+
		dbf	d1,	.ClrVars3 ; clear object variables

		move	#$2700,sr
		bsr.w	ClearScreen
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8004,(a6)
		move.w	#$8730,(a6)
		move.w	#$8C89,(a6)		; H res 40 cells, no interlace, S/H enabled
		move.w	#$8AFF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		clr.w	($FFFFDC00).w
		move.l	#-$2400,($FFFFDCFC).w
		move.w	#$1E,($FFFFFE14).w
		move	#$2300,sr
		bsr.w	RunPLC_RAM
		jsr	Hud_Base
		move.b	#3,d0
		bsr.w	PalLoad1
		bsr.w	LevelSizeLoad
		bsr.w	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr.w	LoadZoneTiles	; load level art
		bsr.w	MainLoadBlockLoad ; load block mappings	and pallets
		bsr.w	LoadTilesFromStart
		bsr.w	ColIndexLoad
		bsr.w	WaterEffects
		move.b	#$D,($FFFFB000).w
		move.w	#$120,($FFFFB008).w
		move.w	#$160,($FFFFB00C).w
		move.b	#$C,($FFFFB380).w
		move.w	#$120,($FFFFB388).w
		move.w	#$140,($FFFFB38C).w
		move.b	#$21,($FFFFB040).w ; load HUD object
		move.w	#0,($FFFFF602).w
		move.w	#0,($FFFFF670).w
		move.w	#0,($FFFFF604).w
		move.w	#0,($FFFFF606).w
		move.b	#0,($FFFFF74F).w
		jsr	ObjPosLoad
		move.b	#0,($FFFFFE17).w
		jsr	RingsManager
		jsr	ObjectsLoad
		jsr	BuildSprites

	@loadmusic:
		jsr	RandomNumber
		andi.b	#7,d0
		cmpi.b	#7,d0
		beq.s	@loadmusic
		addi.b	#mus_Bonus1,d0
		move.b	d0,mQueue+2.w	; play that music!
		moveq	#0,d0
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE2D).w
		move.b	d0,($FFFFFE1A).w
		bclr	#1,($FFFFFE2C).w ; clear invincibility
		move.b	d0,($FFFFFE2E).w ; clear speed shoes
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		move.b	d0,($FFFFFE07).w
		bsr.w	OscillateNumInit
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		move.w	#$3F,($FFFFF626).w
		bsr.w	Pal_FadeTo2
		move.b	#1,($FFFFF74F).w
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.b	#$38,($FFFFB180).w ; load "shield" object

; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

SS_MainLoop:
		bsr.w	PauseGame
		move.b	#8,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		addq.l	#1,(Universal_Timer).w ; add 1 to level timer
		bsr.w	TimeOfDay
		jsr	ObjectsLoad
		jsr	RingsManager
		tst.w	($FFFFFE02).w	; is the level set to restart?
		bne.w	SpecialStage		; if yes, branch
		cmpi.b	#$14,($FFFFF600).w
		bne.w	SS_locret	; if screen mode is $0C	(level), branch
		bsr.w	DeformBgLayer
		jsr	BuildSprites
		jsr	ObjPosLoad	
		bsr.w	PalCycle_Load
		bsr.w	RunPLC_RAM
		bsr.w	OscillateNumDo
		bsr.w	ChangeRingFrame
		bra.s	SS_MainLoop

SS_locret:
		rts	

; ---------------------------------------------------------------------------
; Bonus Stage
; ---------------------------------------------------------------------------

BonusStage:				; XREF: GameModeArray
		sfx		sfx_EnterSS ; play special stage entry sound
		bsr.w	Pal_MakeFlash
		move	#$2700,sr
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8004,(a6)
		move.w	#$8AAF,($FFFFF624).w
		move.w	#$9001,(a6)
		move.w	#$8C81,(a6)		; H res 40 cells, no interlace, S/H disabled
		move.w	($FFFFF60C).w,d0
		andi.b	#$BF,d0
		move.w	d0,($C00004).l
		bsr.w	ClearScreen
		move	#$2300,sr
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$946F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$50000081,(a5)
		move.w	#0,($C00000).l

loc_463C:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_463C
		move.w	#$8F02,(a5)
		bsr.w	BS_BGLoad
		moveq	#$14,d0
		bsr.w	RunPLC_ROM	; load special stage patterns
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

BS_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,BS_ClrObjRam	; clear	the object RAM

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1

BS_ClrRam:
		move.l	d0,(a1)+
		dbf	d1,BS_ClrRam	; clear	variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$27,d1

BS_ClrRam2:
		move.l	d0,(a1)+
		dbf	d1,BS_ClrRam2	; clear	variables

		lea	($FFFFAA00).w,a1
		moveq	#0,d0
		move.w	#$7F,d1

BS_ClrNemRam:
		move.l	d0,(a1)+
		dbf	d1,BS_ClrNemRam	; clear	Nemesis	buffer

		clr.b	($FFFFF64E).w
		clr.w	($FFFFFE02).w
		moveq	#$A,d0
		bsr.w	PalLoad1	; load special stage pallet
		moveq	#3,d0
		cmpi.b	#1,(Current_Character).w
		ble.s	BS_Cont
		moveq	#$F,d0
		cmpi.b	#2,(Current_Character).w
		beq.s	BS_Cont
		moveq	#$15,d0
		cmpi.b	#3,(Current_Character).w
		beq.s	BS_Cont
		moveq	#$B,d0

BS_Cont:
		bsr.w	PalLoad1	; load special stage pallet
		jsr	BS_Load	
		jsr	OscillateNumInit
		move.b	#0,($FFFFF74F).w
		move.l	#0,($FFFFF700).w
		move.l	#0,($FFFFF704).w
		move.b	#9,($FFFFB000).w ; load	special	stage Sonic object
		move.b	#$FF,($FFFFF743).w	; fill previous angle with obviously false value to force an update
		move.b	#1,($FFFFFE1E).w ; update time counter
		clr.l	($FFFFFE22).w ; clear timer
		move.b	#$21,($FFFFB040).w ; load	special	stage Sonic object
		jsr	Hud_Base_SS	; load basic HUD gfx
		clr.w	($FFFFF780).w	; set stage angle to "upright"
		move.w	#$20,($FFFFF782).w ; set stage rotation	speed
		music	mus_Special	; play special stage BG	music
		move.w	#0,($FFFFF790).w
		lea	(Demo_Index).l,a1
		moveq	#6,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1
		move.b	1(a1),($FFFFF792).w
		subq.b	#1,($FFFFF792).w
		clr.b	($FFFFFE1B).w
		move.w	#0,($FFFFFE08).w
		move.w	#1800,($FFFFF614).w
		tst.b	($FFFFFFE2).w	; has debug cheat been entered?
		beq.s	BS_NoDebug	; if not, branch
		btst	#6,($FFFFF604).w ; is A	button pressed?
		beq.s	BS_NoDebug	; if not, branch
		move.b	#1,($FFFFFFFA).w ; enable debug	mode

BS_NoDebug:
		move.w	($FFFFF60C).w,d0
		ori.b	#$40,d0
		move.w	d0,($C00004).l
		bsr.w	Pal_MakeWhite

; ---------------------------------------------------------------------------
; Main Special Stage loop
; ---------------------------------------------------------------------------

BS_MainLoop:
		bsr.w	PauseGame
		move.b	#$A,($FFFFF62A).w
		bsr.w	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer
		addq.l	#1,(Universal_Timer).w ; add 1 to level timer
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	BS_ShowLayout
		jsr	OscillateNumDo
		jsr	Deform_BonusStage

BS_ChkEnd:
		cmpi.b	#$10,($FFFFF600).w ; is	game mode $10 (special stage)?
		beq.w	BS_MainLoop	; if yes, branch
		move.b	#$C,($FFFFF600).w ; set	screen mode to $0C (level)
		sfx		sfx_EnterSS ; play special stage exit sound
		bra.w	Pal_MakeFlash

; ---------------------------------------------------------------------------
; Special stage	background loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_BGLoad:				; XREF: SpecialStage
		lea	($FF0000).l,a1
		lea	(Eni_SSBg).l,a0 ; load	mappings for the birds and fish
		move.w	#$6000,d0
		bsr.w	EniDec
		copyTilemap	$FF0000,($E000),($3F),($1F)

		lea	($FF0000).l,a1
		lea	(Eni_SSFg).l,a0 ; load	mappings for the clouds
		move.w	#$C200,d0
		bsr.w	EniDec
		copyTilemap	$FF0000,($C000),($3F),($1F)
		rts	
; End of function BS_BGLoad

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 97 - The Tornado to the Special Stage
; ----------------------------------------------------------------------------

Obj97:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj97_Index(pc,d0.w),d1
		jsr	Obj97_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj97_Index:	dc.w Obj97_Main-Obj97_Index
		dc.w Obj97_Move-Obj97_Index
		dc.w Obj97_Move2-Obj97_Index
; ===========================================================================

Obj97_Main:
		addq.b	#2,$24(a0)
		move.l	#Map_Tornado,4(a0)
		move.w	#$8DA4,2(a0)
		move.b	#4,1(a0)
		move.b	#$60,$14(a0)
		move.w	#$180,$18(a0)
		moveq	#$30,d0
		jsr	LoadPLC2		; load standard	patterns

Obj97_Move:
		jsr	SpeedToPos
		moveq	#0,d1
		move.b	#$14,d1
		jmp	(PlatformObject).l
; ===========================================================================

Obj97_Move2:
		moveq	#0,d1
		move.b	#$14,d1
		jsr	(ExitPlatform).l
		move.w	8(a0),-(sp)
		jsr	SpeedToPos
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l

; ---------------------------------------------------------------------------
; Sprite mappings - The Tornado
; ---------------------------------------------------------------------------
Map_Tornado:
	include "_maps\tornado.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9A - The Tornado's Sign
; ----------------------------------------------------------------------------

Obj9A:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj9A_Index(pc,d0.w),d1
		jmp	Obj9A_Index(pc,d1.w)
; ===========================================================================
Obj9A_Index:	dc.w Obj9A_Main-Obj9A_Index
		dc.w Obj9A_Stop-Obj9A_Index
		dc.w Obj9A_GetOn-Obj9A_Index
		dc.w Obj9A_Wait-Obj9A_Index
		dc.w Obj9A_Jump-Obj9A_Index
		dc.w Obj9A_Leave-Obj9A_Index
		dc.w Obj9A_Display-Obj9A_Index
; ===========================================================================

Obj9A_Main:
		addq.b	#2,$24(a0)
		move.l	#Map_obj9A,4(a0)
		make_art_tile	ArtTile_TornadoSign,0,1
		move.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$280,$18(a0)
		moveq	#$2F,d0
		jsr	LoadPLC		; load standard	patterns

Obj9A_Stop:
		lea	($FFFFB000).w,a1
		move.w	8(a0),d0
		move.w	8(a1),d1
		sub.w	d0,d1
		cmpi.w	#$10,d1
		bge.w	Obj9A_Display
		cmpi.w	#-$10,d1
		ble.w	Obj9A_Display
		tst.w	$10(a1)
		bne.w	Obj9A_Display
		tst.w	$12(a1)
		bne.w	Obj9A_Display
		move.w	#$20,$10(a1)
		move.b	#1,($FFFFF7CC).w
		move.b	#1,($FFFFF674).w
		addq.b	#2,$24(a0)
		move.w	#$C0,$30(a0)
		bset	#0,($FFFFF602).w
		move.w	($FFFFF700).w,d0
		move.w	d0,($FFFFF72A).w
		cmpi.b	#$95,($FFFFB380).w
		bne.s	Obj9A_GetOn
		bset	#2,($FFFFF670).w

Obj9A_GetOn:
		subi.w	#1,$30(a0)
		bpl.w	Obj9A_Display2
		addq.b	#2,$24(a0)
		move.w	#$60,$30(a0)
		jsr	SingleObjLoad
		bne.s	Obj9A_Wait
		move.b	#$97,0(a1)
		move.l	a1,$34(a0)
		move.w	8(a0),d0
		subi.w	#$100,d0
		move.w	d0,8(a1)
		move.w	$C(a0),d0
		subi.w	#$70,d0
		move.w	d0,$C(a1)
		move.w	#$200,$10(a1)
		move.w	#$1A0,$12(a1)

Obj9A_Wait:
		move.l	$34(a0),a1
		tst.w	$12(a1)
		bmi.s	Obj9A_Wait2
		subi.w	#4,$12(a1)

Obj9A_Wait2:
		subi.w	#1,$30(a0)
		bpl.w	Obj9A_Display2
		addq.b	#2,$24(a0)
		move.w	#1,$30(a0)
		bclr	#0,($FFFFF602).w
		bclr	#2,($FFFFF670).w
		bset	#5,($FFFFF602).w
		bset	#5,($FFFFF670).w
		bset	#5,($FFFFF603).w
		bset	#5,($FFFFF671).w

Obj9A_Jump:
		subi.w	#1,$30(a0)
		bpl.s	Obj9A_Display2
		bclr	#5,($FFFFF603).w
		bclr	#5,($FFFFF671).w
		addq.b	#2,$24(a0)
		move.w	#$C0,$30(a0)

Obj9A_Leave:
		move.l	$34(a0),a1
		subi.w	#$E,$12(a1)
		subi.w	#1,$30(a0)
		bpl.s	Obj9A_Display2
		move.w	#$700,($FFFFFE10).w
		move.b	#$14,($FFFFF600).w
		jmp	DisplaySprite	

Obj9A_Display:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj9A_Display2
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj9A_Delete	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again

Obj9A_Delete:				; XREF: Obj4B_Index
		moveq	#1,d0
		jsr	LoadPLC		; load standard	patterns
		jmp	DeleteObject	

Obj9A_Display2:
		jmp	DisplaySprite		

; ---------------------------------------------------------------------------
; Sprite mappings - The Tornado's Sign
; ---------------------------------------------------------------------------
Map_obj9A:
	include "_maps\obj9A.asm"

; ----------------------------------------------------------------------------
; Sprite
;
; Unknown
; ----------------------------------------------------------------------------

Obj98:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_21170(pc,d0.w),d1
		jsr	off_21170(pc,d1.w)
		jmp	MarkObjGone3
; ===========================================================================
off_21170:	dc.w loc_21176-off_21170; 0 ; DATA XREF: h+A1FCo h+A1FEo ...
		dc.w loc_21224-off_21170; 1
		dc.w loc_212F6-off_21170; 2
; ===========================================================================

loc_21176:				; DATA XREF: h+A1FCo
		addq.b	#2,$24(a0)
		move.l	#Map_Obj25,4(a0)
		make_art_tile	ArtTile_Rings,0,1
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$280,$18(a0)
		move.b	$28(a0),d0
		btst	#2,d0
		beq.s	loc_211F0
		addq.b	#2,$24(a0)
		andi.w	#7,d0
		move.b	d0,$1A(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	$C(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	$C(a1),d1
		bcc.s	loc_211D4
		move.b	#1,$34(a0)

loc_211D4:				; CODE XREF: h+A258j
		lea	($FFFFB380).w,a1
		cmp.w	$C(a1),d1
		bcc.s	loc_211E4
		move.b	#1,$35(a0)

loc_211E4:				; CODE XREF: h+A268j
		bra.w	loc_212F6
; ===========================================================================
word_211E8:	dc.w   $20		; 0
		dc.w   $40		; 1
		dc.w   $80		; 2
		dc.w  $100		; 3
; ===========================================================================

loc_211F0:				; CODE XREF: h+A232j
		andi.w	#3,d0
		move.b	d0,$1A(a0)
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	8(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	8(a1),d1
		bcc.s	loc_21214

loc_2120E:
		move.b	#1,$34(a0)

loc_21214:				; CODE XREF: h+A298j
		lea	($FFFFB380).w,a1
		cmp.w	8(a1),d1
		bcc.s	loc_21224

loc_2121E:
		move.b	#1,$35(a0)

loc_21224:				; CODE XREF: h+A2A8j
					; DATA XREF: h+A1FCo
		tst.w	($FFFFFE08).w
		bne.s	locret_21284
		move.w	8(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_21244
		lea	($FFFFB380).w,a1
		cmpi.w	#4,($FFFFF678).w
		beq.s	locret_21284

loc_21244:				; CODE XREF: h+A2C2p
		tst.b	(a2)+
		bne.s	loc_21286
		cmp.w	8(a1),d1
		bhi.s	locret_21284
		move.b	#1,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#0,1(a0)
		bne.s	loc_2127E
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; ===========================================================================

loc_2127E:				; CODE XREF: h+A300j
		move.b	#0,$39(a1)

locret_21284:				; CODE XREF: h+A2B4j h+A2CEj ...
		rts	
; ===========================================================================

loc_21286:				; CODE XREF: h+A2D2j
		cmp.w	8(a1),d1
		bls.s	locret_21284
		move.b	#0,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#0,1(a0)
		beq.s	loc_212BC
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; ===========================================================================

loc_212BC:				; CODE XREF: h+A33Ej
		move.b	#0,$39(a1)
		rts	
; ===========================================================================

loc_212C4:				; CODE XREF: h+4D66p h+A308j ...
		btst	#2,$22(a1)
		beq.s	loc_212CE
		rts	
; ===========================================================================

loc_212CE:				; CODE XREF: h+A356j
		bset	#2,$22(a1)
		move.b	#$E,$16(a1)
		move.b	#7,$17(a1)
		move.b	#2,$1C(a1)
		addq.w	#5,$C(a1)
		sfx		sfx_RingRight
		rts	
; ===========================================================================

loc_212F6:				; CODE XREF: h+A270j
					; DATA XREF: h+A1FCo
		tst.w	($FFFFFE08).w
		bne.s	locret_21350
		move.w	$C(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_2130E
		lea	($FFFFB380).w,a1

loc_2130E:				; CODE XREF: h+A394p
		tst.b	(a2)+
		bne.s	loc_21352
		cmp.w	$C(a1),d1
		bhi.s	locret_21350
		move.b	#1,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#0,1(a0)
		bne.s	loc_2134A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; ===========================================================================

loc_2134A:				; CODE XREF: h+A3CAj
		move.b	#0,$39(a1)

locret_21350:				; CODE XREF: h+A386j h+A3A2j ...
		rts	
; ===========================================================================

loc_21352:				; CODE XREF: h+A39Cj
		cmp.w	$C(a1),d1
		bls.s	locret_21350
		move.b	#0,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#0,1(a0)
		beq.s	loc_2138A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; ===========================================================================

loc_2138A:				; CODE XREF: h+A40Aj
		move.b	#0,$39(a1)
		rts	

; ---------------------------------------------------------------------------
; Ending sequence demos
; ---------------------------------------------------------------------------
Demo_EndBBZ1:	incbin	demodata\e_BBZ1.bin
		even
Demo_EndDDZ:	incbin	demodata\e_DDZ.bin
		even
Demo_EndCCZ:	incbin	demodata\e_CCZ.bin
		even
Demo_EndEEZ:	incbin	demodata\e_EEZ.bin
		even
Demo_EndAAZ:	incbin	demodata\e_AAZ.bin
		even
Demo_EndFFZ1:	incbin	demodata\e_FFZ1.bin
		even
Demo_EndFFZ2:	incbin	demodata\e_FFZ2.bin
		even
Demo_EndBBZ2:	incbin	demodata\e_BBZ2.bin
		even
; ---------------------------------------------------------------------------
; Subroutine to	load level boundaries and start	locations
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LevelSizeLoad:				; XREF: TitleScreen; Level; EndingSequence
		moveq	#0,d0
		move.b	d0,($FFFFF740).w
		move.b	d0,($FFFFF741).w
		move.b	d0,($FFFFF742).w
		move.b	d0,(Scroll_Lock).w
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	TitleSize
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	LevelSizeArray(pc,d0.w),a0 ; load level	boundaries
		bra.s 	LevelSizeCont

TitleSize:
		lea	TitleSizeArray,a0 ; load level	boundaries

LevelSizeCont:
		move.w	(a0)+,d0
		move.l	(a0)+,d0
		move.l	d0,($FFFFF728).w
		move.l	d0,($FFFFF720).w
		tst.b	($FFFFF7A6).w
		bne.s	.continue
		move.l	(a0)+,d0
		move.l	d0,($FFFFF72C).w
		move.l	d0,($FFFFF724).w

		move.w	#$1010,($FFFFF74A).w
		move.w	(a0)+,d0
		move.w	d0,($FFFFF73E).w

	.continue:
		move.w	#160,(v_camera_pan).w	; reset the horizontal camera pan value to 160 pixels
		bra.w	LevSz_ChkLamp
; ===========================================================================
; ---------------------------------------------------------------------------
; Level size array and ending start location array
; ---------------------------------------------------------------------------
LevelSizeArray: ;unused, left boundary, right boundary, upper boundary (remove), lower boundary, y-camera position ($60 = default)
		dc.w 4, 0, $3E00, 0, $800, $60	; AAZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; AAZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; AAZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; AAZ4
		dc.w 4, 0, $3E00, 0, $6C0, $60	; BBZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; BBZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; BBZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; BBZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; CCZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; CCZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; CCZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; CCZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; DDZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; DDZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; DDZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; DDZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; EEZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; EEZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; EEZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; EEZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; FFZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; FFZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; FFZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; FFZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; GGZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; GGZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; GGZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; GGZ4
		dc.w 4, 0, $3E00, 0, $800, $60	; SSZ1
		dc.w 4, 0, $3E00, 0, $800, $60	; SSZ2
		dc.w 4, 0, $3E00, 0, $800, $60	; SSZ3
		dc.w 4, 0, $3E00, 0, $800, $60	; SSZ4
		even

TitleSizeArray:
		dc.w 4, 0, $3E00, 0, $300, $60	; AAZ1
		even

EndingStLocArray:
		incbin	misc\sloc_end.bin
		even

; ===========================================================================

LevSz_ChkLamp:				; XREF: LevelSizeLoad
		tst.b	($FFFFF7A6).w
		bne.w	LevSz_SonicPos2
		tst.b	($FFFFFE30).w	; have any lampposts been hit?
		beq.s	LevSz_StartLoc	; if not, branch
		jsr	Obj79_LoadInfo

LevSz_LampCont:
		move.w	($FFFFB008).w,d1
		move.w	($FFFFB00C).w,d0
		bra.w	loc_60D0
; ===========================================================================

LevSz_StartLoc:				; XREF: LevelSizeLoad
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		lea	(StartLocArray).l,a1			; MJ: load location array
		lea	(a1,d0.w),a1				; MJ: load Sonic's start location address
		tst.w	($FFFFFFF0).w	; is demo mode on?
		bpl.s	LevSz_SonicPos	; if not, branch
		move.w	($FFFFFFF4).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		lea	EndingStLocArray(pc,d0.w),a1 ; load Sonic's start location

LevSz_SonicPos:
		moveq	#0,d1
		move.w	(a1)+,d1
		move.w	d1,($FFFFB008).w ; set Sonic's position on x-axis
		move.w	d1,($FFFFB388).w ; set Sonic's position on x-axis
		move.w	d1,($FFFFFE32).w ; set Sonic's position on x-axis
		subi.w	#$20,($FFFFB388).w
		move.w	d1,($FFFFB448).w ; set Sonic's position on x-axis
		moveq	#0,d0
		move.w	(a1),d0
		move.w	d0,($FFFFB00C).w ; set Sonic's position on y-axis
		move.w	d0,($FFFFB38C).w ; set Sonic's position on y-axis
		move.w	d0,($FFFFFE34).w ; set Sonic's position on x-axis
		addi.w	#$20,d0
		move.w	d0,($FFFFB44C).w ; set Sonic's position on x-axis

LevSz_SonicPos3:
		move.b	($FFFFF600).w,d2			; MJ: load game mode
		andi.w	#$00FC,d2				; MJ: keep in range
		cmpi.b	#$04,d2					; MJ: is screen mode at title?
		bne	loc_60D0				; MJ: if not, branch
		move.w	#$1A2,d1				; MJ: set positions for title screen
		move.w	#0,d0				; MJ: ''
		move.w	d1,($FFFFB008).w			; MJ: save to object 1 so title screen follows
		move.w	d0,($FFFFB00C).w			; MJ: ''
		bra.s	loc_60D0

LevSz_SonicPos2:
		moveq	#0,d1
		sub.w	#$3E00,($FFFFB388).w ; set Sonic's position on x-axis
		sub.w	#$3E00,($FFFFB788).w
		move.w	($FFFFB008).w,d1
		sub.w	#$3E00,d1
		move.w	d1,($FFFFB008).w ; set Sonic's position on x-axis
		move.w	d1,($FFFFFE32).w
		move.w	($FFFFB00C).w,d0 ; set Sonic's position on y-axis
		move.w	d0,($FFFFFE34).w

loc_60D0:				; XREF: LevSz_ChkLamp
		clr.w	($FFFFFEB2).w
		clr.w	($FFFFF7A8).w		; reset Sonic's position tracking index
		lea	($FFFFE500).w,a2	; load the tracking array into a2
		moveq	#63,d2			; begin a 64-step loop

	.looppoint:
		move.w	d1,(a2)+		; fill in X
		move.w	d0,(a2)+		; fill in Y
		dbf	d2,.looppoint		; loop
		subi.w	#$A0,d1
		bcc.s	loc_60D8
		moveq	#0,d1

loc_60D8:
		move.w	($FFFFF72A).w,d2
		cmp.w	d2,d1
		bcs.s	loc_60E2
		move.w	d2,d1

loc_60E2:
		move.w	d1,($FFFFF700).w
		subi.w	#$60,d0
		bcc.s	loc_60EE
		moveq	#0,d0

loc_60EE:
		cmp.w	($FFFFF72E).w,d0
		blt.s	loc_60F8
		move.w	($FFFFF72E).w,d0

loc_60F8:
		move.w	d0,($FFFFF704).w
		bsr.w	BgScrollSpeed
		bra.w	LevSz_Unk

; ===========================================================================
; ---------------------------------------------------------------------------
; MJ: Sonic start location array
; ---------------------------------------------------------------------------

StartLocArray:
		incbin	startpos\AAZ1.bin
		incbin	startpos\AAZ2.bin
		incbin	startpos\AAZ3.bin
		incbin	startpos\AAZ4.bin
		INCBIN	startpos\BBZ1.bin
		incbin	startpos\BBZ2.bin
		incbin	startpos\BBZ3.bin
		incbin	startpos\BBZ4.bin
		incbin	startpos\CCZ1.bin
		incbin	startpos\CCZ2.bin
		incbin	startpos\CCZ3.bin
		incbin	startpos\CCZ4.bin
		incbin	startpos\DDZ1.bin
		incbin	startpos\DDZ2.bin
		incbin	startpos\DDZ3.bin
		incbin	startpos\DDZ4.bin
		incbin	startpos\EEZ1.bin
		incbin	startpos\EEZ2.bin
		incbin	startpos\EEZ3.bin
		incbin	startpos\EEZ4.bin
		incbin	startpos\FFZ1.bin
		incbin	startpos\FFZ2.bin
		incbin	startpos\FFZ3.bin
		incbin	startpos\FFZ4.bin
		incbin	startpos\GGZ1.bin
		incbin	startpos\GGZ2.bin
		incbin	startpos\GGZ3.bin
		incbin	startpos\GGZ4.bin
		incbin	startpos\SSZ1.bin
		incbin	startpos\SSZ2.bin
		incbin	startpos\SSZ3.bin
		incbin	startpos\SSZ4.bin
		even

; ===========================================================================

LevSz_Unk:				; XREF: LevelSizeLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#3,d0
		lea	dword_61B4(pc,d0.w),a1
		lea	($FFFFF7F0).w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		rts	
; End of function LevelSizeLoad

; ===========================================================================
dword_61B4:	dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000

; ---------------------------------------------------------------------------
; Subroutine to	set scroll speed of some backgrounds
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BgScrollSpeed:				; XREF: LevelSizeLoad
		tst.b	($FFFFFE30).w
		bne.s	loc_6206
		move.w	d0,($FFFFF70C).w
		move.w	d0,($FFFFF714).w
		move.w	d1,($FFFFF708).w
		move.w	d1,($FFFFF710).w
		move.w	d1,($FFFFF718).w

loc_6206:
		cmpi.b	#4,($FFFFF600).w
		beq.w	BgScroll_Title
		moveq	#0,d2
		move.b	($FFFFFE10).w,d2
		add.w	d2,d2
		move.w	BgScroll_Index(pc,d2.w),d2
		jmp	BgScroll_Index(pc,d2.w)
; End of function BgScrollSpeed

; ===========================================================================
BgScroll_Index:	dc.w BgScroll_AAZ-BgScroll_Index, BgScroll_BBZ-BgScroll_Index
		dc.w BgScroll_CCZ-BgScroll_Index, BgScroll_DDZ-BgScroll_Index
		dc.w BgScroll_EEZ-BgScroll_Index, BgScroll_FFZ-BgScroll_Index
		dc.w BgScroll_GGZ-BgScroll_Index, BgScroll_SSZ-BgScroll_Index
; ===========================================================================

BgScroll_BBZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.w	#$3E00,$FFFFF708	; reset position for all BG scroll layers
		move.w	d0,$FFFFF70C	; ''
		move.w	d0,$FFFFF710	; ''
		move.w	d0,$FFFFF714	; ''
		move.w	d0,$FFFFF718	; ''
		move.w	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_EEZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_AAZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================

BgScroll_FFZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_End:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 

BgScroll_SSZ:
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 

BgScroll_Title:
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_CCZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts
; ===========================================================================
 
BgScroll_GGZ:				; XREF: BgScroll_Index
		moveq	#0,d0
		move.l	d0,$FFFFF708	; reset position for all BG scroll layers
		move.l	d0,$FFFFF70C	; ''
		move.l	d0,$FFFFF710	; ''
		move.l	d0,$FFFFF714	; ''
		move.l	d0,$FFFFF718	; ''
		move.l	d0,$FFFFF71C	; ''
		rts 
; ===========================================================================
 
BgScroll_DDZ:				; XREF: BgScroll_Index
		move.w	#$0100,($FFFFF708).w			; force X position to 2nd chunk's position (So redraw always occurs at beginning correctly...)
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFF70C).w			; save as BG Y position
		rts

; ---------------------------------------------------------------------------
; Background layer deformation subroutines
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeformBgLayer:				; XREF: TitleScreen; Level; EndingSequence
		tst.b	($FFFFF744).w
		beq.s	loc_628E
		rts	
; ===========================================================================

loc_628E:
		clr.w	($FFFFF754).w
		clr.w	($FFFFF756).w
		clr.w	($FFFFF758).w
		clr.w	($FFFFF75A).w
		tst.b	(Scroll_Lock).w
		bne.s	loc_6290
		bsr.w	ScrollHoriz
		bsr.w	ScrollVertical

loc_6290
		bsr.w	DynScrResizeLoad
		move.w	($FFFFF700).w,($FFFFF61A).w
		move.w	($FFFFF704).w,($FFFFF616).w
		move.w	($FFFFF708).w,($FFFFF61C).w
		move.w	($FFFFF70C).w,($FFFFF618).w
		move.w	($FFFFF718).w,($FFFFF620).w
		move.w	($FFFFF71C).w,($FFFFF61E).w
		moveq	#0,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.w 	Deform_Title
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Deform_Index(pc,d0.w),d0
		jmp	Deform_Index(pc,d0.w)
; End of function DeformBgLayer

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for background layer deformation	code
; ---------------------------------------------------------------------------
Deform_Index:	dc.w Deform_AAZ-Deform_Index, Deform_BBZ-Deform_Index
		dc.w Deform_CCZ-Deform_Index, Deform_DDZ-Deform_Index
		dc.w Deform_EEZ-Deform_Index, Deform_FFZ-Deform_Index
		dc.w Deform_GGZ-Deform_Index, Deform_SSZ-Deform_Index
; ---------------------------------------------------------------------------
; Green	Hill Zone background layer deformation code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Deform_BBZ:			
		lea	ParallaxScriptBBZ,a1
		jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

ParallaxScriptBBZ:

_normal = $0000
_moving	= $0200
_linear = $0400
_ripple = $0600

	;	Mode			Speed coef.		Number of lines
	dc.w	_moving|$01,	$0000,		68			; Clouds
	dc.w	_moving|$02,	$0000,		20			; Clouds
	dc.w	_moving|$03,	$0000,		16			; Clouds
	dc.w	_normal,		$0008,		48			; Mountain
	dc.w	_ripple,		$0008,		72			; Reflection
	dc.w	-1

;Deform_BBZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
	;	lsl.l	#7,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 8
		move.w	d0,($FFFFD900).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD902).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFD904).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFD906).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD908).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD90A).w			; set speed 2

		lea	DBBZ_Act2(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DBBZ_Act2:	dc.w	$D900,  8				; top 70 scroll
		dc.w	$D902,  8				; top 70 scroll
		dc.w	$D904,  $16				; top 70 scroll
		dc.w	$D906,  $16				; top 70 scroll
		dc.w	$D908,  $16				; bottom 70 scroll
		dc.w	$D90A,  $64				; bottom 70 scroll
		dc.w	$D90C,  $96				; bottom 70 scroll
		dc.w	$0000

HTZ_Screen_Shake:
	move.w	($FFFFF73A).w,d4	; Copy
	ext.l	d4
	lsl.l	#8,d4
	move.w	($FFFFF73C).w,d5 ;Copy
	ext.l	d5
	lsl.l	#8,d5
	bsr.w	ScrollBlock1
	move.w	($FFFFF70C).w,($FFFFF618).w
	move.w	($FFFFF704).w,($FFFFF616).w
	move.w	($FFFFF70C).w,($FFFFF618).w
	moveq	#0,d2
;	tst.b	(Screen_Shaking_Flag).w
;	beq.s	HSS1
	move.w	(Universal_Timer2).w,d0
	andi.w	#$3F,d0
	lea	SwScrl_RippleData,a1
	lea	(a1,d0.w),a1
	moveq	#0,d0
	move.b	(a1)+,d0
	add.w	d0,($FFFFF616).w
	add.w	d0,($FFFFF618).w
	add.w	d0,($FFFFF73C).w
	move.b	(a1)+,d2
	add.w	d2,($FFFFF73A).w

HSS1:
	lea	($FFFFE000).w,a1
	move.w	#$DF,d1	; 'ร'
	move.w	($FFFFF700).w,d0
	add.w	d2,d0
	neg.w	d0
	swap	d0
	move.w	($FFFFF708).w,d0
	add.w	d2,d0
	neg.w	d0

HSS2:
	move.l	d0,(a1)+
	dbf	d1,HSS2
;	add.w	#1,($FFFFF70C).w
	rts
; End of function Deform_BBZ
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Deform_EEZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#7,d0					; divide by 8
		move.w	d0,($FFFFD900).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFD902).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	(Universal_Timer2).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#4,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFD904).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	(Universal_Timer2).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#3,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFD906).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFD908).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD90A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFD90C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFD90E).w			; set speed 2

		lea	DEEZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DEEZ_Act1:	dc.w	$D900,  $B0				; sky
		dc.w	$D902,  $30				; structures
		dc.w	$D904,  8				; small rocks
		dc.w	$D906,  $20				; large rocks
		dc.w	$D908,  $10				; grass 1
		dc.w	$D90A,  $28				; grass 2
		dc.w	$D90C,  $38				; leaves
		dc.w	$D90E,  $108			; trees
		dc.w	$0000

EEZ_Wave_Data:	dc.b   1,  1,  2,  2,  3,  3,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b $FF,$FF,$FE,$FE,$FD,$FD,$FD,$FD,$FE,$FE,$FF,$FF,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   1,  1,  2,  2,  3,  3,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0

; ===========================================================================
; horizontal offsets for the water rippling effect
; byte_C682:
SwScrl_RippleData:
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 48
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 64
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32
	dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0; 16
	dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3; 32

SwScrl_RippleData2:
	dc.b $FE,	1,	2,	2,$FF,	2,	2,	1,	2,$FF,$FE,$FE,$FE,	1,$FF,$FF
	dc.b $FF,	0,$FE,	0,	0,	0,$FE,	0,$FE,	2,	0,$FE,	2,	2,$FF,$FE
	dc.b $FE,	1,	2,	2,$FF,	2,	2,	1,	2,$FF,$FE,$FE,$FE,	1,$FF,$FF
	dc.b $FF,	0,$FE,	0,	0,	0,$FE,	0,$FE,	2,	0,$FE,	2,	2,$FF,$FE
	dc.b $FE,	1,	2,	2,$FF,	2,	2,	1,	2,$FF,$FE,$FE,$FE,	1,$FF,$FF
	dc.b $FF,	0,$FE,	0,	0,	0,$FE,	0,$FE,	2,	0,$FE,	2,	2,$FF,$FE
	dc.b $FE,	1,	2,	2,$FF,	2,	2,	1,	2,$FF,$FE,$FE,$FE,	1,$FF,$FF
	dc.b $FF,	0,$FE,	0,	0,	0,$FE,	0,$FE,	2,	0,$FE,	2,	2,$FF,$FE
	dc.b $FE,	1,	2,	2,$FF,	2,	2,	1,	2,$FF,$FE,$FE,$FE,	1,$FF,$FF
; ===========================================================================
 
Deform_AAZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 8
		move.w	(Universal_Timer2).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#3,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFA800).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	(Universal_Timer2).w,d1			; load X position
		neg.w	d1					; reverse direction
		asr.w	#2,d1					; divide by 8
		add.w	d1,d0
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA808).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA80A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#2,d1
		add.w	d1,d0
		move.w	d0,($FFFFA80C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,d1				; divide by 4
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,($FFFFA80E).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA810).w			; set speed 2
		lea	DAAZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DAAZ_Act1:	dc.w	$A800,  $20				; 
		dc.w	$A802,  $20				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A800,  $20				; 
		dc.w	$A802,  $20				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A800,  $10				; 
		dc.w	$A802,  $10				; 
		dc.w	$A804,  $48				; 
		dc.w	$A806,  $15				; 
		dc.w	$A808,  $E				; 
		dc.w	$A80A,  $A				; 
		dc.w	$A80C,  $6				; 
		dc.w	$A80E,  $E				; 
		dc.w	$A810,  $11F				; 
		dc.w	$0000
; End of function Deform_AAZ

Deform_All:				; XREF: Deform_DDZ, Deform_CCZ, ...
		lea	($FFFFE000).w,a1
		move.w	#$E,d1
		move.w	($FFFFF700).w,d0
		neg.w	d0
		swap	d0
		andi.w	#$F,d2
		add.w	d2,d2
		move.w	(a2)+,d0
		jmp	Deform_All_2(pc,d2.w)
; End of function Deform_DDZ
 
; ===========================================================================
 
Deform_All_1:				; XREF: Deform_All
		move.w	(a2)+,d0
 
Deform_All_2:
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		dbf	d1,Deform_All_1
		rts	

; ===========================================================================		

 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Deform_FFZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#7,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 8
		move.w	d0,($FFFFA800).w			; set speed 1

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DFFZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DFFZ_Act1:	dc.w	$A800,  $50				; middle metal
		dc.w	$A802,  $20				; way back mountains
		dc.w	$A804,  8				; back mountains
		dc.w	$A806,  $20				; middle stuff
		dc.w	$A808,  $20				; foreground mountains
		dc.w	$A800,  $198				; metal
		dc.w	$A802,  $20				; way back mountains
		dc.w	$A804,  8				; back mountains
		dc.w	$A806,  $20				; middle stuff
		dc.w	$A808,  $20				; foreground mountains
		dc.w	$A800,  $198				; metal
		dc.w	$0000

; ===========================================================================

 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
Deform_SSZ:
		lea	ParallaxScriptSSZ,a1
		jmp	ExecuteParallaxScript

; ---------------------------------------------------------------

ParallaxScriptSSZ:

_normal = $0000
_moving	= $0200
_linear = $0400

	;	Mode			Speed coef.		Number of lines
	dc.w	_moving|$02,	$0004,		16			; Clouds
	dc.w	_moving|$03,	$0004,		16			; Clouds
	dc.w	_moving|$04,	$0004,		8			; Clouds
	dc.w	_normal,   		$0004,		8			; Mountains
	dc.w	_normal, 	  	$0006,		208			; Ground
	dc.w	-1
; End of function Deform_SSZ
; ===========================================================================

Deform_Title:
		lea	ParallaxScriptTitleBG,a1
		lea	ParallaxScriptTitleFG,a3
		jmp	ExecuteParallaxScriptTitle

; ---------------------------------------------------------------

ParallaxScriptTitleBG:

_normal = $0000
_linear = $0200

	;	Mode			Speed coef.		Number of lines
	dc.w	_normal,		$0000,		$38			; Sun
	dc.w	_normal,		$0004,		$30			; Clouds
	dc.w	_normal,		$0014,		8			; Grass
	dc.w	_linear|$03,	$0018,		$50			; Water
	dc.w	_normal,   		$0000,		$20			; Blank
	dc.w	-1

ParallaxScriptTitleFG:

_normal = $0000
_linear = $0200

	;	Mode			Speed coef.		Number of lines
	dc.w	_normal,		$000C,		$48			; Clouds
	dc.w	_normal,		$0008,		$28			; Mountains
	dc.w	_normal,		$0048,		$10			; Islands 1
	dc.w	_normal,   		$0074,		$10			; Islands 2
	dc.w	_normal, 		$0090,		8			; Islands 3
	dc.w	_normal, 		$00A4,		8			; Islands 4
	dc.w	_normal, 		$0100,		$40			; Bushes
	dc.w	-1
; End of function Deform_Title

; ---------------------------------------------------------------
; Main routine that runs the script
; ---------------------------------------------------------------
; INPUT:
;	a1	Script
; ---------------------------------------------------------------

ExecuteParallaxScriptTitle:
	lea	($FFFFE000).w,a0

	move.w	($FFFFF700).w,d0			; d0 = BG Position
	moveq	#0,d7
	
.ProcessBlock:
	move.b	(a1)+,d7			; load scrolling mode for the current block in script
	bmi.s	.Return				; if end of list reached, branch
	move.w	.ParallaxRoutines(pc,d7),d6
	move.b	(a1)+,d7			; load scrolling mode parameter
	jmp	.ParallaxRoutines(pc,d6)

.Return:
	lea	($FFFFE000).w,a0

	move.w	($FFFFF700).w,d0			; d0 = BG Position
	moveq	#0,d7
	
.ProcessBlock2:
	move.b	(a3)+,d7			; load scrolling mode for the current block in script
	bmi.s	.Return2				; if end of list reached, branch
	move.w	.ParallaxRoutines2(pc,d7),d6
	move.b	(a3)+,d7			; load scrolling mode parameter
	jmp	.ParallaxRoutines2(pc,d6)

.Return2:
	rts

; ---------------------------------------------------------------
.ParallaxRoutines:
	dc.w	.Parallax_Normal-.ParallaxRoutines
	dc.w	.Parallax_Linear-.ParallaxRoutines

.ParallaxRoutines2:
	dc.w	.Parallax_Normal2-.ParallaxRoutines2
	dc.w	.Parallax_Linear2-.ParallaxRoutines2

; ---------------------------------------------------------------
; Scrolling routine: Static solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Normal:
	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	add.w	d6,d6
	jmp	.0(pc,d6)

	; Main functional block (2 bytes per loop)
.0	rept	32
	addq.w	#2,a0
	move.w	d1,(a0)+
	endr
	dbf	d5,.0

	jmp	.ProcessBlock			; process next bloku!

; ---------------------------------------------------------------
; Scrolling routine: Linear Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Linear:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	.1(pc,d6)

	; Main functional block (10 bytes per loop)
.1	rept	16
	swap	d1
	addq.l	#2,a0
	move.w	d1,(a0)+
	swap	d1
	add.l	d2,d1
	endr
	dbf	d5,.1

	jmp	.ProcessBlock			; process next bloku!

; ---------------------------------------------------------------
; Scrolling routine: Static solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Normal2:
	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	mulu.w	(a3)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef

	; Execute code according to number of lines set
	move.w	(a3)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	add.w	d6,d6
	jmp	.2(pc,d6)

	; Main functional block (2 bytes per loop)
.2	rept	32
	move.w	d1,(a0)+
	addq.l	#2,a0
	endr
	dbf	d5,.2

	jmp	.ProcessBlock2			; process next bloku!

; ---------------------------------------------------------------
; Scrolling routine: Linear Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Linear2:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	mulu.w	(a3)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	; Execute code according to number of lines set
	move.w	(a3)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	.3(pc,d6)

	; Main functional block (10 bytes per loop)
.3	rept	16
	swap	d1
	move.w	d1,(a0)+
	addq.l	#2,a0
	swap	d1
	add.l	d2,d1
	endr
	dbf	d5,.3

	jmp	.ProcessBlock2			; process next bloku!

	;	moveq	#0,d4					; set no X movement redraw
	;	move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

	;	move.w	($FFFFF700).w,d0			; load X position
	;	move.w	#0,($FFFFA800).w			; set speed 1

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#4,d0					; divide by 4
	;	move.w	d0,($FFFFA802).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#1,d0					; divide by 4
	;	move.w	d0,($FFFFA804).w			; set speed 2

	;	lea	($FFFFE1C0).w,a0			; load H-scroll buffer
	;	move.l	($FFFFF700).w,d1	; d1 = X (16.16)
	;	swap	d1				; d1 = X (Int)
	;	mulu.w	#1,d1			; d1 = X*Coef (24.8)
	;	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	;	neg.l	d1				; d1 = Initial position
	;	move.l	d1,d2
	;	asr.l	#1,d2				; d2 = Linear factor

	;	move.w	($FFFFF700).w,d3
	;	neg.w	d3
	;	swap	d3

	; Execute code according to number of lines set
	;	move.w	#$50,d6			; d6 = N, where N is Number of lines
	;	move.w	d6,d5				; d5 = N	
	;	lsr.w	#4,d5				; d5 = N/16
	;	andi.w	#15,d6				; d6 = N%16
	;	neg.w	d6				; d6 = -N%16
	;	add.w	#16,d6				; d6 = 16-N%16
	;	move.w	d6,d4
	;	add.w	d6,d6
	;	add.w	d6,d6
	;	add.w	d4,d6
	;	add.w	d6,d6
	;	jmp	.1(pc,d6)

	; Main functional block (10 bytes per loop)
;.1		rept	16
	;	swap	d1
	;	move.w	d1,d3
	;	move.l	d3,(a0)+
	;	swap	d1
	;	add.l	d2,d1
	;	endr
	;	dbf	d5,.1

	;	move.w	($FFFFF700).w,d0			; load X position
	;	move.w	#0,($FFFFA808).w			; set speed 2

	;	lea	DTitleB(pc),a0			; load scroll data to use
	;	bsr.w	DeformScroll2				; continue

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#3,d0					; divide by 4
	;	move.w	d0,($FFFFA80A).w			; set speed 1

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#2,d0					; divide by 4
	;	move.w	d0,d1				; divide by 4
	;	asr.w	#1,d1
	;	add.w	d1,d0
	;	move.w	d0,($FFFFA80C).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#1,d0					; divide by 4
	;	move.w	d0,($FFFFA80E).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#1,d0					; divide by 4
	;	move.w	d0,($FFFFA810).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#1,d0					; divide by 4
	;	move.w	d0,($FFFFA812).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	asr.w	#1,d0					; divide by 4
	;	move.w	d0,($FFFFA814).w			; set speed 2

	;	move.w	($FFFFF700).w,d0			; load X position
	;	neg.w	d0					; reverse direction
	;	move.w	d0,($FFFFA816).w			; set speed 2

	;	lea	DTitleF(pc),a0			; load scroll data to use
	;	bra.w	DeformScroll3				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DTitleB:;	dc.w	$A800,  $38				; Sun
	;	dc.w	$A802,  $20				; Clouds
	;	dc.w	$A804,  $18				; Grass
	;	dc.w	$A806,  $50				; Water
	;	dc.w	$A808,  $20				; Blank
	;	dc.w	$0000

DTitleF:;	dc.w	$A80A,  $48				; Clouds
	;	dc.w	$A80C,  $28				; Mountains
	;	dc.w	$A80E,  $10				; Islands 1
	;	dc.w	$A810,  $10				; Islands 2
	;	dc.w	$A812,  8				; Islands 3
	;	dc.w	$A814,  8				; Islands 4
	;	dc.w	$A816,  $40				; Bushes
	;	dc.w	$0000



; ---------------------------------------------------------------

Deform_CCZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DCCZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DCCZ_Act1:	dc.w	$A800,  $D0				; stars
		dc.w	$A802,  $78				; mountains
		dc.w	$A804,  $78				; snow 1
		dc.w	$A806,  $40				; snow 2
		dc.w	$A808,  $80				; water
		dc.w	$0000

Deform_GGZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#6,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#6,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		lea	DCCZ_Act1(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

Deform_DDZ:
		moveq	#0,d4					; set no X movement redraw
		move.w	($FFFFF73C).w,d5			; load Y movement
		ext.l	d5					; extend to long-word
		asl.l	#5,d5					; multiply by 100, then divide by 2
		bsr.w	ScrollBlock2				; perform redraw for Y
		move.w	($FFFFF70C).w,($FFFFF618).w		; save as VSRAM BG scroll position

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA800).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA802).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA804).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA806).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#5,d0					; divide by 4
		move.w	d0,($FFFFA808).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#4,d0					; divide by 4
		move.w	d0,($FFFFA80A).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#3,d0					; divide by 4
		move.w	d0,($FFFFA80C).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#2,d0					; divide by 4
		move.w	d0,($FFFFA80E).w			; set speed 2

		move.w	($FFFFF700).w,d0			; load X position
		neg.w	d0					; reverse direction
		asr.w	#1,d0					; divide by 4
		move.w	d0,($FFFFA810).w			; set speed 2

		lea	DDDZ(pc),a0			; load scroll data to use
		bra.w	DeformScroll				; continue

; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DDDZ:	dc.w	$A800,  $30				; big clouds
		dc.w	$A802,  $10				; medium clouds
		dc.w	$A804,  $10				; small clouds
		dc.w	$A806,  $50				; transition
		dc.w	$A808,  $80				; top mountains
		dc.w	$A80A,  $20				; middle mountains
		dc.w	$A80C,  $58				; lower mountains
		dc.w	$A80E,  $38				; bush 1
		dc.w	$A810,  $20				; bush 2
		dc.w	$0000

; ---------------------------------------------------------------

Deform_BonusStage:
		bsr.w	ScrollHoriz
		bsr.w	DynScrResizeLoad
		lea	($FFFFE000).w,a1			; load H-scroll buffer

		move.w	(Universal_Timer2).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		moveq	#0,d2
		move.w	($FFFFFE60).w,d2
		sub.w	#$1000,d2
		asr.w	#3,d2
		add.w	d2,($FFFFF66C).w
		move.w	($FFFFF66C).w,d2
		asr.w	#8,d2
		move.w	d2,($FFFFF616).w
		asr.w	#$03,d0					; divide by 8 (/8 the speed of the FG)
		move.w	#$0058-1,d1				; set number of scanlines to write

DBS_TopLoop:
		addi.w	#0,(a1)+
		move.w	d0,(a1)+				; write AAAA BBBB
		dbf	d1,DBS_TopLoop				; repeat for all $70 scanlines)

		move.w	(Universal_Timer2).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		asr.w	#$01,d0					; divide by 4 (/4 the speed of the FG)
		move.w	d0,d2
		asr.w	#$02,d0					; divide by 4 (/4 the speed of the FG)
		move.w	#$0088-1,d1				; set number of scanlines to write

DBS_NextLoop:
		move.w	d2,(a1)+
		move.w	d0,(a1)+				; write AAAA BBBB
		dbf	d1,DBS_NextLoop			; repeat for all $70 scanlines)

		lea	($FFFFE000).w,a1			; load H-scroll buffer
		move.w	(Universal_Timer2).w,d0			; load FG X position
		neg.w	d0					; reverse direction
		move.w	d0,d2
		asl.w	#$02,d0					; divide by 4 (/4 the speed of the FG)
		asl.w	#$03,d2					; divide by 4 (/4 the speed of the FG)
		move.w	#$0070-1,d1				; set number of scanlines to write

DBS_FrontLoop:
		move.w	d0,(a1)+				; write AAAA BBBB
		addi.w	#0,(a1)+
		move.w	d2,(a1)+				; write AAAA BBBB
		addi.w	#0,(a1)+
		dbf	d1,DBS_FrontLoop			; repeat for all $70 scanlines)

		rts		
; ---------------------------------------------------------------------------
; Scroll data
; ---------------------------------------------------------------------------

DBonusB:	dc.w	$A800,  $58				; Clouds
		dc.w	$A802,  $88				; Clouds

DBonusF:	dc.w	$A804,  $E0				; Clouds
		dc.w	$0000

; ===========================================================================
; ---------------------------------------------------------------------------
; Deform scanlines correctly using a list
; ---------------------------------------------------------------------------

DeformScroll:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF70C).w,d6			; load Y position
		move.l	($FFFFF700).w,d1			; prepare FG X position
		neg.l	d1					; reverse position

DS_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS_EndSection				; if the screen is finished, branch

DS_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS_NextScanline:
		move.l	d1,(a2)+				; save scroll position
		dbf	d6,DS_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS_NextSection				; if the screen is not finished, branch

DS_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS_Finish				; if finished, branch
		move.w	(a1),d1					; load X position

DS_LastScanlines:
		move.l	d1,(a2)+				; save scroll position
		dbf	d7,DS_LastScanlines			; repeat for all scanlines

DS_Finish:
		rts						; return

DeformScroll2:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF70C).w,d6			; load Y position

DS2_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS2_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS2_EndSection				; if the screen is finished, branch

DS2_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS2_NextScanline:
		add.w	#0,(a2)+				; save scroll position
		move.w	d1,(a2)+				; save scroll position
		dbf	d6,DS2_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS2_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS2_NextSection				; if the screen is not finished, branch

DS2_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS2_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS2_Finish				; if finished, branch
		move.w	(a1),d1					; load X position

DS2_LastScanlines:
		add.w	#0,(a2)+				; save scroll position
		move.w	d1,(a2)+				; save scroll position
		dbf	d7,DS2_LastScanlines			; repeat for all scanlines

DS2_Finish:
		rts						; return

DeformScroll3:
		lea	($FFFFE000).w,a2			; load H-scroll buffer
		move.w	#$00E0,d7				; prepare number of scanlines
		move.w	($FFFFF704).w,d6			; load Y position

DS3_FindStart:
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		sub.w	(a0)+,d6				; subtract size
		bpl.s	DS3_FindStart				; if we haven't reached the start, branch
		neg.w	d6					; get remaining size
		sub.w	d6,d7					; subtract from total screen size
		bmi.s	DS3_EndSection				; if the screen is finished, branch

DS3_NextSection:
		subq.w	#$01,d6					; convert for dbf
		move.w	(a1),d1					; load X position

DS3_NextScanline:
		move.w	d1,(a2)+				; save scroll position
		add.w	#0,(a2)+				; save scroll position
		dbf	d6,DS3_NextScanline			; repeat for all scanlines
		move.w	(a0)+,d0				; load scroll speed address
		beq.s	DS3_Last					; if the list is finished, branch
		movea.w	d0,a1					; set scroll speed address
		move.w	(a0)+,d6				; load size

DS3_CheckSection:
		sub.w	d6,d7					; subtract from total screen size
		bpl.s	DS3_NextSection				; if the screen is not finished, branch

DS3_EndSection:
		add.w	d6,d7					; get remaining screen size and use that instead

DS3_Last:
		subq.w	#$01,d7					; convert for dbf
		bmi.s	DS3_Finish				; if finished, branch
		swap	d1
		move.w	(a1),d1					; load X position
		swap	d1

DS3_LastScanlines:
		move.w	d1,(a2)+				; save scroll position
		add.w	#0,(a2)+				; save scroll position
		dbf	d7,DS3_LastScanlines			; repeat for all scanlines

DS3_Finish:
		rts						; return

; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	scroll the level horizontally as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz:				; XREF: DeformBgLayer
		move.w	($FFFFF700).w,d4
		bsr.s	ScrollHoriz2
		move.w	($FFFFF700).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74A).w,d1
		eor.b	d1,d0
		bne.s	locret_65B0
		eori.b	#$10,($FFFFF74A).w
		move.w	($FFFFF700).w,d0
		sub.w	d4,d0
		bpl.s	loc_65AA
		bset	#2,($FFFFF754).w
		rts	
; ===========================================================================

loc_65AA:
		bset	#3,($FFFFF754).w

locret_65B0:
		rts	
; End of function ScrollHoriz


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollHoriz2:				; XREF: ScrollHoriz
		move.w	($FFFFFEB2).w,d1
		beq.s	.cont1
		sub.w	#$100,d1
		move.w	d1,($FFFFFEB2).w
		moveq	#0,d1
		move.b	($FFFFFEB2).w,d1
		lsl.b	#2,d1
		addq.b	#4,d1
		move.w	($FFFFF7A8).w,d0
		sub.b	d1,d0
		lea	($FFFFE500).w,a1
		move.w	(a1,d0.w),d0
		and.w	#$3FFF,d0
		bra.s	.cont2
		
.cont1:
		move.w	($FFFFB008).w,d0
		
.cont2:
		sub.w	($FFFFF700).w,d0
		sub.w	(v_camera_pan).w,d0	; Horizontal camera pan value
		beq.s	SH_ProperlyFramed	; if zero, branch
		blt.s	loc_65F6	; if less than, branch
		bra.s	loc_65CC	; branch
; ===========================================================================

SH_ProperlyFramed:
		clr.w	($FFFFF73A).w
		rts 
; ===========================================================================

loc_65F6:
		cmpi.w	#$FFF0,d0				; has the screen moved more than 10 pixels left?
		bgt.s	Left_NoMax				; if not, branch
		move.w	#$FFF0,d0				; set the maximum move distance to 10 pixels left

Left_NoMax:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF728).w,d0
		bgt.s	loc_65E4
		move.w	($FFFFF728).w,d0
		bra.s	loc_65E4
; ===========================================================================

loc_65CC:
		cmpi.w	#$10,d0
		blo.s	loc_65D6
		move.w	#$10,d0

loc_65D6:
		add.w	($FFFFF700).w,d0
		cmp.w	($FFFFF72A).w,d0
		blt.s	loc_65E4
		move.w	($FFFFF72A).w,d0

loc_65E4:
		move.w	d0,d1
		sub.w	($FFFFF700).w,d1
		asl.w	#8,d1
		move.w	d0,($FFFFF700).w
		move.w	d1,($FFFFF73A).w
		rts	

; End of function ScrollHoriz2

; ===========================================================================


; ---------------------------------------------------------------------------
; Subroutine to	scroll the level vertically as Sonic moves
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollVertical:				; XREF: DeformBgLayer
		moveq	#0,d1
		move.w	($FFFFB00C).w,d0
		sub.w	($FFFFF704).w,d0
		btst	#2,($FFFFB022).w
		beq.s	loc_662A
		subq.w	#5,d0
		cmpi.b	#1,(Current_Character).w
		bne.s	loc_662A
		addq.w	#4,d0

loc_662A:
		btst	#1,($FFFFB022).w
		beq.s	loc_664A
		addi.w	#$20,d0
		sub.w	($FFFFF73E).w,d0
		bcs.s	loc_6696
		subi.w	#$40,d0
		bcc.s	loc_6696
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8
		bra.s	loc_6656
; ===========================================================================

loc_664A:
		sub.w	($FFFFF73E).w,d0
		bne.s	loc_665C
		tst.b	($FFFFF75C).w
		bne.s	loc_66A8

loc_6656:
		clr.w	($FFFFF73C).w
		rts	
; ===========================================================================

loc_665C:
		cmpi.w	#$60,($FFFFF73E).w
		bne.s	loc_6684
		move.w	($FFFFB020).w,d1
		bpl.s	loc_666C
		neg.w	d1

loc_666C:
		cmpi.w	#$800,d1
		bcc.s	loc_6696
		move.w	#$600,d1
		cmpi.w	#6,d0
		bgt.s	loc_66F6
		cmpi.w	#-6,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6684:
		move.w	#$200,d1
		cmpi.w	#2,d0
		bgt.s	loc_66F6
		cmpi.w	#-2,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_6696:
		move.w	#$1000,d1
		cmpi.w	#$10,d0
		bgt.s	loc_66F6
		cmpi.w	#-$10,d0
		blt.s	loc_66C0
		bra.s	loc_66AE
; ===========================================================================

loc_66A8:
		moveq	#0,d0
		move.b	d0,($FFFFF75C).w

loc_66AE:
		moveq	#0,d1
		move.w	d0,d1
		add.w	($FFFFF704).w,d1
		tst.w	d0
		bpl.w	loc_6700
		bra.w	loc_66CC
; ===========================================================================

loc_66C0:
		neg.w	d1
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_66CC:
		cmp.w	($FFFFF72C).w,d1
		bgt.s	loc_6724
		cmpi.w	#-$100,d1
		bgt.s	loc_66F0
		andi.w	#$7FF,d1
		andi.w	#$7FF,($FFFFB00C).w
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_66F0:
		move.w	($FFFFF72C).w,d1
		bra.s	loc_6724
; ===========================================================================

loc_66F6:
		ext.l	d1
		asl.l	#8,d1
		add.l	($FFFFF704).w,d1
		swap	d1

loc_6700:
		cmp.w	($FFFFF72E).w,d1
		blt.s	loc_6724
		subi.w	#$800,d1
		bcs.s	loc_6720
		andi.w	#$7FF,($FFFFB00C).w
		subi.w	#$800,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		bra.s	loc_6724
; ===========================================================================

loc_6720:
		move.w	($FFFFF72E).w,d1

loc_6724:
		move.w	($FFFFF704).w,d4
		swap	d1
		move.l	d1,d3
		sub.l	($FFFFF704).w,d3
		ror.l	#8,d3
		move.w	d3,($FFFFF73C).w
		move.l	d1,($FFFFF704).w
		move.w	($FFFFF704).w,d0
		andi.w	#$10,d0
		move.b	($FFFFF74B).w,d1
		eor.b	d1,d0
		bne.s	locret_6766
		eori.b	#$10,($FFFFF74B).w
		move.w	($FFFFF704).w,d0
		sub.w	d4,d0
		bpl.s	loc_6760
		bset	#0,($FFFFF754).w
		rts	
; ===========================================================================

loc_6760:
		bset	#1,($FFFFF754).w

locret_6766:
		rts	
; End of function ScrollVertical


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ScrollBlock1:				; XREF: Deform_EEZ, Deform_FFZ
		move.l	($FFFFF708).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,($FFFFF708).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74C).w,d3
		eor.b	d3,d1
		bne.s	ScrollBlock1_2
		eori.b	#$10,($FFFFF74C).w
		sub.l	d2,d0
		bpl.s	ScrollBlock1_1
		bset	#2,($FFFFF756).w
		bra.s	ScrollBlock1_2
; ===========================================================================
 
ScrollBlock1_1:				; XREF: ScrollBlock1
		bset	#3,($FFFFF756).w
 
ScrollBlock1_2:				; XREF: ScrollBlock1, Deform_FFZ, ...
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	ScrollBlock1_End
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	ScrollBlock1_3
		bset	#0,($FFFFF756).w
		rts	
; ===========================================================================
 
ScrollBlock1_3:				; XREF: ScrollBlock1
		bset	#1,($FFFFF756).w
 
ScrollBlock1_End:			; XREF: ScrollBlock1
		rts	
; End of function ScrollBlock1
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
ScrollBlock2:				; XREF: Deform_DDZ, Deform_CCZ
		move.l	($FFFFF70C).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,($FFFFF70C).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	($FFFFF74D).w,d2
		eor.b	d2,d1
		bne.s	ScrollBlock2_End
		eori.b	#$10,($FFFFF74D).w
		sub.l	d3,d0
		bpl.s	ScrollBlock2_1
		bset	#4,($FFFFF756).w
		rts	
; ===========================================================================
 
ScrollBlock2_1:				; XREF: ScrollBlock2
		bset	#5,($FFFFF756).w
 
ScrollBlock2_End:			; XREF: ScrollBlock2
		rts	
; End of function ScrollBlock2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_6886:		
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFF756).w,a2
		lea	($FFFFF708).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6D0A
		lea	($FFFFF758).w,a2
		lea	($FFFFF710).w,a3
		bra.w	sub_6DA6
; End of function sub_6886
 
; ---------------------------------------------------------------------------
; Subroutine to	display	correct	tiles as you move
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesAsYouMove:			; XREF: Demo_Time
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFFF32).w,a2
		lea	($FFFFFF18).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG
		move.w	#$6000,d2
		bsr.w	sub_6D0A
		lea	($FFFFFF34).w,a2
		lea	($FFFFFF20).w,a3
		bsr.w	sub_6DA6
		lea	($FFFFFF36).w,a2
		lea	($FFFFFF28).w,a3
		bsr.w	sub_6EA4
		lea	($FFFFFF30).w,a2
		lea	($FFFFFF10).w,a3
		movea.l	($FFFF8000).w,a4; MJ: Load address of layout
		move.w	#$4000,d2
		tst.b	($FFFFF745).w
		beq.s	Draw_FG
		move.b	#0,($FFFFF745).w	;Reset the redraw flag
		moveq	#-$10,d4			;Go to top line oflevel data relative camera position
		moveq	#$F,d6				;
 
Draw_All:
		movem.l	d4-d6,-(sp)			; This whole routine basically redraws the whole
		moveq	#-$10,d5			; area instead of merely a line of tiles
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos
		move.w	d1,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,Draw_All
		rts	
 
Draw_FG:
		tst.b	(a2)
		beq.s	locret_6D08
		bclr	#0,(a2)
		beq.s	loc_6CBE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6CBE:
		bclr	#1,(a2)
		beq.s	loc_6CD8
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6CD8:
		bclr	#2,(a2)
		beq.s	loc_6CEE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_TB
 
loc_6CEE:
		bclr	#3,(a2)
		beq.s	locret_6D08
		moveq	#-$10,d4
		move.w	#$150,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		move.w	#$150,d5
		bsr.w	DrawTiles_TB
 
locret_6D08:
		rts	
 
; End of function LoadTilesAsYouMove
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6D0A:
		tst.b	(a2)
		beq.w	locret_6DA4
		bclr	#0,(a2)
		beq.s	loc_6D26
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6D26:
		bclr	#1,(a2)
		beq.s	loc_6D40
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$E0,d4	; 'ร'
		moveq	#-$10,d5
		bsr.w	DrawTiles_LR
 
loc_6D40:
		bclr	#2,(a2)
		beq.s	loc_6D56
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawTiles_TB
 
loc_6D56:
		bclr	#3,(a2)
		beq.s	loc_6D70
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	DrawTiles_TB
 
loc_6D70:
		bclr	#4,(a2)
		beq.s	loc_6D88
		moveq	#-$10,d4
		moveq	#0,d5
		bsr.w	loc_7176
		moveq	#-$10,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6D88:
		bclr	#5,(a2)
		beq.s	locret_6DA4
		move.w	#$E0,d4	; 'ร'
		moveq	#0,d5
		bsr.w	loc_7176
		move.w	#$E0,d4	; 'ร'
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
locret_6DA4:
		rts	
; End of function sub_6D0A
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6DA6:
		tst.b	(a2)
		beq.w	locret_6DF2
	;	cmpi.b	#5,($FFFFFE10).w
	;	beq.w	loc_6E16
		bclr	#0,(a2)
		beq.s	loc_6DD2
		move.w	#$70,d4	; 'p'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$70,d4	; 'p'
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
loc_6DD2:
		bclr	#1,(a2)
		beq.s	locret_6DF2
		move.w	#$70,d4	; 'p'
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$70,d4	; 'p'
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
locret_6DF2:
		rts	
; ===========================================================================
unk_6DF4:	dc.b   0 ;	 
unk_6DF5:	dc.b   0 ;	 
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   0 ;  
; ===========================================================================
 
loc_6E16:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_6E28
		bclr	#1,(a2)
		beq.s	loc_6E72
		move.w	#$E0,d4	; 'ร'
 
loc_6E28:
		lea	(unk_6DF5).l,a0
		move.w	($FFFFF70C).w,d0
		add.w	d4,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		lea	(unk_6FE4).l,a3
		movea.w	(a3,d0.w),a3
		beq.s	loc_6E5E
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos
		movem.l	(sp)+,d4-d5
		bsr.w	DrawTiles_LR
		bra.s	loc_6E72
; ===========================================================================
 
loc_6E5E:
		moveq	#0,d5
		movem.l	d4-d5,-(sp)
		bsr.w	loc_7176
		movem.l	(sp)+,d4-d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6E72:
		tst.b	(a2)
		bne.s	loc_6E78
		rts	
; ===========================================================================
 
loc_6E78:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_6E8C
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5
 
loc_6E8C:
		lea	(unk_6DF4).l,a0
		move.w	($FFFFF70C).w,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_6FEC
; End of function sub_6DA6
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_6EA4:
		tst.b	(a2)
		beq.w	locret_6EF0
		cmpi.b	#2,($FFFFFE10).w
		beq.w	loc_6F54
		bclr	#0,(a2)
		beq.s	loc_6ED0_2
		move.w	#$40,d4	; '.'
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$40,d4	; '.'
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
loc_6ED0_2:
		bclr	#1,(a2)
		beq.s	locret_6EF0
		move.w	#$40,d4	; '.'
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos
		move.w	#$40,d4	; '.'
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawTiles_TB2
 
locret_6EF0:
		rts	
; ===========================================================================
unk_6EF2:	dc.b   0 ;	 
unk_6EF3:	dc.b   0 ;	 
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   0 ;  
		dc.b   6 ;  
		dc.b   6 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   4 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   2 ;  
		dc.b   0 ;  
; ===========================================================================
 
loc_6F54:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_6F66
		bclr	#1,(a2)
		beq.s	loc_6FAE
		move.w	#$E0,d4	; 'ร'
 
loc_6F66:
		lea	(unk_6EF3).l,a0
		move.w	($FFFFF70C).w,d0
		subi.w	#$200,d0
		add.w	d4,d0
		andi.w	#$7F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		movea.w	unk_6FE4(pc,d0.w),a3
		beq.s	loc_6F9A
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos
		movem.l	(sp)+,d4-d5
		bsr.w	DrawTiles_LR
		bra.s	loc_6FAE
; ===========================================================================
 
loc_6F9A:
		moveq	#0,d5
		movem.l	d4-d5,-(sp)
		bsr.w	loc_7176
		movem.l	(sp)+,d4-d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR3
 
loc_6FAE:
		tst.b	(a2)
		bne.s	loc_6FB4
		rts	
; ===========================================================================
 
loc_6FB4:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_6FC8
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5
 
loc_6FC8:
		lea	(unk_6EF2).l,a0
		move.w	($FFFFF70C).w,d0
		subi.w	#$200,d0
		andi.w	#$7F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_6FEC
; ===========================================================================
unk_6FE4:	dc.b $FF ;  
		dc.b $18 ;  
		dc.b $FF ;  
		dc.b $18 ;  
		dc.b $FF ;  
		dc.b $20 ;  
		dc.b $FF ;  
		dc.b $28 ; (
; ===========================================================================
 
loc_6FEC:
		moveq	#$F,d6
		move.l	#$800000,d7
 
loc_6FF4:
		moveq	#0,d0
		move.b	(a0)+,d0
		btst	d0,(a2)
		beq.s	loc_701C
		movea.w	unk_6FE4(pc,d0.w),a3
		movem.l	d4-d5/a0,-(sp)
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		movem.l	(sp)+,d4-d5
		bsr.w	Calc_VRAM_Pos
		bsr.w	sub_70AC
		movem.l	(sp)+,d4-d5/a0
 
loc_701C:
		addi.w	#$10,d4
		dbf	d6,loc_6FF4
		clr.b	(a2)
		rts	
; End of function sub_6EA4
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR:
		moveq	#$16,d6
; End of function DrawTiles_LR
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR2:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_7032:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		move.l	d1,d0
		bsr.w	sub_70AC
		addq.b	#4,d1
		andi.b	#$7F,d1	; ''
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d5
		dbf	d6,loc_7032
		rts	
; End of function DrawTiles_LR2
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_LR3:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_705C:
		movem.l	d4-d5,-(sp)
		bsr.w	loc_712C
		move.l	d1,d0
		bsr.w	sub_70AC
		addq.b	#4,d1
		andi.b	#$7F,d1	; ''
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d5
		dbf	d6,loc_705C
		rts	
; End of function DrawTiles_LR3
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_TB:
		moveq	#$F,d6
; End of function DrawTiles_TB
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
DrawTiles_TB2:
		move.l	#$800000,d7
		move.l	d0,d1
 
loc_7088:
		movem.l	d4-d5,-(sp)
		bsr.w	sub_712A
		move.l	d1,d0
		bsr.w	sub_70AC
		addi.w	#$100,d1
		andi.w	#$FFF,d1
		movem.l	(sp)+,d4-d5
		addi.w	#$10,d4
		dbf	d6,loc_7088
		rts	
; End of function DrawTiles_TB2
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_70AC:
		or.w	d2,d0
		swap	d0
		btst	#3,(a0)	; MJ: checking bit 3 not 4 (Flip)
		bne.s	loc_70E8
		btst	#2,(a0)	; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_70C8
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		rts	
; ===========================================================================
 
loc_70C8:
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,d4
		eori.l	#$8000800,d4
		swap	d4
		move.l	d4,(a6)
		rts	
; ===========================================================================
 
loc_70E8:
		btst	#2,(a0) ; MJ: checking bit 2 not 3 (Mirror)
		bne.s	loc_710A
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$10001000,d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$10001000,d5
		move.l	d5,(a6)
		rts	
; ===========================================================================
 
loc_710A:
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d4
		eori.l	#$18001800,d4
		swap	d4
		move.l	d4,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$18001800,d5
		swap	d5
		move.l	d5,(a6)
		rts	
; End of function sub_70AC
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
sub_712A:
		add.w	(a3),d5
 
loc_712C:
		add.w	4(a3),d4
		lea	($FFFF9000).w,a1
		move.w	d4,d3
		andi.w  #$780,d3; MJ: get within 780 (Not 380) (E00 pixels (not 700)) in multiples of 80
		lsr.w	#3,d5
		move.w	d5,d0
		lsr.w   #4,d0	; MJ: divide by 10 (Not 20)
		lsl.w   #$01,d3	; MJ: multiply by 2 (So it skips the BG)
		add.w	d3,d0
		moveq	#-1,d3
		move.b	(a4,d0.w),d3
		andi.w  #$FF,d3	; MJ: keep within FF
		ror.w	#7,d3
		ror.w   #2,d3	; MJ: ..plus an extra 2 (so it's within 80 bytes, not 200)
		andi.w  #$070,d4; MJ: keep Y pos within 80 pixels
		andi.w  #$0E,d5	; MJ: keep X pos within 10
		add.w	d4,d3
		add.w	d5,d3
		movea.l	d3,a0
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		adda.w	d3,a1
 
locret_7172:
		rts	
; End of function sub_712A
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Calc_VRAM_Pos:
		add.w	(a3),d5
 
loc_7176:
		add.w	4(a3),d4
		andi.w	#$F0,d4	; 'รฐ'
		andi.w	#$1F0,d5
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#3,d0
		swap	d0
		move.w	d4,d0
		rts	
; End of function Calc_VRAM_Pos
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesFromStart:
		lea	($C00004).l,a5
		lea	($C00000).l,a6
		lea	($FFFFF700).w,a3
		movea.l ($FFFF8000).w,a4; MJ: Load address of layout
		move.w	#$4000,d2
		bsr.s	LoadTilesFromStart2
		lea	($FFFFF708).w,a3
		movea.l	($FFFF8004).w,a4; MJ: Load address of layout BG 
		move.w	#$6000,d2
; End of function LoadTilesFromStart
 
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
LoadTilesFromStart2:
		moveq	#-$10,d4
		moveq	#$F,d6
 
loc_71FC:
		movem.l	d4-d6,-(sp)
		moveq	#0,d5
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos
		move.w	d1,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawTiles_LR2
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_71FC
		rts	
; End of function LoadTilesFromStart2

LoadZoneTiles:
		moveq	#0,d0			; Clear d0
		move.b	($FFFFFE10).w,d0		; Load number of current zone to d0
		lsl.w	#4,d0			; Multiply by $10, converting the zone ID into an offset
		lea	(MainLoadBlocks).l,a2	; Load LevelHeaders's address into a2
		lea	(a2,d0.w),a2		; Offset LevelHeaders by the zone-offset, and load the resultant address to a2
		move.l	(a2)+,d0		; Move the first longword of data that a2 points to to d0, this contains the zone's first PLC ID and its art's address.
						; The auto increment is pointless as a2 is overwritten later, and nothing reads from a2 before then
		andi.l	#$FFFFFF,d0    		; Filter out the first byte, which contains the first PLC ID, leaving the address of the zone's art in d0
		movea.l	d0,a0			; Load the address of the zone's art into a0 (source)
		lea	($FF0000).l,a1		; Load v_256x256/StartOfRAM (in this context, an art buffer) into a1 (destination)
		bsr.w	KosDec			; Decompress a0 to a1 (Kosinski compression)

		move.w	a1,d3			; Move a word of a1 to d3, note that a1 doesn't exactly contain the address of v_256x256/StartOfRAM anymore, after KosDec, a1 now contains v_256x256/StartOfRAM + the size of the file decompressed to it, d3 now contains the length of the file that was decompressed
		move.w	d3,d7			; Move d3 to d7, for use in seperate calculations

		andi.w	#$FFF,d3		; Remove the high nibble of the high byte of the length of decompressed file, this nibble is how many $1000 bytes the decompressed art is
		lsr.w	#1,d3			; Half the value of 'length of decompressed file', d3 becomes the 'DMA transfer length'

		rol.w	#4,d7			; Rotate (left) length of decompressed file by one nibble
		andi.w	#$F,d7			; Only keep the low nibble of low byte (the same one filtered out of d3 above), this nibble is how many $1000 bytes the decompressed art is

	.loop:	
		move.w	d7,d2			; Move d7 to d2, note that the ahead dbf removes 1 byte from d7 each time it loops, meaning that the following calculations will have different results each time
		lsl.w	#7,d2
		lsl.w	#5,d2			; Shift (left) d2 by $C, making it high nibble of the high byte, d2 is now the size of the decompressed file rounded down to the nearest $1000 bytes, d2 becomes the 'destination address'

		move.l	#$FFFFFF,d1		; Fill d1 with $FF
		move.w	d2,d1			; Move d2 to d1, overwriting the last word of $FF's with d2, this turns d1 into 'StartOfRAM'+'However many $1000 bytes the decompressed art is', d1 becomes the 'source address'

		jsr	(QueueDMATransfer).l	; Use d1, d2, and d3 to locate the decompressed art and ready for transfer to VRAM
		move.w	d7,-(sp)		; Store d7 in the Stack
		move.b	#$C,($FFFFF62A).w
		bsr.w	DelayProgram
		bsr.w	RunPLC_RAM
		move.w	(sp)+,d7		; Restore d7 from the Stack
		move.w	#$800,d3		; Force the DMA transfer length to be $1000/2 (the first cycle is dynamic because the art's DMA'd backwards)
		dbf	d7,.loop		; Loop for each $1000 bytes the decompressed art is
		rts
; End of function LoadZoneTiles

; ---------------------------------------------------------------------------
; Main Load Block loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MainLoadBlockLoad:			; XREF: Level; EndingSequence
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addq.l	#4,a2
		movea.l	(a2)+,a0
		lea	($FFFF9000).w,a1 ; RAM address for 16x16 mappings
		move.w	#0,d0
		jsr	EniDec
		movea.l	(a2)+,a0
		lea	($FF0000).l,a1	; RAM address for 256x256 mappings
		jsr	KosDec
		bsr.w	LevelLayoutLoad
		move.w	(a2)+,d0
		cmpi.b	#1,($FFFFFE10).w
		beq.s	MLBL2
		move.w	(a2),d0
		andi.w	#$FF,d0
		bsr.w	PalLoad1	; load pallet (based on	d0)
		bra.s	MLBL3

MLBL2:
		bsr.w	TimeOfDay

MLBL3:
		movea.l	(sp)+,a2
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	locret_6D10
		jsr	LoadPLC		; load pattern load cues

locret_6D10:
		rts	
; End of function MainLoadBlockLoad

; ---------------------------------------------------------------------------
; Level	layout loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
; This method now releases free ram space from A408 - A7FF

LevelLayoutLoad:
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		move.w	d0,d2
		add.w	d0,d0
		add.w	d2,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	TitleLayout
		lea	(Level_Index).l,a1
		bra.s 	LevelLayoutCont

TitleLayout:
		lea	(Title_Index).l,a1

LevelLayoutCont:
		movea.l	(a1,d0.w),a1				; MJ: moving the address strait to a1 rather than adding a word to an address
		move.l	a1,($FFFF8000).w			; MJ: save location of layout to $FFFFA400
		adda.w	#$0080,a1				; MJ: add 80 (As the BG line is always after the FG line)
		move.l	a1,($FFFF8004).w			; MJ: save location of layout to $FFFFA404
		rts						; MJ: Return

; End of function LevelLayoutLoad2

; ---------------------------------------------------------------------------
; Dynamic screen resize	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DynScrResizeLoad:			; XREF: DeformBgLayer
		moveq	#0,d0
		cmpi.b 	#4,($FFFFF600).w ; check if it's the title screen
		beq.s 	Resize_Title
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Resize_Index(pc,d0.w),d0
		jsr	Resize_Index(pc,d0.w)
	;	bra.s 	Resize_Cont

Resize_Title:
	;	cmpi.w	#$300,($FFFFF726).w
	;	beq.s	Resize_Cont
	;	add.w	#4,($FFFFF726).w ; set lower	y-boundary
		tst.b	($FFFFFE13).w
		beq.s	Resize_Cont
		bsr.w	ContinueLevel

Resize_Cont:
		moveq	#2,d1
		move.w	($FFFFF726).w,d0
		sub.w	($FFFFF72E).w,d0
		beq.s	locret_6DAA
		bcc.s	loc_6DAC
		neg.w	d1
		move.w	($FFFFF704).w,d0
		cmp.w	($FFFFF726).w,d0
		bls.s	loc_6DA0
		move.w	d0,($FFFFF72E).w
		andi.w	#-2,($FFFFF72E).w

loc_6DA0:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w

locret_6DAA:
		rts	
; ===========================================================================

loc_6DAC:				; XREF: DynScrResizeLoad
		move.w	($FFFFF704).w,d0
		addq.w	#8,d0
		cmp.w	($FFFFF72E).w,d0
		bcs.s	loc_6DC4
		btst	#1,($FFFFB022).w
		beq.s	loc_6DC4
		add.w	d1,d1
		add.w	d1,d1

loc_6DC4:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w
		rts	
; End of function DynScrResizeLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for dynamic screen resizing
; ---------------------------------------------------------------------------
Resize_Index:	dc.w Resize_AAZ-Resize_Index, Resize_BBZ-Resize_Index
		dc.w Resize_CCZ-Resize_Index, Resize_DDZ-Resize_Index
		dc.w Resize_EEZ-Resize_Index, Resize_FFZ-Resize_Index
		dc.w Resize_GGZ-Resize_Index, Resize_SSZ-Resize_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_BBZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_BBZx(pc,d0.w),d0
		jmp	Resize_BBZx(pc,d0.w)
; ===========================================================================
Resize_BBZx:	dc.w Resize_BBZ1-Resize_BBZx
		dc.w Resize_BBZ2-Resize_BBZx
		dc.w Resize_BBZ3-Resize_BBZx
		dc.w Resize_BBZ4-Resize_BBZx
; ===========================================================================
Resize_BBZ1:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		cmpi.w	#$3E00,($FFFFF700).w
		bcs.w	Resize_BBZReturn
		move.w	#$500,($FFFFF726).w
		move.w	#$500,($FFFFF72C).w
		rts
; ===========================================================================

Resize_BBZ2:
		rts	

Resize_BBZ2_Shake:
		move.w	(Universal_Timer2).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	Resize_BBZReturn
		subq.w	#1,($FFFFF70C).w
		subq.w	#1,($FFFFFE00).w
		andi.w	#$1F,d1
		bne.s	Resize_BBZReturn
		sfx		sfx_Rumble
		bra.s	Resize_BBZReturn

; ===========================================================================

Resize_BBZ3:
		move.w	#$720,($FFFFF726).w
		cmpi.w	#$3D00,($FFFFF700).w
		bcs.s	Resize_BBZReturn
		tst.b	($FFFFF742).w
		bne.s	Resize_BBZReturn
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		jmp	LoadPLC		; load boss patterns

; ===========================================================================
Resize_BBZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts

Resize_BBZReturn:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth Zone dynamic screen	resizing
; ---------------------------------------------------------------------------

Resize_EEZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_EEZx(pc,d0.w),d0
		jmp	Resize_EEZx(pc,d0.w)
; ===========================================================================
Resize_EEZx:	dc.w Resize_EEZ12-Resize_EEZx
		dc.w Resize_EEZ12-Resize_EEZx
		dc.w Resize_EEZ3-Resize_EEZx
		dc.w Resize_EEZ4-Resize_EEZx
; ===========================================================================

Resize_EEZ12:
		move.w	#$800,($FFFFF726).w
		rts	
; ===========================================================================

Resize_EEZ3:
		rts

; ===========================================================================
Resize_EEZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================

locret_6F62:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Star Light Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_AAZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_AAZx(pc,d0.w),d0
		jmp	Resize_AAZx(pc,d0.w)
; ===========================================================================
Resize_AAZx:	dc.w Resize_AAZ12-Resize_AAZx
		dc.w Resize_AAZ12-Resize_AAZx
		dc.w Resize_AAZ3-Resize_AAZx
		dc.w Resize_AAZ4-Resize_AAZx
; ===========================================================================

Resize_AAZ12:
		move.w	#$800,($FFFFF726).w

locret_AAZ12:
		rts	
; ===========================================================================

Resize_AAZ3:
		rts
; ===========================================================================
Resize_AAZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Scrap	Brain Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_FFZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_FFZx(pc,d0.w),d0
		jmp	Resize_FFZx(pc,d0.w)
; ===========================================================================
Resize_FFZx:	dc.w Resize_FFZ1-Resize_FFZx
		dc.w Resize_FFZ2-Resize_FFZx
		dc.w Resize_FZ-Resize_FFZx
		dc.w Resize_FFZ4-Resize_FFZx
; ===========================================================================

Resize_FFZ1:
		move.w	#$800,($FFFFF726).w
		rts	
; ===========================================================================

Resize_FFZ2:
		rts	
; ===========================================================================

Resize_FZ:
		rts	
; ===========================================================================
Resize_FFZ4:
		move.w	#$720,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SSZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SSZx(pc,d0.w),d0
		jmp	Resize_SSZx(pc,d0.w)
; ===========================================================================
Resize_SSZx:	dc.w Resize_SSZ1-Resize_SSZx
		dc.w Resize_SSZ2-Resize_SSZx
		dc.w Resize_SSZ3-Resize_SSZx
		dc.w Resize_SSZ4-Resize_SSZx
; ===========================================================================
Resize_SSZ1:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ2:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ3:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
Resize_SSZ4:
		move.w	#$800,($FFFFF726).w
		move.w	#0,($FFFFF72C).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Ending sequence dynamic screen resizing (empty)
; ---------------------------------------------------------------------------

Resize_Ending:				; XREF: Resize_Index
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; White Acropolis dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_CCZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_CCZx(pc,d0.w),d0
		jmp	Resize_CCZx(pc,d0.w)
; ===========================================================================
Resize_CCZx:	dc.w Resize_CCZ1-Resize_CCZx
		dc.w Resize_CCZ2-Resize_CCZx
		dc.w Resize_CCZ3-Resize_CCZx
		dc.w Resize_CCZ4-Resize_CCZx
; ===========================================================================
Resize_CCZ1:
		rts
; ===========================================================================
Resize_CCZ2:
		rts
; ===========================================================================
Resize_CCZ3:
		rts
; ===========================================================================
Resize_CCZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Flame Core dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_GGZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_GGZx(pc,d0.w),d0
		jmp	Resize_GGZx(pc,d0.w)
; ===========================================================================
Resize_GGZx:	dc.w Resize_GGZ1-Resize_GGZx
		dc.w Resize_GGZ2-Resize_GGZx
		dc.w Resize_GGZ3-Resize_GGZx
		dc.w Resize_GGZ4-Resize_GGZx
; ===========================================================================
Resize_GGZ1:
		rts
; ===========================================================================
Resize_GGZ2:
		rts
; ===========================================================================
Resize_GGZ3:
		rts
; ===========================================================================
Resize_GGZ4:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Ratical Train dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_DDZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_DDZx(pc,d0.w),d0
		jmp	Resize_DDZx(pc,d0.w)
; ===========================================================================
Resize_DDZx:	dc.w Resize_DDZ1-Resize_DDZx
		dc.w Resize_DDZ2-Resize_DDZx
		dc.w Resize_DDZ3-Resize_DDZx
		dc.w Resize_DDZ4-Resize_DDZx
; ===========================================================================
Resize_DDZ1:
		rts
; ===========================================================================
Resize_DDZ2:
		rts
; ===========================================================================
Resize_DDZ3:
		rts
; ===========================================================================
Resize_DDZ4:
		rts
; ===========================================================================


LoadNextLevel:
		move.b	($FFFFFE10).w,d0
		andi.w	#$F,d0
		lsl.w	#3,d0
		move.b	($FFFFFE11).w,d1
		andi.w	#3,d1
		add.w	d1,d1
		add.w	d1,d0
		move.w	LevelOrder(pc,d0.w),d0 ; load level from level order array
		move.w	d0,($FFFFFE10).w ; set level number
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Level	order array
; ---------------------------------------------------------------------------
LevelOrder:	
		dc.w	aaz_act_2	; AAZ1
		dc.w	aaz_act_3	; AAZ2
		dc.w	aaz_act_4	; AAZ3
		dc.w	bbz_act_1	; AAZ4

		dc.w	bbz_act_2	; BBZ1
		dc.w	bbz_act_3	; BBZ2
		dc.w	bbz_act_4	; BBZ3
		dc.w	ccz_act_1	; BBZ4

		dc.w	ccz_act_2	; CCZ1
		dc.w	ccz_act_3	; CCZ2
		dc.w	ccz_act_4	; CCZ3
		dc.w	ddz_act_1	; CCZ4

		dc.w	ddz_act_2	; DDZ1
		dc.w	ddz_act_3	; DDZ2
		dc.w	ddz_act_4	; DDZ3
		dc.w	eez_act_1	; DDZ4

		dc.w	eez_act_2	; EEZ1
		dc.w	eez_act_3	; EEZ2
		dc.w	eez_act_4	; EEZ3
		dc.w	ffz_act_1	; EEZ4

		dc.w	ffz_act_2	; FFZ1
		dc.w	ffz_act_3	; FFZ2
		dc.w	ffz_act_4	; FFZ3
		dc.w	ggz_act_1	; FFZ4

		dc.w	ggz_act_2	; GGZ1
		dc.w	ggz_act_3	; GGZ2
		dc.w	ggz_act_4	; GGZ3
		dc.w	lvlord_sega	; GGZ4

		dc.w	lvlord_sega			; SSZ1
		dc.w	lvlord_sega			; SSZ2
		dc.w	lvlord_sega			; SSZ3
		dc.w	lvlord_sega			; SSZ4

; ===========================================================================
ContinueLevel:
		moveq	#0,d0
		move.b	($FFFFFFF7).w,d0
		move.w	CLevel_Routine(pc,d0.w),d0
		jmp	CLevel_Routine(pc,d0.w)
; ===========================================================================
CLevel_Routine:	dc.w CLevel_Lock-CLevel_Routine
		dc.w CLevel_Main-CLevel_Routine
		dc.w CLevel_Wait-CLevel_Routine
; ===========================================================================

CLevel_Lock:
		move.w	($FFFFF704).w,d0
		move.w	d0,d1
		andi.w	#$F00,d0
		cmp.w	d0,d1
		bne.w	CLevel_Done
		addq.b	#2,($FFFFFFF7).w
		move.w	d0,($FFFFF72C)
		move.w	d0,($FFFFF726)

Clevel_Main:
		btst	#1,($FFFFB022).w ; wait until Sonic is on the floor
		bne.w	CLevel_Done
		addq.b	#2,($FFFFFFF7).w
		bsr.w	LoadNextLevel
		move.b	#1,($FFFFF7A6).w
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	CLevel_Wait
		jsr	LoadPLC		; load level patterns

CLevel_Wait:
		tst.l	($FFFFF680).w	; are there any	items in the pattern load cue?
		bne.w	CLevel_Done	; if yes, branch
		addq.b	#2,($FFFFFFF7).w
		move.w	($FFFFF700).w,d0
		add.w	($FFFFF730).w,d0
		move.w	d0,($FFFFF730).w
		bsr.w	LevelSizeLoad
		move.b	#0,($FFFFFE17).w
		move.b	#0,($FFFFF76C).w
		jsr	RingsManager
		jsr	ObjPosLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addi.l	#$C,a2
		bsr.w	LevelLayoutLoad
		move.w	(a2)+,d0
		cmpi.b	#1,($FFFFFE10).w
		beq.s	MLBL22
		move.w	(a2),d0
		andi.w	#$FF,d0
		bsr.w	PalLoad1	; load pallet (based on	d0)
		bra.s	MLBL32

MLBL22:
		bsr.w	TimeOfDay

MLBL32:
		movea.l	(sp)+,a2
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	locret2_6D10
		jsr	LoadPLC		; load pattern load cues

locret2_6D10:
		bsr.w	ColIndexLoad
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		cmpi.b	#1,($FFFFFE10).w
		beq.s	CLevel_BBZPal
		tst.b	(Water_flag).w	; does level have water
		beq.s	CLevel_LoadPal	;if not, branch
		move.w	#$8014,(a6)
		moveq	#0,d0
		move.w	($FFFFFE10).w,d0
		ror.b	#2,d0
		lsr.w	#6,d0
		add.w	d0,d0
		lea	(WaterHeight).l,a1 ; load water	height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement
		move.b	#1,($FFFFF64C).w ; enable water
		bra.s	CLevel_LoadPal

CLevel_BBZPal:
		move.l	#WaterTransition_BBZ,($FFFFF610).w
		move.w	#$8014,(a6)
		move.w	#0,($FFFFF646).w ; set water heights
		move.w	#0,($FFFFF648).w
		move.w	#0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement

CLevel_LoadPal:
		move.b	#0,($FFFFF74F).w
		tst.b	(Water_flag).w	; does level have water?
		beq.s	CLevel_LoadObj	; if not, branch
		move.b	#$1B,($FFFFB780).w ; load water	surface	object
		move.w	#$60,($FFFFB788).w
		move.b	#$1B,($FFFFB7C0).w
		move.w	#$120,($FFFFB7C8).w

CLevel_LoadObj:
		moveq	#5,d0
		tst.b	(Water_flag).w	; does level have water?
		beq.s	CLevel_LoadCol
		moveq	#$B,d0		; pallet number	$B (EEZ)

CLevel_WaterPal:
		bsr.w	PalLoad4_Water	; load underwater pallet (see d0)
		tst.b	($FFFFFE30).w
		beq.s	CLevel_LoadCol
		move.b	($FFFFFE53).w,($FFFFF64E).w

CLevel_LoadCol:
		lea	($C00000).l,a6
		move.l	#Art_Explode,d1
		move.w	#(ArtTile_Explode*$20),d2
		move.w	#$4FF,d3
		jsr	(QueueDMATransfer).l
		move.w	#0,($FFFFF700).w
		move.b	#1,($FFFFFE1E).w	; start time counter
		clr.l	($FFFFFE22).w	; start time counter
		move.b	#0,($FFFFFE2D).w
		move.b	#1,($FFFFFE2F).w

CLevel_Wait2:
		move.w	#$3E00,($FFFFF72A).w
		moveq	#0,d0
		move.w	d0,($FFFFFE02).w
		move.b	d0,($FFFFFFF7).w
		move.b	d0,($FFFFF7A6).w
		move.b	d0,($FFFFFE13).w
		move.b	d0,($FFFFB02A).w 		; fully unlock the controls
		move.w	d0,($FFFFF72C).w
		move.w	#$800,($FFFFF726).w

CLevel_Done:
		rts

; ---------------------------------------------------------------------------
; Object 11 - BBZ bridge
; ---------------------------------------------------------------------------

Obj11:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj11_Index(pc,d0.w),d1
		jmp	Obj11_Index(pc,d1.w)
; ===========================================================================
Obj11_Index:	dc.w Obj11_Main-Obj11_Index, Obj11_Action-Obj11_Index
		dc.w Obj11_Action2-Obj11_Index,	Obj11_Delete2-Obj11_Index
		dc.w Obj11_Delete2-Obj11_Index,	Obj11_Display2-Obj11_Index
; ===========================================================================

Obj11_Main:				; XREF: Obj11_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj11,4(a0)
		move.w	#$437C,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$80,$14(a0)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		move.b	0(a0),d4	; copy object number ($11) to d4
		lea	$28(a0),a2	; copy bridge subtype to a2
		moveq	#0,d1
		move.b	(a2),d1		; copy a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	Obj11_Action

Obj11_MakeBdg:
		jsr	SingleObjLoad
		bne.s	Obj11_Action
		addq.b	#1,$28(a0)
		cmp.w	8(a0),d3
		bne.s	loc_73B8
		addi.w	#$10,d3
		move.w	d2,$C(a0)
		move.w	d2,$3C(a0)
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		addq.b	#1,$28(a0)

loc_73B8:				; XREF: ROM:00007398j
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,$24(a1)
		move.b	d4,0(a1)	; load bridge object (d4 = $11)
		move.w	d2,$C(a1)
		move.w	d2,$3C(a1)
		move.w	d3,8(a1)
		move.l	#Map_obj11,4(a1)
		move.w	#$437C,2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#8,$14(a1)
		addi.w	#$10,d3
		dbf	d1,Obj11_MakeBdg ; repeat d1 times (length of bridge)

Obj11_Action:				; XREF: Obj11_Index
		bsr.s	Obj11_Solid
		tst.b	$3E(a0)
		beq.s	Obj11_Display
		subq.b	#4,$3E(a0)
		bsr.w	Obj11_Bend

Obj11_Display:
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Solid:				; XREF: Obj11_Action
		moveq	#0,d1
		move.b	$28(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		cmp.w	d2,d0
		bcc.w	locret_751E
		bra.s	Platform2
; End of function Obj11_Solid

; ---------------------------------------------------------------------------
; Platform subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlatformObject:
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E

Platform2:
		move.w	$C(a0),d0
		subq.w	#8,d0

Platform3:
		move.w	$C(a1),d2
		move.b	$16(a1),d1
		ext.w	d1
		add.w	d2,d1
		addq.w	#4,d1
		sub.w	d1,d0
		bhi.w	locret_751E
		cmpi.w	#-$10,d0
		bcs.w	locret_751E
		tst.b	$2A(a1)
		bmi.w	locret_751E
		cmpi.b	#6,$24(a1)
		bcc.w	locret_751E
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,$C(a1)
		addq.b	#2,$24(a0)

loc_74AE:
		btst	#3,$22(a1)
		beq.s	loc_74DC
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)
		clr.b	$25(a2)
		cmpi.b	#4,$24(a2)
		bne.s	loc_74DC
		subq.b	#2,$24(a2)

loc_74DC:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,$26(a1)
		move.w	#0,$12(a1)
		move.w	$10(a1),$20(a1)
		btst	#1,$22(a1)
		beq.s	loc_7512
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Player_ResetOnFloor
		movea.l	(sp)+,a0

loc_7512:
		bset	#3,$22(a1)
		bset	#3,$22(a0)

locret_751E:
		rts	
; End of function PlatformObject

; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to collide Sonic/Tails with the top of a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
;
; input variables:
; d1 = object width
; d3 = object height / 2
; d4 = object x-axis position
;
; address registers:
; a0 = the object to check collision with
; a1 = sonic or tails (set inside these subroutines)
; loc_19C32:
PlatformObjectS2:
	lea	($FFFFB000).w,a1 ; a1=character
	moveq	#3,d6

PlatformObject_SingleCharacter:
	btst	d6,$22(a0)
	beq.w	PlatformObject_cont
	move.w	d1,d2
	add.w	d2,d2
	btst	#1,$22(a1)
	bne.s	PlatformObject_SingleCharacter2
	move.w	8(a1),d0
	sub.w	8(a0),d0
	add.w	d1,d0
	bmi.s	PlatformObject_SingleCharacter2
	cmp.w	d2,d0
	blo.s	loc_19C802

PlatformObject_SingleCharacter2:
	bclr	#3,$22(a1)
	bset	#1,$22(a1)
	bclr	d6,$22(a0)
	moveq	#0,d4
	rts
; ---------------------------------------------------------------------------
loc_19C802:
	move.w	d4,d2
	bsr.w	MvSonicOnPtfm
	moveq	#0,d4
	rts
; ===========================================================================

PlatformObject_cont:
	tst.w	$12(a1)
	bmi.w	return_19E8E
	move.w	8(a1),d0
	sub.w	8(a0),d0
	add.w	d1,d0
	bmi.w	return_19E8E
	add.w	d1,d1
	cmp.w	d1,d0
	bhs.w	return_19E8E

loc_19DD8:
	move.w	$C(a0),d0
	sub.w	d3,d0
;loc_19DDE:
PlatformObject_ChkYRange:
	move.w	$C(a1),d2
	move.b	$16(a1),d1
	ext.w	d1
	add.w	d2,d1
	addq.w	#4,d1
	sub.w	d1,d0
	bhi.w	return_19E8E
	cmpi.w	#-$10,d0
	blo.w	return_19E8E
	tst.b	$2A(a1)
	bmi.w	return_19E8E
	cmpi.b	#6,$24(a1)
	bhs.w	return_19E8E
	add.w	d0,d2
	addq.w	#3,d2
	move.w	d2,$C(a1)
;loc_19E14:
RideObject_SetRide:
	btst	#3,$22(a1)
	beq.s	loc_19E30
	moveq	#0,d0
	move.b	$3D(a1),d0
	lsl.w	#6,d0
	addi.l	#$FFB000,d0
	movea.l	d0,a3	; a3=object
	bclr	d6,$22(a3)

loc_19E30:
	move.w	a0,d0
	subi.w	#$B000,d0
	lsr.w	#6,d0
	andi.w	#$7F,d0
	move.b	d0,$3D(a1)
	move.b	#0,$26(a1)
	move.w	#0,$12(a1)
	move.w	$10(a1),$20(a1)
	btst	#1,$22(a1)
	beq.s	loc_19E7E
	bset	#3,$22(a1)
	move.l	a0,-(sp)
	movea.l	a1,a0
	jsr	(Player_ResetOnFloor).l

loc_19E7C:
	movea.l	(sp)+,a0 ; a0=character

loc_19E7E:
	bset	#3,$22(a1)
	bclr	#1,$22(a1)
	bset	d6,$22(a0)

return_19E8E:
	rts

SolidObjectS2:
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_19736
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		tst.b	1(a1)
		bpl.w	locret_19776
		addq.b	#1,d6

loc_19736:				; CODE XREF: h+27AEp
		btst	d6,$22(a0)
		beq.w	SolidObject_OnScreenTest
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_1975A
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_1975A
		cmp.w	d2,d0
		bcs.s	loc_1976E

loc_1975A:				; CODE XREF: h+27D4j h+27E0j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_1976E:				; CODE XREF: h+27E4j
		move.w	d4,d2
		bsr.w	MvSonicOnPtfm
		moveq	#0,d4

locret_19776:				; CODE XREF: h+27BCj
		rts	
; ===========================================================================

SolidObject_Always:				; CODE XREF: h+9FD2p h+CB74j
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	SolidObject_Always_SingleCharacter
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

SolidObject_Always_SingleCharacter:				; CODE XREF: h+1A26p h+1A3Ep ...
		btst	d6,$22(a0)
		beq.w	SolidObject_cont
		cmpi.b	#$B,(a1)
		beq.s	loc_197B4
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_197B2
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_197B2
		cmp.w	d2,d0
		bcs.s	loc_197C6

loc_197B2:				; CODE XREF: h+282Cj h+2838j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4

loc_197B4:
		rts	
; ===========================================================================

loc_197C6:				; CODE XREF: h+283Cj
		move.w	d4,d2
		bsr.w	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SlopedSolid:				; CODE XREF: h+CB7Aj h+145AEj
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	SlopedSolid_SingleCharacter
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		addq.b	#1,d6

SlopedSolid_SingleCharacter:				; CODE XREF: h+1E10p h+1E28p ...
		btst	d6,$22(a0)
		beq.w	SlopedSolid_cont
		cmpi.b	#$B,(a1)
		beq.s	loc_1980C
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,$22(a1)
		bne.s	loc_1980A
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_1980A
		cmp.w	d2,d0
		bcs.s	loc_1981E

loc_1980A:				; CODE XREF: h+2884j h+2890j
		bclr	#3,$22(a1)
		bset	#1,$22(a1)
		bclr	d6,$22(a0)
		moveq	#0,d4
		
loc_1980C:
		rts	
; ===========================================================================

loc_1981E:				; CODE XREF: h+2894j
		move.w	d4,d2
		bsr.w	MvSonicOnSlope
		moveq	#0,d4
		rts	
; ===========================================================================

SlopedSolid_cont:				; CODE XREF: h+2876j
		cmpi.b	#$B,(a1)
		beq.s	loc_1980C
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	SolidObject_TestClearPush
		move.w	d0,d5
		btst	#0,1(a0)
		beq.s	loc2_19954
		not.w	d5
		add.w	d3,d5

loc2_19954:				; CODE XREF: h+29DAj
		lsr.w	#1,d5
		move.b	(a2,d5.w),d3
		sub.b	(a2),d3
		ext.w	d3
		move.w	$C(a0),d5
		sub.w	d3,d5
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	SolidObject_TestClearPush
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bhs.w	SolidObject_TestClearPush
		bra.w	SolidObject_ChkBounds
; ===========================================================================

SolidObject_OnScreenTest:				; CODE XREF: h+27C6j
		tst.b	1(a0)
		bpl.w	SolidObject_TestClearPush

SolidObject_Return:
		rts

SolidObject_cont:				; CODE XREF: sub_12756+Cj sub_12768+Aj ...
		cmpi.b	#$B,(a1)
		beq.s	SolidObject_Return
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	SolidObject_TestClearPush
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	SolidObject_TestClearPush
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	SolidObject_TestClearPush
		andi.w	#$7FF,d3
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	SolidObject_TestClearPush

SolidObject_ChkBounds:				; CODE XREF: h+29B6j h+2A10j ...
		tst.b	$2A(a1)
		bmi.w	SolidObject_TestClearPush
		cmpi.b	#6,$24(a1)
		bcc.w	loc_19AEA
		tst.w	($FFFFFE08).w
		bne.w	loc_19AEA
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_19A56
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_19A56:				; CODE XREF: h+2AD8j
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_19A64
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_19A64:				; CODE XREF: h+2AE6j
		cmp.w	d1,d5
		bhi.w	loc_19AEE

loc_19A6A:				; CODE XREF: h+2BC6j
		cmpi.w	#4,d1
		bls.s	loc_19AB6
		tst.w	d0
		beq.s	loc_19A90
		bmi.s	loc_19A7E
		tst.w	$10(a1)
		bmi.s	loc_19A90
		bra.s	loc_19A84
; ===========================================================================

loc_19A7E:				; CODE XREF: h+2B00j
		tst.w	$10(a1)
		bpl.s	loc_19A90

loc_19A84:				; CODE XREF: h+2B08j
		move.w	#0,$20(a1)
		move.w	#0,$10(a1)

loc_19A90:				; CODE XREF: h+2AFEj h+2B06j ...
		sub.w	d0,8(a1)
		btst	#1,$22(a1)
		bne.s	loc_19AB6
		move.l	d6,d4
		addq.b	#2,d4
		bset	d4,$22(a0)
		bset	#5,$22(a1)
		move.w	d6,d4
		addi.b	#$D,d4
		bset	d4,d6
		moveq	#1,d4
		rts	
; ===========================================================================

loc_19AB6:				; CODE XREF: h+2AFAj h+2B26j
		bsr.s	loc_19ADC
		move.w	d6,d4
		addi.b	#$D,d4
		bset	d4,d6
		moveq	#1,d4
		rts	
; ===========================================================================

SolidObject_TestClearPush:				; CODE XREF: h+2982j h+298Cj ...
		move.l	d6,d4
		addq.b	#2,d4
		btst	d4,$22(a0)
		beq.s	loc_19AEA
		cmpi.b	#2,$1C(a1)
		beq.s	loc_19ADC
		move.w	#1,$1C(a1)

loc_19ADC:				; CODE XREF: h+2B42p h+2B60j
		move.l	d6,d4
		addq.b	#2,d4
		bclr	d4,$22(a0)
		bclr	#5,$22(a1)

loc_19AEA:				; CODE XREF: h+2AC8j h+2AD0j ...
		moveq	#0,d4
		rts	
; ===========================================================================

loc_19AEE:				; CODE XREF: h+2AF2j
		tst.w	d3
		bmi.s	loc_19B06
		cmpi.w	#$10,d3
		bcs.s	loc_19B56
		bra.s	SolidObject_TestClearPush
; ===========================================================================

loc_19B06:				; CODE XREF: h+2B7Cj
		tst.w	$12(a1)
		beq.s	loc_19B28
		bpl.s	loc_19B1C
		tst.w	d3
		bpl.s	loc_19B1C
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)

loc_19B1C:				; CODE XREF: h+2B98j h+2B9Cj ...
		move.w	d6,d4
		addi.b	#$F,d4
		bset	d4,d6
		moveq	#-2,d4
		rts	
; ===========================================================================

loc_19B28:				; CODE XREF: h+2B96j
		btst	#1,$22(a1)
		bne.s	loc_19B1C
		move.w	d0,d4
		bpl.s	loc_19B36
		neg.w	d4

loc_19B36:				; CODE XREF: h+2BBEj
		cmpi.w	#$10,d4
		bcs.w	loc_19A6A
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	(KillSonic).l
		movea.l	(sp)+,a0
		move.w	d6,d4
		addi.b	#$F,d4
		bset	d4,d6
		moveq	#-2,d4
		rts	
; ===========================================================================

loc_19B56:				; CODE XREF: h+2B82j h+2B8Ej
		subq.w	#4,d3
		moveq	#0,d1
		move.b	$14(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	8(a1),d1
		sub.w	8(a0),d1
		bmi.s	loc_19B8E
		cmp.w	d2,d1
		bcc.s	loc_19B8E
		tst.w	$12(a1)
		bmi.s	loc_19B8E
		sub.w	d3,$C(a1)
		subq.w	#1,$C(a1)
		bsr.w	RideObject_SetRide
		move.w	d6,d4
		addi.b	#$11,d4
		bset	d4,d6
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_19B8E:				; CODE XREF: h+2BF6j h+2BFAj ...
		moveq	#0,d4
		rts	
; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Solid:				; XREF: Obj15_SetSolid
		lea	($FFFFB000).w,a1
		tst.w	$12(a1)
		bmi.w	locret_751E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function Obj15_Solid

; ===========================================================================

Obj11_Action2:				; XREF: Obj11_Index
		bsr.s	Obj11_WalkOff
		bsr.w	DisplaySprite
		bra.w	Obj11_ChkDel

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk off a bridge
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_WalkOff:				; XREF: Obj11_Action2
		moveq	#0,d1
		move.b	$28(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		bsr.s	ExitPlatform2
		bcc.s	locret_75BE
		lsr.w	#4,d0
		move.b	d0,$3F(a0)
		move.b	$3E(a0),d0
		cmpi.b	#$40,d0
		beq.s	loc_75B6
		addq.b	#4,$3E(a0)

loc_75B6:
		bsr.w	Obj11_Bend
		bsr.w	Obj11_MoveSonic

locret_75BE:
		rts	
; End of function Obj11_WalkOff

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk or jump off	a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ExitPlatform:
		move.w	d1,d2

ExitPlatform2:
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_75E0
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_75E0
		cmp.w	d2,d0
		bcs.s	locret_75F2

loc_75E0:
		bclr	#3,$22(a1)
		move.b	#2,$24(a0)
		bclr	#3,$22(a0)

locret_75F2:
		rts	
; End of function ExitPlatform


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_MoveSonic:			; XREF: Obj11_WalkOff
		moveq	#0,d0
		move.b	$3F(a0),d0
		move.b	$29(a0,d0.w),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		lea	($FFFFB000).w,a1
		move.w	$C(a2),d0
		subq.w	#8,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)	; change Sonic's position on y-axis
		rts	
; End of function Obj11_MoveSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Bend:				; XREF: Obj11_Action; Obj11_WalkOff
		move.b	$3E(a0),d0
		jsr	CalcSine
		move.w	d0,d4
		lea	(Obj11_BendData2).l,a4
		moveq	#0,d0
		move.b	$28(a0),d0
		lsl.w	#4,d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		move.w	d3,d2
		add.w	d0,d3
		moveq	#0,d5
		lea	(Obj11_BendData).l,a5
		move.b	(a5,d3.w),d5
		andi.w	#$F,d3
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		lea	$29(a0),a2

loc_765C:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	(a3)+,d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,$C(a1)
		dbf	d2,loc_765C
		moveq	#0,d0
		move.b	$28(a0),d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		addq.b	#1,d3
		sub.b	d0,d3
		neg.b	d3
		bmi.s	locret_76CA
		move.w	d3,d2
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		adda.w	d2,a3
		subq.w	#1,d2
		bcs.s	locret_76CA

loc_76A4:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	-(a3),d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,$C(a1)
		dbf	d2,loc_76A4

locret_76CA:
		rts	
; End of function Obj11_Bend

; ===========================================================================
; ---------------------------------------------------------------------------
; BBZ bridge-bending data
; (Defines how the bridge bends	when Sonic walks across	it)
; ---------------------------------------------------------------------------
Obj11_BendData:	incbin	misc\BBZbend1.bin
		even
Obj11_BendData2:incbin	misc\BBZbend2.bin
		even

; ===========================================================================

Obj11_ChkDel:				; XREF: Obj11_Display; Obj11_Action2
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj11_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj11_DelAll	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj11_DelAll

Obj11_Done:
		rts	
; ===========================================================================

Obj11_DelAll:				; XREF: Obj11_ChkDel
		moveq	#0,d2
		lea	$28(a0),a2	; load bridge length
		move.b	(a2)+,d2	; move bridge length to	d2
		subq.b	#1,d2		; subtract 1
		bcs.s	Obj11_Delete

Obj11_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		cmp.w	a0,d0
		beq.s	loc_791E
		bsr.w	DeleteObject2

loc_791E:
		dbf	d2,Obj11_DelLoop ; repeat d2 times (bridge length)

Obj11_Delete:
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj11_Delete2:				; XREF: Obj11_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj11_Display2:				; XREF: Obj11_Index
		bsr.w	DisplaySprite
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - BBZ	bridge
; ---------------------------------------------------------------------------
Map_obj11:
	include "_maps\obj11.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 15 - swinging platforms (BBZ, DDZ, AAZ)
;		- spiked ball on a chain (FFZ)
; ---------------------------------------------------------------------------

Obj15:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj15_Index(pc,d0.w),d1
		jmp	Obj15_Index(pc,d1.w)
; ===========================================================================
Obj15_Index:	dc.w Obj15_Main-Obj15_Index, Obj15_SetSolid-Obj15_Index
		dc.w Obj15_Action2-Obj15_Index,	Obj15_Delete-Obj15_Index
		dc.w Obj15_Delete-Obj15_Index, Obj15_Display-Obj15_Index
		dc.w Obj15_Action-Obj15_Index
; ===========================================================================

Obj15_Main:				; XREF: Obj15_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj15,4(a0) ; BBZ and DDZ specific code
		move.w	#$236C,2(a0)
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$20,$14(a0)
		move.b	#8,$16(a0)
		move.w	$C(a0),$38(a0)
		move.w	8(a0),$3A(a0)
		
Obj15_SetLength:
		move.b	0(a0),d4
		moveq	#0,d1
		lea	$28(a0),a2	; move chain length to a2
		move.b	(a2),d1		; move a2 to d1
		move.w	d1,-(sp)
		andi.w	#$F,d1
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		addq.b	#8,d3
		move.b	d3,$3C(a0)
		subq.b	#8,d3
		tst.b	$1A(a0)
		beq.s	Obj15_MakeChain
		addq.b	#8,d3
		subq.w	#1,d1

Obj15_MakeChain:
		bsr.w	SingleObjLoad
		bne.s	loc_7A92
		addq.b	#1,$28(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,$24(a1)
		move.b	d4,0(a1)	; load swinging	object
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		bclr	#6,2(a1)
		move.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#8,$14(a1)
		move.b	#1,$1A(a1)
		move.b	d3,$3C(a1)
		subi.b	#$10,d3
		bcc.s	loc_7A8E
		move.b	#2,$1A(a1)
		move.w	#$180,$18(a1)

loc_7A8E:
		dbf	d1,Obj15_MakeChain ; repeat d1 times (chain length)

loc_7A92:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.w	#$4080,$26(a0)
		move.w	#-$200,$3E(a0)
		move.w	(sp)+,d1
		btst	#4,d1		; is object type $8X ?
		beq.s	loc_7AD4	; if not, branch
		move.l	#Map_obj48,4(a0) ; use BBZ ball	mappings
		move.w	#$43AA,2(a0)
		move.b	#1,$1A(a0)
		move.w	#$100,$18(a0)
		move.b	#$81,$20(a0)	; make object hurt when	touched

loc_7AD4:
		cmpi.b	#5,($FFFFFE10).w ; is zone FFZ?
		beq.s	Obj15_Action	; if yes, branch

Obj15_SetSolid:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		moveq	#0,d3
		move.b	$16(a0),d3
		bsr.w	Obj15_Solid

Obj15_Action:				; XREF: Obj15_Index
		bsr.w	Obj15_Move
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel
; ===========================================================================

Obj15_Action2:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	ExitPlatform
		move.w	8(a0),-(sp)
		bsr.w	Obj15_Move
		move.w	(sp)+,d2
		moveq	#0,d3
		move.b	$16(a0),d3
		addq.b	#1,d3
		bsr.w	MvSonicOnPtfm
		bsr.w	DisplaySprite
		bra.w	Obj15_ChkDel

MvSonicOnPtfm:
		move.w	$C(a0),d0
		sub.w	d3,d0
		bra.s	loc_19BA2

MvSonicOnPtfm2:
		move.w	$C(a0),d0
		subi.w	#9,d0

loc_19BA2:
		tst.b	$2A(a1)
		bmi.s	return_19BCA
		cmpi.b	#6,$24(a1)
		bhs.s	return_19BCA
		tst.w	($FFFFFE08).w
		bne.s	return_19BCA
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d2
		sub.w	d2,8(a1)
		cmpi.b	#$95,(a1)
		bne.s	.nottails
		move.w   d0,($FFFFB3CC).w   ; apply change to Shield's Y-Position
		sub.w	d2,($FFFFB3C8).w   ; apply change to Shield's X-Position

	.nottails:
		btst	#7,$22(a0)
		bne.s	.partner
		move.w   d0,($FFFFB18C).w   ; apply change to Shield's Y-Position
		sub.w	d2,($FFFFB188).w   ; apply change to Shield's X-Position
		move.w   d0,($FFFFB1CC).w   ; apply change to Shield's Y-Position
		sub.w	d2,($FFFFB1C8).w   ; apply change to Shield's X-Position
		rts

	.partner:
		move.w   d0,($FFFFB40C).w   ; apply change to Shield's Y-Position
		sub.w	d2,($FFFFB408).w   ; apply change to Shield's X-Position

return_19BCA:
	rts
; ===========================================================================
;loc_19BCC:
MvSonicOnSlope:
		btst	#3,$22(a1)
		beq.s	return_19C0C
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		lsr.w	#1,d0
		btst	#0,1(a0)
		beq.s	loc_19BEC
		not.w	d0
		add.w	d1,d0

loc_19BEC:
		move.b	(a2,d0.w),d1
		ext.w	d1
		move.w	$C(a0),d0
		sub.w	d1,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d2
		sub.w	d2,8(a1)

return_19C0C:
		rts
; End of function MvSonicOnPtfm2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move:				; XREF: Obj15_Action; Obj15_Action2
		move.b	($FFFFFE78).w,d0
		move.w	#$80,d1
		btst	#0,$22(a0)
		beq.s	loc_7B78
		neg.w	d0
		add.w	d1,d0

loc_7B78:
		bra.s	Obj15_Move2
; End of function Obj15_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj48_Move:				; XREF: Obj48_Display2
		tst.b	$3D(a0)
		bne.s	loc_7B9C
		move.w	$3E(a0),d0
		addq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,$26(a0)
		cmpi.w	#$200,d0
		bne.s	loc_7BB6
		move.b	#1,$3D(a0)
		bra.s	loc_7BB6
; ===========================================================================

loc_7B9C:
		move.w	$3E(a0),d0
		subq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,$26(a0)
		cmpi.w	#-$200,d0
		bne.s	loc_7BB6
		move.b	#0,$3D(a0)

loc_7BB6:
		move.b	$26(a0),d0
; End of function Obj48_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move2:				; XREF: Obj15_Move; Obj48_Display
		jsr	CalcSine
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	$28(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_7BCE:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFB000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,$C(a1)
		move.w	d5,8(a1)
		dbf	d6,loc_7BCE
		rts	
; End of function Obj15_Move2

; ===========================================================================

Obj15_ChkDel:				; XREF: Obj15_Action; Obj15_Action2
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj15_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj15_DelAll	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj15_DelAll

Obj15_Done:
		rts	
; ===========================================================================

Obj15_DelAll:				; XREF: Obj15_ChkDel
		moveq	#0,d2
		lea	$28(a0),a2
		move.b	(a2)+,d2

Obj15_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		bsr.w	DeleteObject2
		dbf	d2,Obj15_DelLoop ; repeat for length of	chain
		rts	
; ===========================================================================

Obj15_Delete:				; XREF: Obj15_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================

Obj15_Display:				; XREF: Obj15_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - BBZ	and DDZ swinging	platforms
; ---------------------------------------------------------------------------
Map_obj15:
	include "_maps\obj15BBZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - AAZ	swinging platforms
; ---------------------------------------------------------------------------
Map_obj15a:
	include "_maps\obj15AAZ.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 18 - platforms	(BBZ, CCZ, AAZ)
; ---------------------------------------------------------------------------

Obj18:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj18_Index(pc,d0.w),d1
		jmp	Obj18_Index(pc,d1.w)
; ===========================================================================
Obj18_Index:	dc.w Obj18_Main-Obj18_Index
		dc.w Obj18_Solid-Obj18_Index
		dc.w Obj18_Action2-Obj18_Index
		dc.w Obj18_Delete-Obj18_Index
		dc.w Obj18_Action-Obj18_Index
; ===========================================================================

Obj18_Main:				; XREF: Obj18_Index
		addq.b	#2,$24(a0)
		move.w	#$4486,2(a0)
		move.l	#Map_obj18,4(a0)
		move.w	#$4000,2(a0)
		move.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.w	$C(a0),$2C(a0)
		move.w	$C(a0),$34(a0)
		move.w	8(a0),$32(a0)
		move.w	#$80,$26(a0)
		moveq	#0,d1
		move.b	$28(a0),d0
		btst	#5,d0
		beq.s	Obj18_SmallPlatforms
		btst	#4,d0
		beq.s	Obj18_Long
		bra.s	Obj18_Big

Obj18_SmallPlatforms:
		btst	#4,d0
		bne.s	Obj18_Medium

Obj18_Short:
		move.b	#$10,$14(a0)
		addq.b	#2,d1		; use frame #2
		bra.s	Obj18_SetFrame

Obj18_Medium:
		move.b	#$20,$14(a0)
		bra.s	Obj18_SetFrame

Obj18_Long:
		move.b	#$30,$14(a0)
		addq.b	#3,d1		; use frame #3
		bra.s	Obj18_SetFrame

Obj18_Big:
		move.b	#$20,$14(a0)
		addq.b	#1,d1		; use frame #1

Obj18_SetFrame:
		move.b	d1,$1A(a0)	; set frame to d1

Obj18_Solid:				; XREF: Obj18_Index
		tst.b	$38(a0)
		beq.s	loc_7EE0
		subq.b	#4,$38(a0)

loc_7EE0:
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	PlatformObject

Obj18_Action:				; XREF: Obj18_Index
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		cmpi.b	#5,($FFFFFE10).w ; check if level is FFZ
		bne.s	Obj18_Display
		lea	(Ani_obj18).l,a1
		jsr	AnimateSprite

Obj18_Display:
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel

; ===========================================================================

Obj18_Action2:				; XREF: Obj18_Index
		cmpi.b	#$40,$38(a0)
		beq.s	loc_7F06
		addq.b	#4,$38(a0)

loc_7F06:
		moveq	#0,d1
		move.b	$14(a0),d1
		bsr.w	ExitPlatform
		move.w	8(a0),-(sp)
		bsr.w	Obj18_Move
		bsr.w	Obj18_Nudge
		move.w	(sp)+,d2
		bsr.w	MvSonicOnPtfm2
		cmpi.b	#5,($FFFFFE10).w ; check if level is FFZ
		bne.s	Obj18_Display2
		lea	(Ani_obj18).l,a1
		jsr	AnimateSprite

Obj18_Display2:
		bsr.w	DisplaySprite
		bra.w	Obj18_ChkDel
		rts

; ---------------------------------------------------------------------------
; Subroutine to	move platform slightly when you	stand on it
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Nudge:				; XREF: Obj18_Action; Obj18_Action2
		cmpi.b	#6,$28(a0)
		beq.s	Obj18_NudgeDone
		move.b	$38(a0),d0
		jsr	CalcSine
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$2C(a0),d0
		move.w	d0,$C(a0)

Obj18_NudgeDone:
		rts	
; End of function Obj18_Nudge

; ---------------------------------------------------------------------------
; Subroutine to	move platforms
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Move:				; XREF: Obj18_Action; Obj18_Action2
		moveq	#0,d0
		move.b	$28(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj18_TypeIndex(pc,d0.w),d1
		jmp	Obj18_TypeIndex(pc,d1.w)
; End of function Obj18_Move

; ===========================================================================
Obj18_TypeIndex:dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type01-Obj18_TypeIndex
		dc.w Obj18_Type02-Obj18_TypeIndex, Obj18_Type03-Obj18_TypeIndex
		dc.w Obj18_Type04-Obj18_TypeIndex, Obj18_Type05-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type07-Obj18_TypeIndex
		dc.w Obj18_Type08-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type00-Obj18_TypeIndex
; ===========================================================================

Obj18_Type00:
		rts			; platform 00 doesn't move
; ===========================================================================
Obj18_ChgMotion:
		move.b	($FFFFFE78).w,$26(a0) ;	update platform-movement variable
		rts	

Obj18_Type01:
		move.w	$32(a0),d0
		move.b	$26(a0),d1	; load platform-motion variable
		btst	#0,$22(a0)
		beq.s	Obj18_Type01_Normal
		neg.b	d1
		addi.b	#$40,d1
		bra.s	Obj18_01_Move

Obj18_Type01_Normal:
		subi.b	#$40,d1

Obj18_01_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,8(a0)	; change position on x-axis
		bra.s	Obj18_ChgMotion
; ===========================================================================

Obj18_Type02:
		move.w	$34(a0),d0
		move.b	$26(a0),d1	; load platform-motion variable
		btst	#1,$22(a0)
		beq.s	Obj18_Type02_Normal
		neg.b	d1
		addi.b	#$40,d1
		bra.s	Obj18_02_Move

Obj18_Type02_Normal:
		subi.b	#$40,d1

Obj18_02_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,$2C(a0)	; change position on y-axis
		bra.s	Obj18_ChgMotion
; ===========================================================================

Obj18_Type03:
		move.w	$32(a0),d0
		move.w	$34(a0),d1
		move.b	$26(a0),d2	; load platform-motion variable
		move.b	$26(a0),d3	; load platform-motion variable
		btst	#0,$22(a0)
		beq.s	Obj18_Type03_NoMirror
		neg.b	d2		; reverse platform-motion
		addi.b	#$40,d2
		bra.s	Obj18_Type03_Flip

Obj18_Type03_NoMirror:
		subi.b	#$40,d2

Obj18_Type03_Flip:
		btst	#1,$22(a0)
		beq.s	Obj18_Type03_Normal
		subi.b	#$40,d3
		bra.s	Obj18_03_Move

Obj18_Type03_Normal:
		neg.b	d3		; reverse platform-motion
		addi.b	#$40,d3

Obj18_03_Move:
		ext.w	d2
		ext.w	d3
		add.w	d2,d0
		add.w	d3,d1
		move.w	d0,8(a0)	; change position on x-axis
		move.w	d1,$2C(a0)	; change position on y-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type04:		
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_04_Wait	; if yes, branch
		btst	#3,$22(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_04_NoMove	; if not, branch
		move.w	#30,$3A(a0)	; set time delay to 0.5	seconds

Obj18_04_NoMove:
		rts	
; ===========================================================================

Obj18_04_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time
		bne.s	Obj18_04_NoMove	; if time is > 0, branch
		move.w	#32,$3A(a0)
		move.b	#8,$28(a0)	; change to type 04 (falling)
		rts	
; ===========================================================================

Obj18_Type08:
		tst.w	$3A(a0)
		beq.s	loc_8048
		subq.w	#1,$3A(a0)
		bne.s	loc_8048
		btst	#3,$22(a0)
		beq.s	loc_8042
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		move.w	$12(a0),$12(a1)

loc_8042:
		move.b	#8,$24(a0)

loc_8048:
		move.l	$2C(a0),d3
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,$2C(a0)
		addi.w	#$38,$12(a0)
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$2C(a0),d0
		bcc.s	locret_8074
		move.b	#6,$24(a0)

locret_8074:
		rts	
; ===========================================================================

Obj18_Type05:
		tst.b	$25(a0)
		bne.s	Obj18_Type05Rise
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_05_Wait	; if yes, branch
		btst	#3,$22(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_05_NoMove	; if not, branch
		move.w	#30,$3A(a0)	; set time delay to 0.5	seconds

Obj18_05_NoMove:
		rts	
; ===========================================================================

Obj18_05_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time
		bne.s	Obj18_05_NoMove	; if time is > 0, branch
		move.w	#32,$3A(a0)
		addq.b	#2,$25(a0)	; change to type 04 (falling)
		rts	
; ===========================================================================

Obj18_Type05Rise:
		subq.w	#2,$2C(a0)	; move platform	up
		move.w	$34(a0),d0
		subi.w	#$200,d0
		rts	
; ===========================================================================

Obj18_Type07:
		move.w	($FFFFFE04).w,d0	; load platform-motion variable
		move.w	$32(a0),d2
		move.w	$34(a0),d3
		add.w	d0,d0			; double the value (doubles the speed)
		jsr	CalcSine		; calc sine based on it
		asr.w	#2,d0			; shrink down the Sine output (shrink down the horizontal radius)
		asr.w	#2,d1			; shrink down the Cos output (shrink down the vertical radius)
		btst	#0,$22(a0)
		beq.s	Obj18_07_Move
		neg.w	d0		; reverse platform-motion

Obj18_07_Move:
		btst	#1,$22(a0)
		beq.s	Obj18_07_Move2
		neg.w	d1		; reverse platform-motion
		move.b	#1,$1C(a0)

Obj18_07_Move2:
		add.w	d0,d2
		add.w	d1,d3
		move.w	d2,8(a0)		; save result to new X-pos
		move.w	d3,$2C(a0)		; save result to new Y-pos
		rts
; ===========================================================================

Obj18_ChkDel:				; XREF: Obj18_Action; Obj18_Action2
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj18_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj18_Delete	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj18_Delete

Obj18_Done:
		rts	
; ===========================================================================

Obj18_Delete:				; XREF: Obj18_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - unused
; ---------------------------------------------------------------------------
Map_obj18x:
	include "_maps\obj18x.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - BBZ	platforms
; ---------------------------------------------------------------------------
Map_obj18:
	include "_maps\obj18BBZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - AAZ	platforms
; ---------------------------------------------------------------------------
Map_obj18b:
	include "_maps\obj18AAZ.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - FFZ	platforms
; ---------------------------------------------------------------------------
Map_obj18c:
	include "_maps\obj18FFZ.asm"

; ---------------------------------------------------------------------------
Ani_obj18:
	include "_anim\obj18.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - swinging ball on a chain from BBZ boss
; ---------------------------------------------------------------------------
Map_obj48:
	include "_maps\obj48.asm"

; ---------------------------------------------------------------------------
; Sloped platform subroutine (BBZ collapsing ledges and	DDZ platforms)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject2:				; XREF: Obj1A_WalkOff; et al
		lea	($FFFFB000).w,a1
		btst	#3,$22(a1)
		beq.s	locret_856E
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		lsr.w	#1,d0
		btst	#0,1(a0)
		beq.s	loc_854E
		not.w	d0
		add.w	d1,d0

loc_854E:
		moveq	#0,d1
		move.b	(a2,d0.w),d1
		move.w	$C(a0),d0
		sub.w	d1,d0
		moveq	#0,d1
		move.b	$16(a1),d1
		sub.w	d1,d0
		move.w	d0,$C(a1)
		sub.w	8(a0),d2
		sub.w	d2,8(a1)

locret_856E:
		rts	
; End of function SlopeObject2

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for BBZ collapsing ledge
; ---------------------------------------------------------------------------
Obj1A_SlopeData:
		incbin	misc\BBZledge.bin
		even

; ---------------------------------------------------------------------------
; Sprite mappings - BBZ	collapsing ledge
; ---------------------------------------------------------------------------
Map_obj1A:
	include "_maps\obj1A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - collapsing floors (DDZ, AAZ,	FFZ)
; ---------------------------------------------------------------------------
Map_obj53:
	include "_maps\obj53.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1C - scenery (BBZ bridge stump, AAZ lava thrower)
; ---------------------------------------------------------------------------

Obj1C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1C_Index(pc,d0.w),d1
		jmp	Obj1C_Index(pc,d1.w)
; ===========================================================================
Obj1C_Index:	dc.w Obj1C_Main-Obj1C_Index
		dc.w Obj1C_ChkDel-Obj1C_Index
; ===========================================================================

Obj1C_Main:				; XREF: Obj1C_Index
		addq.b	#2,$24(a0)
		moveq	#0,d0
		move.b	$28(a0),d0	; copy object type to d0
		mulu.w	#$A,d0		; multiply by $A
		lea	Obj1C_Var(pc,d0.w),a1
		move.l	(a1)+,4(a0)
		move.w	(a1)+,2(a0)
		ori.b	#4,1(a0)
		move.b	(a1)+,$1A(a0)
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$18(a0)
		move.w 	$18(a0),d0
		lsr.w 	#1,d0
		andi.w 	#$380,d0
		move.w 	d0,$18(a0)
		move.b	(a1)+,$20(a0)

Obj1C_ChkDel:				; XREF: Obj1C_Index
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.w	DisplaySprite
		move.w	$1E(a0),d0	; get address in respawn table
		beq.w	DeleteObject	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Variables for	object $1C are stored in an array
; ---------------------------------------------------------------------------
Obj1C_Var:	dc.l Map_obj11		; mappings address
		dc.w $4384		; VRAM setting
		dc.b 3,	$10, 4, 0		; frame, width,	priority, collision response
		dc.l Map_obj11
		dc.w $4384
		dc.b 4,	$10, 4, 0
		dc.l Map_obj11
		dc.w $4384
		dc.b 1,	$38, 3, 0
		dc.l Map_obj11
		dc.w $437C
		dc.b 1,	$10, 1,	0
; ---------------------------------------------------------------------------
; Sprite mappings - AAZ	lava thrower
; ---------------------------------------------------------------------------
Map_obj1C:
	include "_maps\obj1C.asm"


; ---------------------------------------------------------------------------
; Subroutine to	check if Sonic touches the object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1D_ChkTouch:				; XREF: Obj1D_Action
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_8918
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.s	loc_8918
		move.w	$C(a1),d2
		move.b	$16(a1),d1
		ext.w	d1
		add.w	d2,d1
		move.w	$C(a0),d0
		subi.w	#$10,d0
		sub.w	d1,d0
		bhi.s	loc_8918
		cmpi.w	#-$10,d0
		bcs.s	loc_8918
		moveq	#-1,d0
		rts	
; ===========================================================================

loc_8918:
		moveq	#0,d0
		rts	
; End of function Obj1D_ChkTouch

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - object 1D
; ---------------------------------------------------------------------------
Map_obj1D:
	include "_maps\obj1D.asm"

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall:			; XREF: Obj44_Solid
		bsr.w	Obj44_SolidWall2
		beq.s	loc_8AA8
		bmi.w	loc_8AC4
		tst.w	d0
		beq.w	loc_8A92
		bmi.s	loc_8A7C
		tst.w	$10(a1)
		bmi.s	loc_8A92
		bra.s	loc_8A82
; ===========================================================================

loc_8A7C:
		tst.w	$10(a1)
		bpl.s	loc_8A92

loc_8A82:
		sub.w	d0,8(a1)
		move.w	#0,$20(a1)
		move.w	#0,$10(a1)

loc_8A92:
		btst	#1,$22(a1)
		bne.s	loc_8AB6
		bset	#5,$22(a1)
		bset	#5,$22(a0)
		rts	
; ===========================================================================

loc_8AA8:
		btst	#5,$22(a0)
		beq.s	locret_8AC2
		move.w	#1,$1C(a1)

loc_8AB6:
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)

locret_8AC2:
		rts	
; ===========================================================================

loc_8AC4:
		tst.w	$12(a1)
		bpl.s	locret_8AD8
		tst.w	d3
		bpl.s	locret_8AD8
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)

locret_8AD8:
		rts	
; End of function Obj44_SolidWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall2:			; XREF: Obj44_SolidWall
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_8B48
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_8B48
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		add.w	d2,d3
		bmi.s	loc_8B48
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.s	loc_8B48
		tst.b	($FFFFB02A).w
		bmi.s	loc_8B48
		cmpi.b	#6,($FFFFB024).w
		bcc.s	loc_8B48
		tst.w	($FFFFFE08).w
		bne.s	loc_8B48
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_8B30
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_8B30:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_8B3C
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_8B3C:
		cmp.w	d1,d5
		bhi.s	loc_8B44
		moveq	#1,d4
		rts	
; ===========================================================================

loc_8B44:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_8B48:
		moveq	#0,d4
		rts	
; End of function Obj44_SolidWall2
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 27 - explosion	from a destroyed enemy
; ---------------------------------------------------------------------------

Obj27:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj27_Index(pc,d0.w),d1
		jmp	Obj27_Index(pc,d1.w)
; ===========================================================================
Obj27_Index:	dc.w Obj27_LoadAnimal-Obj27_Index
		dc.w Obj27_Main-Obj27_Index
		dc.w Obj27_Animate-Obj27_Index
; ===========================================================================

Obj27_LoadAnimal:			; XREF: Obj27_Index
		addq.b	#2,$24(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj27_Main
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	$3E(a0),$3E(a1)

Obj27_Main:				; XREF: Obj27_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj27,4(a0)
		make_art_tile	ArtTile_Explode,0,1
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#0,$20(a0)
		move.b	#$C,$14(a0)
		move.b	#7,$23(a0)	; set frame duration to	7 frames
		move.b	#0,$1A(a0)
		sfx		sfx_Break	;	play breaking enemy sound

Obj27_Animate:				; XREF: Obj27_Index
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Obj27_Display
		move.b	#7,$23(a0)	; set frame duration to	7 frames
		addq.b	#1,$1A(a0)	; next frame
		cmpi.b	#5,$1A(a0)	; is the final frame (05) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj27_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3F - explosion	from a destroyed boss, bomb or cannonball
; ---------------------------------------------------------------------------

Obj3F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3F_Index(pc,d0.w),d1
		jmp	Obj3F_Index(pc,d1.w)
; ===========================================================================
Obj3F_Index:	dc.w Obj3F_Main-Obj3F_Index
		dc.w Obj3F_Animate-Obj3F_Index
; ===========================================================================

Obj3F_Main:				; XREF: Obj3F_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj3F,4(a0)
		make_art_tile	ArtTile_Explode,0,1
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#0,$20(a0)
		move.b	#$C,$14(a0)
		move.b	#7,$23(a0)
		move.b	#0,$1A(a0)
		sfx		sfx_Explode ;	play exploding bomb sound

Obj3F_Animate:				; XREF: Obj27_Index
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Obj27_Display
		move.b	#4,$23(a0)	; set frame duration to	7 frames
		addq.b	#1,$1A(a0)	; next frame
		cmpi.b	#6,$1A(a0)	; is the final frame (05) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj3F_Display:
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj1E:
	include "_anim\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Ball Hog enemy (FFZ)
; ---------------------------------------------------------------------------
Map_obj1E:
	include "_maps\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj27:	
	include "_maps\obj27.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion from when	a boss is destroyed
; ---------------------------------------------------------------------------
Map_obj3F:	
	include "_maps\obj3F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 28 - animals
; ---------------------------------------------------------------------------

Obj28:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj28_Index(pc,d0.w),d1
		jmp	Obj28_Index(pc,d1.w)
; ===========================================================================
Obj28_Index:	dc.w Obj28_Ending-Obj28_Index, loc_912A-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9184-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9240-Obj28_Index
		dc.w loc_9260-Obj28_Index, loc_9260-Obj28_Index
		dc.w loc_9280-Obj28_Index, loc_92BA-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9370-Obj28_Index
		dc.w loc_92D6-Obj28_Index

Obj28_VarIndex:	dc.b 0,	5, 2, 3, 6, 3, 4, 5, 4,	1, 0, 1

Obj28_Variables:dc.w $FE00, $FC00
		dc.l Map_obj28
		dc.w $FE00, $FD00	; horizontal speed, vertical speed
		dc.l Map_obj28a		; mappings address
		dc.w $FE80, $FD00
		dc.l Map_obj28
		dc.w $FEC0, $FE80
		dc.l Map_obj28a
		dc.w $FE40, $FD00
		dc.l Map_obj28b
		dc.w $FD00, $FC00
		dc.l Map_obj28a
		dc.w $FD80, $FC80
		dc.l Map_obj28b

Obj28_EndSpeed:	dc.w $FBC0, $FC00, $FBC0, $FC00, $FBC0,	$FC00, $FD00, $FC00
		dc.w $FD00, $FC00, $FE80, $FD00, $FE80,	$FD00, $FEC0, $FE80
		dc.w $FE40, $FD00, $FE00, $FD00, $FD80,	$FC80

Obj28_EndMap:	dc.l Map_obj28a, Map_obj28a, Map_obj28a, Map_obj28, Map_obj28
		dc.l Map_obj28,	Map_obj28, Map_obj28a, Map_obj28b, Map_obj28a
		dc.l Map_obj28b

Obj28_EndVram:	dc.w $85A5, $85A5, $85A5, $8553, $8553, $8573, $8573, $8585, $8593
		dc.w $8565, $85B3
; ===========================================================================

Obj28_Ending:				; XREF: Obj28_Index
		tst.b	$28(a0)		; did animal come from a destroyed enemy?
		beq.w	Obj28_FromEnemy	; if yes, branch
		moveq	#0,d0
		move.b	$28(a0),d0	; move object type to d0
		add.w	d0,d0		; multiply d0 by 2
		move.b	d0,$24(a0)	; move d0 to routine counter
		subi.w	#$14,d0
		move.w	Obj28_EndVram(pc,d0.w),2(a0)
		add.w	d0,d0
		move.l	Obj28_EndMap(pc,d0.w),4(a0)
		lea	Obj28_EndSpeed(pc),a1
		move.w	(a1,d0.w),$32(a0) ; load horizontal speed
		move.w	(a1,d0.w),$10(a0)
		move.w	2(a1,d0.w),$34(a0) ; load vertical speed
		move.w	2(a1,d0.w),$12(a0)
		move.b	#$C,$16(a0)
		move.b	#4,1(a0)
		bset	#0,1(a0)
		move.w	#$300,$18(a0)
		move.b	#8,$14(a0)
		move.b	#7,$23(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj28_FromEnemy:			; XREF: Obj28_Ending
		addq.b	#2,$24(a0)
		jsr	RandomNumber
		andi.w	#1,d0
		moveq	#0,d1
		move.b	($FFFFFE10).w,d1
		add.w	d1,d1
		add.w	d0,d1
		lea	Obj28_VarIndex(pc),a1
		move.b	(a1,d1.w),d0
		move.b	d0,$30(a0)
		lsl.w	#3,d0
		lea	Obj28_Variables(pc),a1
		adda.w	d0,a1
		move.w	(a1)+,$32(a0)	; load horizontal speed
		move.w	(a1)+,$34(a0)	; load vertical	speed
		move.l	(a1)+,4(a0)	; load mappings
		make_art_tile	ArtTile_Animal1,0,1	; VRAM setting for 1st animal
		btst	#0,$30(a0)	; is 1st animal	used?
		beq.s	loc_90C0	; if yes, branch
		make_art_tile	ArtTile_Animal2,0,1	; VRAM setting for 2nd animal

loc_90C0:
		move.b	#$C,$16(a0)
		move.b	#4,1(a0)
		bset	#0,1(a0)
		move.w	#$300,$18(a0)
		move.b	#8,$14(a0)
		move.b	#7,$23(a0)
		move.b	#2,$1A(a0)
		move.w	#-$400,$12(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_911C
		move.w	$3E(a0),d0
		lsr.w	#1,d0
		move.b	d0,$1A(a1)

Obj28_Display:
		bra.w	DisplaySprite
; ===========================================================================

loc_911C:
		move.b	#$12,$24(a0)
		clr.w	$10(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_912A:				; XREF: Obj28_Index
		tst.b	1(a0)
		bpl.w	DeleteObject
		bsr.w	ObjectFall
		tst.w	$12(a0)
		bmi.s	loc_9180
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9180
		add.w	d1,$C(a0)
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#1,$1A(a0)
		move.b	$30(a0),d0
		add.b	d0,d0
		addq.b	#4,d0
		move.b	d0,$24(a0)
		tst.b	($FFFFF7A7).w
		beq.s	loc_9180
		btst	#4,($FFFFFE0F).w
		beq.s	loc_9180
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_9180:
		bra.w	DisplaySprite
; ===========================================================================

loc_9184:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_91AE
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91AE
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_91AE:
		tst.b	$28(a0)
		bne.s	loc_9224
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_91C0:				; XREF: Obj28_Index
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		tst.w	$12(a0)
		bmi.s	loc_91FC
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91FC
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)
		tst.b	$28(a0)
		beq.s	loc_91FC
		cmpi.b	#$A,$28(a0)
		beq.s	loc_91FC
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_91FC:
		subq.b	#1,$23(a0)
		bpl.s	loc_9212
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_9212:
		tst.b	$28(a0)
		bne.s	loc_9224
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_9224:				; XREF: Obj28_Index
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		bcs.s	loc_923C
		subi.w	#$180,d0
		bpl.s	loc_923C
		tst.b	1(a0)
		bpl.w	DeleteObject

loc_923C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9240:				; XREF: Obj28_Index
		tst.b	1(a0)
		bpl.w	DeleteObject
		subq.w	#1,$36(a0)
		bne.w	loc_925C
		move.b	#2,$24(a0)
		move.w	#$180,$18(a0)

loc_925C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9260:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bcc.s	loc_927C
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#$E,$24(a0)
		bra.w	loc_91C0
; ===========================================================================

loc_927C:
		bra.w	loc_9224
; ===========================================================================

loc_9280:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_92B6
		clr.w	$10(a0)
		clr.w	$32(a0)
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		bsr.w	loc_93C4
		bsr.w	loc_93EC
		subq.b	#1,$23(a0)
		bpl.s	loc_92B6
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_92B6:
		bra.w	loc_9224
; ===========================================================================

loc_92BA:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_9310
		move.w	$32(a0),$10(a0)
		move.w	$34(a0),$12(a0)
		move.b	#4,$24(a0)
		bra.w	loc_9184
; ===========================================================================

loc_92D6:				; XREF: Obj28_Index
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_9310
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9310
		not.b	$29(a0)
		bne.s	loc_9306
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_9306:
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_9310:
		bra.w	loc_9224
; ===========================================================================

loc_9314:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_932E
		clr.w	$10(a0)
		clr.w	$32(a0)
		bsr.w	ObjectFall
		bsr.w	loc_93C4
		bsr.w	loc_93EC

loc_932E:
		bra.w	loc_9224
; ===========================================================================

loc_9332:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_936C
		bsr.w	ObjectFall
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	loc_936C
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_936C
		neg.w	$10(a0)
		bchg	#0,1(a0)
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_936C:
		bra.w	loc_9224
; ===========================================================================

loc_9370:				; XREF: Obj28_Index
		bsr.w	sub_9404
		bpl.s	loc_93C0
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		tst.w	$12(a0)
		bmi.s	loc_93AA
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_93AA
		not.b	$29(a0)
		bne.s	loc_93A0
		neg.w	$10(a0)
		bchg	#0,1(a0)

loc_93A0:
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

loc_93AA:
		subq.b	#1,$23(a0)
		bpl.s	loc_93C0
		move.b	#1,$23(a0)
		addq.b	#1,$1A(a0)
		andi.b	#1,$1A(a0)

loc_93C0:
		bra.w	loc_9224
; ===========================================================================

loc_93C4:
		move.b	#1,$1A(a0)
		tst.w	$12(a0)
		bmi.s	locret_93EA
		move.b	#0,$1A(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_93EA
		add.w	d1,$C(a0)
		move.w	$34(a0),$12(a0)

locret_93EA:
		rts	
; ===========================================================================

loc_93EC:
		bset	#0,1(a0)
		move.w	8(a0),d0
		sub.w	($FFFFB008).w,d0
		bcc.s	locret_9402
		bclr	#0,1(a0)

locret_9402:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_9404:
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		subi.w	#$B8,d0
		rts	
; End of function sub_9404

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - animals
; ---------------------------------------------------------------------------
Map_obj28:
	include "_maps\obj28.asm"

Map_obj28a:
	include "_maps\obj28a.asm"

Map_obj28b:
	include "_maps\obj28b.asm"

; ---------------------------------------------------------------------------
; Object 25 - rings
; ---------------------------------------------------------------------------

Obj25:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj25_Index(pc,d0.w),d1
		jmp	Obj25_Index(pc,d1.w)
; ===========================================================================
Obj25_Index:	dc.w Obj25_Main-Obj25_Index
		dc.w Obj25_Animate-Obj25_Index
		dc.w Obj25_Collect-Obj25_Index
		dc.w Obj25_Sparkle-Obj25_Index
		dc.w Obj25_Delete-Obj25_Index
; ===========================================================================

Obj25_Main:				; XREF: Obj25_Index
		addq.b	#2,$24(a0)
		move.w	8(a0),$32(a0)
		move.l	#Map_obj25,4(a0)
		make_art_tile	ArtTile_Rings,0,1
		move.b	#4,1(a0)
		move.w	#$100,$18(a0)
		move.b	#$47,$20(a0)
		move.b	#8,$14(a0)

Obj25_Animate:				; XREF: Obj25_Index
		move.w	$32(a0),d0
		bra.w	MarkObjGone
; ===========================================================================

Obj25_Collect:				; XREF: Obj25_Index
		addq.b	#2,$24(a0)
		move.b	#0,$20(a0)
		move.w	#$80,$18(a0)
		bsr.w	CollectRing

Obj25_Sparkle:				; XREF: Obj25_Index
		lea	(Ani_obj25).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj25_Delete:				; XREF: Obj25_Index
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

CollectRing:				; XREF: Obj25_Collect
		addq.w	#1,($FFFFFE20).w ; add 1 to rings
		ori.b	#1,($FFFFFE1D).w ; update the rings counter
		sfx		sfx_RingRight
		rts
; End of function CollectRing

RingsManager:
	moveq	#0,d0
	move.b	($FFFFFE17).w,d0
	move.w	RingsManager_States(pc,d0.w),d0
	jmp	RingsManager_States(pc,d0.w)
; ===========================================================================
; off_16F96:
RingsManager_States:
	dc.w RingsManager_Init-RingsManager_States
	dc.w RingsManager_Main-RingsManager_States
; ===========================================================================
; loc_16F9A:
RingsManager_Init:
	addq.b	#2,($FFFFFE17).w ; => RingsManager_Main
	bsr.w	RingsManager_Setup
	movea.l	($FFFFE800+Rings_Space).w,a1
	lea	($FFFFE800).w,a2
	move.w	($FFFFF700).w,d4
	subq.w	#8,d4
	bhi.s	loc_16FB6
	moveq	#1,d4
	bra.s	loc_16FB6
; ===========================================================================

loc_16FB2:
	addq.w	#4,a1
	addq.w	#2,a2

loc_16FB6:
	cmp.w	(a1),d4
	bhi.s	loc_16FB2
	move.l	a1,($FFFFE800+Rings_Space).w
	move.w	a2,($FFFFF7A2).w
	addi.w	#$150,d4
	bra.s	loc_16FCE
; ===========================================================================

loc_16FCA:
	addq.w	#4,a1

loc_16FCE:
	cmp.w	(a1),d4
	bhi.s	loc_16FCA
	move.l	a1,($FFFFE800+Rings_Space+4).w
	rts
; ===========================================================================
; loc_16FDE:
RingsManager_Main:
	lea	($FFFFEF80).w,a2
	move.w	(a2)+,d1
	subq.w	#1,d1
	bcs.s	loc_17014

loc_16FE8:
	move.w	(a2)+,d0
	beq.s	loc_16FE8
	movea.w	d0,a1
	subq.b	#1,(a1)
	bne.s	loc_17010
	move.b	#6,(a1)
	addq.b	#1,1(a1)
	cmpi.b	#5,1(a1)
	bne.s	loc_17010
	move.w	#-1,(a1)
	move.w	#0,-2(a2)
	subq.w	#1,($FFFFEF80).w

loc_17010:
	dbf	d1,loc_16FE8

loc_17014:
	movea.l	($FFFFE800+Rings_Space).w,a1
	movea.w	($FFFFF7A2).w,a2
	move.w	($FFFFF700).w,d4
	subq.w	#8,d4
	bhi.s	loc_17028
	moveq	#1,d4
	bra.s	loc_17028
; ===========================================================================

loc_17024:
	addq.w	#4,a1
	addq.w	#2,a2

loc_17028:
	cmp.w	(a1),d4
	bhi.s	loc_17024
	bra.s	loc_17032
; ===========================================================================

loc_17030:
	subq.w	#4,a1
	subq.w	#2,a2

loc_17032:
	cmp.w	-4(a1),d4
	bls.s	loc_17030
	move.l	a1,($FFFFE800+Rings_Space).w
	move.w	a2,($FFFFF7A2).w
	movea.l	($FFFFE800+Rings_Space+4).w,a2
	addi.w	#$150,d4
	bra.s	loc_1704A
; ===========================================================================

loc_17046:
	addq.w	#4,a2

loc_1704A:
	cmp.w	(a2),d4
	bhi.s	loc_17046
	bra.s	loc_17054
; ===========================================================================

loc_17052:
	subq.w	#4,a2

loc_17054:
	cmp.w	-4(a2),d4
	bls.s	loc_17052
	move.l	a2,($FFFFE800+Rings_Space+4).w
	rts
; ===========================================================================

Touch_Rings:
	movea.l	($FFFFE800+Rings_Space).w,a1
	movea.l	($FFFFE800+Rings_Space+4).w,a2

loc_170D0:
	cmpa.l	a1,a2
	beq.w	return_17166
	movea.w	($FFFFF7A2).w,a4
	cmpi.w	#$5A,$30(a0)
	bcc.w	return_17166
	btst	#5,($FFFFFE2C).w	; does Sonic have a lightning shield?
	beq.s	Touch_Rings_NoAttraction	; if not, branch
	move.w	8(a0),d2
	move.w	$C(a0),d3
	subi.w	#$40,d2
	subi.w	#$40,d3
	move.w	#6,d1
	move.w	#$C,d6
	move.w	#$80,d4
	move.w	#$80,d5
	bra.s	loc_17112
; ===========================================================================
	
Touch_Rings_NoAttraction:
	move.w	8(a0),d2
	move.w	$C(a0),d3
	subi.w	#8,d2
	moveq	#0,d5
	move.b	$16(a0),d5
	subq.b	#3,d5
	sub.w	d5,d3
	cmpi.b	#$4D,4(a0)
	bne.s	loc_17111
	addi.w	#$C,d3
	moveq	#$A,d5

loc_17111:
	move.w	#6,d1
	move.w	#$C,d6
	move.w	#$10,d4
	add.w	d5,d5

loc_17112:
	tst.w	(a4)
	bne.w	loc_1715C
	move.w	(a1),d0
	sub.w	d1,d0
	sub.w	d2,d0
	bcc.s	loc_1712A
	add.w	d6,d0
	bcs.s	loc_17130
	bra.w	loc_1715C
; ===========================================================================

loc_1712A:
	cmp.w	d4,d0
	bhi.w	loc_1715C

loc_17130:
	move.w	2(a1),d0
	sub.w	d1,d0
	sub.w	d3,d0
	bcc.s	loc_17142
	add.w	d6,d0
	bcs.s	loc_17148
	bra.w	loc_1715C
; ===========================================================================

loc_17142:
	cmp.w	d5,d0
	bhi.w	loc_1715C

loc_17148:
	btst	#5,($FFFFFE2C).w	; does Sonic have a lightning shield?
	bne.s	AttractRing
	
loc_17148_cont:
	move.w	#$601,(a4)
	bsr.s	loc_17168
	lea	($FFFFEF82).w,a3

loc_17152:
	tst.w	(a3)+
	bne.s	loc_17152
	move.w	a4,-(a3)
	addq.w	#1,($FFFFEF80).w

loc_1715C:
	addq.w	#4,a1
	addq.w	#2,a4
	cmpa.l	a1,a2
	bne.w	loc_17112

return_17166:
	rts
; ===========================================================================

loc_17168:
	subq.w	#1,($FFFFF712).w
	bra.w	CollectRing
; ===========================================================================

AttractRing:
	movea.l	a1,a3
	jsr	SingleObjLoad
	bne.w	AttractRing_NoFreeSlot
	move.b	#$91,(a1)
	move.w	(a3),8(a1)
	move.w	2(a3),$C(a1)
	move.w	a0,$34(a1)
	move.w	#-1,(a4)
	rts	
; ===========================================================================
	
AttractRing_NoFreeSlot:
	movea.l	a3,a1
	bra.s	loc_17148_cont
; ===========================================================================

BuildRings:
	movea.l	($FFFFE800+Rings_Space).w,a0
	move.l	($FFFFE800+Rings_Space+4).w,d7
	sub.l	a0,d7
	bne.s	loc_17186
	rts
; ===========================================================================

loc_17186:
	movea.w	($FFFFF7A2).w,a4
	lea	($FFFFF700).w,a3

loc_1718A:
	tst.w	(a4)+
	bmi.w	loc_171EC
	move.w	(a0),d3
	sub.w	(a3),d3
	addi.w	#$80,d3
	move.w	2(a0),d2
	sub.w	4(a3),d2
	andi.w	#$7FF,d2
	addi.w	#8,d2
	bmi.s	loc_171EC
	cmpi.w	#$F0,d2
	bge.s	loc_171EC
	addi.w	#$78,d2
	lea	(Map_Obj25).l,a1
	moveq	#0,d1
	move.b	-1(a4),d1
	bne.s	loc_171C8
	moveq	#0,d1

loc_171C8:
	add.w	d1,d1
	adda.w	(a1,d1.w),a1
	moveq	#$00,d1					; MJ: clear d1 (because of our byte to word change)
	move.b	(a1)+,d1
	subq.b	#1,d1
	bmi.s	loc_171EC
	move.b	(a1)+,d0
	ext.w	d0
	add.w	d2,d0
	move.w	d0,(a2)+
	move.b	(a1)+,(a2)+
	addq.b	#1,d5
	move.b	d5,(a2)+
	move.b	(a1)+,d0
	lsl.w	#8,d0
	move.b	(a1)+,d0
	addi.w	#(ArtTile_Rings+$8000),d0
	move.w	d0,(a2)+
	move.b	(a1)+,d0
	ext.w	d0
	add.w	d3,d0
	move.w	d0,(a2)+

loc_171EC:
	addq.w	#4,a0
	subq.w	#4,d7
	bne.w	loc_1718A
	rts
; ===========================================================================

RingsManager_Setup:
	lea	($FFFFE800).w,a1
	moveq	#0,d0
	move.w	#Rings_Space/4-1,d1

loc_172AE:				; CODE XREF: h+33Cj
	move.l	d0,(a1)+
	dbf	d1,loc_172AE

	lea	($FFFFEF80).w,a1
	move.w	#$1F,d1

loc_172AF:
	move.l	d0,(a1)+
	dbf	d1,loc_172AF

	moveq	#0,d5
	moveq	#0,d0
	move.w	($FFFFFE10).w,d0
	lsl.b	#6,d0
	lsr.w	#4,d0
	lea	(RingPos_Index).l,a1
	move.w	(a1,d0.w),d0
	lea	(a1,d0.w),a1
	move.l	a1,($FFFFE800+Rings_Space).w
	addq.w	#4,a1
	moveq	#0,d5
	move.w	#(Max_Rings-1),d0

loc_172B0:
	tst.l	(a1)+
	bmi.s	loc_172B1
	addq.w	#1,d5
	dbf	d0,loc_172B0

loc_172B1:
	move.w	d5,($FFFFF712).w
	rts
	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 37 - rings flying out of Sonic	when he's hit
; ---------------------------------------------------------------------------

Obj37:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj37_Index(pc,d0.w),d1
		jmp	Obj37_Index(pc,d1.w)
; ===========================================================================
Obj37_Index:	dc.w Obj37_CountRings-Obj37_Index
		dc.w Obj37_Bounce-Obj37_Index
		dc.w Obj37_Collect-Obj37_Index
		dc.w Obj37_Sparkle-Obj37_Index
		dc.w Obj37_Delete-Obj37_Index
; ===========================================================================

Obj37_CountRings:			; XREF: Obj37_Index
		movea.l	a0,a1
		moveq	#0,d5
		move.w	($FFFFFE20).w,d5 ; check number	of rings you have
		moveq	#32,d0
		cmp.w	d0,d5		; do you have 32 or more?
		bcs.s	loc_9CDE	; if not, branch
		move.w	d0,d5		; if yes, set d5 to 32

loc_9CDE:
		subq.w	#1,d5
		move.w	#$288,d4
		bra.s	Obj37_MakeRings
; ===========================================================================

Obj37_Loop:
		bsr.w	SingleObjLoad
		bne.w	Obj37_ResetCounter

Obj37_MakeRings:			; XREF: Obj37_CountRings
		move.b	#$37,0(a1)	; load bouncing	ring object
		addq.b	#2,$24(a1)
		move.b	#8,$16(a1)
		move.b	#8,$17(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.l	#Map_obj25,4(a1)
		move.w	#($8000+ArtTile_Rings),2(a1)
		move.b	#4,1(a1)
		move.w	#$180,$18(a1)
		move.b	#$47,$20(a1)
		move.b	#8,$14(a1)
		move.b	#-1,($FFFFFEC6).w
		tst.w	d4
		bmi.s	loc_9D62
		move.w	d4,d0
		jsr 	CalcSine
		move.w	d4,d2
		lsr.w	#8,d2
		asl.w	d2,d0
		asl.w	d2,d1
		move.w	d0,d2
		move.w	d1,d3
		addi.b	#$10,d4
		bcc.s	loc_9D62
		subi.w	#$80,d4
		bcc.s	loc_9D62
		move.w	#$288,d4

loc_9D62:
		btst	#0,($FFFFB022).w
		beq.s	Obj37_Reverse
		neg.w	d2
		move.w	d2,$10(a1)
		move.w	d3,$12(a1)
		bra.s	Obj37_Done

Obj37_Reverse:
		move.w	d2,$10(a1)
		move.w	d3,$12(a1)
		neg.w	d2

Obj37_Done:
		neg.w	d4
		dbf	d5,Obj37_Loop	; repeat for number of rings (max 31)

Obj37_ResetCounter:			; XREF: Obj37_Loop
		move.w	#0,($FFFFFE20).w ; reset number	of rings to zero
		move.b	#$80,($FFFFFE1D).w ; update ring counter
		move.b	#0,($FFFFFE1B).w
		sfx		sfx_RingLoss

Obj37_Bounce:				; XREF: Obj37_Index
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)
		bmi.s	Obj37_ChkDel
		move.b	($FFFFFE0F).w,d0
		add.b	d7,d0
		andi.b	#3,d0
		bne.s	Obj37_ChkDel
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		blt.s	Obj37_Bounce2		; if yes, branch
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj37_ChkDel
		add.w	d1,$C(a0)

Obj37_Bounce2:
		move.w	$12(a0),d0
		asr.w	#2,d0
		sub.w	d0,$12(a0)
		neg.w	$12(a0)

Obj37_ChkDel:				; XREF: Obj37_Bounce
		tst.b	($FFFFFEC6).w
		beq.s	Obj37_JMPDelete
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		bcs.s	Obj37_JMPDelete	; if yes, branch
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has object moved below level boundary?
		bcs.s	Obj37_JMPDelete	; if yes, branch
		btst	#5,($FFFFFE2C).w
		beq.s	Obj37_skip
		tst.b	1(a0)
		bpl.s	Obj37_skip
		lea ($FFFFB000).w,a1
		move.w	8(a1),d0	; load Sonic's x-axis position
		sub.w	8(a0),d0
		bpl.s	Obj37_a1
		neg.w	d0
		bra.w 	Obj37_a1
		
Obj37_JMPDelete:
		bsr.w 	Obj37_Delete

	Obj37_a1:
		cmpi.w	#$A0,d0
		bhi.s	Obj37_skip
		
		move.w	$C(a1),d0	; load Sonic's y-axis position
		sub.w	$C(a0),d0
		bpl.s	Obj37_a2
		neg.w	d0
		
	Obj37_a2:
		cmpi.w	#$A0,d0
		bhi.s	Obj37_skip
		
		move.b	#$A,$24(a0)
		move.b	#$25,0(a0)
		
	Obj37_skip:
		move.b	($FFFFFEC6).w,d0
		btst	#0,d0
		beq.w	DisplaySprite
		cmpi.b	#$80,d0
		bhi.w	DisplaySprite
		rts
; ===========================================================================

Obj37_Collect:				; XREF: Obj37_Index
		addq.b	#2,$24(a0)
		move.b	#0,$20(a0)
		move.w	#$80,$18(a0)
		bsr.w	CollectRing

Obj37_Sparkle:				; XREF: Obj37_Index
		lea	(Ani_obj25).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj37_Delete:				; XREF: Obj37_Index
		bra.w	DeleteObject

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 91 - Attracted ring (ported from Sonic and Knuckles)
; ----------------------------------------------------------------------------
Obj91:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj_91_subtbl(pc,d0.w),d1
	jmp	Obj_91_subtbl(pc,d1.w)
; ===========================================================================
Obj_91_subtbl:
	dc.w	Obj_91_sub_0-Obj_91_subtbl; 0
	dc.w	Obj_91_sub_2-Obj_91_subtbl; 2
	dc.w	Obj_91_sub_4-Obj_91_subtbl; 4
	dc.w	Obj_91_sub_6-Obj_91_subtbl; 6
	dc.w	Obj_91_sub_8-Obj_91_subtbl; 8
; ===========================================================================

Obj_91_sub_0:
	addq.b	#2,$24(a0)
	move.w	8(a0),$32(a0)
	move.l	#Map_obj25,4(a0)
	make_art_tile	ArtTile_Rings,0,1
	move.b	#4,1(a0)
	move.w	#$100,$18(a0)
	move.b	#$47,$20(a0)
	move.b	#8,$14(a0)

Obj_91_sub_2:
	bsr.w	Obj_91_Move
	movea.w	$34(a0),a1
	btst	#5,($FFFFFE2C).w	; Change the #0 to #5 if you've ported the actual lightning shield
	bne.s	Obj_91_sub_3
	move.b	#$37,(a0)	; Load object 37 (scattered rings)
	move.b	#2,$24(a0)
	move.b	#-1,($FFFFFEC6).w

Obj_91_sub_3:
	move.w	$32(a0),d0
	bra.w	DisplaySprite
; ===========================================================================

Obj_91_sub_4:
	addq.b	#2,$24(a0)
	move.b	#0,$20(a0)
	move.w	#$80,$18(a0)
	subq.w	#1,($FFFFF712).w
	bsr.w	CollectRing

Obj_91_sub_6:
	lea	(Ani_obj25).l,a1
	bsr.w	AnimateSprite
	bra.w	DisplaySprite
; ===========================================================================

Obj_91_sub_8:
	bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj_91_Move:
	movea.w	$34(a0),a1
	move.w	#$30,d1
	move.w	8(a1),d0
	cmp.w	8(a0),d0
	bcc.s	loc2_1A954
	neg.w	d1
	tst.w	$10(a0)
	bmi.s	loc2_1A95E
	add.w	d1,d1
	add.w	d1,d1
	bra.s	loc2_1A95E
; ===========================================================================

loc2_1A954:
	tst.w	$10(a0)
	bpl.s	loc2_1A95E
	add.w	d1,d1
	add.w	d1,d1

loc2_1A95E:
	add.w	d1,$10(a0)
	move.w	#$30,d1
	move.w	$C(a1),d0
	cmp.w	$C(a0),d0
	bcc.s	loc2_1A97E
	neg.w	d1
	tst.w	$12(a0)
	bmi.s	loc2_1A988
	add.w	d1,d1
	add.w	d1,d1
	bra.s	loc2_1A988
; ===========================================================================

loc2_1A97E:
	tst.w	$12(a0)
	bpl.s	loc2_1A988
	add.w	d1,d1
	add.w	d1,d1

loc2_1A988:
	add.w	d1,$12(a0)
	jmp	(SpeedtoPos).l
; ===========================================================================
Ani_obj25:
	include "_anim\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25:
	include "_maps\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25RM:
	include "_maps\obj25rm.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 26 - monitors
; ---------------------------------------------------------------------------

Obj26:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj26_Index(pc,d0.w),d1
		jmp	Obj26_Index(pc,d1.w)
; ===========================================================================
Obj26_Index:	dc.w Obj26_Main-Obj26_Index
		dc.w Obj26_Solid-Obj26_Index
		dc.w Obj26_BreakOpen-Obj26_Index
		dc.w Obj26_Animate-Obj26_Index
		dc.w Obj26_Display-Obj26_Index
; ===========================================================================

Obj26_Main:				; XREF: Obj26_Index
		addq.b	#2,$24(a0)
		move.b	#$E,$16(a0)
		move.b	#$E,$17(a0)
		move.l	#Map_obj26,4(a0)
		make_art_tile	ArtTile_Monitor,0,1
		move.b	#4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#$F,$14(a0)
		move.w  $1E(a0),d0	; get address in respawn table
		movea.w d0,a2   ; load address into a2
		btst	#0,(a2)	; has monitor been broken?
		beq.s	Obj26_NotBroken	; if not, branch
		move.b	#8,$24(a0)	; run "Obj26_Display" routine
		move.b	#9,$1A(a0)	; use broken monitor frame
		rts	
; ===========================================================================

Obj26_NotBroken:			; XREF: Obj26_Main
		move.b	#$46,$20(a0)
		move.b	#0,$1C(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj26_Solid
		move.b	#$2E,0(a1)	; load monitor contents	object
		move.w	a1,$30(a0)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	$28(a0),$28(a1)

Obj26_Solid:				; XREF: Obj26_Index
		move.b	$25(a0),d0	; is monitor set to fall?
		beq.s	SolidObject_Monitor
		; only when secondary routine isn't 0
		; make monitor fall
		bsr.w	ObjectFall
		jsr	(ObjHitFloor).l
		tst.w	d1			; is monitor in the ground?
		bpl.w	SolidObject_Monitor	; if not, branch
		add.w	d1,$C(a0)		; move monitor out of the ground
		clr.w	$12(a0)
		clr.b	$25(a0)	; stop monitor from falling
; loc_1271C:
SolidObject_Monitor:
		move.w	#$1A,d1	; monitor's width
		move.w	#$F,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		lea	($FFFFB000).w,a1 ; a1=character
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_Monitor_Sonic
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1 ; a1=character
		moveq	#4,d6
		bsr.w	SolidObject_Monitor_Tails
		bra.w	Obj26_Animate

Obj26_Animate:				; XREF: Obj26_Index
		subq.b	#1,$34(a0)
		bpl.s	Obj26_Animate2
		jsr	RandomNumber
		andi.b	#$7F,d0
		addi.b	#$80,d0
		move.b	d0,$34(a0)
		jsr	RandomNumber
		andi.b	#3,d0
		addq.b	#1,d0
		move.b	d0,$1C(a0)

Obj26_Animate2:
		lea	(Ani_obj26).l,a1
		bsr.w	AnimateSprite

Obj26_Display:
		bra.w	MarkObjGone

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
; sub_12756:
SolidObject_Monitor_Sonic:
	btst	d6,$22(a0)			; is Sonic standing on the monitor?
	bne.s	Obj26_ChkOverEdge		; if yes, branch
	cmpi.b	#2,$1C(a1)		; is Sonic spinning?
	bne.w	SolidObject_cont		; if not, branch
	rts
; End of function SolidObject_Monitor_Sonic


; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
; sub_12768:
SolidObject_Monitor_Tails:
	btst	d6,$22(a0)			; is Tails standing on the monitor?
	bne.s	Obj26_ChkOverEdge		; if yes, branch
	tst.w	($FFFFF672).w		; is it two player mode?
	beq.w	SolidObject_cont		; if not, branch
	; in one player mode monitors always behave as solid for Tails
	cmpi.b	#2,$1C(a1)	; is Tails spinning?
	bne.w	SolidObject_cont		; if not, branch
	rts
; End of function SolidObject_Monitor_Tails

; ---------------------------------------------------------------------------
; Checks if the player has walked over the edge of the monitor.
; ---------------------------------------------------------------------------
;loc_12782:
Obj26_ChkOverEdge:
	move.w	d1,d2
	add.w	d2,d2
	btst	#1,$22(a1)	; is the character in the air?
	bne.s	.jump		; if yes, branch
	; check, if character is standing on
	move.w	8(a1),d0
	sub.w	8(a0),d0
	add.w	d1,d0
	bmi.s	.jump	; branch, if character is behind the left edge of the monitor
	cmp.w	d2,d0
	blo.s	Obj26_CharStandOn	; branch, if character is not beyond the right edge of the monitor
.jump:
	; if the character isn't standing on the monitor
	bclr	#3,$22(a1)	; clear 'on object' bit
	bset	#1,$22(a1)	; set 'in air' bit
	bclr	d6,$22(a0)	; clear 'standing on' bit for the current character
	moveq	#0,d4
	rts
; ---------------------------------------------------------------------------
;loc_127B2:
Obj26_CharStandOn:
	move.w	d4,d2
	bsr.w	MvSonicOnPtfm
	moveq	#0,d4
	rts
; ===========================================================================

Obj26_BreakOpen:			; XREF: Obj26_Index
		addq.b	#4,$24(a0)
		movea.w	$30(a0),a1
		addq.b	#2,$24(a1)
		move.b	#0,$20(a0)
		bsr.w	SingleObjLoad
		bne.s	Obj26_SetBroken
		move.b	#$27,0(a1)	; load explosion object
		addq.b	#2,$24(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Obj26_SetBroken:
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		move.b	#9,$1A(a0)	; set monitor type to broken
		bra.w	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2E - contents of monitors
; ---------------------------------------------------------------------------

Obj2E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj2E_Index(pc,d0.w),d1
		jsr	Obj2E_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj2E_Index:	dc.w Obj2E_Main-Obj2E_Index
		dc.w Obj2E_Display-Obj2E_Index
		dc.w Obj2E_Move-Obj2E_Index
		dc.w Obj2E_Delete-Obj2E_Index
; ===========================================================================

Obj2E_Main:				; XREF: Obj2E_Index
		addq.b	#2,$24(a0)
		make_art_tile	ArtTile_Monitor,0,1
		move.b	#$4,1(a0)
		move.w	#$180,$18(a0)
		move.b	#8,$14(a0)
		move.w	#-$300,$12(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		move.b	d0,$1C(a0)
		addi.b	#$A,d0
		move.b	d0,$1A(a0)
		move.l	#Map_obj26,4(a0)

Obj2E_Display:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts

Obj2E_Move:				; XREF: Obj2E_Index
		tst.w	$12(a0)		; is object moving?
		bpl.w	Obj2E_ChkRings; if not, branch
		bsr.w	SpeedToPos
		addi.w	#$18,$12(a0)	; reduce object	speed
		lea	(Ani_obj2E).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj2E_ChkRings:
		addq.b	#2,$24(a0)
		move.w	#29,$1E(a0)
		move.b	$28(a0),d0
		tst.b	d0		; does monitor contain 10 rings?
		bne.s	Obj2E_ChkShoes
		addi.w	#$A,($FFFFFE20).w ; add	10 rings to the	number of rings	you have
		ori.b	#1,($FFFFFE1D).w ; update the ring counter
		sfx		sfx_RingRight
		rts
; ===========================================================================

Obj2E_ChkShoes:
		cmpi.b	#1,d0		; does monitor contain speed shoes?
		bne.s	Obj2E_ChkInvinc
		move.b	#1,($FFFFFE2E).w ; speed up the	BG music
		move.w	#$4B0,($FFFFB034).w ; time limit for the power-up
		move.w	#$C00,($FFFFF760).w ; change Sonic"s top speed
		move.w	#$18,($FFFFF762).w
		move.w	#$80,($FFFFF764).w
		command	mus_ShoesOn	; Speed	up the music
		rts
; ===========================================================================

Obj2E_ChkInvinc:
		cmpi.b	#2,d0		; does monitor contain invincibility?
		bne.s	Obj2E_ChkShield
		bset	#1,($FFFFFE2C).w
		move.w  #$3B0,($FFFFB032).w	; Set Invisibility timer to 4B0
		move.b	#$4A,($FFFFB200).w ; load stars	object ($3801)
		move.b	#1,($FFFFB21C).w
		move.b	#$4A,($FFFFB240).w ; load stars	object ($3802)
		move.b	#2,($FFFFB25C).w
		move.b	#$4A,($FFFFB280).w ; load stars	object ($3803)
		move.b	#3,($FFFFB29C).w
		move.b	#$4A,($FFFFB2C0).w ; load stars	object ($3804)
		move.b	#4,($FFFFB2DC).w
		tst.b	($FFFFF7AA).w		; is boss mode on?
		bne.s   DontPlayMusic		; If so, don't play music
		cmpi.w  #$C,($FFFFFE14).w	; Check if Sonic has air left
		bls.s   DontPlayMusic		; If so, don't play music
		music	mus_Invincible		; Load Invincibility music

DontPlayMusic:
		rts
; ===========================================================================

Obj2E_ChkShield:
		cmpi.b	#3,d0		; does monitor contain a shield?
		bne.s	Obj2E_ChkFlame
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#5,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		sfx		sfx_ElectricShield	; play shield sound
		rts
; ===========================================================================

Obj2E_ChkFlame:	
		cmpi.b	#4,d0		; does monitor contain a flame shield?
		bne.w	Obj2E_ChkBubble
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#4,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		sfx		sfx_FireShield	; play shield sound
		rts
; ===========================================================================

Obj2E_ChkBubble:	
		cmpi.b	#5,d0		; does monitor contain a shield?
		bne.w	Obj2E_ChkEnd
		andi.b	#$8E,($FFFFFE2C).w
		bset	#0,($FFFFFE2C).w
		bset	#6,($FFFFFE2C).w
		move.b	#$38,($FFFFB180).w ; load shield object	($38)
		move.b	#0,($FFFFB1A4).w
		sfx		sfx_BubbleShield	; play shield sound

Obj2E_ChkEnd:
		rts			; 'S' and goggles monitors do nothing
; ===========================================================================

Obj2E_Delete:				; XREF: Obj2E_Index
		bra.w	DeleteObject

; ===========================================================================
Ani_obj26:
	include "_anim\obj26.asm"

Ani_obj2E:
	include "_anim\obj2E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitors
; ---------------------------------------------------------------------------
Map_obj26:
	include "_maps\obj26.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitor contents
; ---------------------------------------------------------------------------
Map_obj2E:
	include "_maps\obj2E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0E - Sonic on the title screen
; ---------------------------------------------------------------------------

Obj0E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0E_Index(pc,d0.w),d1
		jmp	Obj0E_Index(pc,d1.w)
; ===========================================================================
Obj0E_Index:	dc.w Obj0E_Main-Obj0E_Index
		dc.w Obj0E_Move-Obj0E_Index
		dc.w Obj0E_WaitStart-Obj0E_Index
		dc.w Obj0E_Move2-Obj0E_Index
		dc.w Obj0E_Display-Obj0E_Index
		dc.w Obj0E_Move3-Obj0E_Index
		dc.w Obj0E_Display-Obj0E_Index
; ===========================================================================

Obj0E_Main:				; XREF: Obj0E_Index
		addq.b	#2,$24(a0)
		move.w	#$E6,8(a0)
		move.w	#8,$A(a0)
		move.l	#Map_obj0E,4(a0)
		move.w	#$8300,2(a0)
		move.w	#$80,$18(a0)
		move.w	#$500,$12(a0)
		lea	(Obj0E_Positions).l,a2
		move.w	#3,d1
		move.b	#0,d2
		movea.l	a0,a1
		bra.s	Obj0E_MakeItem

Obj0E_Loop:
		jsr	SingleObjLoad
		bne.s	loc2_150FE
		move.b	#$E,0(a1)
		move.b	#2,$24(a1)
		move.w	(a2)+,8(a1)
		move.w	(a2)+,$A(a1)
		move.w	#$80,$18(a1)
		move.w	#$500,$12(a1)
		addq.b	#1,d2
		move.b	d2,$1A(a1)

Obj0E_MakeItem:				; XREF: Obj66_Main
		move.l	#Map_obj0E,4(a1)
		move.w	#$8300,2(a1)

loc2_150FE:
		dbf	d1,Obj0E_Loop			; XREF: Obj0E_Index

loc2_15100:
		bra.w	DisplaySprite

Obj0E_Positions:	dc.w $176,	8
		dc.w $D2,	$38
		dc.w $152,	$38
; ===========================================================================


Obj0E_Move3:
		subi.w	#$10,$12(a0)

Obj0E_Move:				; XREF: Obj0E_Index
		subi.w	#$20,$12(a0)

Obj0E_Move2:
		addi.w	#$10,$12(a0)
		move.w	$10(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		add.l	d0,8(a0)	; add to y-axis	position
		move.w	$12(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		add.l	d0,$A(a0)	; add to y-axis	position
		tst.w	$12(a0)
		bne.s	Obj0E_Display
		addq.b	#2,$24(a0)

Obj0E_Display:
		bra.w	DisplaySprite

Obj0E_WaitStart:
		cmpi.b	#$F,($FFFFB080).w
		bne.w	DisplaySprite	; if not, branch
		cmpi.b	#2,$1A(a0)
		bge.s	Obj0E_WaitStart2
		addq.b	#2,$24(a0)
		move.w	#-$200,$12(a0)
		bra.w	DisplaySprite

Obj0E_WaitStart2:
		addq.b	#6,$24(a0)
		move.w	#$440,$12(a0)
		bra.w	DisplaySprite
; ===========================================================================

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0F - Main Menu
; ----------------------------------------------------------------------------

Obj0F:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_13612(pc,d0.w),d1
		jmp	off_13612(pc,d1.w)
; ===========================================================================
off_13612:	dc.w loc_13616-off_13612; 0 ; DATA XREF: ROM:00013612o
					; ROM:00013614o
		dc.w Obj0F_WaitStart-off_13612; 1
		dc.w Obj0F_Move-off_13612
; ===========================================================================

loc_13616:				; DATA XREF: ROM:00013612o
		cmpi.b	#8,($FFFFB064)
		blt.w	locret_13684
		addq.b	#2,$24(a0)
		move.b	#$D,d1
		move.w	#$120,d2
		moveq	#0,d3
		moveq	#0,d4

Obj0F_Loop:
		jsr	SingleObjLoad
		bne.s	Obj0F_WaitStart
		move.b	#$F,0(a1)	; load
		move.l	#Map_Obj0F,4(a1)
		move.w	#$8480,2(a1)
		move.b	#4,$24(a1)
		cmpi.b	#4,d3
		bge.s	Obj0F_LoopOp
		move.w	d2,$32(a1)
		move.w	d2,$30(a1)
		add.w	#$100,d2

Obj0F_Loop3:
		move.w	#$DC,$A(a1)
		move.b	d3,$1A(a1)
		addq.b	#1,d3
		dbf	d1,Obj0F_Loop	; repeat

Obj0F_LoopOp:
		move.w	#320/2+$180,$32(a1)
		move.w	#320/2+$180,$30(a1)
		move.b	d3,d4
		subq.b	#2,d4
		move.b	d4,$34(a1)
		lsr.w	#1,d4
		lsl.w	#4,d4
		addi.w	#$DC,d4
		move.w	d4,$A(a1)
		move.b	d3,$1A(a1)
		addq.b	#1,d3
		dbf	d1,Obj0F_Loop	; repeat

Obj0F_WaitStart:
		move.w	($FFFFF622).w,d0
		andi.w	#$FF,d0
		tst.w	d0
		beq.s	loc_13644
		tst.b	$30(a0)
		beq.s	Obj0F_WaitStart2
		addi.w	#$10,($FFFFF622).w
		rts

Obj0F_WaitStart2:
		subi.w	#$10,($FFFFF622).w
		rts

loc_13644:				; DATA XREF: ROM:00013612o
		tst.b	($FFFFF62D).w
		bne.s	Obj0F_CheckOpt
		moveq	#0,d2
		move.b	($FFFFF62B).w,d2
		move.b	($FFFFF605).w,d0
		btst	#2,d0
		beq.s	loc_13660
		addi.w	#$10,($FFFFF622).w
		bset	#0,$30(a0)
		subq.b	#1,d2

loc_13660:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d0
		beq.s	loc_13671
		subi.w	#$10,($FFFFF622).w
		bclr	#0,$30(a0)
		addq.b	#1,d2

loc_13671:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		andi.b	#3,d2
		move.b	d2,($FFFFF62B).w
		andi.b	#$C,d0
		beq.s	Obj0F_CheckOpt
		sfx		sfx_Switch

Obj0F_CheckOpt:
		cmpi.b	#1,($FFFFF62B).w
		bne.w	locret_13686
		moveq	#0,d2
		move.b	($FFFFF62D).w,d2
		move.b	($FFFFF605).w,d0
		btst	#0,d0
		beq.s	loc_136602
		subq.b	#2,d2
		tst.b	d2
		bge.s	.checksame
		move.b	#$A,d2
		bra.s	loc_136602

	.checksame:
		cmpi.b	#2,d2
		bne.s	loc_136602
		move.b	(Current_Character).w,d1
		move.b	#0,$31(a0)
		cmp.b	(Current_Partner).w,d1
		beq.s	loc_136602
		move.b	#1,$31(a0)

loc_136602:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#1,d0
		beq.s	loc_136712
		addq.b	#2,d2
		cmpi.b	#$C,d2
		blt.s	loc_136712
		moveq	#0,d2

loc_136712:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,($FFFFF62D).w
		andi.b	#3,d0
		beq.s	Obj0F_OptSet
		sfx		sfx_Switch

Obj0F_OptSet:
		moveq	#0,d0
		move.b	($FFFFF62D).w,d0
		move.w	Obj0F_OptList(pc,d0.w),d1
		jmp	Obj0F_OptList(pc,d1.w)
; ===========================================================================
Obj0F_OptList:	dc.w locret_13684-Obj0F_OptList
		dc.w Obj0F_Char-Obj0F_OptList
		dc.w Obj0F_Part-Obj0F_OptList
		dc.w Obj0F_Act-Obj0F_OptList
		dc.w Obj0F_Ext-Obj0F_OptList
		dc.w Obj0F_Jump-Obj0F_OptList
; ===========================================================================

Obj0F_Char:
		moveq	#0,d2
		moveq	#0,d3
		move.b	(Current_Character).w,d2
		cmp.b	(Current_Partner).w,d2
		bne.s	Obj0F_Char2
		tst.b	$31(a0)
		bne.s	Obj0F_Char2
		bset	#0,d3

Obj0F_Char2:
		move.b	($FFFFF605).w,d0
		btst	#2,d0
		beq.s	loc_136603
		subq.b	#1,d2
		tst.b	d2
		bge.s	loc_136603
		move.b	#4,d2

loc_136603:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d0
		beq.s	loc_136713
		addq.b	#1,d2
		cmpi.b	#5,d2
		blt.s	loc_136713
		moveq	#0,d2

loc_136713:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,(Current_Character).w
		andi.b	#$C,d0
		beq.s	locret_13686
		tst.b	d3
		beq.s	loc_136723
		move.b	d2,(Current_Partner).w

loc_136723:
		sfx		sfx_Switch
		rts

Obj0F_Part:
		moveq	#0,d2
		move.b	(Current_Partner).w,d2
		move.b	($FFFFF605).w,d0
		btst	#2,d0
		beq.s	loc_136604
		subq.b	#1,d2
		tst.b	d2
		bge.s	loc_136604
		move.b	#4,d2

loc_136604:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d0
		beq.s	loc_136714
		addq.b	#1,d2
		cmpi.b	#5,d2
		blt.s	loc_136714
		moveq	#0,d2

loc_136714:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,(Current_Partner).w
		andi.b	#$C,d0
		beq.s	locret_13686
		sfx		sfx_Switch

locret_13686:				; CODE XREF: ROM:0001367Cj
		rts

Obj0F_Act:
		moveq	#0,d2
		move.b	($FFFFF605).w,d1
		move.b	($FFFFFFEE).w,d2
		cmpi.b	#$10,d2
		beq.s	Obj0F_ActB
		cmpi.b	#$20,d2
		beq.s	Obj0F_ActC
		btst	#3,d1
		beq.s	loc_136715
		move.b	#$10,d2
		sfx		sfx_Switch
		bra.s	loc_136715

Obj0F_ActB:
		btst	#2,d1
		beq.s	loc_136605
		move.b	#$40,d2
		sfx		sfx_Switch

loc_136605:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d1
		beq.s	loc_136715
		move.b	#$20,d2
		sfx		sfx_Switch
		bra.s	loc_136715

Obj0F_ActC:
		btst	#2,d1
		beq.s	loc_136715
		move.b	#$10,d2
		sfx		sfx_Switch


loc_136715:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,($FFFFFFEE).w
		rts

Obj0F_Ext:
		moveq	#0,d2
		move.b	($FFFFFFEF).w,d2
		move.b	($FFFFF605).w,d1
		btst	#2,d1
		beq.s	loc_136606
		tst.b	d2
		beq.s	loc_136606
		subq.b	#1,d2
		sfx		sfx_Switch

loc_136606:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d1
		beq.s	loc_136716
		cmpi.b	#2,d2
		beq.s	loc_136716
		addq.b	#1,d2
		sfx		sfx_Switch

loc_136716:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,($FFFFFFEF).w
		rts

Obj0F_Jump:
		moveq	#0,d2
		move.b	($FFFFFFF6).w,d2
		move.b	($FFFFF605).w,d1
		btst	#2,d1
		beq.s	loc_136607
		cmpi.b	#sfx_FMJump,d2
		beq.s	loc_136607
		move.b	#sfx_FMJump,d2
		sfx		sfx_FMJump

loc_136607:				; CODE XREF: ROM:00013656j
					; ROM:0001365Aj
		btst	#3,d1
		beq.s	loc_136717
		cmpi.b	#sfx_Jump,d2
		beq.s	loc_136717
		move.b	#sfx_Jump,d2
		sfx		sfx_Jump

loc_136717:				; CODE XREF: ROM:00013664j
					; ROM:0001366Cj
		move.b	d2,($FFFFFFF6).w

locret_13684:				; CODE XREF: ROM:0001367Cj
		rts

Obj0F_Move:
		move.w	$30(a0),d0
		add.w	($FFFFF622),d0
		andi.w	#$3FF,d0
		move.w	d0,$32(a0)
		btst	#0,$34(a0)
		bne.s	Obj0F_DisOpt
		bset	#5,2(a0)
		bset	#6,2(a0)
		cmpi.w	#$120,d0
		bne.s	Obj0F_Display
		move.b	($FFFFF62D).w,d0
		cmp.b	$34(a0),d0
		bne.s	Obj0F_Display
		bclr	#5,2(a0)
		bclr	#6,2(a0)

Obj0F_Display:
		move.w	$32(a0),d0
		sub.w	#$28,d0
		btst	#9,d0
		bne.w	locret_13684
		move.w	$32(a0),8(a0)
		bra.w	DisplaySprite

Obj0F_DisOpt:
		moveq	#0,d0
		move.b	$34(a0),d0
		subq.b	#1,d0
		move.w	Obj0F_DisList(pc,d0.w),d1
		jsr	Obj0F_DisList(pc,d1.w)
		bra.s	Obj0F_Display
; ===========================================================================
Obj0F_DisList:	dc.w locret_13684-Obj0F_DisList
		dc.w Obj0F_DisChar-Obj0F_DisList
		dc.w Obj0F_DisPart-Obj0F_DisList
		dc.w Obj0F_DisAct-Obj0F_DisList
		dc.w Obj0F_DisExt-Obj0F_DisList
		dc.w Obj0F_DisJump-Obj0F_DisList
; ===========================================================================

Obj0F_DisChar:
		move.b	(Current_Character).w,d0
		move.b	CharTable(pc,d0.w),$1A(a0)
		rts

CharTable:
		dc.b	5, $E, $F, $10, $11, 0

Obj0F_DisPart:
		move.b	(Current_Partner).w,d0
		cmp.b	(Current_Character).w,d0
		beq.s	Obj0F_DisPart2
		move.b	CharTable(pc,d0.w),$1A(a0)
		rts

Obj0F_DisPart2:
		move.b	#7,$1A(a0)
		rts

Obj0F_DisAct:
		move.b	#$12,$1A(a0)
		cmpi.b	#$10,($FFFFFFEE).w
		beq.s	Obj0F_DisActDone
		move.b	#$13,$1A(a0)
		cmpi.b	#$20,($FFFFFFEE).w
		beq.s	Obj0F_DisActDone
		move.b	#9,$1A(a0)

Obj0F_DisActDone:
		rts

Obj0F_DisExt:
		move.b	($FFFFFFEF).w,d0
		move.b	ExtTable(pc,d0.w),$1A(a0)
		rts

ExtTable:
		dc.b	$B, $14, $15, 0

Obj0F_DisJump:
		move.b	#$D,$1A(a0)
		cmpi.b	#sfx_FMJump,($FFFFFFF6).w
		beq.s	Obj0F_DisJumpDone
		move.b	#$16,$1A(a0)

Obj0F_DisJumpDone:
		rts

; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj0F:
	include "_maps\obj0F.asm"

; ---------------------------------------------------------------------------
; Object 8F - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------

Obj8F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8F_Index(pc,d0.w),d1
		jsr	Obj8F_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj8F_Index:	dc.w Obj8F_Main-Obj8F_Index
		dc.w Obj8F_PrsStart-Obj8F_Index
		dc.w locret_A6F8-Obj8F_Index
		dc.w Obj8F_Delete-Obj8F_Index
; ===========================================================================

Obj8F_Main:				; XREF: Obj8F_Index
		addq.b	#2,$24(a0)
		move.w	#$D8,8(a0)
		move.w	#$130,$A(a0)
		move.l	#Map_Obj8F,4(a0)
		move.w	#$8200,2(a0)
		tst.b	$1A(a0)	; is object "PRESS START"?
		beq.s	Obj8F_PrsStart	; if yes, branch
		addq.b	#2,$24(a0)
		move.w	#$8510,2(a0)	; "TM" specific	code
		move.w	#$1AC,8(a0)
		move.w	#$AC,$A(a0)

locret_A6F8:				; XREF: Obj8F_Index
		rts	
; ===========================================================================

Obj8F_PrsStart:				; XREF: Obj8F_Index
		cmpi.b	#4,($FFFFB064)
		blt.s	locret_A6F8
		andi.b	#$80,($FFFFF605).w ; check if Start is pressed
		bne.w	Obj8F_PrsStart2	; if not, branch

Obj8F_Display:
		lea	(Ani_Obj8F).l,a1
		bra.w	AnimateSprite
; ===========================================================================
Obj8F_PrsStart2:
		addq.b	#4,$24(a0)
		addq.b	#1,$1C(a0)
		move.b	#$20,$30(a0)
		sfx		sfx_LightTunnel

Obj8F_Delete:				; XREF: Obj8F_Index
		subq.b	#1,$30(a0)
		bpl.s	Obj8F_Display
		jsr	DeleteObject	; clear object RAM to make room for the "Press Start Button" object
		move.b	#$F,($FFFFB080).w
		rts

Ani_Obj8F:
	include "_anim\obj8F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj8F:
	include "_maps\obj8F.asm"

; ---------------------------------------------------------------------------
; Pause Menu Object
; ---------------------------------------------------------------------------

ObjMenu:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$C(a0),d0
		move.w	ObjMenu_Table(pc,d0.w),d1
		jmp	ObjMenu_Table(pc,d1.w)
; ===========================================================================
ObjMenu_Table:	dc.w ObjMenu_Init-ObjMenu_Table; 0
		dc.w ObjMenu_Main-ObjMenu_Table; 1
; ===========================================================================

ObjMenu_Init:
		addq.b	#2,$C(a0)
		make_art_tile	ArtTile_Explode,0,1
		move.l	#Map_objmenu,4(a0)
		move.w	#$90,8(a0)
		move.w	#$E0,$A(a0)
		move.w	#0,$18(a0)
		adda.w	#$20,a0
		move.b	#-1,(a0)
		move.l	#Map_objmusic,4(a0)
		move.w	#$B0,8(a0)
		move.w	#$D8,$A(a0)
		move.w	#0,$18(a0)
		move.b	#0,$1A(a0)
		move.b	#-1,$E(a0)
		move.b	#%11111111,$D(a0)
		move.b	#1,$F(a0)
		suba.w	#$20,a0
	;	move.b	#0,($FFFFF746).w

ObjMenu_Main:
		move.b	($FFFFF746).w,d2
		btst	#0,($FFFFF605).w
		beq.s	.notup
		tst.b	d2
		ble.s	.notup
		subq.b	#1,d2

	.notup:
		btst	#1,($FFFFF605).w
		beq.s	.notdown
		cmp.b	#4,d2
		bge.s	.notdown
		addq.b	#1,d2

	.notdown:
		move.b	d2,($FFFFF746).w

	.display:
		move.b	d2,$1A(a0)
		bsr.w	DisplaySprite

ObjMenu_Music:
		adda.w	#$20,a0
		make_art_tile	ArtTile_Explode,3,1
		cmpi.b	#1,($FFFFF746).w
		bne.w	.display
		make_art_tile	(ArtTile_Explode+$28),0,1
		move.b	($FFFFF605).w,d0
		or.b	($FFFFF607).w,d0
		andi.b	#$80,d0
		bne.w	.display
		btst	#2,($FFFFF605).w
		beq.s	.notleft
		tst.b	$F(a0)
		bne.s	.leftunlocked
		move.b	$E(a0),d0

	.leftloop:
		subq.b	#1,d0
		tst.b	d0
		blt.s	.leftreset
		btst	d0,$D(a0)
		beq.s	.leftloop
		move.b	.OmakeTracks(pc,d0.w),$1A(a0)
		move.b	d0,$E(a0)
		bra.s	.notleft

	.leftreset:	
		move.b	#0,$1A(a0)
		move.b	#-1,$E(a0)
		bra.s	.notright

	.OmakeTracks:	dc.b $1F, $20, $21, $22, $23, $24, $25, $26

	.leftunlocked:
		tst.b	$1A(a0)
		ble.s	.notleft
		subq.b	#1,$1A(a0)
		bra.s	.notright

	.notleft:
		btst	#3,($FFFFF605).w
		beq.s	.display
		tst.b	$F(a0)
		bne.s	.rightunlocked
		move.b	$E(a0),d0

	.rightloop:
		addq.b	#1,d0
		cmpi.b	#7,d0
		bgt.s	.notright
		btst	d0,$D(a0)
		beq.s	.rightloop
		move.b	.OmakeTracks(pc,d0.w),$1A(a0)
		move.b	d0,$E(a0)
		bra.s	.notright

	.rightunlocked:
		cmpi.b	#$2C,$1A(a0)
		bgt.s	.display
		addq.b	#1,$1A(a0)

	.notright:
		move.b	$1A(a0),d0
		tst.b	d0
		beq.s	.default
		addi.b	#mus_Title-1,d0
		move.b	d0,mQueue+0.w	; play that sound!
		bra.w	DisplaySprite

	.default:
		move.b	#0,($FFFFF75D).w
		bsr.w	LoadMusic

	.display:
		bra.w	DisplaySprite

	.locret:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings
; ---------------------------------------------------------------------------
Map_objmenu:
	include "_maps\menu.asm"

Map_objmusic:
	include "_maps\music.asm"

; ---------------------------------------------------------------------------
; Subroutine to	animate	a sprite using an animation script
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AnimateSprite:
		moveq	#0,d0
		move.b	$1C(a0),d0	; move animation number	to d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	Anim_Run	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

Anim_Run:
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	Anim_Wait	; if time remains, branch
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),$23(a0)	; load frame duration
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FA,d0					; MJ: is it a flag from FA to FF?
		bhs	Anim_End_FF				; MJ: if so, branch to flag routines
 
Anim_Next:
		move.b	d0,d1
		andi.b	#$1F,d0
		move.b	d0,$1A(a0)	; load sprite number
		move.b	$22(a0),d0
		rol.b	#3,d1
		eor.b	d0,d1
		andi.b	#3,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		addq.b	#1,$1B(a0)	; next frame number

Anim_Wait:
		rts	
; ===========================================================================

Anim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	Anim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	Anim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	Anim_End_FC	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

Anim_End_FC:
		addq.b	#1,d0		; is the end flag = $FC	?
		bne.s	Anim_End_FB	; if not, branch
		addq.b	#2,$24(a0)	; jump to next routine

Anim_End_FB:
		addq.b	#1,d0		; is the end flag = $FB	?
		bne.s	Anim_End_FA	; if not, branch
		move.b	#0,$1B(a0)	; reset	animation
		clr.b	$25(a0)		; reset	2nd routine counter

Anim_End_FA:
		addq.b	#1,d0		; is the end flag = $FA	?
		bne.s	Anim_End	; if not, branch
		addq.b	#2,$25(a0)	; jump to next routine

Anim_End:
		rts	
; End of function AnimateSprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic on the title screen
; ---------------------------------------------------------------------------
Map_obj0E:
	include "_maps\obj0E.asm"

Ani_obj0E:
	include "_anim\obj0E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 32 - switches (DDZ, CCZ, EEZ, FFZ)
; ---------------------------------------------------------------------------

Obj32:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj32_Index(pc,d0.w),d1
		jmp	Obj32_Index(pc,d1.w)
; ===========================================================================
Obj32_Index:	dc.w Obj32_Main-Obj32_Index
		dc.w Obj32_Pressed-Obj32_Index
; ===========================================================================

Obj32_Main:				; XREF: Obj32_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj32,4(a0)
		move.w	#$2424,2(a0)	; CCZ, EEZ and FFZ specific code
		move.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		addq.w	#3,$C(a0)

Obj32_Pressed:				; XREF: Obj32_Index
		tst.b	1(a0)
		bpl.s	Obj32_Display
		move.w	#$1B,d1
		move.w	#5,d2
		move.w	#4,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		bclr	#0,$1A(a0)	; use "unpressed" frame
		move.b	$28(a0),d0
		andi.w	#$F,d0
		lea	($FFFFF7E0).w,a3
		lea	(a3,d0.w),a3
		moveq	#0,d3
		btst	#6,$28(a0)
		beq.s	loc_BDB2
		moveq	#7,d3

loc_BDB2:
		tst.b	$28(a0)
		bpl.s	loc_BDBE
		bne.s	loc_BDC8

loc_BDBE:
		tst.b	$25(a0)
		bne.s	loc_BDC8
		bclr	d3,(a3)
		bra.s	loc_BDDE
; ===========================================================================

loc_BDC8:
		tst.b	(a3)
		bne.s	loc_BDD6
		sfx		sfx_Switch ;	play switch sound

loc_BDD6:
		bset	d3,(a3)
		bset	#0,$1A(a0)	; use "pressed"	frame

loc_BDDE:
		btst	#5,$28(a0)
		beq.s	Obj32_Display
		subq.b	#1,$23(a0)
		bpl.s	Obj32_Display
		move.b	#7,$23(a0)
		bchg	#1,$1A(a0)

Obj32_Display:
		bsr.w	DisplaySprite
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj32_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj32_Delete	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj32_Delete

Obj32_Done:
		rts	
; ===========================================================================

Obj32_Delete:
		bsr.w	DeleteObject
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - switches (DDZ, CCZ, EEZ, FFZ)
; ---------------------------------------------------------------------------
Map_obj32:
	include "_maps\obj32.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 34 - zone title cards
; ---------------------------------------------------------------------------

Obj34:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj34_Index(pc,d0.w),d1
		jmp	Obj34_Index(pc,d1.w)
; ===========================================================================
Obj34_Index:	dc.w Obj34_CheckSBZ3-Obj34_Index
		dc.w Obj34_ChkPos-Obj34_Index
		dc.w Obj34_Wait-Obj34_Index
		dc.w Obj34_Wait-Obj34_Index
; ===========================================================================

Obj34_CheckSBZ3:			; XREF: Obj34_Index
		movea.l	a0,a1
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		move.w	d0,d2

Obj34_LoadConfig:
		lea	(Obj34_ConData).l,a3
		lsl.w	#4,d0
		adda.w	d0,a3
		lea	(Obj34_ItemData).l,a2
		moveq	#3,d1

Obj34_Loop:
		move.b	#$34,0(a1)
		move.w	(a3),8(a1)	; load start x-position
		move.w	(a3)+,$32(a1)	; load finish x-position (same as start)
		move.w	(a3)+,$30(a1)	; load main x-position
		move.w	(a2)+,$A(a1)
		move.b	(a2)+,$24(a1)
		move.b	(a2)+,d0
		bne.s	Obj34_ActNumber
		move.b	d2,d0

Obj34_ActNumber:
		add.b	($FFFFFE11).w,d0

Obj34_MakeSprite:
		move.b	d0,$1A(a1)	; display frame	number d0
		move.l	#Map_obj34,4(a1)
		move.w	#(ArtTile_Animal1+$8000),2(a1)
		move.b	#$78,$14(a1)
		move.b	#0,1(a1)
		move.w	#0,$18(a1)
		move.w	#60,$34(a1)	; set time delay to 1 second
		lea	$40(a1),a1	; next object
		dbf	d1,Obj34_Loop	; repeat sequence another 3 times

Obj34_ChkPos:				; XREF: Obj34_Index
		moveq	#$10,d1		; set horizontal speed
		move.w	$30(a0),d0
		cmp.w	8(a0),d0	; has item reached the target position?
		beq.s	loc_C3C8	; if yes, branch
		bge.s	Obj34_Move
		neg.w	d1

Obj34_Move:
		add.w	d1,8(a0)	; change item's position

loc_C3C8:
		move.w	8(a0),d0
		bmi.s	locret_C3D8
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C3D8	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C3D8:
		rts	
; ===========================================================================

Obj34_Wait:				; XREF: Obj34_Index
		tst.w	$34(a0)		; is time remaining zero?
		beq.s	Obj34_ChkPos2	; if yes, branch
		subq.w	#1,$34(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

Obj34_ChkPos2:				; XREF: Obj34_Wait
		tst.b	1(a0)
		bpl.s	Obj34_ChangeArt
		moveq	#$20,d1
		move.w	$32(a0),d0
		cmp.w	8(a0),d0	; has item reached the finish position?
		beq.s	Obj34_ChangeArt	; if yes, branch
		bge.s	Obj34_Move2
		neg.w	d1

Obj34_Move2:
		add.w	d1,8(a0)	; change item's position
		move.w	8(a0),d0
		bmi.s	locret_C412
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C412	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

locret_C412:
		rts	
; ===========================================================================

Obj34_ChangeArt:			; XREF: Obj34_ChkPos2
		cmpi.b	#4,$24(a0)
		bne.s	Obj34_Delete
		lea	($C00000).l,a6
		move.l	#Art_MText,d1
		move.w	#(ArtTile_Explode*$20),d2
		move.w	#$64F,d3
		jsr	(QueueDMATransfer).l
		jsr	LoadAnimalPLC

Obj34_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj34_ItemData:	dc.w $D0	; y-axis position
		dc.b 2,	0	; routine number, frame	number (changes)
		dc.w $E4
		dc.b 2,	6
		dc.w $EA
		dc.b 2,	7
		dc.w $E0
		dc.b 2,	$A
; ---------------------------------------------------------------------------
; Title	card configuration data
; Format:
; 4 bytes per item (YYYY XXXX)
; 4 items per level (GREEN HILL, ZONE, ACT X, oval)
; ---------------------------------------------------------------------------
Obj34_ConData:	dc.w 0,	$120, $FEFC, $13C, $414, $154, $214, $154 ; AAZ
		dc.w 0,	$120, $FEF4, $134, $40C, $14C, $20C, $14C ; BBZ
		dc.w 0,	$120, $FEE0, $120, $3F8, $138, $1F8, $138 ; CCZ
		dc.w 0,	$120, $FEFC, $13C, $414, $154, $214, $154 ; DDZ
		dc.w 0,	$120, $FF04, $144, $41C, $15C, $21C, $15C ; EEZ
		dc.w 0,	$120, $FF04, $144, $41C, $15C, $21C, $15C ; FFZ
		dc.w 0,	$120, $FEE4, $124, $3EC, $3EC, $1EC, $12C ; GGZ
		dc.w 0,	$120, $FEE4, $124, $3EC, $3EC, $1EC, $12C ; AAZ
		dc.w 0,	$120, $FEE4, $124, $3EC, $3EC, $1EC, $12C ; SSZ

; ---------------------------------------------------------------------------
; Sprite mappings - "GAME OVER"	and "TIME OVER"
; ---------------------------------------------------------------------------
Map_obj39:
	include "_maps\obj39.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 36 - spikes
; ---------------------------------------------------------------------------

Obj36:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_1590E(pc,d0.w),d1
		jmp	off_1590E(pc,d1.w)
; ===========================================================================
off_1590E:	dc.w loc_15926-off_1590E; 0 ; DATA XREF: ROM:0001590Eo
					; ROM:00015910o ...
		dc.w loc_15996-off_1590E; 1
		dc.w loc_159E6-off_1590E; 2
		dc.w loc_15A42-off_1590E; 3
byte_15916:	dc.b $10		; 0 ; DATA XREF: ROM:00015952t
		dc.b $10		; 1
		dc.b $20		; 2
		dc.b $10		; 3
		dc.b $30		; 4
		dc.b $10		; 5
		dc.b $40		; 6
		dc.b $10		; 7
		dc.b $10		; 8
		dc.b $10		; 9
		dc.b $10		; 10
		dc.b $20		; 11
		dc.b $10		; 12
		dc.b $30		; 13
		dc.b $10		; 14
		dc.b $40		; 15
; ===========================================================================

loc_15926:				; DATA XREF: ROM:0001590Eo
		addq.b	#2,$24(a0)
		move.l	#Map_Obj36,4(a0)
		make_art_tile	ArtTile_Spikes,0,1
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),d0
		andi.b	#$F,$28(a0)
		andi.w	#$F0,d0	; 'รฐ'
		lea	(byte_15916,pc),a1
		lsr.w	#3,d0
		adda.w	d0,a1
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$16(a0)
		lsr.w	#1,d0
		move.b	d0,$1A(a0)
		cmpi.b	#4,d0
		bcs.s	loc_15978
		addq.b	#2,$24(a0)

loc_15978:				; CODE XREF: ROM:0001596Cj
		btst	#1,$22(a0)
		beq.s	loc_15986
		move.b	#6,$24(a0)

loc_15986:				; CODE XREF: ROM:0001597Ej
		move.w	8(a0),$30(a0)
		move.w	$C(a0),$32(a0)
		rts
; ===========================================================================

loc_15996:				; DATA XREF: ROM:0001590Eo
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		move.b	$22(a0),d6
		andi.b	#$18,d6
		beq.s	loc_159DE
		move.b	d6,d0
		andi.b	#8,d0
		beq.s	loc_159DE
		lea	($FFFFB000).w,a1
		bsr.w	sub_15A90

loc_159DE:				; CODE XREF: ROM:000159BEj
					; ROM:000159D4j
		move.w	$30(a0),d0
		bra.w	MarkObjGone
; ===========================================================================

loc_159E6:				; DATA XREF: ROM:0001590Eo
		move.w	8(a0),-(sp)
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		bsr.w	SolidObject
		btst	#3,$22(a0)
		bne.s	loc_15A3A
		cmpi.w	#1,d4
		bne.s	loc_15A3A
		bsr.w	sub_15A90
		bclr	#5,$22(a0)

loc_15A3A:				; CODE XREF: ROM:00015A0Ej
					; ROM:00015A2Aj
		move.w	$30(a0),d0
		bra.w	MarkObjGone
; ===========================================================================

loc_15A42:				; DATA XREF: ROM:0001590Eo
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject
		btst	#3,$22(a0)
		bne.s	loc_15A88
		tst.w	d4
		bpl.s	loc_15A88
		bsr.w	sub_15A90

loc_15A88:				; CODE XREF: ROM:00015A68j
					; ROM:00015A7Ej
		move.w	$30(a0),d0
		bra.w	MarkObjGone

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15A90:				; CODE XREF: ROM:0001293Aj
					; ROM:000159CCp ...
		btst	#1,($FFFFFE2C).w	; is Sonic invincible?
		bne.s	locret_15AC4
		tst.w	$30(a1)
		bne.s	locret_15AC4
		cmpi.b	#4,$24(a1)
		bcc.s	locret_15AC4
		move.l	$C(a1),d3
		move.w	$12(a1),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a1)
		movea.l	a0,a2
		movea.l	a1,a0
		jsr	HurtSonic
		movea.l	a2,a0

locret_15AC4:				; CODE XREF: sub_15A90+6j sub_15A90+Cj ...
		rts	
; End of function sub_15A90


; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15AC6:				; CODE XREF: ROM:00015996p
					; ROM:000159EAp ...
		moveq	#0,d0
		move.b	$28(a0),d0
		add.w	d0,d0
		move.w	off_15AD6(pc,d0.w),d1
		jmp	off_15AD6(pc,d1.w)
; End of function sub_15AC6

; ===========================================================================
off_15AD6:	dc.w locret_15ADC-off_15AD6; 0 ; DATA XREF: ROM:00015AD6o
					; ROM:00015AD8o ...
		dc.w loc_15ADE-off_15AD6; 1
		dc.w loc_15AF2-off_15AD6; 2
; ===========================================================================

locret_15ADC:				; DATA XREF: ROM:00015AD6o
		rts	
; ===========================================================================

loc_15ADE:				; DATA XREF: ROM:00015AD6o
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,$C(a0)
		rts	
; ===========================================================================

loc_15AF2:				; DATA XREF: ROM:00015AD6o
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)
		rts	

; รรรรรรรรรรรรรรร S U B	R O U T	I N E รรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรรร


sub_15B06:				; CODE XREF: ROM:00015ADEp
					; ROM:00015AF2p
		tst.w	$38(a0)
		beq.s	loc_15B24
		subq.w	#1,$38(a0)
		bne.s	locret_15B66
		tst.b	1(a0)
		bpl.s	locret_15B66
		sfx		sfx_SpikeHit
		bra.s	locret_15B66
; ===========================================================================

loc_15B24:				; CODE XREF: sub_15B06+4j
		tst.w	$36(a0)
		beq.s	loc_15B46
		subi.w	#$800,$34(a0)
		bcc.s	locret_15B66
		move.w	#0,$34(a0)
		move.w	#0,$36(a0)
		move.w	#$3C,$38(a0) ; '<'
		bra.s	locret_15B66
; ===========================================================================

loc_15B46:				; CODE XREF: sub_15B06+22j
		addi.w	#$800,$34(a0)
		cmpi.w	#$2000,$34(a0)
		bcs.s	locret_15B66
		move.w	#$2000,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0) ; '<'

locret_15B66:				; CODE XREF: sub_15B06+Aj
					; sub_15B06+10j ...
		rts	
; End of function sub_15B06
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - spikes
; ---------------------------------------------------------------------------
Map_obj36:
	include "_maps\obj36.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 04 - rain/snow
; ---------------------------------------------------------------------------
Obj04:
		btst	#6,1(a0)				; Is this object set to render sub sprites?
		bne.s   .SubSpr				; If so, branch
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj04_Index(pc,d0.w),d1
		jmp	Obj04_Index(pc,d1.w)

	.SubSpr:
		move.w	#0,d0				; Display sprites
		jmp	DisplaySprite3
; ===========================================================================
Obj04_Index:	dc.w Obj04_Init-Obj04_Index
		dc.w Obj04_Main-Obj04_Index
; ===========================================================================	

Obj04_Init:
		addq.b	#2,$24(a0)				; Set as initialized
		jsr   	SingleObjLoad				; Find a free object slot
		bne.w	Obj04_Main
		move.w	a1,$3A(a0)				; Set as child object
		bsr.s	.setup
		jsr   	SingleObjLoad				; Find a free object slot
		bne.w	Obj04_Main
		move.w	a1,$3C(a0)				; Set as child object
		bsr.s	.setup
		jsr   	SingleObjLoad				; Find a free object slot
		bne.w	Obj04_Main
		move.w	a1,$3E(a0)				; Set as child object
		bsr.s	.setup
		bra.s	Obj04_Main

	.setup:
		move.b	#4,(a1)					; Load object
		move.b	#%01000100,1(a1)			; Set to render sub sprites
		move.w	#$8308,2(a1)
		move.l	#Map_Obj04,4(a1)			; Mappings
		move.b	#2,mainspr_width(a1)			; Set main sprite width
		move.b	#2,mainspr_height(a1)			; Set main sprite height
        move.b  #0,mainspr_mapframe(a1)            ; Set main sprite frame
		move.b	#8,mainspr_childsprites(a1)		; Set number of child sprites
        moveq    #0,d5
        move.b    mainspr_childsprites(a1),d5        ; Get number of sub sprites
        subq.b    #1,d5
        bmi.s    Obj04_Main                ; If there are none, branch
        lea    sub2_x_pos(a1),a2            ; Get sub sprite data

    .spawn:
		jsr	RandomNumber
		move.w	($FFFFF700).w,d1; get screen position
		andi.w	#$1FF,d0
		cmpi.w	#320,d0
		bge.w	.spawn
		add.w	d1,d0
		move.w	d0,(a2)+
		jsr	RandomNumber
		move.w	($FFFFF704).w,d1; get screen position
		andi.w	#$FF,d0
		add.w	d1,d0
		move.w	d0,(a2)+
		move.w	#0,(a2)+
		dbf    d5,.spawn           ; Loop until every sub sprite is set
		rts

Obj04_Main:
        movea.w    $3A(a0),a1                ; Get child object
        bsr.s	.dostuff
        movea.w    $3C(a0),a1                ; Get child object
        bsr.s	.dostuff
        movea.w    $3E(a0),a1                ; Get child object

    .dostuff:
		move.w	($FFFFB008).w,8(a1)
		move.w	($FFFFB00C).w,$C(a1)
        moveq    #0,d5
        move.b    mainspr_childsprites(a1),d5        ; Get number of sub sprites
        subq.b    #1,d5
        bmi.s    Obj04_Return                ; If there are none, branch
		move.w	($FFFFF700).w,d1
		move.w	($FFFFF704).w,d3
        lea    sub2_x_pos(a1),a2            ; Get sub sprite data

    .adjust:
    	move.w	(a2),d0
    	move.w	2(a2),d2
    	move.w	d0,d4
    	andi.w	#3,d4
    	addi.w	#4,d4
		sub.w	d1,d0
		sub.w	d3,d2
    	andi.w	#$1FF,d0
    	addi.w	#$100,d0
    	add.w	d4,d2
    	andi.w	#$FF,d2
		add.w	d3,d2
		add.w	d1,d0
    	move.w	d0,(a2)
    	move.w	d2,2(a2)
    	adda.w	#6,a2
		dbf    d5,.adjust           ; Loop until every sub sprite is set

Obj04_Return:
		rts

; ===========================================================================

Map_Obj04:
		include	"_maps\obj04.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 06 - ZONE 1 Sun
; ---------------------------------------------------------------------------
Obj06:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj06_Index(pc,d0.w),d1
		jmp	Obj06_Index(pc,d1.w)
; ===========================================================================
Obj06_Index:	dc.w Obj06_Main-Obj06_Index
		dc.w Obj06_Display-Obj06_Index
		dc.w Obj06_Display2-Obj06_Index
; ===========================================================================

Obj06_Main:
		addq.b	#2,$24(a0)
		move.l	#Map_Obj06,4(a0)
		move.w	#$630A,2(a0)
		move.b	#$10,$14(a0)
		move.w	#$380,$18(a0)
		tst.b	$28(a0)
		beq.s	Obj06_Display
		addq.b	#2,$24(a0)

Obj06_Display2:
		move.w	(Universal_Timer2).w,d0
		move.w	d0,d1
		andi.w	#$7FFF,d0
		asr.w	#7,d0
		addi.w	#$C0,d0
		move.w	d0,8(a0)
		move.w	(Day_Time).w,d0
		asr.w	#6,d0
		divs.w	#3,d0
		jsr	CalcSine
		asr.w	#1,d0
		addi.w	#$110,d0
		move.w	d0,$A(a0)
		bra.w	DisplaySprite

Obj06_Display:
		move.w	(Universal_Timer2).w,d0
		andi.w	#$7FFF,d0
		asr.w	#7,d0
		addi.w	#$C0,d0
		move.w	d0,8(a0)
		move.w	(Day_Time).w,d0
		asr.w	#6,d0
		divs.w	#3,d0
		jsr	CalcSine
		asr.w	#1,d0
		neg.w	d0
		addi.w	#$120,d0
		move.w	d0,$A(a0)
		bra.w	DisplaySprite


; ===========================================================================

Map_Obj06:
		include	"_maps\obj06.asm"

; ---------------------------------------------------------------------------
; Subroutine to	smash a	block (BBZ walls and DDZ	blocks)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SmashObject:				; XREF: Obj3C_Smash
		moveq	#0,d0
		move.b	$1A(a0),d0
		add.w	d0,d0
		movea.l	4(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,1(a0)
		move.b	0(a0),d4
		move.b	1(a0),d5
		movea.l	a0,a1
		bra.s	Smash_LoadFrag
; ===========================================================================

Smash_Loop:
		bsr.w	SingleObjLoad
		bne.s	Smash_PlaySnd
		addq.w	#5,a3

Smash_LoadFrag:				; XREF: SmashObject
		move.b	#4,$24(a1)
		move.b	d4,0(a1)
		move.l	a3,4(a1)
		move.b	d5,1(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.w	2(a0),2(a1)
		move.w	$18(a0),$18(a1)
		move.b	$14(a0),$14(a1)
		move.w	(a4)+,$10(a1)
		move.w	(a4)+,$12(a1)
		cmpa.l	a0,a1
		bcc.s	loc_D268
		move.l	a0,-(sp)
		movea.l	a1,a0
		bsr.w	SpeedToPos
		add.w	d2,$12(a0)
		movea.l	(sp)+,a0
		bsr.w	DisplaySprite2

loc_D268:
		dbf	d1,Smash_Loop

Smash_PlaySnd:
		sfx		sfx_Collapse ;	play smashing sound
; End of function SmashObject

; ---------------------------------------------------------------------------
; Object code loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectsLoad:
	lea	($FFFFB000).w,a0 ; a0=object

	moveq	#$7F,d7 ; run the first $80 objects out of levels
	moveq	#0,d0
	cmpi.b	#8,($FFFFF600).w	; demo mode?
	beq.s	ObjectsLoad2	; if in a level in a demo, branch
	cmpi.b	#$C,($FFFFF600).w	; regular level mode?
	bne.s	RunObject ; if not in a level, branch to RunObject

ObjectsLoad2:
	move.w	#$8F,d7	; run the first $90 objects in levels
	
	cmpi.b	#6,($FFFFB024).w
	bhs.s	RunObjectsWhenPlayerIsDead ; if dead, branch
	tst.b	($FFFFF5C0).w
	beq.s	RunObject
	tst.w	($FFFFF63A).w
	bne.s	RunObjectsWhilePaused
	; continue straight to RunObject
; ---------------------------------------------------------------------------

; -------------------------------------------------------------------------------
; This is THE place where each individual object's code gets called from
; -------------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_15FCC:
RunObject:
	move.b	(a0),d0	; get the object's ID
	beq.s	RunNextObject ; if it's obj00, skip it
	add.w	d0,d0
	add.w	d0,d0	; d0 = object ID * 4
	movea.l	Obj_Index-4(pc,d0.w),a1	; load the address of the object's code
	jsr	(a1)	; dynamic call! to one of the the entries in Obj_Index
	moveq	#0,d0

; loc_15FDC:
RunNextObject:
	lea	$40(a0),a0 ; load 0bj address
	dbf	d7,RunObject
; return_15FE4:
RunObjects_End:
	rts

; ---------------------------------------------------------------------------
; this skips certain objects to make enemies and things pause when Sonic dies
; loc_15FE6:
RunObjectsWhenPlayerIsDead:
	moveq	#$F,d7
	bsr.s	RunObject	; run the first $10 objects normally
	moveq	#$6F,d7
	bsr.s	RunObjectDisplayOnly ; all objects in this range are paused
	moveq	#$F,d7
	bra.s	RunObject	; run the last $10 objects normally

RunObjectsWhilePaused:
	lea	($FFFFF5C0).w,a0
	jsr		ObjMenu
	moveq	#0,d0
	lea	($FFFFB000).w,a0 ; a0=object

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_15FF2:
RunObjectDisplayOnly:
	moveq	#0,d0
	move.b	(a0),d0	; get the object's ID
	beq.s	RunObjectDisplayOnly2	; if it's obj00, skip it
	cmpi.b	#$27,d0
	beq.s	RunObjectDisplayOnly2
	cmpi.b	#$3F,d0
	beq.s	RunObjectDisplayOnly2
	tst.b	1(a0)	; should we render it?
	bpl.s	RunObjectDisplayOnly2			; if not, skip it
	btst	#6,1(a0)
	bne.s	RunObjectDisplayOnly2
	bsr.w	DisplaySprite

RunObjectDisplayOnly2:
	lea	$40(a0),a0 ; load 0bj address
	dbf	d7,RunObjectDisplayOnly
	rts
; End of function RunObjectDisplayOnly

; ===========================================================================
; ---------------------------------------------------------------------------
; Object pointers
; ---------------------------------------------------------------------------
Obj_Index:
	dc.l Obj01, Obj02,	Obj03, Obj04
	dc.l Obj05, Obj06, ObjNone, Obj08
	dc.l Obj09, Obj0A, Obj0B, Obj0C
	dc.l Obj0D, Obj0E, Obj0F, ObjNone
	dc.l Obj11, ObjNone, ObjNone, ObjNone
	dc.l Obj15, ObjNone, ObjNone, Obj18
	dc.l ObjNone, ObjNone, Obj1B, Obj1C
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l Obj21, ObjNone, ObjNone, ObjNone
	dc.l Obj25, Obj26, Obj27, Obj28
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, Obj2E, ObjNone, ObjNone
	dc.l ObjNone, Obj32, ObjNone, Obj34
	dc.l ObjNone, Obj36, Obj37, Obj38
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, Obj3E, Obj3F, ObjNone
	dc.l Obj41, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, Obj4A, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, Obj54
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, Obj5C
	dc.l ObjNone, ObjNone, ObjNone, Obj60
	dc.l ObjNone, ObjNone, ObjNone, Obj64
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l Obj71, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l Obj79, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, ObjNone, ObjNone, ObjNone
	dc.l ObjNone, Obj8A, ObjNone, ObjNone
	dc.l ObjNone, Obj8E, Obj8F, ObjNone
	dc.l Obj91, ObjNone, ObjNone, ObjNone
	dc.l Obj95, Obj96, Obj97, Obj98
	dc.l Obj99, Obj9A, ObjNone, ObjNone

ObjNone:
	rts

; ---------------------------------------------------------------------------
; Subroutine to	make an	object fall downwards, increasingly fast
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectFall:
		move.b	(a0),d0
		move.b	($FFFFB000).w,d1
		cmp.b 	d0,d1 ; is Sonic object?
		beq.s  	CharacterFall	 ; if is, branch
		move.b	($FFFFB380).w,d1
		cmp.b 	d0,d1 ; is Sonic object?
		beq.s  	CharacterFall	 ; if is, branch
		bra.s	ObjectFall_NotSonic

CharacterFall:
		cmpi.b 	#0,$1C(a0) ; is running/walking animation?
		bne.s   ObjectFall_NotSonic  ; if not, dont make rolling ani (to prevent from being in rolling ani when died, jumped from spring, etc.)
		move.b #$C,$1C(a0)  ; use falling animation
		bset #2,$22(a0)			  ; set in air flag, to enable in air moves

ObjectFall_NotSonic:			  
		move.w	$10(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,8(a0)
		move.w	$12(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,$C(a0)
		addi.w	#$38,$12(a0)	; increase vertical speed

ObjectFall_Done:
		rts	

ObjectFall2:
		move.w	$10(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,8(a0)
		move.w	$12(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,$C(a0)
		rts	


; End of function ObjectFall

; ---------------------------------------------------------------------------
; Subroutine translating object	speed to update	object position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SpeedToPos:
		move.w	$10(a0),d0	; load horizontal speed
		ext.l	d0
		lsl.l	#8,d0		; multiply speed by $100
		add.l	d0,8(a0)	; add to x-axis	position
		move.w	$12(a0),d0	; load vertical	speed
		ext.l	d0
		lsl.l	#8,d0		; multiply by $100
		add.l	d0,$C(a0)	; add to y-axis	position
		rts	s	
; End of function SpeedToPos

; ---------------------------------------------------------------------------
; Subroutine to	display	a sprite/object, when a0 is the	object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DisplaySprite:
		lea	($FFFFAC00).w,a1
		adda.w	$18(a0),a1
		cmpi.w	#$7E,(a1)
		bcc.s	locret_D620
		addq.w	#2,(a1)
		adda.w	(a1),a1
		move.w	a0,(a1)
	;	bset	#6,1(a0)	; ++ setup display flag

locret_D620:
		rts	
; End of function DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	display	a 2nd sprite/object, when a1 is	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DisplaySprite2:
		lea	($FFFFAC00).w,a2
		adda.w	$18(a1),a2
		cmpi.w	#$7E,(a2)
		bcc.s	locret_D63E
		addq.w	#2,(a2)
		adda.w	(a2),a2
		move.w	a1,(a2)
	;	bset	#6,1(a0)	; ++ setup display flag

locret_D63E:
		rts	
; End of function DisplaySprite2

DisplaySprite3:
		lea	($FFFFAC00).w,a1
		adda.w	d0,a1
		cmpi.w	#$7E,(a1) ; '~'
		bcc.s	locret_16542
		addq.w	#2,(a1)
		adda.w	(a1),a1
		move.w	a0,(a1)

locret_16542:				; CODE XREF: ROM:0001653Aj
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	delete an object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeleteObject:
		movea.l	a0,a1

DeleteObject2:
		moveq	#0,d1
		moveq	#$F,d0

loc_D646:
		move.l	d1,(a1)+	; clear	the object RAM
		dbf	d0,loc_D646	; repeat $F times (length of object RAM)
		rts	
; End of function DeleteObject

; ===========================================================================
BldSpr_ScrPos:	dc.l 0			; blank
		dc.l $FFF700		; main screen x-position
		dc.l $FFF708		; background x-position	1
		dc.l $FFF718		; background x-position	2
; ---------------------------------------------------------------------------
; Subroutine to	convert	mappings (etc) to proper Megadrive sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BuildSprites:				; XREF: TitleScreen; et al
		lea	($FFFFF800).w,a2 ; set address for sprite table
		moveq	#0,d5
		moveq	#0,d4
		tst.b	($FFFFF74F).w
		beq.s	BuildSpritesCont
		bsr.w	BuildRings

BuildSpritesCont:
		lea	($FFFFAC00).w,a4
		moveq	#7,d7

loc_D66A:
		tst.w	(a4)
		beq.w	loc_D72E
		moveq	#2,d6

loc_D672:
		movea.w	(a4,d6.w),a0
		tst.b	(a0)
		beq.w	loc_D726
	;	btst	#6,1(a0)	; ++ is object already processed?
	;	beq.w	loc_D726	; ++ if yes, branch
	;	bclr	#6,1(a0)	; ++ clear display flag
		bclr	#7,1(a0)
		move.b	1(a0),d0
		move.b	d0,d4
		btst	#6,d0	; is the multi-draw flag set?
		bne.w	BuildSprites_MultiDraw	; if it is, branch
		andi.w	#$C,d0	; is this to be positioned by screen coordinates?
		beq.s	loc_D6DE	; if it is, branch
		movea.l	BldSpr_ScrPos(pc,d0.w),a1
		moveq	#0,d0
		move.b	$14(a0),d0
		move.w	8(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1
		bmi.w	loc_D726
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#$140,d1
		bge.s	loc_D726
		addi.w	#$80,d3
		btst	#4,d4
		beq.s	loc_D6E8
		moveq	#0,d0
		move.b	$16(a0),d0
		move.w	$C(a0),d2
		sub.w	4(a1),d2
		move.w	d2,d1
		add.w	d0,d1
		bmi.s	loc_D726
		move.w	d2,d1
		sub.w	d0,d1
		cmpi.w	#$E0,d1
		bge.s	loc_D726
		addi.w	#$80,d2
		bra.s	loc_D700
; ===========================================================================

loc_D6DE:
		move.w	$A(a0),d2
		move.w	8(a0),d3
		bra.s	loc_D700
; ===========================================================================

loc_D6E8:
		move.w	$C(a0),d2
		sub.w	4(a1),d2
		addi.w	#$80,d2
		cmpi.w	#$60,d2
		bcs.s	loc_D726
		cmpi.w	#$180,d2
		bcc.s	loc_D726

loc_D700:
		movea.l	4(a0),a1
		moveq	#0,d1
		btst	#5,d4
		bne.s	loc_D71C
		move.b	$1A(a0),d1
		add.w	d1,d1					; MJ: changed from byte to word (we want more than 7F sprites)
		adda.w	(a1,d1.w),a1
		moveq	#$00,d1					; MJ: clear d1 (because of our byte to word change)
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_D720


loc_D71C:
		bsr.w	sub_D750

loc_D720:
		bset	#7,1(a0)

loc_D726:
		addq.w	#2,d6
		subq.w	#2,(a4)
		bne.w	loc_D672

loc_D72E:
		lea	$80(a4),a4
		dbf	d7,loc_D66A
		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_D748
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_D748:
		move.b	#0,-5(a2)
		rts	
; End of function BuildSprites

BuildSprites_MultiDraw:
		move.l	a4,-(sp)
		lea		($FFFFF700).w,a4
		movea.w	2(a0),a3
		movea.l	4(a0),a5
		moveq	#0,d0
		; check if object is within X bounds
		move.b	mainspr_width(a0),d0	; load pixel width
		move.w	8(a0),d3
		sub.w	(a4),d3
		move.w	d3,d1
		add.w	d0,d1
		bmi.w	BuildSprites_MultiDraw_NextObj
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#320,d1
		bge.w	BuildSprites_MultiDraw_NextObj
		addi.w	#128,d3
		; check if object is within Y bounds
		btst	#4,d4
		beq.s	BuildSprites_MD1
		moveq	#0,d0
		move.b	mainspr_height(a0),d0	; load pixel height
		move.w	$C(a0),d2
		sub.w	4(a4),d2
		move.w	d2,d1
		add.w	d0,d1
		bmi.w	BuildSprites_MultiDraw_NextObj
		move.w	d2,d1
		sub.w	d0,d1
		cmpi.w	#224,d1
		bge.w	BuildSprites_MultiDraw_NextObj
		addi.w	#128,d2
		bra.s	BuildSprites_MD2

BuildSprites_MD1:
		move.w	$C(a0),d2
		sub.w	4(a4),d2
		addi.w	#128,d2
		andi.w	#$7FF,d2
		cmpi.w	#-32+128,d2
		blo.s	BuildSprites_MultiDraw_NextObj
   		cmpi.w	#32+128+224,d2
		bhs.s	BuildSprites_MultiDraw_NextObj

BuildSprites_MD2:
		moveq	#0,d1
		move.b	mainspr_mapframe(a0),d1	; get current frame
		beq.s	BuildSprites_MD3
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1
    	moveq    #0,d1
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	BuildSprites_MD3
		move.w	d4,-(sp)
		bsr.w	ChkDrawSprite	; draw the sprite
		move.w	(sp)+,d4

BuildSprites_MD3:
		ori.b	#$80,1(a0)	; set onscreen flag
		lea		sub2_x_pos(a0),a6
		moveq	#0,d0
		move.b	mainspr_childsprites(a0),d0	; get child sprite count
		subq.w	#1,d0		; if there are 0, go to next object
		bcs.s	BuildSprites_MultiDraw_NextObj

BuildSprites_MD4:
		swap    d0
    	move.w    (a6)+,d3    ; get X pos
    	sub.w    (a4),d3
    	addi.w    #128,d3
    	move.w    (a6)+,d2    ; get Y pos
    	sub.w    4(a4),d2
    	addi.w    #128,d2
   		andi.w    #$7FF,d2
    	addq.w    #1,a6
    	moveq    #0,d1
    	move.b    (a6)+,d1    ; get mapping frame
    	add.w    d1,d1
    	movea.l    a5,a1
    	adda.w    (a1,d1.w),a1
    	moveq    #0,d1
    	move.b    (a1)+,d1
    	subq.b    #1,d1
		bmi.s	BuildSprites_MD5
		move.w	d4,-(sp)
		bsr.w	ChkDrawSprite
		move.w	(sp)+,d4

BuildSprites_MD5:
		swap	d0
		dbf		d0,BuildSprites_MD4	; repeat for number of child sprites

BuildSprites_MultiDraw_NextObj:
		movea.l	(sp)+,a4
		bra.w	loc_D726

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D750:				; XREF: BuildSprites
		movea.w	2(a0),a3

ChkDrawSprite:
		btst	#0,d4
		bne.s	loc_D796
		btst	#1,d4
		bne.w	loc_D7E4
; End of function sub_D750


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D762:				; XREF: sub_D762; BS_ShowLayout
		cmpi.b	#$50,d5
		beq.s	locret_D794
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D78E
		addq.w	#1,d0

loc_D78E:
		move.w	d0,(a2)+
		dbf	d1,sub_D762

locret_D794:
		rts	
; End of function sub_D762

; ===========================================================================

loc_D796:
		btst	#1,d4
		bne.w	loc_D82A

loc_D79E:
		cmpi.b	#$50,d5
		beq.s	locret_D7E2
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D7DC
		addq.w	#1,d0

loc_D7DC:
		move.w	d0,(a2)+
		dbf	d1,loc_D79E

locret_D7E2:
		rts	
; ===========================================================================

loc_D7E4:				; XREF: sub_D750
		cmpi.b	#$50,d5
		beq.s	locret_D828
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1000,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D822
		addq.w	#1,d0

loc_D822:
		move.w	d0,(a2)+
		dbf	d1,loc_D7E4

locret_D828:
		rts	
; ===========================================================================

loc_D82A:
		cmpi.b	#$50,d5
		beq.s	locret_D87C
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D876
		addq.w	#1,d0

loc_D876:
		move.w	d0,(a2)+
		dbf	d1,loc_D82A

locret_D87C:
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	check if an object is on the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen:
		move.w	8(a0),d0	; get object x-position
		sub.w	($FFFFF700).w,d0 ; subtract screen x-position
		bmi.s	NotOnScreen
		cmpi.w	#320,d0		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		move.w	$C(a0),d1	; get object y-position
		sub.w	($FFFFF704).w,d1 ; subtract screen y-position
		bmi.s	NotOnScreen
		cmpi.w	#224,d1		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		moveq	#0,d0		; set flag to 0
		rts	
; ===========================================================================

NotOnScreen:				; XREF: ChkObjOnScreen
		moveq	#1,d0		; set flag to 1
		rts	
; End of function ChkObjOnScreen


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen2:
		moveq	#0,d1
		move.b	$14(a0),d1
		move.w	8(a0),d0
		sub.w	($FFFFF700).w,d0
		add.w	d1,d0
		bmi.s	NotOnScreen2
		add.w	d1,d1
		sub.w	d1,d0
		cmpi.w	#320,d0
		bge.s	NotOnScreen2

		move.w	$C(a0),d1
		sub.w	($FFFFF704).w,d1
		bmi.s	NotOnScreen2
		cmpi.w	#224,d1
		bge.s	NotOnScreen2

		moveq	#0,d0
		rts	
; ===========================================================================

NotOnScreen2:				; XREF: ChkObjOnScreen2
		moveq	#1,d0
		rts	
; End of function ChkObjOnScreen2

; ---------------------------------------------------------------------------
; Objects Manager
; Subroutine to load objects whenever they are close to the screen. Unlike in
; normal s2, in this version every object gets an entry in the respawn table.
; This is necessary to get the additional y-range checks to work.
;
; input variables:
;  -none-
;
; writes:
;  d0, d1, d2
;  d3 = upper boundary to load object
;  d4 = lower boundary to load object
;  d5 = #$FFF, used to filter out object's y position
;  d6 = camera position
;
;  a0 = address in object placement list
;  a3 = address in object respawn table
;  a6 = object loading routine
; ---------------------------------------------------------------------------
; loc_17AA4
ObjPosLoad:
		moveq	#0,d0
		move.b   ($FFFFF76C).w,d0
		jmp	ObjPosLoad_States(pc,d0.w)
; ============== JUMP TABLE	=============================================
ObjPosLoad_States:
		bra.w	ObjPosLoad_Init		; 0
		bra.w	ObjPosLoad_Main		; 2
; ============== END JUMP TABLE	=============================================
ObjPosLoad_Init:
		addq.b	#4,($FFFFF76C).w

		lea	 ($FFFFD600).w,a0
		moveq   #0,d0
		move.w  #$BF,d1 ; set loop counter
OPL1:
		move.l  d0,(a0)+
		dbf	 d1,OPL1
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0			; then this yields $87...
		lsr.w	#4,d0			; and this yields $0002.
		lea	(ObjPos_Index).l,a0	; load the first pointer in the object layout list pointer index,
		adda.w	(a0,d0.w),a0		; load the pointer to the current object layout
		; initialize each object load address with the first object in the layout
		move.l	a0,($FFFFF770).w
		move.l	a0,($FFFFF774).w
		lea	($FFFFD600).w,a3
		move.w	($FFFFF700).w,d6
		subi.w	#$80,d6	; look one chunk to the left
		bcc.s	OPL2	; if the result was negative,
		moveq	#0,d6	; cap at zero
OPL2:	andi.w	#$FF80,d6	; limit to increments of $80 (width of a chunk)
		movea.l	($FFFFF770).w,a0	; get first object in layout
OPL3:	; at the beginning of a level this gives respawn table entries to any object that is one chunk
		; behind the left edge of the screen that needs to remember its state (Monitors, Badniks, etc.)
		cmp.w	(a0),d6		; is object's x position >= d6?
		bls.s	OPL4		; if yes, branch
		addq.w	#6,a0	; next object
		addq.w	#1,a3	; respawn index of next object going right
		bra.s	OPL3
; ===========================================================================
OPL4:	move.l	a0,($FFFFF770).w	; remember rightmost object that has been processed, so far (we still need to look forward)
		move.w	a3,($FFFFF778).w	; and its respawn table index
		lea	($FFFFD600).w,a3	; reset a3
		movea.l	($FFFFF774).w,a0	; reset a0
		subi.w	#$80,d6		; look even farther left (any object behind this is out of range)
		bcs.s	OPL6		; branch, if camera position would be behind level's left boundary
OPL5:	; count how many objects are behind the screen that are not in range and need to remember their state
		cmp.w	(a0),d6		; is object's x position >= d6?
		bls.s	OPL6		; if yes, branch
		addq.w	#6,a0
		addq.w	#1,a3	; respawn index of next object going left
		bra.s	OPL5	; continue with next object
; ===========================================================================
OPL6:	move.l	a0,($FFFFF774).w	; remember current object from the left
		move.w	a3,($FFFFF77C).w	; and its respawn table index
		move.w	#-1,($FFFFF76E).w	; make sure ObjPosLoad_GoingForward is run
		move.w	($FFFFF704).w,d0
		andi.w	#$FF80,d0
		move.w	d0,($FFFFFE2A).w	; make sure the Y check isn't run unnecessarily during initialization
; ===========================================================================
ObjPosLoad_Main:
		; get coarse camera position

		tst.w	($FFFFF72E).w	; does this level y-wrap?
		bpl.s	ObjMan_Main_NoYWrap	; if not, branch
		lea	(ChkLoadObj_YWrap).l,a6	; set object loading routine
		move.w	($FFFFF704).w,d3
		andi.w	#$FF80,d3	; get coarse value
		move.w	d3,d4
		addi.w	#$200,d4	; set lower boundary
		subi.w	#$80,d3		; set upper boundary
		bpl.s	OPL7		; branch, if upper boundary > 0
		andi.w	#$7FF,d3	; wrap value
		bra.s	ObjMan_Main_Cont
; ===========================================================================
OPL7:	move.w	#$7FF,d0
		addq.w	#1,d0
		cmp.w	d0,d4
		bls.s	OPL8		; branch, if lower boundary < $7FF
		andi.w	#$7FF,d4	; wrap value
		bra.s	ObjMan_Main_Cont
; ===========================================================================
ObjMan_Main_NoYWrap:
		move.w	($FFFFF704).w,d3
		andi.w	#$FF80,d3	; get coarse value
		move.w	d3,d4
		addi.w	#$200,d4	; set lower boundary
		subi.w	#$80,d3		; set upper boundary
		bpl.s	OPL8
		moveq	#0,d3	; no negative values allowed
OPL8:   lea	(ChkLoadObj).l,a6	; set object loading routine
ObjMan_Main_Cont:
		move.w	#$FFF,d5	; this will be used later when we load objects
		move.w	($FFFFF700).w,d6
		andi.w	#$FF80,d6
		cmp.w	($FFFFF76E).w,d6	; is the X range the same as last time?
		beq.w	ObjPosLoad_SameXRange	; if yes, branch
		bge.s	ObjPosLoad_GoingForward	; if new pos is greater than old pos, branch
		; if the player is moving back
		move.w	d6,($FFFFF76E).w	; remember current position for next time
		movea.l	($FFFFF774).w,a0	; get current object going left
		movea.w	($FFFFF77C).w,a3	; and its respawn table index
		subi.w	#$80,d6			; look one chunk to the left
		bcs.s	ObjMan_GoingBack_Part2	; branch, if camera position would be behind level's left boundary
		jsr	(SingleObjLoad).l		; find an empty object slot
		bne.s	ObjMan_GoingBack_Part2		; branch, if there are none
OPL9:	; load all objects left of the screen that are now in range
		cmp.w	-6(a0),d6		; is the previous object's X pos less than d6?
		bge.s	ObjMan_GoingBack_Part2	; if it is, branch
		subq.w	#6,a0		; get object's address
		subq.w	#1,a3		; and respawn table index
		jsr	(a6)		; load object
		bne.s	OPL10		; branch, if SST is full
		subq.w	#6,a0
		bra.s	OPL9	; continue with previous object
; ===========================================================================
OPL10:	; undo a few things, if the object couldn't load
		addq.w	#6,a0	; go back to last object
		addq.w	#1,a3	; since we didn't load the object, undo last change
ObjMan_GoingBack_Part2:
		move.l	a0,($FFFFF774).w	; remember current object going left
		move.w	a3,($FFFFF77C).w	; and its respawn table index
		movea.l	($FFFFF770).w,a0	; get next object going right
		movea.w	($FFFFF778).w,a3	; and its respawn table index
		addi.w	#$300,d6	; look two chunks beyond the right edge of the screen
OPL11:	; subtract number of objects that have been moved out of range (from the right side)
		cmp.w	-6(a0),d6	; is the previous object's X pos less than d6?
		bgt.s	OPL12		; if it is, branch
		subq.w	#6,a0		; get object's address
		subq.w	#1,a3		; and respawn table index
		bra.s	OPL11	; continue with previous object
; ===========================================================================
OPL12:	move.l	a0,($FFFFF770).w	; remember next object going right
		move.w	a3,($FFFFF778).w	; and its respawn table index
		bra.s	ObjPosLoad_SameXRange
; ===========================================================================
ObjPosLoad_GoingForward:
		move.w	d6,($FFFFF76E).w
		movea.l	($FFFFF770).w,a0	; get next object from the right
		movea.w ($FFFFF778).w,a3	; and its respawn table index
		addi.w	#$280,d6	; look two chunks forward
		jsr	(SingleObjLoad).l		; find an empty object slot
		bne.s	ObjMan_GoingForward_Part2	; branch, if there are none
OPL13:	; load all objects right of the screen that are now in range
		cmp.w	(a0),d6				; is object's x position >= d6?
		bls.s	ObjMan_GoingForward_Part2	; if yes, branch
		jsr	(a6)		; load object (and get address of next object)
		addq.w	#1,a3		; respawn index of next object to the right
		beq.s	OPL13	; continue loading objects, if the SST isn't full
ObjMan_GoingForward_Part2:
		move.l	a0,($FFFFF770).w	; remember next object from the right
		move.w	a3,($FFFFF778).w	; and its respawn table index
		movea.l	($FFFFF774).w,a0	; get current object from the left
		movea.w	($FFFFF77C).w,a3	; and its respawn table index
		subi.w	#$300,d6		; look one chunk behind the left edge of the screen
		bcs.s	ObjMan_GoingForward_End	; branch, if camera position would be behind level's left boundary
OPL14:	; subtract number of objects that have been moved out of range (from the left)
		cmp.w	(a0),d6			; is object's x position >= d6?
		bls.s	ObjMan_GoingForward_End	; if yes, branch
		addq.w	#6,a0	; next object
		addq.w	#1,a3	; respawn index of next object to the left
		bra.s	OPL14	; continue with next object
; ===========================================================================

ObjMan_GoingForward_End:
		move.l	a0,($FFFFF774).w	; remember current object from the left
		move.w	a3,($FFFFF77C).w	; and its respawn table index
ObjPosLoad_SameXRange:
		move.w	($FFFFF704).w,d6
		andi.w	#$FF80,d6
		move.w	d6,d3
		cmp.w	($FFFFFE2A).w,d6	; is the y range the same as last time?
		beq.w	ObjPosLoad_SameYRange	; if yes, branch
		bge.s	ObjPosLoad_GoingDown	; if the player is moving down
		; if the player is moving up
		tst.w	($FFFFF72E).w	; does the level y-wrap?
		bpl.s	ObjMan_GoingUp_NoYWrap	; if not, branch
		tst.w	d6
		bne.s	ObjMan_GoingUp_YWrap
		cmpi.w	#$80,($FFFFFE2A).w
		bne.s	ObjMan_GoingDown_YWrap
ObjMan_GoingUp_YWrap:
		subi.w	#$80,d3			; look one chunk up
		bpl.s	ObjPosLoad_YCheck	; go to y check, if camera y position >= $80
		andi.w	#$7FF,d3		; else, wrap value
		bra.s	ObjPosLoad_YCheck
; ===========================================================================
ObjMan_GoingUp_NoYWrap:
		subi.w	#$80,d3				; look one chunk up
		bmi.w	ObjPosLoad_SameYRange	; don't do anything if camera y position is < $80
		bra.s	ObjPosLoad_YCheck
; ===========================================================================
ObjPosLoad_GoingDown:
		tst.w	($FFFFF72E).w		; does the level y-wrap?
		bpl.s	ObjMan_GoingDown_NoYWrap	; if not, branch
		tst.w	($FFFFFE2A).w
		bne.s	ObjMan_GoingDown_YWrap
		cmpi.w	#$80,d6
		bne.s	ObjMan_GoingUp_YWrap
ObjMan_GoingDown_YWrap:
		addi.w	#$180,d3		; look one chunk down
		cmpi.w	#$7FF,d3
		bcs.s	ObjPosLoad_YCheck	; go to  check, if camera y position < $7FF
		andi.w	#$7FF,d3		; else, wrap value
		bra.s	ObjPosLoad_YCheck
; ===========================================================================
ObjMan_GoingDown_NoYWrap:
		addi.w	#$180,d3			; look one chunk down
		cmpi.w	#$7FF,d3
		bhi.w	ObjPosLoad_SameYRange	; don't do anything, if camera is too close to bottom
ObjPosLoad_YCheck:
		jsr	(SingleObjLoad).l		; get an empty object slot
		bne.w	ObjPosLoad_SameYRange	; branch, if there are none
		move.w	d3,d4
		addi.w	#$80,d4
		move.w	#$FFF,d5	; this will be used later when we load objects
		movea.l	($FFFFF774).w,a0	; get next object going left
		movea.w	($FFFFF77C).w,a3	; and its respawn table index
		move.l	($FFFFF770).w,d7	; get next object going right
		sub.l	a0,d7	; d7 = number of objects between the left and right boundaries * 6
		beq.s	ObjPosLoad_SameYRange	; branch if there are no objects inbetween
		addq.w	#2,a0	; align to object's y position
OPL15:	; check, if current object needs to be loaded
		tst.b	(a3)	; is object already loaded?
		bmi.s	OPL16	; if yes, branch
		move.w	(a0),d1
		and.w	d5,d1	; get object's y position
		cmp.w	d3,d1
		blo.s	OPL16	; branch, if object is out of range from the top
		cmp.w	d4,d1
		bhi.s	OPL16	; branch, if object is out of range from the bottom
		bset	#7,(a3)	; mark object as loaded
		; load object
		move.w	-2(a0),8(a1)
		move.w	(a0),d1
		move.w	d1,d2
		and.w	d5,d1	; get object's y position
		move.w	d1,$C(a1)
		rol.w	#3,d2
		andi.w	#3,d2	; get object's render flags and status
		move.b	d2,1(a1)
		move.b	d2,$22(a1)
		moveq	#0,d2
		move.b	2(a0),d2
		andi.b	#$7F,d2
		move.b	d2,0(a1)
		moveq	#0,d2
		move.b	3(a0),$28(a1)
		move.w	a3,$1E(a1)
		jsr	(SingleObjLoad).l	; find new object slot
		bne.s	ObjPosLoad_SameYRange	; brach, if there are none left
OPL16:
		addq.w	#6,a0	; address of next object
		addq.w	#1,a3	; and its respawn index
		subq.w	#6,d7	; subtract from size of remaining objects
		bne.s	OPL15	; branch, if there are more
ObjPosLoad_SameYRange:
		move.w	d6,($FFFFFE2A).w
		rts   
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutines to check if an object needs to be loaded,
; with and without y-wrapping enabled.
;
; input variables:
;  d3 = upper boundary to load object
;  d4 = lower boundary to load object
;  d5 = #$FFF, used to filter out object's y position
;
;  a0 = address in object placement list
;  a1 = object
;  a3 = address in object respawn table
;
; writes:
;  d1, d2, d7
; ---------------------------------------------------------------------------
ChkLoadObj_YWrap:
		tst.b	(a3)	; is object already loaded?
		bpl.s	OPL17	; if not, branch
		addq.w	#6,a0	; address of next object
		moveq	#0,d1	; let the objects manager know that it can keep going
		rts
; ===========================================================================
OPL17:	move.w	(a0)+,d7	; x_pos
		move.w	(a0)+,d1	; there are three things stored in this word
		move.w	d1,d2	; does this object skip y-Checks?
		bmi.s	OPL18	; if yes, branch
		and.w	d5,d1	; y_pos
		cmp.w	d3,d1
		bcc.s	LoadObj_YWrap
		cmp.w	d4,d1
		bls.s	LoadObj_YWrap
		addq.w	#2,a0	; address of next object
		moveq	#0,d1	; let the objects manager know that it can keep going
		rts
; ===========================================================================
OPL18:	and.w	d5,d1	; y_pos
LoadObj_YWrap:
		bset	#7,(a3)	; mark object as loaded
		move.w	d7,8(a1)
		move.w	d1,$C(a1)
		rol.w	#3,d2	; adjust bits
		andi.w	#3,d2	; get render flags and status
		move.b	d2,1(a1)
		move.b	d2,$22(a1)
		moveq	#0,d0
		move.b	(a0)+,d0
		move.b	d0,0(a1)
		move.b	(a0)+,$28(a1)
		move.w	a3,$1E(a1)
		bra.s	SingleObjLoad	; find new object slot
;loc_17F36
ChkLoadObj:
		tst.b	(a3)	; is object already loaded?
		bpl.s	OPL19	; if not, branch
		addq.w	#6,a0	; address of next object
		moveq	#0,d1	; let the objects manager know that it can keep going
		rts
; ===========================================================================
OPL19:	move.w	(a0)+,d7	; x_pos
		move.w	(a0)+,d1	; there are three things stored in this word
		move.w	d1,d2	; does this object skip y-Checks?	;*6
		bmi.s	OPL21	; if yes, branch
		and.w	d5,d1	; y_pos
		cmp.w	d3,d1
		bcs.s	OPL20	; branch, if object is out of range from the top
		cmp.w	d4,d1
		bls.s	LoadObj	; branch, if object is in range from the bottom
OPL20:
		addq.w	#2,a0	; address of next object
		moveq	#0,d1
		rts   
; ===========================================================================
OPL21:	and.w	d5,d1	; y_pos
LoadObj:
		bset	#7,(a3)	; mark object as loaded
		move.w	d7,8(a1)
		move.w	d1,$C(a1)
		rol.w	#3,d2	; adjust bits
		andi.w	#3,d2	; get render flags and status
		move.b	d2,1(a1)
		move.b	d2,$22(a1)
		moveq	#0,d0
		move.b	(a0)+,d0
		move.b	d0,0(a1)
		move.b	(a0)+,d0
		move.b	d0,$28(a1)
		move.w	a3,$1E(a1)
		; continue straight to SingleObjLoad
; End of function ChkLoadObj

; ===========================================================================
; ---------------------------------------------------------------------------
; Single object	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad:
		lea	($FFFFB800).w,a1 ; start address for object RAM
		move.w	#$5F,d0

loc_DA94:
		tst.b	(a1)		; is object RAM	slot empty?
		beq.s	locret_DAA0	; if yes, branch
		lea	$40(a1),a1	; goto next object RAM slot
		dbf	d0,loc_DA94	; repeat $5F times

locret_DAA0:
		rts	
; End of function SingleObjLoad


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad2:
		movea.l	a0,a1
		move.w	#$D000,d0
		sub.w	a0,d0
		lsr.w	#6,d0
		subq.w	#1,d0
		bcs.s	locret_DABC

loc_DAB0:
		tst.b	(a1)
		beq.s	locret_DABC
		lea	$40(a1),a1
		dbf	d0,loc_DAB0

locret_DABC:
		rts	
; End of function SingleObjLoad2

LoadChildObject:
	jsr	(SingleObjLoad2).l
	bne.s	LoadChildObject2	; rts
	move.w	(a2)+,d0
	move.w	a1,(a0,d0.w) ; store pointer to child in parent's SST
	move.b	(a2)+,1(a1) ; load obj
	move.b	(a2)+,$28(a1)
	move.w	a0,$2C(a1) ; store pointer to parent in child's SST
	move.w	8(a0),8(a1)
	move.w	$C(a0),$C(a1)

LoadChildObject2:
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to destroy all enemies/monitors/etc on screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DestroyEnemiesUW:
		lea	($FFFFB800).w,a1			; load start of level object ram
		moveq	#$5F,d6					; set repeat times

DE_CheckNext:
		tst.b	(a1)					; is the object valid?
		beq	DE_NextObject				; if not, branch
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a1),d0	; is bubble maker underwater?
		bcc	DE_NextObject				; if not, branch
		lea	DE_BossList(pc),a2			; load start of boss ID list
		bra	DE_CheckBoss				; continue

DE_NoEndList:
		cmp.b	(a1),d0					; is it a boss?
		beq	DE_NextObject				; if so, branch

DE_CheckBoss:
		move.b	(a2)+,d0				; load boss ID
		bne	DE_NoEndList				; if it's not the end of the list, branch
		cmpi.b	#$5F,(a1)				; is it a bomb fuse?
		bne	DE_NoBombFuse				; if not, branch
		cmpi.b	#$04,$28(a1)				; is it a fuse and not the bomb?
		beq	DE_DestroyNoAnimal			; if so, branch

DE_NoBombFuse:
		tst.b	$01(a1)					; is the object displayed on screen?
		bpl	DE_NextObject				; if not, branch
		cmpi.b	#$20,(a1)				; is it the ball of a ball hog?
		beq	DE_DestroyNoAnimal			; if so, branch
		cmpi.b	#$5F,(a1)				; is it a bomb?
		bne	DE_NoBomb				; if not, branch

DE_DestroyNoAnimal:
		move.b	#$3F,(a1)				; change bomb into an explosion object
		sf.b	$24(a1)					; clear routine counter
		bra	DE_NextObject				; skip for next object

DE_NoBomb:
		cmpi.b	#$26,(a1)				; is it a monitor?
		bne	DE_NoMonitor				; if not, branch
		cmpi.b	#$04,$24(a1)				; is the monitor destroyed?
		bge	DE_NextObject				; if so, branch
		move.b	#$04,$24(a1)				; set to correct destory routine
		bra	DE_NextObject				; skip for next object

DE_NoMonitor:
		cmpi.b	#$50,(a1)				; is it a yadrin?
		beq	DE_Destory				; if so, branch
		move.b	$20(a1),d0				; load touch type
		beq	DE_NextObject				; if it's not valid, branch
		andi.b	#$C0,d0					; get only types
		bne	DE_NextObject				; if it's not an enemie, branch

DE_Destory:
		movem.l	d0-a6,-(sp)				; store register data
		move.w	$12(a0),-(sp)				; store Y speed
		clr.w	$12(a0)					; set no Y speed
		jsr	touch_killenemy				; run destroy code
		move.w	(sp)+,$12(a0)				; reload Y speed
		movem.l	(sp)+,d0-a6				; reload register data

DE_NextObject:
		lea	$40(a1),a1				; advance to next object slot
		dbf	d6,DE_CheckNext				; repeat til all object slots are done
		rts						; return
; ===========================================================================

; ---------------------------------------------------------------------------
; Boss ID's to check (00 means end of list)
; ---------------------------------------------------------------------------

DE_BossList:	dc.b	$3D,$73,$75,$77,$7A,$82,$85,$00
		even
; ----------------------------------------------------------------------------
; Object
;
; Spring
; ----------------------------------------------------------------------------

Obj41:				; DATA XREF: ROM:0001600Co
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	off_1889C(pc,d0.w),d1
		jsr	off_1889C(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
off_1889C:	dc.w Obj41_loc_188A8-off_1889C; 0 ; DATA XREF: h+1928o h+192Ao ...
		dc.w Obj41_loc_18980-off_1889C; 1
		dc.w Obj41_loc_18A70-off_1889C; 2
		dc.w Obj41_loc_18C80-off_1889C; 3
		dc.w Obj41_loc_18D6A-off_1889C; 4
		dc.w Obj41_loc_18E9E-off_1889C; 5
; ===========================================================================

Obj41_loc_188A8:				; DATA XREF: h+1928o
		addq.b	#2,$24(a0)
		move.l	#MapUnc_1901C,4(a0)
		make_art_tile	ArtTile_HSpring,0,1
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$200,$18(a0)
		move.b	$28(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		move.w	off_188DE(pc,d0.w),d0
		jmp	off_188DE(pc,d0.w)
; ===========================================================================
off_188DE:	dc.w Obj41_loc_18954-off_188DE; 0 ; DATA XREF: h+196Ao h+196Co ...
		dc.w Obj41_loc_188E8-off_188DE; 1
		dc.w Obj41_loc_18908-off_188DE; 2
		dc.w Obj41_loc_1891C-off_188DE; 3
		dc.w Obj41_loc_18936-off_188DE; 4
; ===========================================================================

Obj41_loc_188E8:				; DATA XREF: h+196Ao
		move.b	#4,$24(a0)
		move.b	#2,$1C(a0)
		move.b	#3,$1A(a0)
		make_art_tile	ArtTile_VSpring,0,1
		move.b	#8,$14(a0)
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_18908:				; DATA XREF: h+196Ao
		move.b	#6,$24(a0)
		move.b	#6,$1A(a0)
		bset	#1,$22(a0)
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_1891C:				; DATA XREF: h+196Ao
		move.b	#8,$24(a0)
		move.b	#4,$1C(a0)
		move.b	#7,$1A(a0)
		make_art_tile	ArtTile_DSpring,0,1
		bra.s	Obj41_loc_18954
; ===========================================================================

Obj41_loc_18936:				; DATA XREF: h+196Ao
		move.b	#$A,$24(a0)
		move.b	#4,$1C(a0)
		move.b	#$A,$1A(a0)
		make_art_tile	ArtTile_DSpring,0,1
		bset	#1,$22(a0)

Obj41_loc_18954:				; CODE XREF: h+1992j h+19A6j ...
		move.b	$28(a0),d0
		andi.w	#2,d0
		move.w	word_1897C(pc,d0.w),$30(a0)
		btst	#1,d0
		beq.s	Obj41_loc_18976
		move.l	#MapUnc_19032,4(a0)

Obj41_loc_18976:				; CODE XREF: h+19F2j
		rts	
; ===========================================================================
word_1897C:	dc.w $F000		; 0
		dc.w $F600		; 1
; ===========================================================================

Obj41_loc_18980:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	8(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_Always_SingleCharacter
		btst	#3,$22(a0)
		beq.s	Obj41_loc_189A8
		bsr.s	Obj41_loc_189CA

Obj41_loc_189A8:				; CODE XREF: h+1A30j
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_Always_SingleCharacter
		btst	#4,$22(a0)
		beq.s	Obj41_loc_189C0
		bsr.s	Obj41_loc_189CA

Obj41_loc_189C0:				; CODE XREF: h+1A48j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_189CA:				; CODE XREF: h+1A32p h+1A4Ap
	;	tst.b	$2B(a1)
	;	beq.s	.noglow
	;	bsr.w	Silver_ResetGlow
	;	move.b	#0,$2B(a1)	; clear jumpdash flag

	.noglow:
		move.b	#0,$39(a1)
		move.w	#$100,$1C(a0)
		addq.w	#8,$C(a1)
		move.w	$30(a0),$12(a1)
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#$10,$1C(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_189FE
		move.w	#0,$10(a1)

Obj41_loc_189FE:				; CODE XREF: h+1A82j
		btst	#0,d0
		beq.s	Obj41_loc_18A3E
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#0,$2C(a1)
	;	move.b	#4,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18A2E
	;	move.b	#1,$2C(a1)

Obj41_loc_18A2E:				; CODE XREF: h+1AB2j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18A3E
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18A3E:				; CODE XREF: h+1A8Ej h+1AC0j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18A54
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

Obj41_loc_18A54:				; CODE XREF: h+1AD2j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18A66
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

Obj41_loc_18A66:				; CODE XREF: h+1AE4j
		sfx		sfx_Spring
		rts
; ===========================================================================

Obj41_loc_18A70:				; DATA XREF: h+1928o
		move.w	#$13,d1
		move.w	#$E,d2
		move.w	#$F,d3
		move.w	8(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w SolidObject_Always_SingleCharacter
		btst	#5,$22(a0)
		beq.s	Obj41_loc_18AB0
		move.b	$22(a0),d1
		move.w	8(a0),d0
		sub.w	8(a1),d0
		bcs.s	Obj41_loc_18AA8
		eori.b	#1,d1

Obj41_loc_18AA8:				; CODE XREF: h+1B2Ej
		andi.b	#1,d1
		bne.s	Obj41_loc_18AB0
		bsr.s	Obj41_loc_18AEE

Obj41_loc_18AB0:				; CODE XREF: h+1B20j h+1B38j
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		moveq	#4,d6
		bsr.w SolidObject_Always_SingleCharacter
		btst	#6,$22(a0)
		beq.s	Obj41_loc_18AE0
		move.b	$22(a0),d1
		move.w	8(a0),d0
		sub.w	8(a1),d0
		bcs.s	Obj41_loc_18AD8
		eori.b	#1,d1

Obj41_loc_18AD8:				; CODE XREF: h+1B2Ej
		andi.b	#1,d1
		bne.s	Obj41_loc_18AE0
		bsr.s	Obj41_loc_18AEE

Obj41_loc_18AE0:				; CODE XREF: h+1B50j h+1B68j
		bsr.w	Obj41_loc_18BC6
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18AEE:				; CODE XREF: h+1B3Ap h+1B6Ap ...
		move.w	#$300,$1C(a0)
		move.w	$30(a0),$10(a1)
		addq.w	#8,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18B1C
		bclr	#0,$22(a1)
		subi.w	#$10,8(a1)
		neg.w	$10(a1)

Obj41_loc_18B1C:				; CODE XREF: h+1B96j
	;	move.w	#$F,$2E(a1)
		move.w	$10(a1),$20(a1)
		btst	#2,$22(a1)
		bne.s	Obj41_loc_18B36
		move.b	#0,$1C(a1)
		cmpi.b	#1,($FFFFB000).w
		beq.s	Obj41_loc_18B36
		move.b	#3,$1C(a1)

Obj41_loc_18B36:				; CODE XREF: h+1BBAj
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_18B42
		move.w	#0,$12(a1)

Obj41_loc_18B42:				; CODE XREF: h+1BC6j
		btst	#0,d0
		beq.s	Obj41_loc_18B82
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18B72
	;	move.b	#3,$2C(a1)

Obj41_loc_18B72:				; CODE XREF: h+1BF6j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18B82
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18B82:				; CODE XREF: h+1BD2j h+1C04j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18B98
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

Obj41_loc_18B98:				; CODE XREF: h+1C16j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18BAA
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

Obj41_loc_18BAA:				; CODE XREF: h+1C28j
		bclr	#5,$22(a0)
		bclr	#6,$22(a0)
		bclr	#5,$22(a1)
		sfx		sfx_Spring
		rts
; ===========================================================================

Obj41_loc_18BC6:				; CODE XREF: h+1B6Cp
		cmpi.b	#3,$1C(a0)
		beq.w	Obj41_locret_18C7E
		move.w	8(a0),d0
		move.w	d0,d1
		addi.w	#$28,d1	; '('
		btst	#0,$22(a0)
		beq.s	Obj41_loc_18BE8
		move.w	d0,d1
		subi.w	#$28,d0	; '('

Obj41_loc_18BE8:				; CODE XREF: h+1C6Cj
		move.w	$C(a0),d2
		move.w	d2,d3
		subi.w	#$18,d2
		addi.w	#$18,d3
		btst	#1,$22(a1)
		bne.s	Obj41_loc_18C3C
		move.w	$20(a1),d4
		btst	#0,$22(a0)
		beq.s	Obj41_loc_18C10
		neg.w	d4

Obj41_loc_18C10:				; CODE XREF: h+1C98j
		tst.w	d4
		bmi.s	Obj41_loc_18C3C
		move.w	8(a1),d4
		cmp.w	d0,d4
		bcs.w	Obj41_loc_18C3C
		cmp.w	d1,d4
		bcc.w	Obj41_loc_18C3C
		move.w	$C(a1),d4
		cmp.w	d2,d4
		bcs.w	Obj41_loc_18C3C
		cmp.w	d3,d4
		bcc.w	Obj41_loc_18C3C
		move.w	d0,-(sp)
		bsr.w	Obj41_loc_18AEE
		move.w	(sp)+,d0

Obj41_loc_18C3C:				; CODE XREF: h+1C8Cj h+1C9Ej ...

Obj41_locret_18C7E:				; CODE XREF: h+1C58j h+1CD2j ...
		rts	
; ===========================================================================

Obj41_loc_18C80:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	8(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsr SolidObject_Always_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	Obj41_loc_18CA6
		bsr.s	Obj41_loc_18CC6

Obj41_loc_18CA6:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		moveq	#4,d6
		jsr SolidObject_Always_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	Obj41_loc_18CBC
		bsr.s	Obj41_loc_18CC6


Obj41_loc_18CBC:				; CODE XREF: h+1D44j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18CC6:				; CODE XREF: h+1D30p h+1D46p
		move.w	#$100,$1C(a0)
		subq.w	#8,$C(a1)
		move.w	$30(a0),$12(a1)
		neg.w	$12(a1)
		move.b	$28(a0),d0
		bpl.s	Obj41_loc_18CE6
		move.w	#0,$10(a1)

Obj41_loc_18CE6:				; CODE XREF: h+1D6Aj
		btst	#0,d0
		beq.s	Obj41_loc_18D26
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#0,$2C(a1)
	;	move.b	#4,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18D16
	;	move.b	#1,$2C(a1)

Obj41_loc_18D16:				; CODE XREF: h+1D9Aj
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18D26
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18D26:				; CODE XREF: h+1D76j h+1DA8j
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18D3C
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

Obj41_loc_18D3C:				; CODE XREF: h+1DBAj
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18D4E
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

Obj41_loc_18D4E:				; CODE XREF: h+1DCCj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		sfx		sfx_Spring
		rts
; ===========================================================================

Obj41_loc_18D6A:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	8(a0),d4
		lea	(byte_18FAA,pc),a2
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsr	SlopedSolid_SingleCharacter
		btst	#3,$22(a0)
		beq.s	Obj41_loc_18D92
		bsr.s	Obj41_loc_18DB4

Obj41_loc_18D92:				; CODE XREF: h+1E1Aj
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1
		moveq	#4,d6
		jsr	SlopedSolid_SingleCharacter
		btst	#4,$22(a0)
		beq.s	Obj41_loc_18DAA
		bsr.s	Obj41_loc_18DB4

Obj41_loc_18DAA:				; CODE XREF: h+1E32j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18DB4:				; CODE XREF: h+1E1Cp h+1E34p
	;	tst.b	$2B(a1)
	;	beq.s	.noglow
	;	bsr.w	Silver_ResetGlow
	;	move.b	#0,$2B(a1)	; clear jumpdash flag

	.noglow:
		move.b	#0,$39(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18DCA
		move.w	8(a0),d0
		subq.w	#4,d0
		cmp.w	8(a1),d0
		blo.s	Obj41_loc_18DD8
		rts	
; ===========================================================================

Obj41_loc_18DCA:				; CODE XREF: h+1E46j
		move.w	8(a0),d0
		addq.w	#4,d0
		cmp.w	8(a1),d0
		bhs.s	Obj41_loc_18DD8
		rts	
; ===========================================================================

Obj41_loc_18DD8:				; CODE XREF: h+1E52j h+1E60j
		move.w	#$500,$1C(a0)
		move.w	$30(a0),$12(a1)
		move.w	$30(a0),$10(a1)
		addq.w	#6,$C(a1)
		addq.w	#6,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18E10
		bclr	#0,$22(a1)
		subi.w	#$C,8(a1)
		neg.w	$10(a1)

Obj41_loc_18E10:				; CODE XREF: h+1E8Aj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#$10,$1C(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		btst	#0,d0
		beq.s	Obj41_loc_18E6C
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18E5C
	;	move.b	#3,$2C(a1)

Obj41_loc_18E5C:				; CODE XREF: h+1EE0j
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18E6C
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18E6C:				; CODE XREF: h+1EBCj h+1EEEj
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18E82
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

Obj41_loc_18E82:				; CODE XREF: h+1F00j
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18E94
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

Obj41_loc_18E94:				; CODE XREF: h+1F12j
		sfx		sfx_Spring
		rts
; ===========================================================================

Obj41_loc_18E9E:				; DATA XREF: h+1928o
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	8(a0),d4
		lea	(byte_18FC6,pc),a2
		lea	($FFFFB000).w,a1 ; a1=character
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SlopedSolid_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	Obj41_loc_18EC4
		bsr.s	Obj41_loc_18EE6

Obj41_loc_18EC4:				; CODE XREF: h+1F4Cj
		movem.l	(sp)+,d1-d4
		lea	($FFFFB380).w,a1 ; a1=character
		move.b	#4,d6
		bsr.w	SlopedSolid_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	Obj41_loc_18EDA
		bsr.s	Obj41_loc_18EE6

Obj41_loc_18EDA:				; CODE XREF: h+1F62j
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_loc_18EE6:				; CODE XREF: h+1F4Ep h+1F64p
		move.w	#$500,$1C(a0)
		move.w	$30(a0),$12(a1)
		neg.w	$12(a1)
		move.w	$30(a0),$10(a1)
		subq.w	#6,$C(a1)
		addq.w	#6,8(a1)
		bset	#0,$22(a1)
		btst	#0,$22(a0)
		bne.s	Obj41_loc_18F22
		bclr	#0,$22(a1)
		subi.w	#$C,8(a1)
		neg.w	$10(a1)

Obj41_loc_18F22:				; CODE XREF: h+1F9Cj
		bset	#1,$22(a1)
		bclr	#3,$22(a1)
		move.b	#2,$24(a1)
		move.b	$28(a0),d0
		btst	#0,d0
		beq.s	Obj41_loc_18F78
		move.w	#1,$20(a1)
		move.b	#1,$27(a1)
		move.b	#0,$1C(a1)
	;	move.b	#1,$2C(a1)
	;	move.b	#8,$2D(a1)
	;	btst	#1,d0
	;	bne.s	Obj41_loc_18F68
	;	move.b	#3,$2C(a1)

Obj41_loc_18F68:				; CODE XREF: h+1FECj
		btst	#0,$22(a1)
		beq.s	Obj41_loc_18F78
		neg.b	$27(a1)
		neg.w	$20(a1)

Obj41_loc_18F78:				; CODE XREF: h+1FC8j h+1FFAj
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	Obj41_loc_18F8E
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

Obj41_loc_18F8E:				; CODE XREF: h+200Cj
		cmpi.b	#8,d0
		bne.s	Obj41_loc_18FA0
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

Obj41_loc_18FA0:				; CODE XREF: h+201Ej
		sfx		sfx_Spring
		rts
; ===========================================================================
byte_18FAA:	dc.b $10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10, $E, $C, $A,  8; 0
					; DATA XREF: h+1E02t
		dc.b   6,  4,  2,  0,$FE,$FC,$FC,$FC,$FC,$FC,$FC,$FC; 16
byte_18FC6:	dc.b $F4,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F2,$F4,$F6,$F8; 0
					; DATA XREF: h+1F36t
		dc.b $FA,$FC,$FE,  0,  2,  4,  4,  4,  4,  4,  4,  4; 16
off_18FE2:	dc.w byte_18FEE-off_18FE2; 0 ; DATA XREF: h+1A4Co h+1B70o ...
		dc.w byte_18FF1-off_18FE2; 1
		dc.w byte_18FFD-off_18FE2; 2
		dc.w byte_19000-off_18FE2; 3
		dc.w byte_1900C-off_18FE2; 4
		dc.w byte_1900F-off_18FE2; 5
byte_18FEE:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   0		; 1
		dc.b $FF		; 2
byte_18FF1:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   1		; 1
		dc.b   0		; 2
		dc.b   0		; 3
		dc.b   2		; 4
		dc.b   2		; 5
		dc.b   2		; 6
		dc.b   2		; 7
		dc.b   2		; 8
		dc.b   2		; 9
		dc.b $FD		; 10
		dc.b   0		; 11
byte_18FFD:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   3		; 1
		dc.b $FF		; 2
byte_19000:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   4		; 1
		dc.b   3		; 2
		dc.b   3		; 3
		dc.b   5		; 4
		dc.b   5		; 5
		dc.b   5		; 6
		dc.b   5		; 7
		dc.b   5		; 8
		dc.b   5		; 9
		dc.b $FD		; 10
		dc.b   2		; 11
byte_1900C:	dc.b  $F		; 0 ; DATA XREF: h+206Eo
		dc.b   7		; 1
		dc.b $FF		; 2
byte_1900F:	dc.b   0		; 0 ; DATA XREF: h+206Eo
		dc.b   8		; 1
		dc.b   7		; 2
		dc.b   7		; 3
		dc.b   9		; 4
		dc.b   9		; 5
		dc.b   9		; 6
		dc.b   9		; 7
		dc.b   9		; 8
		dc.b   9		; 9
		dc.b $FD		; 10
		dc.b   4		; 11
		dc.b   0		; 12
; ----------------------------------------------------------------------------
; Unknown sprite mappings
; ----------------------------------------------------------------------------
Map_Obj41:
MapUnc_1901C:				; DATA XREF: h+1938o h+20A8o ...
		include 	"_maps\obj41r.asm"

; -------------------------------------------------------------------------------
; Unknown Sprite Mappings
; -------------------------------------------------------------------------------
MapUnc_19032:				; DATA XREF: h+19FAo h+20BEo ...
		include 	"_maps\obj41y.asm"

; ===========================================================================
		nop	
; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GotThroughAct:				; XREF: Obj3E_EndAct
		cmpi.b	#3,($FFFFFE11).w ; is act number 02 (act 3)?
		beq.s	Signpost_Exit	; if yes, branch
		tst.b	($FFFFFE1E).w
		beq.s	Signpost_Exit
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	Signpost_Exit	; if yes, branch
		move.w	($FFFFF700).w,d0
		move.w	($FFFFF72A).w,d1
		cmp.w	d1,d0		; has Sonic reached the	edge of	the level?
		blt.s	Signpost_Exit	; if not, branch
		move.w	d1,($FFFFF728).w
		bclr	#1,($FFFFFE2C).w	; disable invincibility
		clr.b	($FFFFFE1E).w	; stop time counter
		moveq	#$10,d0
		jsr	(LoadPLC2).l	; load title card patterns
		move.b	#1,($FFFFF7D6).w
		command	mus_ShoesOff ;	use normal speed
		move.b 	#0,($FFFFFFBB).w
		move.b	#1,($FFFFFE13).w

Signpost_Exit:
		rts	
; End of function GotThroughAct
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 54 - Quicksand (DDZ)
; ---------------------------------------------------------------------------
; Sprite_24020:
Obj54:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj54_Index(pc,d0.w),d1
	jmp	Obj54_Index(pc,d1.w)
; ===========================================================================
; off_2402E: Obj07_States:
Obj54_Index:
		dc.w Obj54_Init-Obj54_Index	; 0
		dc.w Obj54_Main-Obj54_Index	; 2
; ===========================================================================
; loc_24032:
Obj54_Init:
	addq.b	#2,$24(a0) ; => Obj07_Main
	move.b	$28(a0),d0
	lsl.w	#3,d0
	move.b	d0,$14(a0)
	move.w	$C(a0),$30(a0)
	move.b	#$30,$38(a0)

; loc_24054:
Obj54_Main:
	tst.w	($FFFFFE08).w
	bne.w	Obj54_End
	lea	($FFFFB000).w,a1 ; a1=character
	btst	#3,$22(a0)
	bne.s	Obj54_CheckKillChar1
	cmpi.b	#$30,$38(a0)
	bcc.s	Obj54_CheckSupportChar1
	addq.b	#2,$38(a0)
	bra.s	Obj54_CheckSupportChar1
; ---------------------------------------------------------------------------
; loc_24078:
Obj54_CheckKillChar1:
	tst.b	$38(a0)
	beq.s	Obj54_SuffocateCharacter
	subq.b	#1,$38(a0)

; loc_24082:
Obj54_CheckSupportChar1:
	moveq	#0,d1
	move.b	$14(a0),d1
	moveq	#0,d3
	move.b	$38(a0),d3
	lsr.w	#1,d3
	moveq	#3,d6
	move.w	8(a0),d4
	jsr	(PlatformObject_SingleCharacter).l ; stop the character from falling past the oil

	lea	($FFFFB380).w,a1 ; a1=character
	btst	#4,$22(a0)
	bne.s	Obj54_CheckKillChar2
	cmpi.b	#$30,$39(a0)
	bcc.s	Obj54_CheckSupportChar2
	addq.b	#2,$39(a0)
	bra.s	Obj54_CheckSupportChar2
; ---------------------------------------------------------------------------
; loc_24078:
Obj54_CheckKillChar2:
	tst.b	$39(a0)
	beq.s	Obj54_SuffocateCharacter
	subq.b	#1,$39(a0)

; loc_24082:
Obj54_CheckSupportChar2:
	moveq	#0,d1
	move.b	$14(a0),d1
	moveq	#0,d3
	move.b	$39(a0),d3
	lsr.w	#1,d3
	moveq	#4,d6
	move.w	8(a0),d4
	jmp	(PlatformObject_SingleCharacter).l ; stop the character from falling past the oil
; ---------------------------------------------------------------------------
; loc_240D6:
Obj54_SuffocateCharacter:
	move.b	#$30,$38(a0)
	not.b	d1
	and.b	d1,$22(a0)
	move.l	a0,-(sp)
	movea.l	a0,a2
	movea.l	a1,a0
	jsr	(KillSonic).l
	movea.l	(sp)+,a0 ; load 0bj address

Obj54_End:
	rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible lava tag (DDZ)
; ---------------------------------------------------------------------------
Map_obj54:
	include "_maps\obj54.asm"

; ---------------------------------------------------------------------------
; Routine to mark an enemy/monitor/ring	as destroyed
; ---------------------------------------------------------------------------

MarkObjGone:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Mark_ChkGone:
		move.w  $1E(a0),d0	; get address in respawn table
		beq.s   Mark_Delete   ; if it's zero, object was placed in debug mode
		movea.w d0,a2   ; load address into a2
		bclr	#7,(a2) ; clear respawn entry, so object can be loaded again

Mark_Delete:
		bra.w	DeleteObject

MarkObjGone3:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		rts	

; ---------------------------------------------------------------------------
; Solid	object subroutine (includes spikes, blocks, rocks etc)
;
; variables:
; d1 = width
; d2 = height /	2 (when	jumping)
; d3 = height /	2 (when	walking)
; d4 = x-axis position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SolidObject:
		tst.b	$25(a0)
		beq.w	loc_FAC8
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_F9FE
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_F9FE
		cmp.w	d2,d0
		bcs.s	loc_FA12

loc_F9FE:
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA12:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SolidObject71:				; XREF: Obj71_Solid
		tst.b	$25(a0)
		beq.w	loc_FAD0
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFB000).w,a1
		btst	#1,$22(a1)
		bne.s	loc_FA44
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.s	loc_FA44
		cmp.w	d2,d0
		bcs.s	loc_FA58

loc_FA44:
		bclr	#3,$22(a1)
		bclr	#3,$22(a0)
		clr.b	$25(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA58:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FAC8:
		tst.b	1(a0)
		bpl.w	loc_FB92

loc_FAD0:
		lea	($FFFFB000).w,a1
		move.w	8(a1),d0
		sub.w	8(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.b	$16(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	$C(a1),d3
		sub.w	$C(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	loc_FB92

loc_FB0E:
		tst.b	($FFFFB02A).w
		bmi.w	loc_FB92
		cmpi.b	#6,($FFFFB024).w
		bcc.w	loc_FB92
		tst.w	($FFFFFE08).w
		bne.w	loc_FBAC
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_FB36
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_FB36:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_FB44
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_FB44:
		cmp.w	d1,d5
		bhi.w	loc_FBB0
		cmpi.w	#4,d1
		bls.s	loc_FB8C
		tst.w	d0
		beq.s	loc_FB70
		bmi.s	loc_FB5E
		tst.w	$10(a1)
		bmi.s	loc_FB70
		bra.s	loc_FB64
; ===========================================================================

loc_FB5E:
		tst.w	$10(a1)
		bpl.s	loc_FB70

loc_FB64:
		move.w	#0,$20(a1)	; stop Sonic moving
		move.w	#0,$10(a1)

loc_FB70:
		sub.w	d0,8(a1)
		btst	#1,$22(a1)
		bne.s	loc_FB8C
		bset	#5,$22(a1)
		bset	#5,$22(a0)
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB8C:
		bsr.s	loc_FBA0
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB92:
		btst	#5,$22(a0)
		beq.s	loc_FBAC
		cmp.b	#2,$1C(a1)	; check if in jumping/rolling animation
		beq.s	loc_FBA0
		cmp.b	#$17,$1C(a1)	; check if in drowning animation
		beq.s	loc_FBA0
		cmp.b	#$1A,$1C(a1)	; check if in hurt animation
		beq.s	loc_FBA0
		move.w	#1,$1C(a1)	; use walking animation

loc_FBA0:
		bclr	#5,$22(a0)
		bclr	#5,$22(a1)

loc_FBAC:
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FBB0:
		tst.w	d3
		bmi.s	loc_FBBC
		cmpi.w	#$10,d3
		bcs.s	loc_FBEE
		bra.s	loc_FB92
; ===========================================================================

loc_FBBC:
		tst.w	$12(a1)
		beq.s	loc_FBD6
		bpl.s	loc_FBD2
		tst.w	d3
		bpl.s	loc_FBD2
		sub.w	d3,$C(a1)
		move.w	#0,$12(a1)	; stop Sonic moving

loc_FBD2:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBD6:
		btst	#1,$22(a1)
		bne.s	loc_FBD2
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	KillSonic
		movea.l	(sp)+,a0
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBEE:
		subq.w	#4,d3
		moveq	#0,d1
		move.b	$14(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	8(a1),d1
		sub.w	8(a0),d1
		bmi.s	loc_FC28
		cmp.w	d2,d1
		bcc.s	loc_FC28
		tst.w	$12(a1)
		bmi.s	loc_FC28
		sub.w	d3,$C(a1)
		subq.w	#1,$C(a1)
		bsr.s	sub_FC2C
		move.b	#2,$25(a0)
		bset	#3,$22(a0)
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FC28:
		moveq	#0,d4
		rts	
; End of function SolidObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_FC2C:				; XREF: SolidObject
		btst	#3,$22(a1)
		beq.s	loc_FC4E
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)
		clr.b	$25(a2)

loc_FC4E:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,$26(a1)
		move.w	#0,$12(a1)
		move.w	$10(a1),$20(a1)
		btst	#1,$22(a1)
		beq.s	loc_FC84
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Player_ResetOnFloor
		movea.l	(sp)+,a0

loc_FC84:
		bset	#3,$22(a1)
		bset	#3,$22(a0)
		rts	
; End of function sub_FC2C

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5C - metal girders in foreground (AAZ)
; ---------------------------------------------------------------------------

Obj5C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj5C_Index(pc,d0.w),d1
		jmp	Obj5C_Index(pc,d1.w)
; ===========================================================================
Obj5C_Index:	dc.w Obj5C_Main-Obj5C_Index
		dc.w Obj5C_Display-Obj5C_Index
; ===========================================================================

Obj5C_Main:				; XREF: Obj5C_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj5C,4(a0)
		move.w	#$83CC,2(a0)
		move.b	#$10,$14(a0)

Obj5C_Display:				; XREF: Obj5C_Index
		move.l	($FFFFF700).w,d1
		add.l	d1,d1
		swap	d1
		neg.w	d1
		move.w	d1,8(a0)
		move.l	($FFFFF704).w,d1
		add.l	d1,d1
		swap	d1
		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,$A(a0)
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal girders in foreground	(AAZ)
; ---------------------------------------------------------------------------
Map_obj5C:
	include "_maps\obj5C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1B - water surface (EEZ)
; ---------------------------------------------------------------------------

Obj1B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj1B_Index(pc,d0.w),d1
		jmp	Obj1B_Index(pc,d1.w)
; ===========================================================================
Obj1B_Index:	dc.w Obj1B_Main-Obj1B_Index
		dc.w Obj1B_Action-Obj1B_Index
; ===========================================================================

Obj1B_Main:				; XREF: Obj1B_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj1B,4(a0)
		move.w	#$A380,2(a0)
		move.b	#4,1(a0)
		move.b	#$80,$14(a0)
		move.w	8(a0),$30(a0)

Obj1B_Action:				; XREF: Obj1B_Index
		move.w	($FFFFF700).w,d1
		andi.w	#$FFE0,d1
		add.w	$30(a0),d1
		btst	#0,($FFFFFE05).w
		beq.s	loc_11114
		addi.w	#$20,d1

loc_11114:
		move.w	d1,8(a0)	; match	obj x-position to screen position
		move.w	($FFFFF646).w,d1
		move.w	d1,$C(a0)	; match	obj y-position to water	height
		tst.b	$32(a0)
		bne.s	Obj1B_Animate
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq.s	loc_1114A	; if not, branch
		addq.b	#3,$1A(a0)	; use different	frames
		move.b	#1,$32(a0)	; stop animation
		bra.s	Obj1B_Display
; ===========================================================================

Obj1B_Animate:				; XREF: loc_11114
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	Obj1B_Display	; if yes, branch
		move.b	#0,$32(a0)	; resume animation
		subq.b	#3,$1A(a0)	; use normal frames

loc_1114A:				; XREF: loc_11114
		subq.b	#1,$23(a0)
		bpl.s	Obj1B_Display
		move.b	#7,$23(a0)
		addq.b	#1,$1A(a0)
		cmpi.b	#3,$1A(a0)
		bcs.s	Obj1B_Display
		move.b	#0,$1A(a0)

Obj1B_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - water surface (EEZ)
; ---------------------------------------------------------------------------
Map_obj1B:
	include "_maps\obj1B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 71 - invisible	solid blocks
; ---------------------------------------------------------------------------

Obj71:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj71_Index(pc,d0.w),d1
		jmp	Obj71_Index(pc,d1.w)
; ===========================================================================
Obj71_Index:	dc.w Obj71_Main-Obj71_Index
		dc.w Obj71_Solid-Obj71_Index
; ===========================================================================

Obj71_Main:				; XREF: Obj71_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj71,4(a0)
		move.w	#$8680,2(a0)
		ori.b	#4,1(a0)
		move.b	$28(a0),d0	; get object type
		move.b	d0,d1
		andi.w	#$F0,d0		; read only the	1st byte
		addi.w	#$10,d0
		lsr.w	#1,d0
		move.b	d0,$14(a0)	; set object width
		andi.w	#$F,d1		; read only the	2nd byte
		addq.w	#1,d1
		lsl.w	#3,d1
		move.b	d1,$16(a0)	; set object height

Obj71_Solid:				; XREF: Obj71_Index
		bsr.w	ChkObjOnScreen
		bne.s	Obj71_ChkDel
		moveq	#0,d1
		move.b	$14(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$16(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	8(a0),d4
		bsr.w	SolidObject71

Obj71_ChkDel:
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj71_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj71_Delete	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj71_Delete

Obj71_Done:
		tst.w	($FFFFFE08).w	; are you using	debug mode?
		beq.s	Obj71_NoDisplay	; if not, branch
		jmp	DisplaySprite	; if yes, display the object
; ===========================================================================

Obj71_NoDisplay:
		rts	
; ===========================================================================

Obj71_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible solid blocks
; ---------------------------------------------------------------------------
Map_obj71:
	include "_maps\obj71.asm"

; ---------------------------------------------------------------------------
; Object 60 - Orbinaut enemy (EEZ, AAZ, FFZ)
; ---------------------------------------------------------------------------

Obj60:				; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj60_Index(pc,d0.w),d1
		jmp	Obj60_Index(pc,d1.w)
; ===========================================================================
Obj60_Index:	dc.w Obj60_Main-Obj60_Index
		dc.w Obj60_ChkSonic-Obj60_Index
		dc.w Obj60_Display-Obj60_Index
		dc.w Obj60_MoveOrb-Obj60_Index
		dc.w Obj60_ChkDel2-Obj60_Index
; ===========================================================================

Obj60_Main:				; XREF: Obj60_Index
		move.l	#Map_obj60,4(a0)
		make_art_tile	ArtTile_Orbinaut,1,1
		ori.b	#4,1(a0)
		move.w	#$200,$18(a0)
		move.b	#$B,$20(a0)
		move.b	#$C,$14(a0)
		moveq	#0,d2
		move.w	d2,$2A(a0)
		lea	$37(a0),a2
		movea.l	a2,a3
		addq.w	#1,a2
		moveq	#3,d1

Obj60_MakeOrbs:
		bsr.w	SingleObjLoad2
		bne.s	loc_11D90
		addq.b	#1,(a3)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	0(a0),0(a1)	; load spiked orb object
		move.b	#6,$24(a1)
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		ori.b	#4,1(a1)
		move.w	#$200,$18(a1)
		move.b	#8,$14(a1)
		move.b	#8,$16(a1)
		move.b	#8,$17(a1)
		move.b	#3,$1A(a1)
		move.b	#$98,$20(a1)
		move.b	d2,$26(a1)
		addi.b	#$40,d2
		move.b	#0,$27(a1)
		move.l	a0,$3C(a1)
		dbf	d1,Obj60_MakeOrbs ; repeat sequence 3 more times

loc_11D90:
		moveq	#1,d0
		btst	#3,$28(a0)
		beq.s	.short
		addq.b	#1,d0

	.short:
		btst	#0,$22(a0)
		beq.s	Obj60_Move
		neg.w	d0

Obj60_Move:
		move.b	d0,$36(a0)
		move.b	#2,$24(a0)
		btst	#5,$28(a0)
		bne.s	.shoot
		addq.b	#2,$24(a0)	; skip the firing rountine

	.shoot:
		btst	#4,$28(a0)
		bne.s	.dontmove
		move.w	#-$40,$10(a0)	; move orbinaut	to the left

	.dontmove:
		btst	#0,$22(a0)	; is orbinaut reversed?
		beq.s	.range	; if not, branch
		neg.w	$10(a0)		; move orbinaut	to the right

	.range:
		move.b	#4,$2A(a0)
		move.b	#4,$2B(a0)
		btst	#6,$28(a0)
		beq.s	locret_11DBC
		move.b	#3,$2A(a0)
		move.b	#5,$2B(a0)

locret_11DBC:
		rts	
; ===========================================================================

Obj60_ChkSonic:				; XREF: Obj60_Index
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		bcc.s	loc_11DCA
		neg.w	d0

loc_11DCA:
		cmpi.w	#$A0,d0		; is Sonic within $A0 pixels of	orbinaut?
		bcc.s	Obj60_Animate	; if not, branch
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		bcc.s	loc_11DDC
		neg.w	d0

loc_11DDC:
		cmpi.w	#$50,d0		; is Sonic within $50 pixels of	orbinaut?
		bcc.s	Obj60_Animate	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	Obj60_Animate	; if yes, branch
		move.b	#1,$1C(a0)	; use "angry" animation

Obj60_Animate:
		lea	(Ani_obj60).l,a1
		bsr.w	AnimateSprite
		bra.w	Obj60_ChkDel
; ===========================================================================

Obj60_Display:				; XREF: Obj60_Index
		bsr.w	SpeedToPos

Obj60_ChkDel:				; XREF: Obj60_Animate
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj60_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj60_ChkGone:				; XREF: Obj60_ChkDel
		move.w  $1E(a0),d0	; get address in respawn table
		beq.s   loc_11E34   ; if it's zero, object was placed in debug mode
		movea.w d0,a2   ; load address into a2
		bclr	#7,(a2) ; clear respawn entry, so object can be loaded again

loc_11E34:
		lea	$37(a0),a2
		moveq	#0,d2
		move.b	(a2)+,d2
		subq.w	#1,d2
		bcs.s	Obj60_Delete

loc_11E40:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a1
		cmpi.b	#$B,(a1)
		beq.s	.dontdelete
		bsr.w	DeleteObject2

	.dontdelete:
		dbf	d2,loc_11E40

Obj60_Delete:
		bra.w	DeleteObject
; ===========================================================================

Obj60_MoveOrb:				; XREF: Obj60_Index
		movea.l	$3C(a0),a1
		cmpi.b	#$60,0(a1)
		beq.s	.nodelete
		cmpi.b	#$B,0(a1)
		bne.w	DeleteObject
		jsr	ObjectFall
		bsr.w	SpeedToPos
		bra.w	DisplaySprite

	.nodelete:
		cmpi.b	#2,$1A(a1)
		bne.s	Obj60_Circle
		cmpi.b	#$40,$26(a0)
		bne.s	Obj60_Circle
		addq.b	#2,$24(a0)
		subq.b	#1,$37(a1)
		bne.s	Obj60_FireOrb
		addq.b	#2,$24(a1)

Obj60_FireOrb:
		move.w	#-$200,$10(a0)	; move orb to the left (quickly)
		btst	#0,$22(a1)
		beq.s	Obj60_Display2
		neg.w	$10(a0)

Obj60_Display2:
		bsr.w	SpeedToPos
		bra.w	DisplaySprite

Obj60_Circle:
		moveq	#0,d0
		move.b	$28(a1),d0
		andi.b	#7,d0
		lsl.b	d0
		move.w	Obj60_BallIndex(pc,d0.w),d1
		jmp	Obj60_BallIndex(pc,d1.w)
; ===========================================================================
Obj60_BallIndex:	dc.w Obj60_Revolve-Obj60_BallIndex
		dc.w Obj60_Horz-Obj60_BallIndex
		dc.w Obj60_Vert-Obj60_BallIndex
		dc.w Obj60_HorzVert-Obj60_BallIndex
		dc.w Obj60_HorzVert-Obj60_BallIndex
		dc.w Obj60_Clock-Obj60_BallIndex
		dc.w Obj60_DiagHorz-Obj60_BallIndex
		dc.w Obj60_DiagVert-Obj60_BallIndex
; ===========================================================================

Obj60_Revolve:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d2
		asr.w	d2,d1
		add.w	8(a1),d1
		move.w	d1,8(a0)
		asr.w	d2,d0
		add.w	$C(a1),d0
		move.w	d0,$C(a0)
		move.b	$36(a1),d0
		add.b	d0,$26(a0)
		bra.w	DisplaySprite

Obj60_Horz:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d3
		asr.w	d3,d1
		add.w	8(a1),d1
		move.w	d1,8(a0)
		move.w	$C(a1),$C(a0)
		move.b	$36(a1),d2
		add.b	d2,$26(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d0
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d0
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite
	
Obj60_Vert:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d3
		asr.w	d3,d0
		add.w	$C(a1),d0
		move.w	d0,$C(a0)
		move.w	8(a1),8(a0)
		move.b	$36(a1),d2
		add.b	d2,$26(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d1
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d1
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite

Obj60_HorzVert:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d3
		asr.w	d3,d1
		move.w	d1,d2
		cmpi.b	#2,$28(a1)
		beq.s	.notflipped
		neg.w	d1

	.notflipped:
		add.w	8(a1),d1
		move.w	d1,8(a0)
		add.w	$C(a1),d2
		move.w	d2,$C(a0)
		move.b	$36(a1),d2
		add.b	d2,$26(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d0
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d0
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite

Obj60_Clock:
		moveq	#0,d3
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.w	d0,d2
		move.w	d0,d3
		move.w	d1,d4
		move.b	$27(a0),d0
		jsr	(CalcSine).l
		muls.w	d1,d2
		move.b	$2B(a1),d5
		asl.l	d5,d2
		swap	d2
		muls.w	d0,d3
		asl.l	d5,d3
		swap	d3

		add.w	8(a1),d3
		move.w	d3,8(a0)
		add.w	$C(a1),d2
		move.w	d2,$C(a0)
		move.b	$36(a1),d3
		add.b	d3,$27(a0)
		asl.b	d3
		add.b	d3,$26(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d4
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d4
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite

Obj60_DiagHorz:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d4
		asr.w	d4,d1
		move.w	d0,d2
		move.w	d1,d3
		move.b	$27(a0),d0
		jsr	(CalcSine).l
		asr.w	d4,d0
		add.w	8(a1),d3
		move.w	d3,8(a0)
		add.w	$C(a1),d0
		move.w	d0,$C(a0)
		move.b	$36(a1),d3
		add.b	d3,$26(a0)
		asl.b	d3
		add.b	d3,$27(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d2
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d2
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite

Obj60_DiagVert:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		move.b	$2A(a1),d4
		asr.w	d4,d0
		move.w	d0,d2
		move.w	d1,d3
		move.b	$27(a0),d0
		jsr	(CalcSine).l
		asr.w	d4,d1
		add.w	8(a1),d1
		move.w	d1,8(a0)
		add.w	$C(a1),d2
		move.w	d2,$C(a0)
		move.b	$36(a1),d2
		add.b	d2,$26(a0)
		asl.b	d2
		add.b	d2,$27(a0)
		move.w	#$100,$18(a0)
		cmpi.w	#$80,d3
		bgt.w	DisplaySprite
		move.w	#$200,$18(a0)
		cmpi.w	#-$80,d3
		blt.w	DisplaySprite
		move.w	#$180,$18(a0)
		bra.w	DisplaySprite

; ===========================================================================

Obj60_ChkDel2:				; XREF: Obj60_Index
		bsr.w	SpeedToPos
		tst.b	1(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj60:
	include "_anim\obj60.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Orbinaut enemy (EEZ,	AAZ, FFZ)
; ---------------------------------------------------------------------------
Map_obj60:
	include "_maps\obj60.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 64 - bubbles (EEZ)
; ---------------------------------------------------------------------------

Obj64:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj64_Index(pc,d0.w),d1
		jmp	Obj64_Index(pc,d1.w)
; ===========================================================================
Obj64_Index:	dc.w Obj64_Main-Obj64_Index
		dc.w Obj64_Animate-Obj64_Index
		dc.w Obj64_ChkWater-Obj64_Index
		dc.w Obj64_Display2-Obj64_Index
		dc.w Obj64_Delete3-Obj64_Index
		dc.w Obj64_BblMaker-Obj64_Index
; ===========================================================================

Obj64_Main:				; XREF: Obj64_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj64,4(a0)
		move.w	#$A390,2(a0)
		move.b	#$84,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$80,$18(a0)
		move.b	$28(a0),d0	; get object type
		bpl.s	Obj64_Bubble	; if type is $0-$7F, branch
		addq.b	#8,$24(a0)
		andi.w	#$7F,d0		; read only last 7 bits	(deduct	$80)
		move.b	d0,$32(a0)
		move.b	d0,$33(a0)
		move.b	#6,$1C(a0)
		bra.w	Obj64_BblMaker
; ===========================================================================

Obj64_Bubble:				; XREF: Obj64_Main
		move.b	d0,$1C(a0)
		move.w	8(a0),$30(a0)
		move.w	#-$88,$12(a0)	; float	bubble upwards
		jsr	(RandomNumber).l
		move.b	d0,$26(a0)

Obj64_Animate:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		cmpi.b	#6,$1A(a0)
		bne.s	Obj64_ChkWater
		move.b	#1,$2E(a0)

Obj64_ChkWater:				; XREF: Obj64_Index
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is bubble underwater?
		bcs.s	Obj64_Wobble	; if yes, branch

Obj64_Burst:				; XREF: Obj64_Wobble
		move.b	#6,$24(a0)
		addq.b	#3,$1C(a0)	; run "bursting" animation
		bra.w	Obj64_Display2
; ===========================================================================

Obj64_Wobble:				; XREF: Obj64_ChkWater
		move.b	$26(a0),d0
		addq.b	#1,$26(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)	; change bubble's horizontal position
		tst.b	$2E(a0)
		beq.s	Obj64_Display
		bsr.w	Obj64_ChkSonic	; has Sonic touched the	bubble?
		beq.s	Obj64_Display	; if not, branch
		btst	#6,($FFFFFE2C).w	; does Sonic have a bubble shield?
		bne.s	locret_2FC7C	; if so, branch

		jsr	ResumeMusic	; cancel countdown music
		sfx		sfx_Bubble ;	play collecting	bubble sound
		lea	($FFFFB000).w,a1
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$20(a1)
		move.b	#$15,$1C(a1)
		move.w	#$23,$2E(a1)
		move.b	#0,$3C(a1)
		bclr	#5,$22(a1)
		btst	#2,$22(a1)
		beq.w	Obj64_Burst
		bclr	#2,$22(a1)
		move.b	#$13,$16(a1)
		move.b	#9,$17(a1)
		subq.w	#5,$C(a1)
		bra.w	Obj64_Burst

locret_2FC7C:
		rts
; ===========================================================================

Obj64_Display:				; XREF: Obj64_Wobble
		bsr.w	SpeedToPos
		tst.b	1(a0)
		bpl.s	Obj64_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj64_Display2:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		tst.b	1(a0)
		bpl.s	Obj64_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete2:
		jmp	DeleteObject
; ===========================================================================

Obj64_Delete3:				; XREF: Obj64_Index
		bra.w	DeleteObject
; ===========================================================================

Obj64_BblMaker:				; XREF: Obj64_Index
		tst.w	$36(a0)
		bne.s	loc_12874
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is bubble maker underwater?
		bcc.w	Obj64_ChkDel	; if not, branch
		tst.b	1(a0)
		bpl.w	Obj64_ChkDel
		subq.w	#1,$38(a0)
		bpl.w	loc_12914
		move.w	#1,$36(a0)

loc_1283A:
		jsr	(RandomNumber).l
		move.w	d0,d1
		andi.w	#7,d0
		cmpi.w	#6,d0
		bcc.s	loc_1283A

		move.b	d0,$34(a0)
		andi.w	#$C,d1
		lea	(Obj64_BblTypes).l,a1
		adda.w	d1,a1
		move.l	a1,$3C(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_12872
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)

loc_12872:
		bra.s	loc_1287C
; ===========================================================================

loc_12874:				; XREF: Obj64_BblMaker
		subq.w	#1,$38(a0)
		bpl.w	loc_12914

loc_1287C:
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		move.w	d0,$38(a0)
		bsr.w	SingleObjLoad
		bne.s	loc_128F8
		move.b	#$64,0(a1)	; load bubble object
		move.w	8(a0),8(a1)
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,8(a1)
		move.w	$C(a0),$C(a1)
		moveq	#0,d0
		move.b	$34(a0),d0
		movea.l	$3C(a0),a2
		move.b	(a2,d0.w),$28(a1)
		btst	#7,$36(a0)
		beq.s	loc_128F8
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_128E4
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,$28(a1)

loc_128E4:
		tst.b	$34(a0)
		bne.s	loc_128F8
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,$28(a1)

loc_128F8:
		subq.b	#1,$34(a0)
		bpl.s	loc_12914
		jsr	(RandomNumber).l
		andi.w	#$7F,d0
		addi.w	#$80,d0
		add.w	d0,$38(a0)
		clr.w	$36(a0)

loc_12914:
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite

Obj64_ChkDel:				; XREF: Obj64_BblMaker
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj64_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.w	DeleteObject	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.w	DeleteObject

Obj64_Done:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0
		bcs.w	DisplaySprite
		rts	
; ===========================================================================
; bubble production sequence

; 0 = small bubble, 1 =	large bubble

Obj64_BblTypes:	dc.b 0,	1, 0, 0, 0, 0, 1, 0, 0,	0, 0, 1, 0, 1, 0, 0, 1,	0

; ===========================================================================

Obj64_ChkSonic:				; XREF: Obj64_Wobble
		lea	($FFFFB000).w,a1
		tst.b	$2A(a1)
		bmi.s	loc_12998
		move.w	8(a1),d0
		move.w	8(a0),d1
		subi.w	#$10,d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$20,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		move.w	$C(a1),d0
		move.w	$C(a0),d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$10,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		moveq	#1,d0
		rts	
; ===========================================================================

loc_12998:
		moveq	#0,d0
		rts	
; ===========================================================================
Ani_obj64:
	include "_anim\obj64.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - bubbles (EEZ)
; ---------------------------------------------------------------------------
Map_obj64:
	include "_maps\obj64.asm"

; ---------------------------------------------------------------------------
; Spin Dash Dust
; ---------------------------------------------------------------------------
Obj05:
		moveq	#0,d0
		move.b	$24(a0),d0 
		move.w	Obj05_Index(pc,d0.w),d1
		jmp	Obj05_Index(pc,d1.w)
; ===========================================================================
Obj05_Index:
		dc.w Obj05_Init-Obj05_Index
		dc.w Obj05_Main-Obj05_Index
		dc.w DeleteObject-Obj05_Index
		dc.w Obj05_CheckSkid-Obj05_Index
; ===========================================================================
Obj05_Init:
		addq.b	#2,$24(a0)
		move.l	#Map_Dust,4(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		make_art_tile	ArtTile_Dust,3,1
		move.w	#$B000,$3E(a0)
		move.w	#(ArtTile_Dust*$20),$3C(a0)	
		cmpa.w	#$B1C0,a0
		beq.s	Obj05_CheckTails
		make_art_tile	ArtTile_Dust2,3,1
		move.w	#$B380,$3E(a0)
		move.w	#(ArtTile_Dust2*$20),$3C(a0)	
		cmpi.b	#1,(Current_Partner).w
		bne.s	Obj05_Main
		move.b	#1,$34(a0)
		bra.s	Obj05_Main

Obj05_CheckTails:
		cmpi.b	#1,(Current_Character).w
		bne.s	Obj05_Main
		move.b	#1,$34(a0)

; ===========================================================================
Obj05_Main:
		movea.w	$3E(a0),a2 ; a2=character
		moveq	#0,d0
		move.b	$1C(a0),d0	; use current animation as a secondary routine counter
		add.w	d0,d0
		move.w	Obj05_DisplayModes(pc,d0.w),d1
		jmp	Obj05_DisplayModes(pc,d1.w)
; ===========================================================================
; off_1DDA4:
Obj05_DisplayModes:
		dc.w Obj05_Display-Obj05_DisplayModes	; 0
		dc.w Obj05_MdSplash-Obj05_DisplayModes	; 2
		dc.w Obj05_MdSpindashDust-Obj05_DisplayModes	; 4
		dc.w Obj05_Display-Obj05_DisplayModes	; 6
; ===========================================================================
; loc_1DDAC:
Obj05_MdSplash:
		move.w	($FFFFF646).w,$C(a0)
		tst.b	$1D(a0)
		bne.s	Obj05_Display
		move.w	8(a2),8(a0)
		move.b	#0,$22(a0)
		andi.w	#$7FFF,2(a0)
		bra.s	Obj05_Display
; ===========================================================================
; loc_1DDCC:
Obj05_MdSpindashDust:
	;	tst.b	$39(a2)
	;	beq.s	Obj05_ResetDisplayMode
		move.w	8(a2),8(a0)
		move.w	$C(a2),$C(a0)
		move.b	$22(a2),$22(a0)
		andi.b	#1,$22(a0)
		tst.b	$34(a0)
		beq.s	Obj05_MdSpindashTails
		subi.w	#4,$C(a0)

Obj05_MdSpindashTails:
		tst.b	$1D(a0)
		bne.s	Obj05_Display
		andi.w	#$7FFF,2(a0)
		tst.w	2(a2)
		bpl.s	Obj05_Display
		ori.w	#-$8000,2(a0)
; ===========================================================================

Obj05_Display:
		lea	(Ani_Dust).l,a1
		jsr	AnimateSprite
		bsr.w	Obj05_LoadArt
		jmp	DisplaySprite

Obj05_ResetDisplayMode:
		move.b	#0,$1C(a0)
		rts
; ===========================================================================
; loc_1DE4A:
Obj05_CheckSkid:
		movea.w	$3E(a0),a2 ; a2=character
		moveq	#$10,d1
		cmpi.b	#$D,$1C(a2)	; SonAni_Stop
		beq.s	Obj05_SkidDust
		moveq	#6,d1	; move different y offset to d1
		cmpi.b	#$99,0(a2)	; playing as Knuckles?
		bne.s	Obj05_CheckSkid2
		cmpi.b	#3,$2B(a2)	; check for sliding
		beq.s	Obj05_SkidDust

Obj05_CheckSkid2:
		move.b	#2,$24(a0)
		move.b	#0,$32(a0)
		rts
; ===========================================================================
; loc_1DE64:
Obj05_SkidDust:
		subq.b	#1,$32(a0)
		bpl.w	return_1DF36
		move.b	#3,$32(a0)
		bsr.w	SingleObjLoad
		bne.w	return_1DF36
		move.b	0(a0),0(a1) ; load obj05
		move.w	8(a2),8(a1)
		move.w	$C(a2),$C(a1)
		tst.b	$34(a0)
		beq.s	Obj05_SkidTails
		subi.w	#4,d1

Obj05_SkidTails:
		add.w	d1,$C(a1)
		move.b	#0,$22(a1)
		move.b	#3,$1C(a1)
		addq.b	#2,$24(a1)
		move.l	4(a0),4(a1)
		move.b	1(a0),1(a1)
		move.w	#$80,$18(a1)
		move.b	#4,$14(a1)
		move.w	2(a0),2(a1)
		move.w	$3E(a0),$3E(a1)
		andi.w	#$7FFF,2(a1)
		tst.w	2(a2)
		bpl.s	Obj05_LoadArt
		ori.w	#$8000,2(a1)
; ===========================================================================
Obj05_LoadArt:
		moveq	#0,d0
		move.b	$1A(a0),d0
		cmp.b	$30(a0),d0
		beq.s	return_1DF36
		move.b	d0,$30(a0)
		lea	(DynPLC_Dust).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	return_1DF36
		move.w	$3C(a0),d4

	.loop:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_Dust,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(QueueDMATransfer).l
		dbf	d5,.loop

	return_1DF36:
		rts

Ani_Dust:
	include	"_anim\obj05.asm"

Map_Dust:
	include	"_maps\obj05.asm"

DynPLC_Dust:
	include	"_maps\Spindash Dust DPLC.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 01 - Sonic
; ---------------------------------------------------------------------------

Obj01:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj01_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj01_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj01_Index(pc,d0.w),d1
		jmp	Obj01_Index(pc,d1.w)
; ===========================================================================
Obj01_Index:	dc.w Obj01_Main-Obj01_Index
		dc.w Obj01_Control-Obj01_Index
		dc.w Obj01_Hurt-Obj01_Index
		dc.w Obj01_Death-Obj01_Index
		dc.w Obj01_ResetLevel-Obj01_Index
; ===========================================================================

Obj01_Main:				; XREF: Obj01_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Sonic,4(a0)
		make_art_tile	ArtTile_Main,0,1
		btst	#7,$22(a0)
		beq.s	Obj01_Cont
		make_art_tile	ArtTile_Partner,0,1

Obj01_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$1E,$28(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_CreateDust
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w
		bra.s	Obj01_Control

Obj01_CreateDust:
		move.b	#5,($FFFFB400).w

Obj01_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.w	loc_12C58
		bsr.s	Character_PanCamera
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.w	loc_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.w	loc_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	horizontally pan the camera view ahead of the player
; (Ported from the US version of Sonic CD's "R11A__.MMD" by Nat The Porcupine)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_PanCamera:
		cmpi.b	#2,($FFFFFFEF).w
		beq.w	.end_pan
		move.w	(v_camera_pan).w,d1		; get the current camera pan value
		move.w	$20(a0),d0		; get sonic's inertia
		move.w	d0,d2
		cmpi.b	#1,(Current_Character).w
		bne.s	.nottails
		tst.b	$2B(a0)
		beq.s	.notsilver
		move.w	$10(a0),d0
		move.w	d0,d2
		bra.s	.notsilver

	.nottails:
		cmpi.b	#2,(Current_Character).w
		bne.s	.notknuckles
		cmpi.b	#1,$2B(a0)
		bne.s	.notsilver
		tst.w	$10(a0)
		bpl.s	.abs_inertia
		neg.w	d2
		bra.s	.abs_inertia

	.notknuckles:
		cmpi.b	#4,(Current_Character).w
		bne.s	.notsilver
		btst	#0,$2B(a0)
		beq.s	.notsilver
		move.w	$10(a0),d0
		move.w	d0,d2

	.notsilver:
		tst.w	d0
		bpl.s	.abs_inertia			; if sonic's inertia is positive, branch ahead
		neg.w	d0						; otherwise, we negate it to get the absolute value

	.abs_inertia:
		asr.w	#5,d2
		neg.w	d2
		addi.w	#160,d2
		tst.b	$39(a0)					; is sonic charging up a spin dash?
		bne.s	.pan_spin2					; if not, branch
		tst.b	($FFFFFFEF).w
		bne.s	.pan_spin

	.skip:
		cmpi.w	#$100,d0				; is sonic's inertia greater than $100
		bcs.s	.reset_pan				; if not, recenter the screen (if needed)
		tst.w	$10(a0)			; otherwise, check the direction of inertia (by subtracting it from 0)
		bpl.s	.pan_left				; if the result was positive, then inertia was negative, so we pan the screen left

	.pan_right:
		cmpi.w	#224,d1
		bgt.s	.update_pan				; if not, branch
		cmp.w	d2,d1					; is the pan value greater than 224 pixels?
		beq.s	.update_pan				; if not, branch
		subq.w	#1,d1					; subtract 1 from the pan value
		cmp.w	d2,d1					; is the pan value greater than 224 pixels?
		bge.s	.update_pan				; if not, branch
		addq.w	#2,d1					; add 2 to the pan value
		bra.s	.update_pan				; branchs

; ---------------------------------------------------------------------------

	.pan_left:
		cmpi.w	#96,d1
		blt.s	.update_pan				; if not, branch
		cmp.w	d2,d1					; is the pan value greater than 96 pixels?
		beq.s	.update_pan				; if not, branch
		addq.w	#1,d1					; add 1 to the pan value
		cmp.w	d2,d1					; is the pan value less than 96 pixels?
		ble.s	.update_pan				; if not, branch
		subq.w	#2,d1					; subtract 2 from the pan value
		bra.s	.update_pan				; branch
; ---------------------------------------------------------------------------

	.pan_spin:
		cmpi.w	#$600,d0
		bcs.s	.reset_pan

	.pan_spin2:
		btst	#0,$22(a0)			; check the direction that sonic is facing
		beq.s	.pan_sdleft				; if he's facing left, pan the camera to the left

    .pan_sdright:
        addq.w    #2,d1                    ; add 2 to the pan value
        cmpi.w    #224,d1                    ; is the pan value greater than 224 pixels?
        blt.s    .update_pan                ; if not, branch
        move.w    #224,d1                    ; otherwise, cap the value at the maximum of 224 pixels
        bra.s    .update_pan                ; branch
; ---------------------------------------------------------------------------

    .pan_sdleft:
        subq.w    #2,d1                    ; subtract 2 from the pan value
        cmpi.w    #96,d1                    ; is the pan value less than 96 pixels?
        bgt.s    .update_pan                ; if not, branch
        move.w    #96,d1                    ; otherwise, cap the value at the minimum of 96 pixels
        bra.s    .update_pan                ; branch
; ---------------------------------------------------------------------------

	.reset_pan:
		andi.w	#$FFFE,d1					; add 1 to the pan value
		cmpi.w	#160,d1					; is the pan value 160 pixels?
		beq.s	.update_pan				; if so, branch
		bhi.s	.reset_left				; otherwise, branch if it greater than 160
	 
	.reset_right:
		addq.w	#2,d1					; add 1 to the pan value
		bra.s	.update_pan				; branch
; ---------------------------------------------------------------------------

	.reset_left:
		subq.w	#2,d1					; subtract 1 from the pan value

	.update_pan:
		move.w	d1,(v_camera_pan).w		; update the camera pan value

	.end_pan:
		rts								; return	
	 
; End of function Character_PanCamera

loc_12C58:
		tst.b	($FFFFF674).w	; are controls locked?
		bne.s	loc_12C62	; if yes, branch
	;	move.b	#0,$2B(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control
		btst	#0,($FFFFF604).w
		beq.s	loc_12C62

	.skip:
		move.w	($FFFFF604).w,($FFFFF670).w ; enable joypad control	
		bclr	#0,($FFFFF670).w

loc_12C62:
		bsr.w	CPU_Control
		bra.s	loc_12C64

loc_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc_12C64	; if yes, branch
		bset	#0,($FFFFF602).w
		btst	#0,($FFFFF604).w
		bne.s	loc_12C64
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc_12C64:
		btst	#0,$2A(a0) ; are controls	locked?
		bne.s	loc_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj01_Modes(pc,d0.w),d1
		jsr	Obj01_Modes(pc,d1.w)

loc_12C7E:
		bsr.s	Sonic_Display
		bsr.w	Main_RecordPos
		bsr.w	Character_Water
		btst	#7,$22(a0)
		bne.s	loc_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc_12C7E2

loc_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc_12C7E2
		add.w	#2,($FFFFF75E).w

loc_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc_12CA6
		tst.b	$1C(a0)
		bne.s	loc_12CA6
		move.b	$1D(a0),$1C(a0)

loc_12CA6:
		bsr.w	Sonic_Animate
		tst.b	$2A(a0)
		bmi.s	loc_12CB6
		jsr	TouchResponse

loc_12CB6:
		jmp	LoadCharacterDynPLC
; ===========================================================================
Obj01_Modes:	dc.w Obj01_MdNormal-Obj01_Modes
		dc.w Obj01_MdJump-Obj01_Modes
		dc.w Obj01_MdRoll-Obj01_Modes
		dc.w Obj01_MdJump2-Obj01_Modes

Sonic_Display:				; XREF: loc_12C7E
		move.w	$30(a0),d0
		beq.s	Obj01_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_Display
		lsr.w	#3,d0
		bcc.s	Obj01_ChkInvin

Obj01_Display:
		jsr	DisplaySprite

Obj01_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Sonic have invincibility?
		beq.w	Obj01_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj01_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj01_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj01_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj01_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w	; store level music
		jsr	LoadMusic

Obj01_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj01_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Sonic have speed	shoes?
		beq.s	Obj01_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj01_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj01_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Sonic"s speed
		move.w	#$C,($FFFFF762).w ; restore Sonic"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Sonic"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

Obj01_ExitChk:
		rts	

; ---------------------------------------------------------------------------
; AI Code
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; loc_1BAD4:
CPU_Control: ; a0=Tails
	move.b	($FFFFF670).w,d0	; did the real player 2 hit something?
	andi.b	#$7F,d0
	beq.s	CPU1			; if not, branch
	move.w	#120,($FFFFF672).w ; give player 2 control for 2 seconds (minimum)
CPU1:
	lea	($FFFFB000).w,a1 ; a1=character ; a1=Sonic
	move.w	($FFFFF678).w,d0
	move.w	CPU_States(pc,d0.w),d0
	jmp	CPU_States(pc,d0.w)
; ===========================================================================
; off_1BAF4:
CPU_States:
	dc.w CPU_Init-CPU_States	; 0
	dc.w CPU_Spawning-CPU_States	; 2
	dc.w CPU_Flying-CPU_States	; 4
	dc.w CPU_Normal-CPU_States	; 6
	dc.w CPU_Panic-CPU_States	; 8

; ===========================================================================
; initial AI State
; ---------------------------------------------------------------------------
; loc_1BAFE:
CPU_Init:
	move.w	#6,($FFFFF678).w	; => CPU_Normal
	move.b	#0,$2A(a0)
	move.b	#0,$1C(a0)
	move.w	#0,$10(a0)
	move.w	#0,$12(a0)
	move.w	#0,$20(a0)
	move.b	#$80,$22(a0)
	move.w	#0,($FFFFF674).w
	rts

; ===========================================================================
; AI State where Tails is waiting to respawn
; ---------------------------------------------------------------------------
; loc_1BB30:
CPU_Spawning:
	move.b	($FFFFF670).w,d0
	andi.b	#-$10,d0
	bne.s	CPU_Respawn
	move.w	($FFFFFE04).w,d0
	andi.w	#$3F,d0
	bne.s	return_1BB88
	tst.b	$2A(a1)
	bne.s	return_1BB88
	move.b	$22(a1),d0
	andi.b	#$D2,d0
	bne.s	return_1BB88
; loc_1BB54:
CPU_Respawn:
	move.w	#4,($FFFFF678).w	; => CPU_Flying
	move.w	8(a1),d0
	move.w	d0,8(a0)
	move.w	d0,($FFFFF67A).w
	move.w	$C(a1),d0
	move.w	d0,($FFFFF67C).w
	subi.w	#$C0,d0
	move.w	d0,$C(a0)
	ori.w	#(1<<15),2(a0)
	move.b	#0,$39(a0)
	move.w	#0,$3A(a0)

return_1BB88:
	rts

; ===========================================================================
; AI State where Tails pretends to be a helicopter
; ---------------------------------------------------------------------------
; loc_1BB8A:
CPU_Flying:
	tst.b	1(a0)
	bmi.s	CPU_FlyingOnscreen
	addq.w	#1,($FFFFF674).w
	cmpi.w	#$12C,($FFFFF674).w
	blo.s	CPU_Flying_Part2
	move.w	#0,($FFFFF674).w
	move.w	#2,($FFFFF678).w	; => CPU_Spawning
	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.w	#0,8(a0)
	move.w	#0,$C(a0)
	move.b	#$1D,$1C(a0)
	rts
; ---------------------------------------------------------------------------
; loc_1BBC8:
CPU_FlyingOnscreen:
	move.w	#0,($FFFFF674).w
; loc_1BBCE:
CPU_Flying_Part2:
	lea	($FFFFE500).w,a2
	move.w	#$10,d2
	lsl.b	#2,d2
	addq.b	#4,d2
	move.w	($FFFFF7A8).w,d3
	sub.b	d2,d3
	move.w	(a2,d3.w),($FFFFF67A).w
	move.w	2(a2,d3.w),($FFFFF67C).w
	tst.b	(Water_flag).w
	beq.s	CPU2
	move.w	($FFFFF646).w,d0
	subi.w	#$10,d0
	cmp.w	($FFFFF67C).w,d0
	bge.s	CPU2
	move.w	d0,($FFFFF67C).w
CPU2:
	move.w	8(a0),d0
	sub.w	($FFFFF67A).w,d0
	beq.s	loc_1BC54
	move.w	d0,d2
	bpl.s	loc_1BC14
	neg.w	d2

loc_1BC14:				; CODE XREF: h+4C9Cj
	lsr.w	#4,d2
	cmpi.w	#$C,d2
	blo.s	CPU3
	moveq	#$C,d2
CPU3:
	move.b	$10(a1),d1
	bpl.s	loc_1BC26
	neg.b	d1

loc_1BC26:				; CODE XREF: h+4CAEj
	add.b	d1,d2
	addq.w	#1,d2
	tst.w	d0
	bmi.s	loc_1BC42
	bset	#0,$22(a0)
	cmp.w	d0,d2
	blo.s	CPU4
	move.w	d0,d2
	moveq	#0,d0
CPU4:
	neg.w	d2
	bra.s	loc_1BC50
; ---------------------------------------------------------------------------

loc_1BC42:
	bclr	#0,$22(a0)
	neg.w	d0
	cmp.w	d0,d2
	blo.s	loc_1BC50
	move.b	d0,d2
	moveq	#0,d0

loc_1BC50:
	add.w	d2,8(a0)

loc_1BC54:
	moveq	#1,d2
	move.w	$C(a0),d1
	sub.w	($FFFFF67C).w,d1
	beq.s	loc_1BC68
	bmi.s	loc_1BC64
	neg.w	d2

loc_1BC64:
	add.w	d2,$C(a0)

loc_1BC68:
	lea	($FFFFE400).w,a2
	move.b	2(a2,d3.w),d2
	andi.b	#$52,d2
	bne.s	return_1BCDE
	or.w	d0,d1
	bne.s	return_1BCDE
	move.w	#6,($FFFFF678).w	; => CPU_Normal
	move.b	#0,$2A(a0)
	move.b	#0,$1C(a0)
	move.w	#0,$10(a0)
	move.w	#0,$12(a0)
	move.w	#0,$20(a0)
	move.b	#$82,$22(a0)
	move.w	#0,$2E(a0)
	andi.w	#$7FFF,2(a0)
	tst.b	2(a1)
	bpl.s	CPU5
	ori.w	#-$8000,2(a0)
CPU5:
	move.b	$3E(a1),$3E(a0)
	move.b	$3F(a1),$3F(a0)
	cmpi.b	#9,$1C(a1)
	beq.s	return_1BCDE
	move.b	$39(a0),d0
	beq.s	return_1BCDE
	move.b	d0,$39(a1)
	jmp	loc_212C4

return_1BCDE:
	rts

; ===========================================================================
; AI State where Tails follows the player normally
; ---------------------------------------------------------------------------
; loc_1BCE0:
CPU_Normal:
	cmpi.b	#6,($FFFFB024).w	; is Sonic dead?
	blo.s	CPU_Normal_SonicOK		; if not, branch
	; Sonic's dead; fly down to his corpse
	move.w	#4,($FFFFF678).w	; => CPU_Flying
	move.b	#0,$39(a0)
	move.w	#0,$3A(a0)
	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.b	#$1D,$1C(a0)
	rts
; ---------------------------------------------------------------------------
; loc_1BD0E:
CPU_Normal_SonicOK:
	bsr.w	CPU_CheckDespawn
	tst.w	($FFFFF672).w	; if CPU has control
	bne.w	CPU_Normal_HumanControl		; (if not, branch)
	tst.b	$2A(a0)			; and Tails isn't fully object controlled (&$80)
	bmi.w	CPU_Normal_HumanControl		; (if not, branch)
	tst.w	$2E(a0)			; and Tails' movement is locked (usually because he just fell down a slope)
	beq.s	CPU6					; (if not, branch)
	tst.w	$20(a0)			; and Tails is stopped, then...
	bne.s	CPU6					; (if not, branch)
	move.w	#8,($FFFFF678).w	; => CPU_Panic
CPU6:
	lea	($FFFFE500).w,a1
	move.w	#$10,d1
	lsl.b	#2,d1
	addq.b	#4,d1
	move.w	($FFFFF7A8).w,d0
	sub.b	d1,d0
	move.w	(a1,d0.w),d2	; d2 = earlier x position of Sonic
	move.w	2(a1,d0.w),d3	; d3 = earlier y position of Sonic
	lea	($FFFFE400).w,a1
	move.w	(a1,d0.w),d1	; d1 = earlier input of Sonic
	move.b	2(a1,d0.w),d4	; d4 = earlier status of Sonic
	move.w	d1,d0
	btst	#5,$22(a0)	; is Tails pushing against something?
	beq.s	CPU7		; if not, branch
	btst	#5,d4		; was Sonic pushing against something?
	beq.w	CPU_Normal_FilterAction_Part2 ; if not, branch elsewhere

; either Tails isn't pushing, or Tails and Sonic are both pushing
CPU7:
	sub.w	8(a0),d2
	beq.s	CPU_Normal_Stand ; branch if Tails is already lined up horizontally with Sonic
	bpl.s	CPU_Normal_FollowRight
	neg.w	d2

; Tails wants to go left because that's where Sonic is
; loc_1BD76: CPU_Normal_FollowLeft:
	cmpi.w	#$10,d2
	blo.s	CPU8
	andi.w	#$F3F3,d1 ; %1111001111110011
	ori.w	#$0404,d1 ; %0000010000000100
CPU8:
	tst.w	$20(a0)
	beq.s	CPU_Normal_FilterAction
	btst	#0,$22(a0)
	beq.s	CPU_Normal_FilterAction
	subq.w	#1,8(a0)
	bra.s	CPU_Normal_FilterAction
; ===========================================================================
; Tails wants to go right because that's where Sonic is
; loc_1BD98:
CPU_Normal_FollowRight:
	cmpi.w	#$10,d2
	blo.s	CPU9
	andi.w	#$F3F3,d1 ; %1111001111110011
	ori.w	#$0808,d1 ; %0000100000001000
CPU9:
	tst.w	$20(a0)
	beq.s	CPU_Normal_FilterAction
	btst	#0,$22(a0)
	bne.s	CPU_Normal_FilterAction
	addq.w	#1,8(a0)
	bra.s	CPU_Normal_FilterAction
; ===========================================================================
; Tails is happy where he is
; loc_1BDBA:
CPU_Normal_Stand:
	bclr	#0,$22(a0)
	move.b	d4,d0
	andi.b	#1,d0
	beq.s	CPU_Normal_FilterAction
	bset	#0,$22(a0)

; Filter the action we chose depending on a few things
; loc_1BDCE:
CPU_Normal_FilterAction:
	tst.b	($FFFFF67F).w
	beq.s	CPU10
	ori.w	#$7000,d1
	btst	#1,$22(a0)
	bne.s	CPU_Normal_SendAction
	move.b	#0,($FFFFF67F).w
CPU10:
	move.w	($FFFFFE04).w,d0
	andi.w	#$FF,d0
	beq.s	CPU11
	cmpi.w	#$40,d2
	bhs.s	CPU_Normal_SendAction
CPU11:
	sub.w	$C(a0),d3
	beq.s	CPU_Normal_SendAction
	bpl.s	CPU_Normal_SendAction
	neg.w	d3
	cmpi.w	#$20,d3
	blo.s	CPU_Normal_SendAction
; loc_1BE06:
CPU_Normal_FilterAction_Part2:
	move.b	($FFFFFE05).w,d0
	andi.b	#$3F,d0
	bne.s	CPU_Normal_SendAction
	cmpi.b	#8,$1C(a0)
	beq.s	CPU_Normal_SendAction
	ori.w	#$7070,d1
	move.b	#1,($FFFFF67F).w

; Send the action we chose by storing it into player 2's input
; loc_1BE22:
CPU_Normal_SendAction:
	move.w	d1,($FFFFF670).w
	rts

; ===========================================================================
; Follow orders from controller 2
; and decrease the counter to when the CPU will regain control
; loc_1BE28:
CPU_Normal_HumanControl:
	tst.w	($FFFFF672).w
	beq.s	CPU12	; don't decrease if it's already 0
	subq.w	#1,($FFFFF672).w
CPU12:
	rts

; ===========================================================================
; loc_1BE34:
CPU_Despawn:
	move.w	#0,($FFFFF672).w
	move.w	#0,($FFFFF674).w
	move.w	#2,($FFFFF678).w	; => CPU_Spawning
	move.b	#$81,$2A(a0)
	move.b	#$82,$22(a0)
	move.w	#$4000,8(a0)
	move.w	#0,$C(a0)
	move.b	#$1D,$1C(a0)
	rts
; ===========================================================================
; sub_1BE66:
CPU_CheckDespawn:
	tst.b	1(a0)
	bmi.s	CPU_ResetRespawnTimer
	btst	#3,$22(a0)
	beq.s	CPU_TickRespawnTimer

	moveq	#0,d0
	move.b	$3D(a0),d0
	lsl.w	#6,d0
	addi.l	#$FFFFB000,d0
	movea.l	d0,a3	; a3=object
	move.b	($FFFFF67E).w,d0
	cmp.b	(a3),d0
	bne.s	BranchTo_CPU_Despawn

; loc_1BE8C:
CPU_TickRespawnTimer:
	addq.w	#1,($FFFFF674).w
	cmpi.w	#$12C,($FFFFF674).w
	blo.s	CPU_UpdateObjInteract

BranchTo_CPU_Despawn 
	bra.w	CPU_Despawn
; ===========================================================================
; loc_1BE9C:
CPU_ResetRespawnTimer:
	move.w	#0,($FFFFF674).w
; loc_1BEA2:
CPU_UpdateObjInteract:
	moveq	#0,d0
	move.b	$3D(a0),d0
	lsl.w	#6,d0
	addi.l	#$FFFFB000,d0
	movea.l	d0,a3	; a3=object
	move.b	(a3),($FFFFF67E).w
	rts

; ===========================================================================
; AI State where Tails stops, drops, and spindashes in Sonic's direction
; ---------------------------------------------------------------------------
; loc_1BEB8:
CPU_Panic:
	bsr.w	CPU_CheckDespawn
	tst.w	($FFFFF672).w
	bne.w	return_1BF36
	tst.w	$2E(a0)
	bne.s	return_1BF36
	tst.b	$39(a0)
	bne.s	CPU_Panic_ChargingDash

CPU_Panic_NoDash:
	tst.w	$20(a0)
	bne.s	return_1BF36
	bclr	#0,$22(a0)
	move.w	8(a0),d0
	sub.w	8(a1),d0
	bcs.s	CPU13
	bset	#0,$22(a0)
CPU13:
	move.w	#$202,($FFFFF670).w
	move.b	($FFFFFE05).w,d0
	andi.b	#$7F,d0
	beq.s	CPU_Panic_ReleaseDash

	cmpi.b	#8,$1C(a0)
	bne.s	return_1BF36
	move.w	#$7272,($FFFFF670).w
	rts
; ---------------------------------------------------------------------------
; loc_1BF0C:
CPU_Panic_ChargingDash:
	move.w	#$202,($FFFFF670).w
	move.b	($FFFFFE05).w,d0
	andi.b	#$7F,d0
	bne.s	CPU_Panic_RevDash

; loc_1BF1C:
CPU_Panic_ReleaseDash:
	move.w	#0,($FFFFF670).w
	move.w	#6,($FFFFF678).w	; => CPU_Normal
	rts
; ---------------------------------------------------------------------------
; loc_1BF2A:
CPU_Panic_RevDash:
	andi.b	#$1F,d0
	bne.s	return_1BF36
	ori.w	#$7070,($FFFFF670).w

return_1BF36:
	rts
; End of function CPU_Control

; ---------------------------------------------------------------------------
; Subroutine to	record Sonic's previous positions for invincibility stars
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Main_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF7A8).w,d0
		lea	($FFFFE500).w,a1
		lea	(a1,d0.w),a1
		move.w	8(a0),(a1)+
		move.w	$C(a0),(a1)+
		addq.b	#4,($FFFFF7A9).w

		lea	($FFFFE400).w,a1
		lea	(a1,d0.w),a1
		move.w	($FFFFF602).w,(a1)+
		move.w	$22(a0),(a1)+
		rts

Partner_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF62E).w,d0
		lea	($FFFFE600).w,a1
		lea	(a1,d0.w),a1
		move.w	8(a0),(a1)+
		move.w	$C(a0),(a1)+
		addq.b	#4,($FFFFF72F).w
		rts
; End of function Main_RecordPos

; ---------------------------------------------------------------------------
; Subroutine for Sonic when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Water:				; XREF: loc_12C7E
		tst.b	(Water_flag).w ; does level have water?
		bne.s	Obj01_InWater ; if yes, branch

locret_12D80:
		rts	
; ===========================================================================

Obj01_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; is Sonic above the water?
		bge.s	Obj01_OutWater	; if yes, branch
		bset	#6,$22(a0)
		bne.s	locret_12D80
		jsr	ResumeMusic

Obj01_InWaterCont:
		asr	$10(a0)
		asr	$12(a0)
		asr	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_InWaterCont2
		move.b	#$A,($FFFFB340).w ; load bubbles object	from Sonic's mouth
		move.b	#$81,($FFFFB368).w
		move.w	#$300,($FFFFF760).w ; change Sonic's top speed
		move.w	#6,($FFFFF762).w ; change Sonic's acceleration
		move.w	#$40,($FFFFF764).w ; change Sonic's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.
		bra.s	Obj01_InWaterCont3

Obj01_InWaterCont2:
		move.b	#$A,($FFFFB500).w ; load bubbles object	from Sonic's mouth
		move.b	#$81,($FFFFB528).w
		move.w	#$100,($FFFFB41C).w	; Set the Spin Dash dust animation to $100.

Obj01_InWaterCont3:
		sfx		sfx_Splash ;	play splash sound
		rts
; ===========================================================================

Obj01_OutWater:
		bclr	#6,$22(a0)
		beq.w	locret_12D80
		asl	$12(a0)
		btst	#7,$22(a0)
		bne.s	Obj01_OutWater2
		jsr	ResumeMusic
		move.w	#$600,($FFFFF760).w ; restore Sonic's speed
		move.w	#$C,($FFFFF762).w ; restore Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; restore Sonic's deceleration
		move.w	#$100,($FFFFB1DC).w	; Set the Spin Dash dust animation to $100.
		bra.s	Obj01_OutWater3

Obj01_OutWater2:
		move.w	#$100,($FFFFB41C).w	; Set the Spin Dash dust animation to $100.

Obj01_OutWater3:
		cmpi.w	#-$1000,$12(a0)
		bgt.s	loc_12E0E
		move.w	#-$1000,$12(a0)	; set maximum speed on leaving water

loc_12E0E:
		sfx		sfx_Splash ;	play splash sound
		rts
; End of function Character_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Sonic
; ---------------------------------------------------------------------------

Obj01_MdNormal:				; XREF: Obj01_Modes
		bsr.w	Character_SpinDash
		bsr.w	Character_Jump
		bsr.w	Character_SlopeResist
		bsr.w	Character_Move
		bsr.w	Character_Roll
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		jsr	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj01_MdJump:				; XREF: Obj01_Modes
	;	clr.b	$39(a0)
		bsr.w	Sonic_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc_12E5C
		subi.w	#$28,$12(a0)

loc_12E5C:
		tst.w	$12(a0)
		bmi.s	loc_12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	loc_12E5E
		move.b	#$C,$1C(a0)

loc_12E5E:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	
; ===========================================================================

Obj01_MdRoll:				; XREF: Obj01_Modes
		bsr.w	Character_Jump
		bsr.w	Character_RollRepel
		bsr.w	Character_RollSpeed
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		jsr	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj01_MdJump2:				; XREF: Obj01_Modes
	;	clr.b	$39(a0)
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_DropDash
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc_12EA6
		move.w	$10(a0),d0		; move Sonic's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj01_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj01_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Sonic speed less than $250?
		blt.s	loc_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move sonic's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Sonic slightly in the water?
		bgt.s	loc_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)

loc_12EA6:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Move:				; XREF: Obj01_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_12FEE
		tst.w	$2E(a0)
		bne.w	Obj01_ResetScr
		btst	#7,$22(a0)
		bne.s	Character_Move2
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj01_NotLeft	; if not, branch
		bsr.w	Character_MoveLeft
		bra.s	Obj01_NotLeft

Character_MoveDone:
		rts

Character_MachSpeed:
		move.w	#$700,$20(a0)
		bsr.w	Character_MoveRight
		bra.s	Obj01_NotRight

Obj01_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr.w	Character_MoveRight
		bra.s	Obj01_NotRight

Character_Move2:
		btst	#2,($FFFFF670).w ; is left being pressed?
		beq.s	Obj01_NotLeft2	; if not, branch
		bsr.w	Character_MoveLeft

Obj01_NotLeft2:
		btst	#3,($FFFFF670).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr.w	Character_MoveRight

Obj01_NotRight:
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Sonic on a	slope?
		bne.w	Obj01_ResetScr	; if yes, branch
		tst.w	$20(a0)		; is Sonic moving?
		bne.w	Obj01_ResetScr	; if yes, branch
		bclr	#5,$22(a0)
		btst	#1,$2B(a0)
		beq.s	.nopsy
		cmpi.b	#9,$1C(a0)
		beq.s	.cont
		move.b	#$1C,$1C(a0)	; use "telekinesis" frame
		bra.s	.cont

	.nopsy:
		move.b	#5,$1C(a0)	; use "standing" animation

	.cont:
		btst	#3,$22(a0)
		beq.s	Character_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	$22(a1)
		bmi.w	Character_LookUp
		moveq	#0,d1
		move.b	$14(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	8(a0),d1
		sub.w	8(a1),d1
		cmpi.w	#4,d1
		blt.s	Character_BalanceLeft
		cmp.w	d2,d1
		bge.s	Character_BalanceRight
		bra.w	Character_LookUp

Character_Balance:
		jsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.w	Character_LookUp
		cmpi.b	#2,0(a0)
		beq.w	Chracter_NormalBalance
		cmpi.b	#$99,0(a0)
		beq.w	Chracter_NormalBalance
		cmpi.b	#$95,0(a0)
		beq.w	Chracter_NormalBalance
		cmpi.b	#3,$36(a0)	;Mercury Constants
		beq.s	Character_BalanceRight
		cmpi.b	#3,$37(a0)	;Mercury Constants
		bne.s	Character_LookUp

Character_BalanceLeft:
		move.b	#$E,$1C(a0) ; use forward balancing animation
		btst	#0,$22(a0)	; is Sonic facing left?	;Mercury Constants
		beq.s	Character_BalanceBackward	; if not, balance backward
		bra.w	Obj01_ResetScr	; branch

Character_BalanceRight:
		move.b	#$E,$1C(a0) ; use forward balancing animation
		btst	#0,$22(a0)	; is Sonic facing left?	;Mercury Constants
		bne.s	Character_BalanceBackward	; if so, balance backward
		bra.w	Obj01_ResetScr	; branch

Character_BalanceBackward:
		move.b	#$F,$1C(a0) ; use backward balancing animation
		bra.w	Obj01_ResetScr
; ===========================================================================

Chracter_NormalBalance:
		cmpi.b	#3,$36(a0)
		bne.s	loc_12F62

loc_12F5A:
		bclr	#0,$22(a0)
		bra.s	loc_12F70
; ===========================================================================

loc_12F62:
		cmpi.b	#3,$37(a0)
		bne.s	Character_LookUp

loc_12F6A:
		bset	#0,$22(a0)

loc_12F70:
		move.b	#6,$1C(a0)	; use "balancing" animation
		bra.w	Obj01_ResetScr
; ===========================================================================

Character_LookUp:
		btst	#7,$22(a0)
		beq.s	Character_LookUp2
		btst	#0,($FFFFF670).w ; is up being pressed?
		beq.s	Character_Duck	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		bra.w	loc_12FC4

Character_LookUp2:
		btst	#0,($FFFFF602).w ; is up being pressed?
		beq.s	Character_Duck2	; if not, branch
		move.b	#7,$1C(a0)	; use "looking up" animation
		tst.w	($FFFFF672).w
		bne.s	Obj01_ResetScr
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================
 
Character_Duck:
		btst	#1,($FFFFF670).w ; is down being pressed?
		beq.s	Obj01_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		bra.s	loc_12FC4

Character_Duck2:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	Obj01_ResetScr	; if not, branch
		move.b	#8,$1C(a0)	; use "ducking"	animation
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2

; ===========================================================================
 
Obj01_ResetScr:
		btst	#7,$22(a0)
		bne.s	loc_12FC4
		move.b	#0,($FFFFC903).w
 
Obj01_ResetScr_Part2:
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc_12FC2	; if yes, branch
		bcc.s	loc_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default

loc_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc_12FC2:
		move.b	($FFFFF602).w,d0
		bra.s	loc_12FC6

loc_12FC4:
		move.b	($FFFFF670).w,d0

loc_12FC6:
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc_12FEE	; if yes, branch
		move.w	$20(a0),d0
		beq.s	loc_12FEE
		bmi.s	loc_12FE2
		sub.w	d5,d0
		bcc.s	loc_12FDC
		move.w	#0,d0

loc_12FDC:
		move.w	d0,$20(a0)
		bra.s	loc_12FEE
; ===========================================================================

loc_12FE2:
		add.w	d5,d0
		bcc.s	loc_12FEA
		move.w	#0,d0

loc_12FEA:
		move.w	d0,$20(a0)

loc_12FEE:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)

loc_1300C:
		move.b	$26(a0),d0
		addi.b	#$40,d0
		bmi.s	locret_1307C
		move.b	#$40,d1
		tst.w	$20(a0)
		beq.s	locret_1307C
		bmi.s	loc_13024
		neg.w	d1

loc_13024:
		move.b	$26(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		jsr	Character_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc_13078
		cmpi.b	#$40,d0
		beq.s	loc_13066
		cmpi.b	#$80,d0
		beq.s	loc_13060
		cmpi.w	#2,($FFFFFE10).w
		beq.s	JMP_HurtSonic
		add.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc_13060:
		sub.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_13066:
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts	
; ===========================================================================

loc_13078:
		add.w	d1,$12(a0)

locret_1307C:
		rts	

JMP_HurtSonic:
		cmpi.w	#$600,$10(a0)
		bge.s	JMP_HSMach
		sub.w	d1,$10(a0)
		bset	#5,$22(a0)
		move.w	#0,$20(a0)
		rts

JMP_HSMach:
		subi.w	#$10,$C(a0)
		jmp		HurtSonic

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_MoveLeft:		   ; XREF: Character_Move
		move.w	$20(a0),d0
		beq.s	loc_13086
		bpl.s	loc_130B2
 
loc_13086:
		bset	#0,$22(a0)
		bne.s	loc_1309A
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_130A6
		move.w	d1,d0
 
loc_130A6:
		btst	#1,$2B(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc_130B2:				; XREF: Character_MoveLeft
		sub.w	d4,d0
		bcc.s	loc_130BA
		move.w	#-$80,d0

loc_130BA:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_130E8
		cmpi.w	#$400,d0
		blt.s	locret_130E8
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bclr	#0,$22(a0)
		sfx		sfx_Skid ;	play stopping sound
		btst	#7,$22(a0)
		bne.s	loc_130BC
		move.b	#6,($FFFFB1E4).w
		move.b	#$15,($FFFFB1DA).w
		rts

loc_130BC:
		move.b	#6,($FFFFB424).w
		move.b	#$15,($FFFFB41A).w

locret_130E8:
		rts	
; End of function Character_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_MoveRight:	   ; XREF: Character_Move
		move.w	$20(a0),d0
		bmi.s	loc_13118
		bclr	#0,$22(a0)
		beq.s	loc_13104
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
 
loc_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1310C
		move.w	d6,d0
 
loc_1310C:
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0); use walking animation
		rts
; ===========================================================================

loc_13118:				; XREF: Character_MoveRight
		add.w	d4,d0
		bcc.s	loc_13120
		move.w	#$80,d0

loc_13120:
		move.w	d0,$20(a0)
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret_1314E
		move.b	#$D,$1C(a0)	; use "stopping" animation
		bset	#0,$22(a0)
		sfx		sfx_Skid ;	play stopping sound
		btst	#7,$22(a0)
		bne.s	loc_13122
		move.b	#6,($FFFFB1E4).w
		move.b	#$15,($FFFFB1DA).w
		rts

loc_13122:
		move.b	#6,($FFFFB424).w
		move.b	#$15,($FFFFB41A).w

locret_1314E:
		rts	
; End of function Character_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_RollSpeed:			; XREF: Obj01_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_131CC
		tst.w	$2E(a0)
		bne.s	loc_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_1317C	; if not, branch
		bsr.w	Character_RollLeft

loc_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_13188	; if not, branch
		bsr.w	Character_RollRight

loc_13188:
		move.w	$20(a0),d0
		beq.s	loc_131AA
		bmi.s	loc_1319E
		sub.w	d5,d0
		bcc.s	loc_13198
		move.w	#0,d0

loc_13198:
		move.w	d0,$20(a0)
		bra.s	loc_131AA
; ===========================================================================

loc_1319E:				; XREF: Character_RollSpeed
		add.w	d5,d0
		bcc.s	loc_131A6
		move.w	#0,d0

loc_131A6:
		move.w	d0,$20(a0)

loc_131AA:
		tst.w	$20(a0)		; is Sonic moving?
		bne.s	loc_131CC	; if yes, branch
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		subq.w	#5,$C(a0)

loc_131CC:
		btst	#7,$22(a0)
		bne.s	.cont2
		cmp.w	#$60,($FFFFF73E).w
		beq.s	.cont2
		bcc.s	.cont1
		addq.w	#4,($FFFFF73E).w
 
.cont1:
		subq.w	#2,($FFFFF73E).w
 
.cont2:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		muls.w	$20(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_131F0
		move.w	#$1000,d1

loc_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc_131FA
		move.w	#-$1000,d1

loc_131FA:
		move.w	d1,$10(a0)
		bra.w	loc_1300C
; End of function Character_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_RollLeft:				; XREF: Character_RollSpeed
		move.w	$20(a0),d0
		beq.s	loc_1320A
		bpl.s	loc_13218

loc_1320A:
		bset	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_13218:
		sub.w	d4,d0
		bcc.s	loc_13220
		move.w	#-$80,d0

loc_13220:
		move.w	d0,$20(a0)
		rts	
; End of function Character_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_RollRight:			; XREF: Character_RollSpeed
		move.w	$20(a0),d0
		bmi.s	loc_1323A
		bclr	#0,$22(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_1323A:
		add.w	d4,d0
		bcc.s	loc_13242
		move.w	#$80,d0

loc_13242:
		move.w	d0,$20(a0)
		rts	
; End of function Character_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_ChgJumpDir:		; XREF: Obj01_MdJump; Obj01_MdJump2
		cmpi.w	#2,($FFFFFE10).w
		beq.w	locret_132D2
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		move.w	$10(a0),d0	
		btst	#7,$22(a0)
		bne.s	Character_ChgJumpDir2
		btst	#2,($FFFFF602).w; is left being pressed?
		bra.s	Character_ChgJumpDir3

Character_ChgJumpDir2:		
		btst	#2,($FFFFF670).w; is left being pressed?

Character_ChgJumpDir3:	
		beq.s	loc_13278; if not, branch	
		bset	#0,$22(a0)	
		sub.w	d5,d0	
		move.w	d6,d1	
		neg.w	d1	
		cmp.w	d1,d0	
		bgt.s	loc_13278	
		add.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d1,d0		; +++ compare speed with top speed
		ble.s	loc_13278	; +++ if speed was already greater than the maximum, branch	
		move.w	d1,d0
 
loc_13278:
		btst	#7,$22(a0)
		bne.s	loc_1327A
		btst	#3,($FFFFF602).w; is left being pressed?
		bra.s	loc_1327C

loc_1327A:		
		btst	#3,($FFFFF670).w; is left being pressed?

loc_1327C:	
		beq.s	Obj01_JumpMove; if not, branch	
		bclr	#0,$22(a0)	
		add.w	d5,d0	
		cmp.w	d6,d0	
		blt.s	Obj01_JumpMove
		sub.w	d5,d0		; +++ remove this frame's acceleration change
		cmp.w	d6,d0		; +++ compare speed with top speed
		bge.s	Obj01_JumpMove	; +++ if speed was already greater than the maximum, branch
		move.w	d6,d0

Obj01_JumpMove:
		move.w	d0,$10(a0)	; change Sonic's horizontal speed

Obj01_ResetScr2:
		btst	#7,$22(a0)
		bne.s	loc_132A4
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc_132A4	; if yes, branch
		bcc.s	loc_132A0
		addq.w	#4,($FFFFF73E).w

loc_132A0:
		subq.w	#2,($FFFFF73E).w

loc_132A4:
		cmpi.w	#-$400,$12(a0)	; is Sonic moving faster than -$400 upwards?
		bcs.s	locret_132D2	; if yes, branch
		move.w	$10(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_132D2
		bmi.s	loc_132C6
		sub.w	d1,d0
		bcc.s	loc_132C0
		move.w	#0,d0

loc_132C0:
		move.w	d0,$10(a0)
		rts	
; ===========================================================================

loc_132C6:
		sub.w	d1,d0
		bcs.s	loc_132CE
		move.w	#0,d0

loc_132CE:
		move.w	d0,$10(a0)

locret_132D2:
		rts	
; End of function Character_ChgJumpDir

; ---------------------------------------------------------------------------
; Subroutine to	prevent	Sonic leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_LevelBound:			; XREF: Obj01_MdNormal; et al
		move.l	8(a0),d1
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		bhi.s	Boundary_Sides	; if yes, branch
		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		cmp.w	d1,d0		; has Sonic touched the	side boundary?
		bls.s	Boundary_Sides	; if yes, branch

loc_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0	; has Sonic touched the	bottom boundary?
		blt.s	Boundary_Bottom	; if yes, branch
		rts	
; ===========================================================================

Boundary_Bottom:
		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1			; screen still scrolling down?
		blt.s	Boundary_Bottom_locret	; if so, don't kill Sonic
		jmp 	KillSonic
 
Boundary_Bottom_locret:
		rts
; ===========================================================================

Boundary_Sides:
		tst.w	($FFFFF7CC).w
		bne.s	loc_13336
		move.w	d0,8(a0)
		move.w	#0,$A(a0)
		move.w	#0,$10(a0)	; stop Sonic moving
		move.w	#0,$20(a0)
		bra.s	loc_13336
; End of function Character_LevelBound

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Roll:				; XREF: Obj01_MdNormal\
		tst.b	($FFFFF7CA).w
		bne.s	Obj01_NoRoll
		move.w	$20(a0),d0
		bpl.s	loc_13392
		neg.w	d0

loc_13392:
        move.b	($FFFFF602).w,d0
		btst	#7,$22(a0)
		beq.s	.main
        move.b	($FFFFF670).w,d0

    .main:
        btst	#1,d0    ; is down being pressed?
        beq.s	Obj01_NoRoll    ; if not, branch
        andi.b	#$C,d0    ; is left/right being pressed?
        bne.s	Obj01_NoRoll    ; if yes, branch
        move.w	$20(a0),d0
        bpl.s	.cont ; If ground speed is positive, continue
        neg.w	d0 ; If not, negate it to get the absolute value

	.cont:
        cmpi.w	#$100,d0    ; is Sonic moving at $100 speed or faster?
        bhi.s	Obj01_ChkRoll    ; if yes, branch
        move.b	#8,$1C(a0)    ; use "ducking" animation

Obj01_NoRoll:
		rts	
; ===========================================================================

Obj01_ChkRoll:
		btst	#2,$22(a0)	; is Sonic already rolling?
		beq.s	Obj01_DoRoll	; if not, branch
		move.w	#0,($FFFFB030).w
		rts	

; ===========================================================================

Obj01_DoRoll:
		bset	#2,$22(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)	; use "rolling"	animation
		move.w	#1,$30(a0)
		addq.w	#5,$C(a0)
		sfx		sfx_Roll ;	play rolling sound
		tst.w	$20(a0)
		bne.s	locret_133E8
		move.w	#$200,$20(a0)

locret_133E8:
		rts	
; End of function Character_Roll

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Jump:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		btst	#7,$22(a0)
		bne.s	Character_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Character_Jump3

Character_Jump2:	
		move.b	($FFFFF671).w,d0

Character_Jump3:	
		cmpi.b	#$8E,(a0)
		beq.s	.sonic
		cmpi.b	#2,(a0)
		beq.s	.sonic
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.w	locret_1348E	; if not, branch
		bra.s	.return

	.sonic:
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	locret_1348E	; if not, branch

	.return:
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		jsr	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc_1341C
		move.w	#$380,d2

loc_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Sonic jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Sonic jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.b	($FFFFFFF6).w,d0
		move.b	d0,mQueue+2.w	;	play jumping sound
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
        btst    #2,$22(a0)
        bne.s   locret_1348E
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)
		move.b	#2,$1C(a0)	; use "jumping"	animation
		cmpi.b	#2,0(a0)
		bne.s	locret_1348E
		move.b	#$E,$1C(a0)	; use normal "jumping" animation for Silver

locret_1348E:
		rts	
; End of function Character_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpHeight:			; XREF: Obj01_MdJump; Obj01_MdJump2
		tst.b	$3C(a0)
		beq.s	loc_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc_134AE
		move.w	#-$200,d1

loc_134AE:
		cmp.w	$12(a0),d1
		ble.s	Sonic_JumpDash
		btst	#7,$22(a0)
		bne.s	Sonic_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Sonic_JumpHeight3

Sonic_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Sonic_JumpHeight3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret_134C2:
		rts	
; ===========================================================================

loc_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret_134D2
		move.w	#-$FC0,$12(a0)

locret_134D2:
		rts	
; End of function Sonic_JumpHeight

; ---------------------------------------------------------------------------
; Subroutine to perform a Jumpdash
; ---------------------------------------------------------------------------

Sonic_JumpDash:
		tst.b	$29(a0)		; was jumpdash flag set
		bne.w	JD_Move
		btst	#7,$22(a0)
		bne.s	Sonic_JumpDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Sonic_JumpDash3

Sonic_JumpDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Sonic_JumpDash3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	JD_End			; if not, branch
		tst.b	$2B(a0)		; was jumpdash flag set
		bne.w	JD_End
		btst	#7,$22(a0)
		bne.s	JD_FireCont3
		btst	#0,($FFFFFE2C).w
		bne.w	Sonic_FireShield
		cmpi.b	#$8E,(a0)
		beq.s	JD_End

JD_FireCont:
		move.b	#$14,$29(a0)	; set jumpdash flag
		btst	#4,($FFFFFE2C).w
		bne.w	JD_FireCont2

JD_FireCont3:
		cmpi.b	#$8E,(a0)
		beq.s	JD_End
		move.b	#$C,$29(a0)	; if not, set jumpdash flag
		sfx		sfx_Dash	; play jumpdash sound

JD_FireCont2:
		move.b	#1,$2B(a0)	; set jumpdash flag
		cmpi.w	#2,($FFFFFE10).w
		beq.w	JD_Running
		move.w	$10(a0),d0
		move.w	d0,($FFFFF642).w
		btst	#0,$22(a0)		; is sonic facing left?
		beq.s	JD_NoFlip		; if yes, branch
		sub.w	#$600,d0
		bra.s	JD_Cont

JD_Running:
		btst	#0,$22(a0)		; is sonic facing left?
		bne.s	JD_NoFlip		; if yes, branch
		sub.w	#$600,d0
		bra.s	JD_Cont

JD_NoFlip:
		add.w	#$600,d0

JD_Cont:
		move.w	d0,$10(a0)

JD_Move:
		cmpi.b	#1,$2B(a0)		; was jumpdash flag set
		bne.s	JD_End
		sub.b	#1,$29(a0)
		tst.b	$29(a0)
		beq.s	JD_Reset
		clr.w	$12(a0)			; clear Sonic's Y-velocity to move sonic directly down

JD_End:
		rts				; return

JD_Reset:
		cmpi.w	#2,($FFFFFE10).w
		beq.w	JD_End
		tst.w	$10(a0)
		beq.s	JD_End
		blt.s	JD_Reset2
		tst.b	($FFFFF642).w
		bgt.s	JD_Reset3
		bra.s	JD_Reset4

JD_Reset2:
		tst.b	($FFFFF642).w
		blt.s	JD_Reset3

JD_Reset4:
		neg.w	($FFFFF642).w

JD_Reset3:
		move.w	($FFFFF642).w,$10(a0)
		rts

Sonic_FireShield:
		btst	#4,($FFFFFE2C).w
		beq.s	Sonic_LightningShield
		move.b	#4,($FFFFB19C).w
		sfx		sfx_FireAttack	; play Bubble Shield attack sound
		bra.w	JD_FireCont

Sonic_LightningShield:
		btst	#5,($FFFFFE2C).w
		beq.s	Sonic_BubbleShield
		;move.b	#5,($FFFFB19C).w
		move.b	#1,$2B(a0)
		move.w	#-$580,$12(a0)	; bounce Sonic up, creating the double jump effect
		clr.b	$3C(a0)
		move.w	$10(a0),d0
		btst	#0,$10(a0)
		bne.s	Sonic_LightningShield2		; if yes, branch
		asr.w	#1,d0
		bra.s	Sonic_LightningShield3

Sonic_LightningShield2:
		neg.w	d0
		asr.w	#1,d0
		neg.w	d0

Sonic_LightningShield3:
		move.w	d0,$10(a0)
		sfx		sfx_BubbleAttack	; play Bubble Shield attack sound

Sonic_BubbleShield:
		btst	#6,($FFFFFE2C).w
		beq.s	Sonic_NoShield
	;	move.b	#7,($FFFFB19C).w
		move.b	#1,$2B(a0)
		move.w	#$800,$12(a0)		; force Sonic down
		move.w	$10(a0),d0
		asl.w	d0
	;	btst	#0,$22(a0)		; is sonic facing left?
	;	beq.s	JD2_NoFlip		; if yes, branch
	;	sub.w	#$200,d0
	;	bra.s	JD2_Cont

JD2_NoFlip:
	;	add.w	#$200,d0

JD2_Cont:
		move.w	d0,$10(a0)
		sfx		sfx_Dash	; play jumpdash sound

Sonic_NoShield:
		rts
; End of function Sonic_JumpDash

; ---------------------------------------------------------------------------
; Subroutine to perform a dropdash
; ---------------------------------------------------------------------------

Sonic_DropDash:
		cmpi.b	#1,$2B(a0)
		beq.s	DD_End
		tst.b	$39(a0)
		bne.s	.cont
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		btst	#7,$22(a0)
		beq.s	.mainchar
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

	.mainchar:	
		move.b	($FFFFFFEE).w,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	DD_Reset			; if not, branch
		bra.s	.wait

	.cont:
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		btst	#7,$22(a0)
		beq.s	.mainchar2
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

	.mainchar2:	
		move.b	($FFFFFFEE).w,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	DD_Reset			; if not, branch
		cmpi.b	#2,$2B(a0)		; was jumpdash flag set
		beq.w	DD_End

	.wait:
		cmpi.b	#$18,$39(a0)
		beq.s	DD_Set
		addi.b	#1,$39(a0)

DD_End:
		rts				; return

DD_Set:
		move.b	#2,$2B(a0)	; set jumpdash flag
		move.b	#$1F,$1C(a0)
		sfx		sfx_DropDash	; play dropdash sound
		rts

DD_Reset:
		move.b	#0,$2B(a0)
		move.b	#0,$39(a0)
		rts
; End of function Sonic_JumpDash

; ---------------------------------------------------------------------------
; Subroutine to make Sonic perform a spindash
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Character_SpinDash:
		tst.b	$39(a0)
		bne.s	loc_1AC8E
		cmpi.b	#8,$1C(a0)
		bne.s	locret_1AC8C
		btst	#7,$22(a0)
		bne.s	Character_SpinDash2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Character_SpinDash3

Character_SpinDash2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Character_SpinDash3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	locret_1AC8C
		move.b	#9,$1C(a0)
		sfx		sfx_Spindash
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		cmpi.b	#2,(a0)
		beq.s	Character_Spindash5
		cmpi.b	#$C,$28(a0)
		bcs.s	loc_1AC84
		btst	#7,$22(a0)
		bne.s	Character_Spindash4
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.
		bra.s	loc_1AC84
 
Character_Spindash4:
		move.b	#2,($FFFFB41C).w	; Set the Spin Dash dust animation to $2.
		bra.s	loc_1AC84

Character_Spindash5:
		bsr.w	Silver_Glow

loc_1AC84:
		bsr.w	Character_LevelBound
		jsr	Character_AnglePos
 
locret_1AC8C:
		rts	
; ---------------------------------------------------------------------------
 
loc_1AC8E:
		btst	#7,$22(a0)
		bne.s	loc_1AC8E3
		btst	#0,$22(a0)
		bne.s	loc_1AC8E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc_1AC8E3
		add.w	#2,($FFFFF75E).w
		bra.s	loc_1AC8E3

loc_1AC8E2:
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc_1AC8E3
		sub.w	#2,($FFFFF75E).w

loc_1AC8E3:
		move.b	#9,$1C(a0)
		btst	#7,$22(a0)
		bne.s	loc_1AC8E32
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	loc_1AC8E33

loc_1AC8E32:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

loc_1AC8E33:	
		btst	#1,d0
		bne.w	loc_1AD30
		move.b	#1,$1C(a0)
		cmpi.b	#2,(a0)
		beq.s	.silver
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		addq.w	#5,$C(a0)
		bset	#2,$22(a0)
		bra.s	.notsilver

	.silver:
		bsr.w	Silver_ResetGlow

	.notsilver:
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	Dash_Speeds(pc,d0.w),$20(a0)
		cmpi.b	#2,($FFFFFFEF).w
		bne.w	.nolag
		move.w	$20(a0),d0		; get inertia
		subi.w	#$800,d0		; subtract $800
		add.w	d0,d0			; double it
		andi.w	#$1F00,d0		; mask it against $1F00
		neg.w	d0			; negate it
		addi.w	#$2000,d0		; add $2000
		move.w	d0,($FFFFFEB2).w	; move to $EED0

	.nolag:
		btst	#0,$22(a0)		; is sonic facing right?
		beq.s	loc_1ACF4		; if not, branch
		neg.w	$20(a0)			; negate inertia
 
loc_1ACF4:
		cmpi.b	#2,(a0)
		beq.s	loc_1ACF43
		btst	#7,$22(a0)
		bne.s	loc_1ACF42
		move.b	#0,($FFFFB1DC).w	; clear Spin Dash dust animation.
		bra.s	loc_1ACF43

loc_1ACF42:
		move.b	#0,($FFFFB41C).w	; clear Spin Dash dust animation.

loc_1ACF43:
		sfx		sfx_Dash
		bra.w	loc_1AD78
; ===========================================================================
Dash_Speeds:	dc.w  $800		; 0
		dc.w  $880		; 1
		dc.w  $900		; 2
		dc.w  $980		; 3
		dc.w  $A00		; 4
		dc.w  $A80		; 5
		dc.w  $B00		; 6
		dc.w  $B80		; 7
		dc.w  $C00		; 8
; ===========================================================================
 
loc_1AD30:				; If still charging the dash...
		tst.w	$3A(a0)
		beq.s	loc_1AD48
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc_1AD48
		move.w	#0,$3A(a0)
 
loc_1AD48:
		btst	#7,$22(a0)
		bne.s	loc_1AD482
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	loc_1AD483

loc_1AD482:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

loc_1AD483:
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	loc_1AD78
		move.w	#$900,$1C(a0)
		sfx		sfx_Spindash
		cmpi.b	#2,(a0)
		beq.s	loc_1AD4833
		btst	#7,$22(a0)
		bne.s	loc_1AD4832
		move.b	#2,($FFFFB1DC).w	; Set the Spin Dash dust animation to $2.
		bra.s	loc_1AD4833

loc_1AD4832:
		move.b	#2,($FFFFB41C).w	; clear Spin Dash dust animation.

loc_1AD4833:
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc_1AD78
		move.w	#$800,$3A(a0)
 
loc_1AD78:
		addq.l	#4,sp			; increase stack ptr
		btst	#7,$22(a0)
		bne.s	loc_1AD8C
		cmpi.w	#$60,($FFFFF73E).w
		beq.s	loc_1AD8C
		bcc.s	loc_1AD88
		addq.w	#4,($FFFFF73E).w
 
loc_1AD88:
		subq.w	#2,($FFFFF73E).w
 
loc_1AD8C:
		bsr.w	Character_LevelBound
		jsr	Character_AnglePos
	;	move.w	#$60,($FFFFF73E).w	; reset looking up/down
		rts
; End of subroutine Character_SpinDash

; ---------------------------------------------------------------------------
; Subroutine to	slow Sonic walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_SlopeResist:			; XREF: Obj01_MdNormal
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bcc.s	locret_13508
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		beq.s	locret_13508
		bmi.s	loc_13504
		tst.w	d0
		beq.s	locret_13502
		add.w	d0,$20(a0)	; change Sonic's inertia

locret_13502:
		rts	
; ===========================================================================

loc_13504:
		add.w	d0,$20(a0)

locret_13508:
		rts	
; End of function Character_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_RollRepel:			; XREF: Obj01_MdRoll
		move.b	$26(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_13544
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	$20(a0)
		bmi.s	loc_1353A
		tst.w	d0
		bpl.s	loc_13534
		asr.l	#2,d0

loc_13534:
		add.w	d0,$20(a0)
		rts	
; ===========================================================================

loc_1353A:
		tst.w	d0
		bmi.s	loc_13540
		asr.l	#2,d0

loc_13540:
		add.w	d0,$20(a0)

locret_13544:
		rts	
; End of function Character_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_SlopeRepel:			; XREF: Obj01_MdNormal; Obj01_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret_13580
		tst.w	$2E(a0)
		bne.s	loc_13582
		move.b	$26(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret_13580
		move.w	$20(a0),d0
		bpl.s	loc_1356A
		neg.w	d0

loc_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret_13580
		clr.w	$20(a0)
		bset	#1,$22(a0)
		move.w	#$1E,$2E(a0)

locret_13580:
		rts	
; ===========================================================================

loc_13582:
		subq.w	#1,$2E(a0)
		rts	
; End of function Character_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Sonic's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_JumpAngle:			; XREF: Obj01_MdJump; Obj01_MdJump2
		move.b	$26(a0),d0	; get Sonic's angle
		beq.s	locret_135A2	; if already 0,	branch
		bpl.s	loc_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc_13596
		moveq	#0,d0

loc_13596:
		bra.s	loc_1359E
; ===========================================================================

loc_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc_1359E
		moveq	#0,d0

loc_1359E:
		move.b	d0,$26(a0)

locret_135A2:
		rts	
; End of function Character_JumpAngle

; ---------------------------------------------------------------------------
; Subroutine for Sonic to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_13680
		cmpi.b	#$80,d0
		beq.w	loc_136E2
		cmpi.b	#-$40,d0
		beq.w	loc_1373E
		jsr	Character_HitWall
		tst.w	d1
		bpl.s	loc_135F0
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_135F0:
		jsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13602
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_13602:
		move.b  $12(a0),d0	   ; * get blocks per frame (D)
		andi.w  #$F0,d0		 ; * ''
		move.w  d0,-(sp)		; * save D to stack

loc_13602_0:	 
		exg d0,d2		   ; * D as base Ypos
		add.w   $C(a0),d2	  ; * add ypos
		move.w  8(a0),d3	  ; * get xpos
		jsr   Character_HitFloor2	 ; * check
		tst.w   d1		  ; * success?
		bmi.s   loc_13602_1		  ; * yes, branch
		subi.w  #$10,(sp)	   ; * set D to previous $10 pixels
		move.w  (sp),d0		 ; * get D to our scratch reg
		bpl.s   loc_13602_0		  ; * if we have any remain to check, branch
		addq.w  #2,sp		   ; * if not (if there's definitely nothing to collide with)
		rts			 ;   fix the stack and return

loc_13602_1:	 
		move.w  (sp),d0		 ; * get D to our scratch reg
		addq.w  #2,sp		   ; * fix the stack
		add.w   d0,d1		   ; * add D to the "within-in-block" result (and fix final value)
		add.w   d1,$C(a0)	  ; * add final value to ypos
	;	move.b  d1,($FFFFFFEF).w
		tst.w   d0		  ; * check D
		beq.s   loc_1361E		  ; * if zero (falling slow), branch
		andi.w  #$FFF0,$C(a0)	  ; * just in case, align ypos
 
loc_1361E:
		move.b  d3,$26(a0)
		move.b	#0,$1C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1364E
		asr	$12(a0)
		bra.s	loc_13670
; ===========================================================================

loc_1364E:
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bra.w   Player_ResetOnFloor
; ===========================================================================

loc_1365C:
		move.w	#0,$10(a0)
		cmpi.w	#$FC0,$12(a0)
		ble.s	loc_13670
		move.w	#$FC0,$12(a0)

loc_13670:
		bsr.w   Player_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret_1367E
		neg.w	$20(a0)

locret_1367E:
		rts	
; ===========================================================================

loc_13680:
		jsr	Character_HitWall
		tst.w	d1
		bpl.s	loc_1369A
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc_1369A:
		jsr	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_136B4
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret_136B2
		move.w	#0,$12(a0)

locret_136B2:
		rts	
; ===========================================================================

loc_136B4:
		tst.w	$12(a0)
		bmi.s	locret_136E0
		jsr	Character_HitFloor
		tst.w	d1
		bpl.s	locret_136E0
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#0,$1C(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
		bsr.w	Player_ResetOnFloor

locret_136E0:
		rts	
; ===========================================================================

loc_136E2:
		jsr	Character_HitWall
		tst.w	d1
		bpl.s	loc_136F4
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_136F4:
		jsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13706
		add.w	d1,8(a0)
		move.w	#0,$10(a0)

loc_13706:
		jsr	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	locret_1373C
		sub.w	d1,$C(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_13726
		move.w	#0,$12(a0)
		rts	
; ===========================================================================

loc_13726:
		move.b	d3,$26(a0)
		bsr.w	Player_ResetOnFloor
		move.w	$12(a0),$20(a0)
		tst.b	d3
		bpl.s	locret_1373C
		neg.w	$20(a0)

locret_1373C:
		rts	
; ===========================================================================

loc_1373E:
		jsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13758
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		move.w	$12(a0),$20(a0)
		rts	
; ===========================================================================

loc_13758:
		jsr	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_13772
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	locret_13770
		move.w	#0,$12(a0)

locret_13770:
		rts	
; ===========================================================================

loc_13772:
		tst.w	$12(a0)
		bmi.s	locret_13770
		jsr	Character_HitFloor
		tst.w	d1
		bpl.s	locret_13770
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		move.w	$10(a0),$20(a0)
; End of function Character_Floor

; ---------------------------------------------------------------------------
; Subroutine to	reset Sonic's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Player_ResetOnFloor:			; XREF: PlatformObject; et al
		cmpi.b	#$8E,0(a0)
		beq.w	Shadow_ResetOnFloor
		cmpi.b	#$95,0(a0)
		beq.w	Tails_ResetOnFloor
		cmpi.b	#$99,0(a0)
		beq.w	Knuckles_ResetOnFloor
		cmpi.b	#2,0(a0)
		beq.w	Silver_ResetOnFloor

Sonic_ResetOnFloor:
		bclr	#7,($FFFFB02B).w
		move.b	#0,$39(a0)
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
	;	btst	#7,$22(a0)
	;	bne.s	loc_137E6
		cmpi.b	#1,$2B(a0)
		bne.s	@nobubble
		move.b	#0,$2B(a0)	; clear jumpdash flag
		btst	#7,$22(a0)
		bne.s	@nobubble
		btst	#6,($FFFFFE2C).w
		beq.s	@nobubble
		btst	#3,$22(a0)
		beq.s	BubbleShield_Bounce
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a3	; a3=object
		cmpi.b	#$41,(a3)
		bne.s	BubbleShield_Bounce

	@nobubble:
		cmpi.b	#2,$2B(a0)
		bne.w	@nodash
		btst	#3,$22(a0)
		beq.w	Dropdash_Speed
		clr.b	$2B(a0)
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a3	; a3=object
		cmpi.b	#$41,(a3)
		bne.w	Dropdash_Speed

	@nodash:
		tst.b	$29(a0)		; was jumpdash flag set
		beq.s	locret_12232
		move.b	#0,$29(a0)	; clear jumpdash flag
		bsr.w	JD_Reset
		move.w	$10(a0),$20(a0)

locret_12232:
		rts	
; End of function Player_ResetOnFloor

; =============== S U B R O U T I N E =======================================


BubbleShield_Bounce:
		movem.l	d1-d2,-(sp)
		move.w	#$780,d2
		btst	#6,$22(a0)
		beq.s	loc_12246
		move.w	#$400,d2

loc_12246:
		moveq	#0,d0
		move.w	$10(a0),d0
		asr.w	d0
		move.w	d0,$10(a0)
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)
		movem.l	(sp)+,d1-d2
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		bset	#2,$22(a0)
		move.b	#1,$3C(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		bset	#2,$22(a0)
		move.b	#8,($FFFFB19C).w
		sfx		sfx_BubbleAttack
		rts
; End of function BubbleShield_Bounce

; =============== S U B R O U T I N E =======================================

Dropdash_Speed:
		move.b	($FFFFF602).w,d0
		btst	#7,$22(a0)
		beq.s	.mainchar
		move.b	($FFFFF670).w,d0

	.mainchar:
		btst	#2,d0
		bne.s	.left
		btst	#3,d0
		bne.s	.right
		btst	#0,$22(a0)
		bne.s	.left

	.right:
		bclr	#0,$22(a0)
		moveq	#0,d0
		tst.w	$26(a0)
		blt.s	.rightslope
		move.w	$20(a0),d0
		asr.w	#2,d0
		addi.w	#$800,d0
		cmpi.w	#$C00,d0
		blt.w	.playsound
		move.w	#$C00,d0
		bra.s	.playsound

	.rightslope:
		move.w	$20(a0),d0
		asr.w	#1,d0
		addi.w	#$800,d0
		bra.s	.playsound

	.left:
		bset	#0,$22(a0)
		moveq	#0,d0
		tst.w	$26(a0)
		bgt.s	.leftslope
		move.w	$20(a0),d0
		asr.w	#2,d0
		subi.w	#$800,d0
		cmpi.w	#-$C00,d0
		bgt.w	.playsound
		move.w	#-$C00,d0
		bra.s	.playsound

	.leftslope:
		move.w	$20(a0),d0
		asr.w	#1,d0
		subi.w	#$800,d0

	.playsound:
		move.w	d0,$20(a0)
		bset	#2,$22(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		addq.w	#5,$C(a0)
		move.b	#0,$39(a0)
		move.b	#0,$2B(a0)
		sfx		sfx_Dash
		rts

; ---------------------------------------------------------------------------
; Subroutine to	reset Shadow's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_ResetOnFloor:			; XREF: PlatformObject; et al
		bclr	#7,($FFFFB02B).w
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc3_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc3_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		cmpi.b	#1,$2B(a0)
		bne.s	loc3_137E6
		move.b	#0,$2B(a0)	; clear jumpdash flag
		btst	#7,$22(a0)
		bne.s	loc3_137E6
		btst	#6,($FFFFFE2C).w
		beq.s	loc3_137E6
		btst	#3,$22(a0)
		beq.w	BubbleShield_Bounce
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		addi.l	#$FFB000,d0
		movea.l	d0,a3	; a3=object
		cmpi.b	#$41,(a3)
		bne.w	BubbleShield_Bounce

loc3_137E6:
		tst.b	$29(a0)		; was jumpdash flag set
		beq.s	locret3_12232
		move.b	#0,$29(a0)	; clear jumpdash flag
		bsr.w	JD_Reset
		move.w	$10(a0),$20(a0)

locret3_12232:
		rts	
; End of function Shadow_ResetOnFloor

; ---------------------------------------------------------------------------
; Subroutine to	reset Shadow's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_ResetOnFloor:			; XREF: PlatformObject; et al
		bclr	#7,($FFFFB02B).w
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc4_137E4
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc4_137E4:
		move.b	#0,$3C(a0)
		move.b	#0,$2B(a0)
		move.w	#0,($FFFFF7D0).w
		rts	
; End of function Tails_ResetOnFloor


; ---------------------------------------------------------------------------
; Subroutine to	reset Silver's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_ResetOnFloor:			; XREF: PlatformObject; et al
		bclr	#7,($FFFFB02B).w
		bclr	#5,$22(a0)
		bclr	#1,$22(a0)
		bclr	#4,$22(a0)
		btst	#2,$22(a0)
		beq.s	loc2_137E4
		bclr	#2,$22(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	#0,$1C(a0)	; use running/walking animation
		subq.w	#5,$C(a0)

loc2_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		move.b	#0,$29(a0)
		tst.b	$2B(a0)
		bne.s	Silver_ROFReset
		tst.b	$39(a0)
		bne.s	Silver_ROFReset
		rts

Silver_ROFReset:
		move.b	#0,$39(a0)
		btst	#0,$2B(a0)
		beq.s	Silver_ROFEnd
		asr.w	$10(a0)
		btst	#1,$2B(a0)
		bne.s	Silver_ROFEnd
		bclr	#0,$2B(a0)
		bra.w	Silver_ResetGlow

Silver_ROFEnd:
		rts	

; End of function Silver_ResetOnFloor

; ---------------------------------------------------------------------------
; Subroutine to	reset Shadow's mode when he lands on the floor
; ---------------------------------------------------------------------------

; =============== S U B	R O U T	I N E =======================================


Knuckles_ResetOnFloor:				  ; ...
		bclr	#7,($FFFFB02B).w
		tst.b	$39(a0)
		bne.s	Knuckles_ResetOnFloor_Part3
		move.b	#0,$1C(a0)
; End of function Knuckles_ResetOnFloor


; =============== S U B	R O U T	I N E =======================================


Knuckles_ResetOnFloor_Part2:			  ; ...
		move.b	$16(a0),d0
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		btst	#2,$22(a0)
		beq.s	Knuckles_ResetOnFloor_Part3
		bclr	#2,$22(a0)
		move.b	#0,$1C(a0)
		sub.b	#$13,d0
		ext.w	d0
		add.w	d0,$C(a0)

Knuckles_ResetOnFloor_Part3:
		bclr	#1,$22(a0)
		bclr	#5,$22(a0)
		bclr	#4,$22(a0)
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		move.b	#0,$27(a0)
	;	move.w	#0,($FFFFF66C).w
		move.b	#0,$2B(a0)
		cmp.b	#$20,$1C(a0)
		bcc.s	loc_316D5C
		cmp.b	#$14,$1C(a0)
		bne.s	return_316D62

loc_316D5C:					  ; ...
		move.b	#0,$1C(a0)

return_316D62:					  ; ...
		rts
; End of function Knuckles_ResetOnFloor

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	gets hurt
; ---------------------------------------------------------------------------

Obj01_Hurt:				; XREF: Obj01_Index
		clr.w	($FFFFFEB2).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc_1380C
		subi.w	#$20,$12(a0)

loc_1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_HurtStop:				; XREF: Obj01_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	JMP_KillSonic
		bsr.w	Character_Floor
		btst	#1,$22(a0)
		bne.s	locret_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret_13860:
		rts	
; End of function Character_HurtStop

JMP_KillSonic:
		jmp	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	dies
; ---------------------------------------------------------------------------

Obj01_Death:				; XREF: Obj01_Index
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver:				; XREF: Obj01_Death
		move.b	#1,(Scroll_Lock).w
		move.w	($FFFFF72E).w,d0
		addi.w	#$100,d0
		cmp.w	$C(a0),d0
		bcc.w	locret_13900
		move.w	#-$38,$12(a0)
		addq.b	#2,$24(a0)
		move.w	#60,$3A(a0)	; set time delay to 1 second
		move.b	#0,(Scroll_Lock).w
		move.b	#8,$24(a0)	; => Obj01_Respawning
		move.w	($FFFFFE32).w,8(a0)
		move.w	($FFFFFE34).w,$C(a0)
	;	move.w	(Saved_art_tile).w,2(a0)
		move.w	($FFFFFE54).w,$3E(a0)
		clr.w	($FFFFFE20).w
		move.b	#0,$2A(a0)
		move.w	#500,$1C(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.w	#0,$20(a0)
		move.b	#2,$22(a0)
		move.w	#0,$2E(a0)
		move.w	#0,$3A(a0)

locret_13900:
		rts	
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when the level is restarted
; ---------------------------------------------------------------------------

Obj01_ResetLevel:			; XREF: Obj01_Index
		tst.w	($FFFFF73A).w
		bne.s	Obj01_ResetLevel2
		tst.w	($FFFFF73C).w
		bne.s	Obj01_ResetLevel2
		move.b	#2,$24(a0)	; => Obj01_Control

Obj01_ResetLevel2:
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	(DisplaySprite).l

; ---------------------------------------------------------------------------
; Subroutine to	animate	Sonic's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sonic_Animate:				; XREF: Obj01_Control; et al
		lea	(SonicAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	SAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

SAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

SAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	SAnim_End_FF				; MJ: if so, branch to flag routines
 
SAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

SAnim_Delay:
		rts	
; ===========================================================================

SAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

SAnim_End:
		rts	
; ===========================================================================

SAnim_WalkRun:				; XREF: SAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Sonic's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Sonic mirrored horizontally?
		bne.s	loc_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	SAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Sonic's speed
		bpl.s	loc_13A9C
		neg.w	d2

loc_13A9C:
		lea	(SonAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Sonic at running speed?
		bcc.s	loc_13AB4	; if yes, branch
		lea	(SonAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0

loc_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_13AC2
		moveq	#0,d2

loc_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	SAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

SAnim_RollJump:				; XREF: SAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	SAnim_Push	; if not, branch
		move.w	$20(a0),d2	; get Sonic's speed
		bpl.s	loc_13ADE
		neg.w	d2

loc_13ADE:
		lea	(SonAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Sonic moving fast?
		bcc.s	loc_13AF0	; if yes, branch
		lea	(SonAni_Roll).l,a1 ; use slower	animation

loc_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_13AFA
		moveq	#0,d2

loc_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SAnim_Do2
; ===========================================================================

SAnim_Push:				; XREF: SAnim_RollJump
		move.w	$20(a0),d2	; get Sonic's speed
		bmi.s	loc_13B1E
		neg.w	d2

loc_13B1E:
		addi.w	#$800,d2
		bpl.s	loc_13B26
		moveq	#0,d2

loc_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(SonAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SAnim_Do2
; End of function Sonic_Animate

SonicAniData:
	include "_anim\Sonic.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 02 - Silver
; ---------------------------------------------------------------------------

Obj02:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj02_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj02_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj02_Index(pc,d0.w),d1
		jmp	Obj02_Index(pc,d1.w)
; ===========================================================================
Obj02_Index:	dc.w Obj02_Main-Obj02_Index
		dc.w Obj02_Control-Obj02_Index
		dc.w Obj02_Hurt-Obj02_Index
		dc.w Obj02_Death-Obj02_Index
		dc.w Obj02_ResetLevel-Obj02_Index
; ===========================================================================

Obj02_Main:				; XREF: Obj02_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Silver,4(a0)
		make_art_tile	ArtTile_Main,0,1
		btst	#7,$22(a0)
		beq.s	Obj02_Cont
		make_art_tile	ArtTile_Partner,0,1

Obj02_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$1E,$28(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_CreateDust
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w
		bra.s	Obj02_Control

Obj02_CreateDust:
		move.b	#5,($FFFFB400).w

Obj02_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.s	loc2_12C58
		bsr.w	Character_PanCamera
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc2_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc2_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Silver	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc2_12C58:
		tst.b	($FFFFF674).w	; are controls locked?
		bne.s	loc2_12C62	; if yes, branch
	;	move.b	#0,$2B(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control
		btst	#0,($FFFFF604).w
		beq.s	loc2_12C62
		move.w	($FFFFF604).w,($FFFFF670).w ; enable joypad control	
		bclr	#0,($FFFFF670).w

loc2_12C62:
		bsr.w	CPU_Control
		bra.s	loc2_12C64

loc2_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc2_12C64	; if yes, branch
		bset	#0,($FFFFF602).w
		btst	#0,($FFFFF604).w
		bne.s	loc2_12C64
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc2_12C64:
		btst	#0,$2A(a0) ; are controls	locked?
		bne.s	loc2_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj02_Modes(pc,d0.w),d1
		jsr	Obj02_Modes(pc,d1.w)

loc2_12C7E:
		bsr.s	Silver_Display
		bsr.w	Main_RecordPos
		bsr.w	Character_Water
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc2_12CA6
		tst.b	$1C(a0)
		bne.s	loc2_12CA6
		move.b	$1D(a0),$1C(a0)

loc2_12CA6:
		bsr.w	Silver_Animate
		tst.b	$2A(a0)
		bmi.s	loc2_12CB6
		jsr	TouchResponse

loc2_12CB6:
		jmp	LoadCharacterDynPLC
; ===========================================================================
Obj02_Modes:	dc.w Obj02_MdNormal-Obj02_Modes
		dc.w Obj02_MdJump-Obj02_Modes
		dc.w Obj02_MdRoll-Obj02_Modes
		dc.w Obj02_MdJump2-Obj02_Modes

Silver_Display:				; XREF: loc2_12C7E
		move.w	$30(a0),d0
		beq.s	Obj02_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj02_Display
		lsr.w	#3,d0
		bcc.s	Obj02_ChkInvin

Obj02_Display:
		jsr	DisplaySprite

Obj02_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Silver have invincibility?
		beq.w	Obj02_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj02_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj02_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj02_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj02_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w
		jsr	LoadMusic

Obj02_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj02_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Silver have speed	shoes?
		beq.s	Obj02_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj02_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj02_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Silver's speed
		move.w	#$C,($FFFFF762).w ; restore Silver's acceleration
		move.w	#$80,($FFFFF764).w ; restore Silver's deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

Obj02_ExitChk:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Silver
; ---------------------------------------------------------------------------

Obj02_MdNormal:				; XREF: Obj02_Modes
		bsr.w	Character_SpinDash
		bsr.w	Silver_Pickup
		bsr.w	Character_Jump
		bsr.w	Character_SlopeResist
		bsr.w	Character_Move
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj02_MdJump:				; XREF: Obj02_Modes
		clr.b	$39(a0)
		bsr.w	Silver_Pickup
		bsr.w	Silver_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc2_12E5C
		subi.w	#$28,$12(a0)

loc2_12E5C:
		tst.w	$12(a0)
		bmi.s	loc2_12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	loc2_12E5E
		move.b	#$C,$1C(a0)

loc2_12E5E:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	
; ===========================================================================

Obj02_MdRoll:				; XREF: Obj02_Modes
		bsr.w	Character_Jump
		bsr.w	Character_RollRepel
		bsr.w	Character_RollSpeed
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		jsr	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj02_MdJump2:				; XREF: Obj02_Modes
		clr.b	$39(a0)
		bsr.w	Silver_Pickup
		bsr.w	Silver_Levitate
		bsr.w	Silver_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc2_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc2_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc2_12EA6
		move.w	$10(a0),d0		; move Sonic's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj02_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj02_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Sonic speed less than $250?
		blt.s	loc2_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move sonic's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Sonic slightly in the water?
		bgt.s	loc2_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water

loc2_12EA6:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to make Silver pick up the nearest enemy
; ---------------------------------------------------------------------------

Silver_Pickup:
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		btst	#7,$22(a0)
		beq.s	.main
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

	.main:
		move.b	($FFFFFFEE).w,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	.notpressed
		btst	#1,$2B(a0)
		bne.w	.stophold
		cmpi.w	#$600,$20(a0)
		bge.w	.locret
		cmpi.w	#-$600,$20(a0)
		ble.w	.locret
		move.w	8(a0),d2	; load Silver's x-axis value
		move.w	$C(a0),d3	; load Silver's y-axis value
		moveq	#-1,d5
		lea	($FFFFB800).w,a1 ; begin checking the object RAM
		move.w	#$5F,d6

	.loop:
		tst.b	1(a1)
		bpl.s	.nextobj
		tst.b	$20(a1)
		beq.s	.nextobj
		cmpi.b	#$26,(a1)
		beq.s	.nextobj
		move.w	d2,d0
		sub.w	8(a1),d0
		move.w	d3,d1
		sub.w	$C(a1),d1
		btst	#0,$22(a0)
		bne.s	.right
		neg.w	d0

	.right:
		tst.w	d0
		bmi.s	.nextobj
		tst.w	d1
		bpl.s	.up
		neg.w	d1

	.up:
		add.w	d1,d0
		tst.w	d0
		beq.s	.nextobj
		cmp.w	d0,d5
		bge.s	.nextobj
		move.w	d0,d5
		movea.l	a1,a2

	.nextobj:
		lea	$40(a1),a1	; next object RAM
		dbf	d6,.loop	; repeat $5F more times
		lea	($FFFFB380).w,a1
		tst.b	(a1)
		beq.s	.nopartner
		move.w	d2,d0
		sub.w	8(a1),d0
		move.w	d3,d1
		sub.w	$C(a1),d1
		btst	#0,$22(a0)
		bne.s	.rightpartner
		neg.w	d0

	.rightpartner:
		tst.w	d0
		bmi.s	.nopartner
		tst.w	d1
		bpl.s	.uppartner
		neg.w	d1

	.uppartner:
		add.w	d1,d0
		tst.w	d0
		beq.s	.nopartner
		cmp.w	d0,d5
		bge.s	.nopartner
		move.w	d0,d5
		movea.l	a1,a2
		move.b	#2,$1C(a2)

	.nopartner:
		tst.w	d5
		bmi.s	.locret
		move.b	(a2),$3D(a2)
		move.w	a0,$3E(a2)
		moveq	#0,d0
		move.b	#$B,(a2)
		move.w	d0,$20(a2)
		move.b	d0,$24(a2)
		move.l	d0,$10(a2)
		bset	#1,$2B(a0)
		move.w	#$400,($FFFFF760).w
		sfx		sfx_Dash	; play jumpdash sound
		bsr.w	Silver_Glow
		tst.w	$20(a0)
		bne.s	.locret
		move.b	#$12,$1C(a0)

	.locret:
		rts

	.stophold:
		bclr	#1,$2B(a0)
		move.w	#$600,($FFFFF760).w
		bra.s	Silver_ResetGlow

	.notpressed:
		btst	#1,$2B(a0)
		beq.s	.locret
		rts

Silver_Glow:
		moveq	#0,d1
		move.b	(Current_Partner).w,d1
		btst	#7,$22(a0)
		beq.s	.main
		move.b	(Current_Character).w,d1

	.main:
		move.b	.glowtable(pc,d1.w),d0
		andi.w	#$FF,d0
		movem.l	d7/a1-a3,-(sp)
		jsr	PalLoad2
		movem.l	(sp)+,d7/a1-a3
		tst.b	(Water_Flag).w
		beq.s	.locret
		move.b	.glowtablewater(pc,d1.w),d0
		movem.l	d7/a1-a3,-(sp)
		jsr	PalLoad4_Water
		movem.l	(sp)+,d7/a1-a3

	.locret:
		rts

	.glowtable:	
		dc.b $26, $25, $27, $13, $25

	.glowtablewater:
		dc.b $26, $25, $27, $13, $25

Silver_ResetGlow:
		moveq	#0,d1
		move.b	(Current_Partner).w,d1
		btst	#7,$22(a0)
		beq.s	.main
		move.b	(Current_Character).w,d1

	.main:
		move.b	.resettable(pc,d1.w),d0
		andi.w	#$FF,d0
		movem.l	d7/a1-a3,-(sp)
		jsr	PalLoad2
		movem.l	(sp)+,d7/a1-a3
		tst.b	(Water_Flag).w
		beq.s	.locret
		move.b	.resettablewater(pc,d1.w),d0
		movem.l	d7/a1-a3,-(sp)
		jsr	PalLoad4_Water
		movem.l	(sp)+,d7/a1-a3

	.locret:
		rts

	.resettable:
		dc.b $C, $B, $D, $E, $B

	.resettablewater:
		dc.b $1D, $1C, $1E, $1F, $1C

; ---------------------------------------------------------------------------
; Object under Silver's control
; ---------------------------------------------------------------------------

Obj0B:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0B_Index(pc,d0.w),d1
		jmp	Obj0B_Index(pc,d1.w)
; ===========================================================================
Obj0B_Index:	dc.w Obj0B_ToSilver-Obj0B_Index
		dc.w Obj0B_Release-Obj0B_Index
; ===========================================================================

Obj0B_ToSilver:
		movea.w	$3E(a0),a1
		btst	#1,$2B(a1)
		beq.w	Obj0B_Fling
		cmpi.b	#4,$24(a1)
		bge.w	Obj0B_Fall
		move.b	$10(a1),d2
		move.b	$12(a1),d3
		ext.w	d2
		ext.w	d3
		add.w	d2,8(a0)
		add.w	d3,$C(a0)
		move.w	8(a0),d0
		move.w	$C(a0),d1
		move.w	8(a1),d2
		move.w	$C(a1),d3
		addi.w	#$20,d2
		subi.w	#$20,d3
		btst	#0,$22(a1)
		beq.s	.flip
		subi.w	#$40,d2

	.flip:
		sub.w	d2,d0
		sub.w	d3,d1
		asr.w	#3,d0
		asr.w	#3,d1
		sub.w	d0,8(a0)
		sub.w	d1,$C(a0)
		move.w	$10(a1),$10(a0)
		move.w	$12(a1),$12(a0)
		tst.w	$10(a1)
		bne.s	.notstill
		tst.w	$12(a1)
		bne.s	.notstill
		move.w	#-1,$12(a0)

	.notstill:
		cmp.l	#$FFFFB380,a0
		bne.s	.display
		bset	#7,$2B(a1)
		bsr.w	LoadPartnerDynPLC
		bsr.w	Partner_Animate

	.display:
		jmp	DisplaySprite

Obj0B_Fling:
		addq.b	#2,$24(a0)
		move.w	$10(a1),$10(a0)
		addi.w	#$400,$10(a0)
		move.w	#0,$12(a0)
		btst	#0,$22(a1)
		beq.s	.flip
		subi.w	#$800,$10(a0)

	.flip:
		cmp.l	#$FFFFB380,a0
		bne.s	Obj0B_Release
		move.b	$3D(a0),(a0)
		move.b	#2,$24(a0)
		bset	#1,$22(a0)
		bset	#2,$22(a0)
		move.w	$3E(a1),$3E(a0)
		move.b	#0,($FFFFF678).w
		jmp	DisplaySprite

Obj0B_Release:
		bsr.w	ObjectFall
		jsr	SpeedToPos
		jsr	TouchResponse
		jmp	MarkObjGone

Obj0B_Fall:
		bsr.w	ObjectFall
		jsr	SpeedToPos
		jmp	MarkObjGone

; ---------------------------------------------------------------------------
; Subroutine to make Silver levitate
; ---------------------------------------------------------------------------

Silver_Levitate:
		btst	#0,$2B(a0)		; was jumpdash flag set?
		bne.w	JD_Hold			; if yes, branch
		cmpi.b	#1,$29(a0)
		bpl.w	LV_End
		btst	#7,$22(a0)
		bne.s	Silver_Levitate2
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		bra.s	Silver_Levitate3

Silver_Levitate2:	
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Silver_Levitate3:	
		andi.b	#$30,d0			; is ABC pressed? (part 2)
		beq.w	LV_End			; if not, branch
		bset	#0,$2B(a0)
		asl.w	$10(a0)
		cmpi.w	#$1000,$10(a0)
		ble.s	.leftspeed
		move.w	#$1000,$10(a0)

	.leftspeed:
		cmpi.w	#-$1000,$10(a0)
		bge.s	.speedset
		move.w	#-$1000,$10(a0)

	.speedset:
		sfx		sfx_Dash	; play jumpdash sound
		btst	#1,$2B(a0)
		bne.s	LV_End
		bra.w	Silver_Glow

JD_Hold:
		btst	#7,$22(a0)
		bne.s	JD_Hold2
		move.b	($FFFFF602).w,d0	; is ABC pressed? (part 1)
		bra.s	JD_Hold3
JD_Hold2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed? (part 1)

JD_Hold3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		addi.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.s	LV_Lose			; if not, branch
		subi.b	#1,$29(a0)
		bpl.s	LV_Clear
		clr.w	$12(a0)			; clear Sonic's Y-velocity to move sonic directly down
		move.b	#2,$1C(a0)		

LV_End:
		rts				; return

LV_Lose:
		subi.b	#1,$29(a0)
		bpl.s	LV_Clear
		subi.b	#1,$29(a0)
		bpl.s	LV_Clear
		subi.b	#1,$29(a0)
		bpl.s	LV_Clear
		subi.b	#1,$29(a0)
		bpl.s	LV_Clear
		subi.b	#1,$29(a0)

LV_Clear:
		bclr	#0,$2B(a0)
		move.b	#$C,$1C(a0)
		asr.w	$10(a0)
		btst	#1,$2B(a0)
		bne.s	LV_End
		bra.w	Silver_ResetGlow
; End of function Silver_Levitate

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_JumpHeight:			; XREF: Obj02_MdJump; Obj02_MdJump2
		tst.b	$3C(a0)
		beq.s	loc2_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc2_134AE
		move.w	#-$200,d1

loc2_134AE:
		cmp.w	$12(a0),d1
		ble.s	locret2_134C2
		btst	#7,$22(a0)
		bne.s	Silver_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Silver_JumpHeight3

Silver_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Silver_JumpHeight3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		bne.s	locret2_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret2_134C2:
		rts	
; ===========================================================================

loc2_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret2_134D2
		move.w	#-$FC0,$12(a0)

locret2_134D2:
		rts	
; End of function Character_JumpHeight

; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when he	gets hurt
; ---------------------------------------------------------------------------

Obj02_Hurt:				; XREF: Obj02_Index
		clr.w	($FFFFFEB2).w
		tst.b	$2B(a0)
		beq.s	.nopower
		clr.b	$2B(a0)
		bsr.w	Silver_ResetGlow

	.nopower:
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc2_1380C
		subi.w	#$20,$12(a0)

loc2_1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Silver_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when he	dies
; ---------------------------------------------------------------------------

Obj02_Death:				; XREF: Obj02_Index
		tst.b	$2B(a0)
		beq.s	.nopower
		clr.b	$2B(a0)
		bsr.w	Silver_ResetGlow

	.nopower:
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Silver_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Silver	when the level is restarted
; ---------------------------------------------------------------------------

Obj02_ResetLevel:			; XREF: Obj02_Index
		tst.w	($FFFFF73A).w
		bne.s	Obj02_ResetLevel2
		tst.w	($FFFFF73C).w
		bne.s	Obj02_ResetLevel2
		move.b	#2,$24(a0)	; => Obj01_Control

Obj02_ResetLevel2:
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	(DisplaySprite).l

; ---------------------------------------------------------------------------
; Subroutine to	animate	Silver's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Silver_Animate:				; XREF: Obj01_Control; et al
		lea	(SilverAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	SilAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

SilAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SilAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SilAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

SilAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	SilAnim_End_FF				; MJ: if so, branch to flag routines
 
SilAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

SilAnim_Delay:
		rts	
; ===========================================================================

SilAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SilAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	SilAnim_Next
; ===========================================================================

SilAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SilAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	SilAnim_Next
; ===========================================================================

SilAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SilAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

SilAnim_End:
		rts	
; ===========================================================================

SilAnim_WalkRun:				; XREF: SilAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	SilAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SilAnim_Push	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Silver's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Silver mirrored horizontally?
		bne.s	loc2_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc2_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc2_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc2_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	SilAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Silver's speed
		bpl.s	loc2_13A9C
		neg.w	d2

loc2_13A9C:
		lea	(SilAni_Fly).l,a1 ; use running animation
		cmpi.w	#$600,d2	; is Sonic at running speed?
		bcc.s	loc2_13AC4	; if yes, branch
		lea	(SilAni_Walk).l,a1 ; use walking animation
		btst	#1,$2B(a0)
		beq.s	.walk
		lea	(SilAni_PsyWalk).l,a1 ; use walking animation

	.walk:
		add.b	d0,d0
		add.b	d0,d0
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc2_13AC2
		moveq	#0,d2

loc2_13AC2:
		lsr.w	#8,d2
		bra.s	loc2_13AC6

loc2_13AC4:
		moveq	#3,d2

loc2_13AC6:
		move.b	d0,d3
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	SilAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	
; ===========================================================================			

SilAnim_Push:				; XREF: SilAnim_RollJump
		move.w	$20(a0),d2	; get Silver's speed
		bmi.s	loc2_13B1E
		neg.w	d2

loc2_13B1E:
		addi.w	#$800,d2
		bpl.s	loc2_13B26
		moveq	#0,d2

loc2_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(SilAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	SilAnim_Do2
; End of function Silver_Animate

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8E - Shadow
; ---------------------------------------------------------------------------

obj8E:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	obj8E_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

obj8E_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	obj8E_Index(pc,d0.w),d1
		jmp	obj8E_Index(pc,d1.w)
; ===========================================================================
obj8E_Index:	dc.w obj8E_Main-obj8E_Index
		dc.w obj8E_Control-obj8E_Index
		dc.w obj8E_Hurt-obj8E_Index
		dc.w obj8E_Death-obj8E_Index
		dc.w obj8E_ResetLevel-obj8E_Index
; ===========================================================================

obj8E_Main:				; XREF: obj8E_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Shadow,4(a0)
		make_art_tile	ArtTile_Main,0,1
		btst	#7,$22(a0)
		beq.s	Obj8E_Cont
		make_art_tile	ArtTile_Partner,0,1

Obj8E_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$1E,$28(a0)
		btst	#7,$22(a0)
		bne.s	Obj8E_CreateDust
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w
		bra.s	Obj8E_Control

Obj8E_CreateDust:
		move.b	#5,($FFFFB400).w

Obj8E_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.s	loc3_12C58
		bsr.w	Character_PanCamera
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc3_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc3_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Shadow	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc3_12C58:
		tst.b	($FFFFF674).w	; are controls locked?
		bne.s	loc3_12C62	; if yes, branch
	;	move.b	#0,$2B(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control
		btst	#0,($FFFFF604).w
		beq.s	loc3_12C62
		move.w	($FFFFF604).w,($FFFFF670).w ; enable joypad control	
		bclr	#0,($FFFFF670).w

loc3_12C62:
		bsr.w	CPU_Control
		bra.s	loc3_12C64

loc3_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc3_12C64	; if yes, branch
		bset	#0,($FFFFF602).w
		btst	#0,($FFFFF604).w
		bne.s	loc3_12C64
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc3_12C64:
		btst	#0,$2A(a0) ; are controls	locked?
		bne.s	loc3_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	obj8E_Modes(pc,d0.w),d1
		jsr	obj8E_Modes(pc,d1.w)

loc3_12C7E:
		bsr.s	Shadow_Display
		bsr.w	Main_RecordPos
		bsr.w	Character_Water
		btst	#7,$22(a0)
		bne.s	loc3_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc3_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc3_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc3_12C7E2

loc3_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc3_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc3_12C7E2
		add.w	#2,($FFFFF75E).w

loc3_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc3_12CA6
		tst.b	$1C(a0)
		bne.s	loc3_12CA6
		move.b	$1D(a0),$1C(a0)

loc3_12CA6:
		bsr.w	Shadow_Animate
		tst.b	$2A(a0)
		bmi.s	loc3_12CB6
		jsr	TouchResponse

loc3_12CB6:
		jmp	LoadCharacterDynPLC
; ===========================================================================
obj8E_Modes:	dc.w obj8E_MdNormal-obj8E_Modes
		dc.w obj8E_MdJump-obj8E_Modes
		dc.w obj8E_MdRoll-obj8E_Modes
		dc.w obj8E_MdJump2-obj8E_Modes
; ===========================================================================

Shadow_Display:				; XREF: loc3_12C7E
		move.w	$30(a0),d0
		beq.s	obj8E_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj8E_Display
		lsr.w	#3,d0
		bcc.s	obj8E_ChkInvin

obj8E_Display:
		jsr	DisplaySprite

obj8E_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Shadow have invincibility?
		beq.w	obj8E_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	obj8E_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	obj8E_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	obj8E_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	obj8E_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w
		jsr	LoadMusic

obj8E_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

obj8E_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Shadow have speed	shoes?
		beq.s	obj8E_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	obj8E_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	obj8E_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Shadow"s speed
		move.w	#$C,($FFFFF762).w ; restore Shadow"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Shadow"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

obj8E_ExitChk:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Shadow
; ---------------------------------------------------------------------------

obj8E_MdNormal:				; XREF: obj8E_Modes
		bsr.w	Character_SpinDash
		bsr.w	Character_Jump
		bsr.w	Character_SlopeResist
		bsr.w	Character_Move
		bsr.w	Character_Roll
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

obj8E_MdJump:				; XREF: obj8E_Modes
		clr.b	$39(a0)
		bsr.w	Shadow_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc3_12E5C
		subi.w	#$28,$12(a0)

loc3_12E5C:
		tst.w	$12(a0)
		bmi.s	loc3_12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	loc3_12E5E
		move.b	#$C,$1C(a0)

loc3_12E5E:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	
; ===========================================================================

obj8E_MdRoll:				; XREF: obj8E_Modes
		bsr.w	Character_Jump
		bsr.w	Character_RollRepel
		bsr.w	Character_RollSpeed
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

obj8E_MdJump2:				; XREF: obj8E_Modes
		clr.b	$39(a0)
		bsr.w	Shadow_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc3_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc3_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc3_12EA6
		move.w	$10(a0),d0		; move Shadow's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	obj8E_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

obj8E_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Shadow speed less than $250?
		blt.s	loc3_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move Shadow's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Shadow slightly in the water?
		bgt.s	loc3_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)		; jump out of water

loc3_12EA6:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_JumpHeight:			; XREF: obj8E_MdJump; obj8E_MdJump2
		tst.b	$3C(a0)
		beq.s	loc3_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc3_134AE
		move.w	#-$200,d1

loc3_134AE:
		cmp.w	$12(a0),d1
		ble.w	Sonic_JumpDash
		btst	#7,$22(a0)
		bne.s	Shadow_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Shadow_JumpHeight3

Shadow_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Shadow_JumpHeight3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		bne.s	locret3_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret3_134C2:
		rts	
; ===========================================================================

loc3_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret3_134D2
		move.w	#-$FC0,$12(a0)

locret3_134D2:
		rts	
; End of function Shadow_JumpHeight

; ==========================================================================
; ---------------------------------------------------------------------------
; Shadow	when he	gets hurt
; ---------------------------------------------------------------------------

obj8E_Hurt:				; XREF: obj8E_Index
		clr.w	($FFFFFEB2).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc3_1380C
		subi.w	#$20,$12(a0)

loc3_1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Shadow_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Shadow	when he	dies
; ---------------------------------------------------------------------------

obj8E_Death:				; XREF: obj8E_Index
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Shadow_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Shadow	when the level is restarted
; ---------------------------------------------------------------------------

Obj8E_ResetLevel:			; XREF: obj8E_Index
		tst.w	($FFFFF73A).w
		bne.s	Obj8E_ResetLevel2
		tst.w	($FFFFF73C).w
		bne.s	Obj8E_ResetLevel2
		move.b	#2,$24(a0)	; => Obj01_Control

Obj8E_ResetLevel2:
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	(DisplaySprite).l

; ---------------------------------------------------------------------------
; Subroutine to	animate	Shadow's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Shadow_Animate:				; XREF: obj8E_Control; et al
		lea	(ShadowAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	ShaAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

ShaAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	ShaAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	ShaAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

ShaAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	ShaAnim_End_FF				; MJ: if so, branch to flag routines
 
ShaAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

ShaAnim_Delay:
		rts	
; ===========================================================================

ShaAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	ShaAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	ShaAnim_Next
; ===========================================================================

ShaAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	ShaAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	ShaAnim_Next
; ===========================================================================

ShaAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	ShaAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

ShaAnim_End:
		rts	
; ===========================================================================

ShaAnim_WalkRun:				; XREF: ShaAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	ShaAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	ShaAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Shadow's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Shadow mirrored horizontally?
		bne.s	loc3_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc3_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc3_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc3_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	ShaAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Shadow's speed
		bpl.s	loc3_13A9C
		neg.w	d2

loc3_13A9C:
		lea	(ShaAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Shadow at running speed?
		bcc.s	loc3_13AC4	; if yes, branch
		lea	(ShaAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc3_13AC2
		moveq	#0,d2

loc3_13AC2:
		lsr.w	#8,d2
		bra.s	loc3_13AC6

loc3_13AC4:
		add.b	d0,d0
		add.b	d0,d0
		add.b	d0,d0
		move.b	d0,d3
		moveq	#3,d2

loc3_13AC6:
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	ShaAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

ShaAnim_RollJump:				; XREF: ShaAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	ShaAnim_Push	; if not, branch
		move.w	$20(a0),d2	; get Shadow's speed
		bpl.s	loc3_13ADE
		neg.w	d2

loc3_13ADE:
		lea	(ShaAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Shadow moving fast?
		bcc.s	loc3_13AF0	; if yes, branch
		lea	(ShaAni_Roll).l,a1 ; use slower	animation

loc3_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc3_13AFA
		moveq	#0,d2

loc3_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	ShaAnim_Do2
; ===========================================================================

ShaAnim_Push:				; XREF: ShaAnim_RollJump
		move.w	$20(a0),d2	; get Shadow's speed
		bmi.s	loc3_13B1E
		neg.w	d2

loc3_13B1E:
		addi.w	#$800,d2
		bpl.s	loc3_13B26
		moveq	#0,d2

loc3_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(ShaAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	ShaAnim_Do2
; End of function Shadow_Animate

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 95 - Tails
; ---------------------------------------------------------------------------

Obj95:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj95_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj95_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj95_Index(pc,d0.w),d1
		jmp	Obj95_Index(pc,d1.w)
; ===========================================================================
Obj95_Index:	dc.w Obj95_Main-Obj95_Index
		dc.w Obj95_Control-Obj95_Index
		dc.w Obj95_Hurt-Obj95_Index
		dc.w Obj95_Death-Obj95_Index
		dc.w Obj95_ResetLevel-Obj95_Index
; ===========================================================================

Obj95_Main:				; XREF: Obj95_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Tails,4(a0)
		make_art_tile	ArtTile_Main,0,1
		btst	#7,$22(a0)
		beq.s	Obj95_Cont
		make_art_tile	ArtTile_Partner,0,1

Obj95_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$96,($FFFFB3C0).w ; load Obj05 (Tails' Tails)
		move.w	a0,($FFFFB3F2).w ; set its parent object to this
		move.b	#$1E,$28(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_CreateDust
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w
		bra.s	Obj95_Control

Obj95_CreateDust:
		move.b	#5,($FFFFB400).w

Obj95_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.s	loc4_12C58
		bsr.w	Character_PanCamera
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc4_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc4_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Tails	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc4_12C58:
		tst.b	($FFFFF674).w	; are controls locked?
		bne.s	loc4_12C62	; if yes, branch
	;	move.b	#0,$2B(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control
		btst	#0,($FFFFF604).w
		beq.s	loc4_12C62
		move.w	($FFFFF604).w,($FFFFF670).w ; enable joypad control	
		bclr	#0,($FFFFF670).w

loc4_12C62:
		bsr.w	CPU_Control
		bra.s	loc4_12C64

loc4_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc4_12C64	; if yes, branch
		bset	#0,($FFFFF602).w
		btst	#0,($FFFFF604).w
		bne.s	loc4_12C64
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc4_12C64:
		btst	#0,$2A(a0) ; are controls	locked?
		bne.s	loc4_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj95_Modes(pc,d0.w),d1
		jsr	Obj95_Modes(pc,d1.w)

loc4_12C7E:
		bsr.s	Tails_Display
		bsr.w	Main_RecordPos
		bsr.w	Character_Water
		btst	#7,$22(a0)
		bne.s	loc4_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc4_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc4_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc4_12C7E2

loc4_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc4_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc4_12C7E2
		add.w	#2,($FFFFF75E).w

loc4_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc4_12CA6
		tst.b	$1C(a0)
		bne.s	loc4_12CA6
		move.b	$1D(a0),$1C(a0)

loc4_12CA6:
		bsr.w	Tails_Animate
		tst.b	$2A(a0)
		bmi.s	loc4_12CB6
		jsr	TouchResponse

loc4_12CB6:
		bra.w	LoadCharacterDynPLC
; ===========================================================================
Obj95_Modes:	dc.w Obj95_MdNormal-Obj95_Modes
		dc.w Obj95_MdJump-Obj95_Modes
		dc.w Obj95_MdRoll-Obj95_Modes
		dc.w Obj95_MdJump2-Obj95_Modes

Tails_Display:				; XREF: loc4_12C7E
		move.w	$30(a0),d0
		beq.s	Obj95_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj95_Display
		lsr.w	#3,d0
		bcc.s	Obj95_ChkInvin

Obj95_Display:
		jsr	DisplaySprite

Obj95_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Tails have invincibility?
		beq.w	Obj95_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj95_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj95_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj95_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj95_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w
		jsr	LoadMusic

Obj95_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj95_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Tails have speed	shoes?
		beq.s	Obj95_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj95_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj95_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Tails"s speed
		move.w	#$C,($FFFFF762).w ; restore Tails"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Tails"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

Obj95_ExitChk:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Tails
; ---------------------------------------------------------------------------

Obj95_MdNormal:				; XREF: Obj95_Modes
		bsr.w	Character_SpinDash
		bsr.w	Tails_TailWhip
		bsr.w	Tails_Jump
		bsr.w	Character_SlopeResist
		bsr.w	Character_Move
		bsr.w	Character_Roll
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj95_MdJump:				; XREF: Obj95_Modes
		clr.b	$39(a0)
		tst.b	$2B(a0)
		bne.w	Tails_FlyingSwimming
		bsr.w	Tails_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc4_12E5C
		subi.w	#$28,$12(a0)

loc4_12E5C:
		tst.w	$12(a0)
		bmi.s	loc4_12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	loc4_12E5E
		move.b	#$C,$1C(a0)

loc4_12E5E:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	
; ===========================================================================

Obj95_MdRoll:				; XREF: Obj95_Modes
		bsr.w	Tails_Jump
		bsr.w	Character_RollRepel
		bsr.w	Tails_RollSpeed
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj95_MdJump2:				; XREF: Obj95_Modes
		clr.b	$39(a0)
		bsr.w	Tails_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc4_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc4_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc4_12EA6
		move.w	$10(a0),d0		; move Tails's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj95_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj95_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Tails speed less than $250?
		blt.s	loc4_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move Tails's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Tails slightly in the water?
		bgt.s	loc4_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)		; jump out of water

loc4_12EA6:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	change Tails's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_RollSpeed:			; XREF: Obj95_MdRoll
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc4_131CC
		tst.w	$2E(a0)
		bne.s	loc4_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc4_1317C	; if not, branch
		bsr.w	Character_RollLeft

loc4_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc4_13188	; if not, branch
		bsr.w	Character_RollRight

loc4_13188:
		move.w	$20(a0),d0
		beq.s	loc4_131AA
		bmi.s	loc4_1319E
		sub.w	d5,d0
		bcc.s	loc4_13198
		move.w	#0,d0

loc4_13198:
		move.w	d0,$20(a0)
		bra.s	loc4_131AA
; ===========================================================================

loc4_1319E:				; XREF: Tails_RollSpeed
		add.w	d5,d0
		bcc.s	loc4_131A6
		move.w	#0,d0

loc4_131A6:
		move.w	d0,$20(a0)

loc4_131AA:
		tst.w	$20(a0)		; is Tails moving?
		bne.s	loc4_131CC	; if yes, branch
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	#5,$1C(a0)	; use "standing" animation
		subq.w	#5,$C(a0)

loc4_131CC:
		btst	#7,$22(a0)
		bne.s	.cont2
		cmp.w	#$60,($FFFFF73E).w
		beq.s	.cont2
		bcc.s	.cont1
		addq.w	#4,($FFFFF73E).w
 
.cont1:
		subq.w	#2,($FFFFF73E).w
 
.cont2:
		move.b	$26(a0),d0
		jsr	(CalcSine).l
		muls.w	$20(a0),d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		muls.w	$20(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc4_131F0
		move.w	#$1000,d1

loc4_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc4_131FA
		move.w	#-$1000,d1

loc4_131FA:
		move.w	d1,$10(a0)
		bra.w	loc_1300C
; End of function Tails_RollSpeed

; ---------------------------------------------------------------------------
; Subroutine allowing Tails to jump
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_Jump:				; XREF: Obj95_MdNormal; Obj95_MdRoll
		btst	#7,$22(a0)
		bne.s	Tails_Jump2
		move.b	($FFFFF603).w,d0
		bra.s	Tails_Jump3

Tails_Jump2:	
		move.b	($FFFFF671).w,d0

Tails_Jump3:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	locret4_1348E	; if not, branch
		move.b	#0,$2A(a0)
		moveq	#0,d0
		move.b	$26(a0),d0
		addi.b	#$80,d0
		bsr.w	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret4_1348E
		move.w	#$680,d2
		btst	#6,$22(a0)
		beq.s	loc4_1341C
		move.w	#$380,d2

loc4_1341C:
		moveq	#0,d0
		move.b	$26(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,$10(a0)	; make Tails jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,$12(a0)	; make Tails jump
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		sfx		sfx_Jump ;	play jumping sound
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
        btst    #2,$22(a0)
        bne.s   locret4_1348E
		move.b	#2,$1C(a0)	; use "jumping"	animation
		bset	#2,$22(a0)
		addq.w	#5,$C(a0)

locret4_1348E:
		rts	
; End of function Tails_Jump

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_JumpHeight:			; XREF: Obj95_MdJump; Obj95_MdJump2
		tst.b	$3C(a0)
		beq.s	loc4_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc4_134AE
		move.w	#-$200,d1

loc4_134AE:
		cmp.w	$12(a0),d1
		ble.s	Tails_Test_For_FLight
		btst	#7,$22(a0)
		bne.s	Tails_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Tails_JumpHeight3

Tails_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Tails_JumpHeight3:	
	;	move.b	($FFFFFFEE).w,d1
	;	neg.b	d1
	;	add.b	#$70,d1
	;	and.b	d1,d0		; is A,	B or C pressed?
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret4_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret4_134C2:
		rts	
; ===========================================================================

loc4_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret4_134D2
		move.w	#-$FC0,$12(a0)

locret4_134D2:
		rts	
; End of function Tails_JumpHeight

Tails_Test_For_Flight:
		tst.b	$2B(a0)
		bne.w	locret_151A2
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF603).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF671).w,d0

	.player1:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	locret_151A2
	;	cmpi.w	#2,(Player_mode).w
	;	bne.s	loc_15156
	;	tst.b	(Super_Tails_flag).w
	;	bne.s	loc_1515C
	;	cmpi.b	#7,(Super_emerald_count).w
	;	blo.s	loc_1515C
	;	cmpi.w	#$32,(Ring_count).w
	;	blo.s	loc_1515C
	;	tst.b	(Update_HUD_timer).w
	;	bne.s	Tails_Transform
	;	bra.s	loc_1515C
; ---------------------------------------------------------------------------

loc_15156:
	;	tst.w	($FFFFF672).w
	;	beq.s	locret_151A2

loc_1515C:
		btst	#2,$22(a0)
		beq.s	loc_1518C
		bclr	#2,$22(a0)
		move.b	#$F,$16(a0)
		move.b	#9,$17(a0)
		move.b	$16(a0),d1
		sub.b	#$F,d1
		ext.w	d1
	;	tst.b	(Reverse_gravity_flag).w
	;	beq.s	loc_15188
	;	neg.w	d0

loc_15188:
		add.w	d1,$C(a0)

loc_1518C:
		bclr	#4,$22(a0)
		move.b	#1,$2B(a0)
		move.b	#-$10,$29(a0)
		bsr.w	Tails_Set_Flying_Animation

locret_151A2:
					; Tails_JumpHeight+52j	...
		rts

; =============== S U B R O U T I N E =======================================


Tails_Carry_Sonic:
		tst.b	(a2)
		beq.w	loc_14534
		cmpi.b	#4,$24(a1)
		bhs.w	loc_14466
		btst	#1,$22(a1)
		beq.w	loc_1445A
		move.w	($FFFFF750).w,d1
		cmp.w	$10(a1),d1
		bne.s	loc_1445A
		move.w	($FFFFF752).w,d1
		cmp.w	$12(a1),d1
		bne.s	loc_14460
		tst.b	$2A(a1)
		bmi.s	loc_1446A
		andi.b	#$70,d0
		beq.w	loc_14474
		clr.b	$2A(a1)
		clr.b	(a2)
		move.b	#$12,1(a2)
		andi.w	#$F00,d0
		beq.w	loc_14410
		move.b	#$3C,1(a2)

loc_14410:
		btst	#$A,d0
		beq.s	loc_1441C
		move.w	#-$200,$10(a1)

loc_1441C:
		btst	#$B,d0
		beq.s	loc_14428
		move.w	#$200,$10(a1)

loc_14428:
		move.w	#-$380,$12(a1)
		bset	#1,$22(a1)
		move.b	#1,$3C(a1)
		move.b	#$E,$16(a1)
		move.b	#7,$17(a1)
		move.b	#2,$1C(a1)
		bset	#2,$22(a1)
		bclr	#4,$22(a1)
		rts
; ---------------------------------------------------------------------------

loc_1445A:
		move.w	#-$100,$12(a1)

loc_14460:
		move.b	#0,$3C(a1)

loc_14466:
		clr.b	$2A(a1)

loc_1446A:
		clr.b	(a2)
		move.b	#$3C,1(a2)
		rts
; ---------------------------------------------------------------------------

loc_14474:
		move.w	#120,($FFFFF672).w ; give player 2 control for 2 seconds (minimum)
		move.w	$8(a0),$8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)

loc_14492:
		andi.b	#-4,1(a1)
		andi.b	#-2,$22(a1)
		move.b	$22(a0),d0
		andi.b	#1,d0
		or.b	d0,1(a1)
		or.b	d0,$22(a1)

loc_144BA:
	;	subq.b	#1,$23(a1)
	;	bpl.s	loc_144F8
	;	move.b	#$B,$23(a1)
	;	moveq	#0,d1
	;	move.b	$1B(a1),d1
	;	addq.b	#1,$1B(a1)
	;	move.b	byte_14522(pc,d1.w),d0
	;	cmpi.b	#-1,d0
	;	bne.s	loc_144E4
	;	move.b	#0,$1B(a1)
	;	move.b	byte_14522(pc),d0

loc_144E4:
	;	move.b	d0,$1A(a1)
	;	moveq	#0,d0
	;	move.b	$1A(a1),d0
	;	move.l	a2,-(sp)
	;	jsr	(LoadMainDynPLC).l
	;	movea.l	(sp)+,a2

loc_144F8:
		move.w	$10(a0),$10(a1)
		move.w	$12(a0),$12(a1)
		move.w	$10(a0),($FFFFF750).w
		move.w	$12(a0),($FFFFF752).w
		movem.l	d0-a6,-(sp)
		movea.w	a1,a0;
		bsr.w	Character_Floor
		movem.l	(sp)+,d0-a6
		rts
; ---------------------------------------------------------------------------
byte_14522:	dc.b $91
		dc.b $91
		dc.b $90
		dc.b $90
		dc.b $90
		dc.b $90
		dc.b $90
		dc.b $90
		dc.b $92
		dc.b $92
		dc.b $92
		dc.b $92
		dc.b $92
		dc.b $92
		dc.b $91
		dc.b $91
		dc.b $FF
		dc.b 0
; ---------------------------------------------------------------------------

loc_14534:
		tst.b	1(a2)
		beq.s	loc_14542
		subq.b	#1,1(a2)
		bne.w	locret_1459C

loc_14542:
		move.w	8(a1),d0
		sub.w	8(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bhs.w	locret_1459C
		move.w	$C(a1),d1
		sub.w	$C(a0),d1
		subi.w	#$20,d1

loc_1456C:
		cmpi.w	#$10,d1
		bhs.w	locret_1459C
		tst.b	$2A(a1)
		bne.s	locret_1459C
		cmpi.b	#4,$24(a1)
		bhs.s	locret_1459C
		tst.w	($FFFFFE08).w
		bne.s	locret_1459C
		tst.b	$39(a1)
		bne.s	locret_1459C
		bsr.s	sub_1459E
		sfx		sfx_Grab
		move.b	#1,(a2)

locret_1459C:
					; Tails_Carry_Sonic+198j ...
		rts
; End of function Tails_Carry_Sonic

; =============== S U B R O U T I N E =======================================


sub_1459E:
		clr.w	$10(a1)
		clr.w	$12(a1)
		clr.w	$20(a1)
		clr.w	$26(a1)
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		move.w	#$2000,$1C(a1)
		move.b	#0,$23(a1)
		move.b	#0,$1B(a1)
		move.b	#3,$2A(a1)
		bset	#1,$22(a1)
		bclr	#4,$22(a1)
		move.b	#0,$39(a1)
		andi.b	#-4,1(a1)
		andi.b	#-2,$22(a1)
		move.b	$22(a0),d0
		andi.b	#1,d0
		or.b	d0,1(a1)
		or.b	d0,$22(a1)
		move.w	$10(a0),($FFFFF750).w
		move.w	$10(a0),$10(a1)
		move.w	$12(a0),($FFFFF752).w
		move.w	$12(a0),$12(a1)

locret_14630:
		rts
; End of function sub_1459E

Tails_FlyingSwimming:
		bsr.w	Tails_Move_FlySwim
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	(ObjectFall2).l
		bsr.w	Character_JumpAngle
		movem.l	a4-a6,-(sp)
		bsr.w	Character_Floor
		movem.l	(sp)+,a4-a6
		tst.b	($FFFFB380).w
		beq.s	locret_14820
		lea	(Flying_carrying_flag).w,a2
		lea	($FFFFB380).w,a1
		move.w	($FFFFF602).w,d0
		cmpi.w	#$B000,a0
		beq.w	Tails_Carry_Sonic
		tst.w	($FFFFF672).w
		beq.s	locret_14820
		lea	($FFFFB000).w,a1
		move.w	($FFFFF670).w,d0
		bra.w	Tails_Carry_Sonic

locret_14820:
		rts

; =============== S U B R O U T I N E =======================================


Tails_Move_FlySwim:
		move.b	($FFFFFE05).w,d0
		andi.b	#1,d0
		beq.s	loc_14836
		tst.b	$29(a0)
		beq.s	loc_14836
		subq.b	#1,$29(a0)

loc_14836:
					; Tails_Move_FlySwim+Ej
		cmpi.b	#1,$2B(a0)
		beq.s	loc_14860
		cmpi.w	#-$100,$12(a0)
		blt.s	loc_14858
		subi.w	#$20,$12(a0)
		addq.b	#1,$2B(a0)
		cmpi.b	#$20,$2B(a0)
		bne.s	loc_1485E

loc_14858:
		move.b	#1,$2B(a0)

loc_1485E:
		bra.s	loc_14892
; ---------------------------------------------------------------------------

loc_14860:
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF602).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF670).w,d0

	.player1:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.s	loc_1488C
		cmpi.w	#-$100,$12(a0)
		blt.s	loc_1488C
		tst.b	$29(a0)
		beq.s	loc_1488C
	;	btst	#6,$22(a0)
	;	beq.s	loc_14886
	;	tst.b	(Flying_carrying_Character_flag).w
	;	bne.s	loc_1488C

loc_14886:
		move.b	#2,$2B(a0)

loc_1488C:
					; Tails_Move_FlySwim+4Ej ...
		addi.w	#8,$12(a0)

loc_14892:
		move.w	($FFFFF72C).w,d0
		addi.w	#$10,d0
		cmp.w	$C(a0),d0
		blt.s	Tails_Set_Flying_Animation
		tst.w	$12(a0)
		bpl.s	Tails_Set_Flying_Animation
		move.w	#0,$12(a0)
; End of function Tails_Move_FlySwim


; =============== S U B R O U T I N E =======================================


Tails_Set_Flying_Animation:

		btst	#6,$22(a0)
		bne.s	loc_14914
		moveq	#$1E,d0
		tst.w	$12(a0)
		bpl.s	loc_148C4
		moveq	#$1D,d0

loc_148C4:
	;	tst.b	(Flying_carrying_Character_flag).w
	;	beq.s	loc_148CC
	;	addq.b	#2,d0

loc_148CC:
		tst.b	$29(a0)
		bne.s	loc_148F4
		moveq	#$21,d0
		move.b	d0,$1C(a0)
		tst.b	1(a0)
		bpl.s	locret_148F2
		move.b	($FFFFFE05).w,d0
		addq.b	#8,d0
		andi.b	#$F,d0
		bne.s	locret_148F2
		sfx		sfx_Flying

locret_148F2:
					; Tails_Set_Flying_Animation+3Cj
		rts
; ---------------------------------------------------------------------------
loc_148F4:
					; Tails_Set_Flying_Animation+24j
		move.b	d0,$1C(a0)
		tst.b	1(a0)
		bpl.s	locret_14912
		move.b	($FFFFFE05).w,d0
		addq.b	#8,d0
		andi.b	#$F,d0
		bne.s	locret_14912
		sfx		sfx_FlyTired

locret_14912:
					; Tails_Set_Flying_Animation+5Cj
		rts

loc_14914:
		moveq	#$25,d0
		tst.w	$12(a0)
		bpl.s	loc_1491E
		moveq	#$23,d0

loc_1491E:
	;	tst.b	(Flying_carrying_Character_flag).w
	;	beq.s	loc_14926
	;	moveq	#$24,d0

loc_14926:
		tst.b	$29(a0)
		bne.s	loc_1492E
		moveq	#$25,d0

loc_1492E:
		move.b	d0,$1C(a0)
		rts
; End of function Tails_Set_Flying_Animation


; ---------------------------------------------------------------------------
; Subroutine to make Tails whip his tails
; ---------------------------------------------------------------------------
 
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
 
 
Tails_TailWhip:
		tst.b	$15(a0)
		bne.s	Tails_TailCont
		tst.b	$20(a0)
		bne.s	Tails_TailEnd
		move.b	($FFFFF603).w,d0	; is ABC pressed? (part 1)
		btst	#7,$22(a0)
		beq.s	Tails_TailWhip2
		move.b	($FFFFF671).w,d0	; is ABC pressed? (part 1)

Tails_TailWhip2:	
		move.b	($FFFFFFEE).w,d1
		and.b	d1,d0
		beq.w	Tails_TailEnd
		move.b	#$12,$1C(a0)
		sfx		sfx_Clank
		addq.l	#4,sp
		move.b	#1,$15(a0)
 
Tails_TailSet:
		bsr.w	Character_LevelBound
		jsr	Character_AnglePos

Tails_TailEnd:
		rts	
; ---------------------------------------------------------------------------
 
Tails_TailCont:
		cmpi.b	#$12,$1C(a0)
		beq.s	Tails_TailEnd2
		move.b	#0,$15(a0)
		rts

Tails_TailEnd2:
		addq.l	#4,sp			; increase stack ptr
		bsr.w	Character_LevelBound
		jmp	Character_AnglePos
; End of subroutine Character_SpinDash

; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when he	gets hurt
; ---------------------------------------------------------------------------

Obj95_Hurt:				; XREF: Obj95_Index
		clr.w	($FFFFFEB2).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc4_1380C
		subi.w	#$20,$12(a0)

loc4_1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Tails_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when he	dies
; ---------------------------------------------------------------------------

Obj95_Death:				; XREF: Obj95_Index
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Tails_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Tails	when the level is restarted
; ---------------------------------------------------------------------------

Obj95_ResetLevel:			; XREF: Obj95_Index
		tst.w	($FFFFF73A).w
		bne.s	Obj95_ResetLevel2
		tst.w	($FFFFF73C).w
		bne.s	Obj95_ResetLevel2
		move.b	#2,$24(a0)	; => Obj01_Control

Obj95_ResetLevel2:
		bsr.w	Tails_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	(DisplaySprite).l

; ---------------------------------------------------------------------------
; Subroutine to	animate	Tails's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Tails_Animate:				; XREF: Obj95_Control; et al
		lea	(TailsAniData).l,a1

Tails_Animate_Part2:
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	TaiAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration

TaiAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	TaiAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	TaiAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

TaiAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	TaiAnim_End_FF				; MJ: if so, branch to flag routines
 
TaiAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

TaiAnim_Delay:
		rts	
; ===========================================================================

TaiAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	TaiAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	TaiAnim_Next
; ===========================================================================

TaiAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	TaiAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	TaiAnim_Next
; ===========================================================================

TaiAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	TaiAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

TaiAnim_End:
		rts	
; ===========================================================================

TaiAnim_WalkRun:				; XREF: TaiAnim_Do
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	TaiAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	TaiAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0	; get Tails's angle
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Tails mirrored horizontally?
		bne.s	loc4_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc4_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc4_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc4_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	TaiAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Tails's speed
		bpl.s	loc4_13A32
		neg.w	d2

loc4_13A32:
		move.b	d0,d3
		add.b	d3,d3
		add.b	d3,d3
		lea	(TaiAni_Walk).l,a1
		cmpi.w	#$600,d2
		blo.s	loc4_13AB4
		lea	(TaiAni_Run).l,a1
		move.b	d0,d3
		add.b	d3,d3
		cmpi.w	#$700,d2
		blo.s	loc4_13AB4
		lea	(TaiAni_FastRun).l,a1
		move.b	d0,d3

loc4_13AB4:
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc4_13AC2
		moveq	#0,d2

loc4_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	TaiAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number
		rts	

; ===========================================================================			

TaiAnim_RollJump:				; XREF: TaiAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	TaiAnim_GetTailFrame	; if not, branch
		move.w	$20(a0),d2	; get Tails's speed
		bpl.s	loc4_13ADE
		neg.w	d2

loc4_13ADE:
		lea	(TaiAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Tails moving fast?
		bcc.s	loc4_13AF0	; if yes, branch
		lea	(TaiAni_Roll).l,a1 ; use slower	animation

loc4_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc4_13AFA
		moveq	#0,d2

loc4_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	TaiAnim_Do2
; ===========================================================================

TaiAnim_Push:				; XREF: TaiAnim_RollJump
		move.w	$20(a0),d2	; get Tails's speed
		bmi.s	loc4_13B1E
		neg.w	d2

loc4_13B1E:
		addi.w	#$800,d2
		bpl.s	loc4_13B26
		moveq	#0,d2

loc4_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(TaiAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	TaiAnim_Do2

TaiAnim_GetTailFrame:
		move.w	$10(a2),d1
		move.w	$12(a2),d2

	.notheld:
		jsr	(CalcAngle).l
		cmpi.b	#$10,($FFFFF600).w
		bne.s	TaiAnim_GetTailFrame2
		add.b	($FFFFF780).w,d0

TaiAnim_GetTailFrame2:
		moveq	#0,d1
		move.b	$22(a0),d2
		andi.b	#1,d2
		bne.s	loc4_1D002
		not.b	d0
		bra.s	loc4_1D006
; ===========================================================================

loc4_1D002:
	addi.b	#$80,d0

loc4_1D006:
	addi.b	#$10,d0
	bpl.s	loc4_1D008
	moveq	#3,d1

loc4_1D008:
	andi.b	#$FC,1(a0)
	eor.b	d1,d2
	or.b	d2,1(a0)
	lsr.b	#3,d0
	andi.b	#$C,d0
	move.b	d0,d3
	lea	(Obj96Ani_Directional).l,a1
	move.b	#3,$23(a0)
	bsr.w	TaiAnim_Do2
	add.b	d3,$1A(a0)
	rts
; End of function Tails_Animate

; ===========================================================================

; ----------------------------------------------------------------------------
; Object 96 - Tails' tails
; ----------------------------------------------------------------------------
; Sprite_1D200:
Obj96:
	moveq	#0,d0
	move.b	$24(a0),d0
	move.w	Obj96_Index(pc,d0.w),d1
	jmp	Obj96_Index(pc,d1.w)
; ===========================================================================
; off_1D20E: Obj96_States:
Obj96_Index:
		dc.w Obj96_Init-Obj96_Index	; 0
		dc.w Obj96_Main-Obj96_Index	; 2
; ===========================================================================
; loc_1D212
Obj96_Init:
	addq.b	#2,$24(a0) ; => Obj96_Main
	move.l	#Map_TailsTails,4(a0)
	move.w	#$100,$18(a0)
	move.b	#$18,$14(a0)
	move.b	#4,1(a0)
	make_art_tile	ArtTile_PartnerSec,0,1
	cmpi.b	#$95,($FFFFB380).w
	beq.s	Obj96_Main
	make_art_tile	ArtTile_MainSec,0,1

; loc_1D23A:
Obj96_Main:
	movea.w	$32(a0),a2 ; a2=character
	move.b	$2C(a2),$2C(a0)
	move.b	$22(a2),$22(a0)
	move.w	8(a2),8(a0)
	move.w	$C(a2),$C(a0)
	andi.w	#$7FFF,2(a0)
	tst.w	2(a2)
	bpl.s	Obj96_solid
	ori.w	#(1<<15),2(a0)

Obj96_solid:
	moveq	#0,d0
	move.b	$1C(a2),d0
	cmpi.b	#$12,d0
	bne.s	Obj96_1
	move.b	$1A(a2),d0
	subi.b	#$CB,d0
	move.b	HeightTable(pc,d0.w),$16(a0)
	move.b	WidthTable(pc,d0.w),$17(a0)
	move.b	$17(a0),d1
	lsl.b	#1,d0
	moveq	#0,d1
	move.w	XTable(pc,d0.w),d1
	btst	#0,$22(a2)
	beq.s	Obj96_solid2
	neg.w	d1

Obj96_solid2:
	add.w	d1,8(a0)
	moveq	#0,d1
	move.w	YTable(pc,d0.w),d1
	add.w	d1,$C(a0)
	jmp	(TouchResponse).l

XTable:	dc.w $FFEE, $FFF2, 7, $15, $14, $F, $FFF6
YTable:	dc.w 2, 6, 8, 7, $FFFF, $FFFA, $FFFC
WidthTable:	dc.b $A, $A, $D, $10, $E, 9, $C
HeightTable: dc.b 9, 9, 8, 8, 9, 6, $A

Obj96_1:
	btst	#5,$22(a2)		; is Tails about to push against something?
	beq.s	Obj96_2			; if not, branch
	cmpi.b	#$A9,$1A(a2)	; Is Tails in his pushing animation yet?
	blo.s	Obj96_2			; If not yet, branch, and do not set tails' tail pushing animation
	cmpi.b	#$AC,$1A(a2)	; ''
	bhi.s	Obj96_2			; ''
	moveq	#4,d0

Obj96_2:
	cmp.b	$30(a0),d0
	beq.s	loc_1D288
	move.b	d0,$30(a0)
	move.b	Obj96AniSelection(pc,d0.w),$1C(a0)

loc_1D288:
	lea	(Obj96AniData).l,a1
	bsr.w	Tails_Animate_Part2
	bsr.w	LoadTailsTailsDynPLC
	movea.w	$32(a0),a1			; Move Tails' register to a1
	move.w	$30(a1),d0	; Move Tails' invulnerable time to d0
	beq.s	Obj96_display			; Is invulnerable_time 0?  If so, always display his tails
	addq.w	#1,d0				; Make d0 the same as old invulnerable_time's d0
	lsr.w	#3,d0				; Shift bits to the right 3 times
	bcc.s	Obj96_return				; If the Carry bit is not set, branch and do not display Tails' tails

Obj96_display:
	jmp	(DisplaySprite).l			   ; Display Tails' tails

Obj96_return:
	rts

; ===========================================================================
; animation master script table for the tails
; chooses which animation script to run depending on what Tails is doing
; byte_1D29E:
Obj96AniSelection:
	dc.b	0,0	; TailsAni_Walk,Run	->
	dc.b	3	; TailsAni_Roll		-> Directional
	dc.b	3	; TailsAni_Roll2	-> Directional
	dc.b	9	; TailsAni_Push		-> Pushing
	dc.b	1	; TailsAni_Wait		-> Swish
	dc.b	$A	; TailsAni_Balance	-> Blank
	dc.b	1	; TailsAni_LookUp	-> Flick
	dc.b	1	; TailsAni_Duck		-> Swish
	dc.b	7	; TailsAni_Spindash	-> Spindash
	dc.b	0,0,3	; TailsAni_Dummy1,2,3	->
	dc.b	8	; TailsAni_Stop		-> Skidding
	dc.b	0,0	; TailsAni_Float,2	->
	dc.b	0	; TailsAni_Spring	->
	dc.b	0	; TailsAni_Hang		->
	dc.b	0,0	; TailsAni_Blink,2	->
	dc.b	$A	; TailsAni_Surf	-> Hanging
	dc.b	0	; TailsAni_Bubble	->
	dc.b	0,0,0,0	; TailsAni_Death,2,3,4	->
	dc.b	0,0	; TailsAni_Hurt,Slide	->
	dc.b	0	; TailsAni_Blank	->
	dc.b	$B,$B,$B,$B,$B,$B,$B,$B,$B	; TailsAni_Fly		->
	even

; ---------------------------------------------------------------------------
; Animation script - Tails' tails
; ---------------------------------------------------------------------------
; off_1D2C0:
Obj96AniData:
		dc.w Obj96Ani_Blank-Obj96AniData	;  0
		dc.w Obj96Ani_Swish-Obj96AniData	;  1
		dc.w Obj96Ani_Flick-Obj96AniData	;  2
		dc.w Obj96Ani_Directional-Obj96AniData	;  3
		dc.w Obj96Ani_DownLeft-Obj96AniData	;  4
		dc.w Obj96Ani_Down-Obj96AniData	;  5
		dc.w Obj96Ani_DownRight-Obj96AniData	;  6
		dc.w Obj96Ani_Spindash-Obj96AniData	;  7
		dc.w Obj96Ani_Skidding-Obj96AniData	;  8
		dc.w Obj96Ani_Pushing-Obj96AniData	;  9
		dc.w Obj96Ani_Hanging-Obj96AniData	; $A
		dc.w Obj96Ani_Fly-Obj96AniData	; $B

Obj96Ani_Blank:		dc.b $20,  0,$FF
	even
Obj96Ani_Swish:		dc.b   7,  $22, $23, $24, $25, $26,$FF
	even
Obj96Ani_Flick:		dc.b   3,  $22, $23, $24, $25, $26,$FD,  1
	even
Obj96Ani_Directional:	dc.b $FC,5,6,7,8,$FF ; Tails is moving right
	even
Obj96Ani_DownLeft:	dc.b   3,9,$A,$B,$C,$FF ; Tails is moving up-right
	even
Obj96Ani_Down:		dc.b   3,$D,$E,$F,$10,$FF ; Tails is moving up
	even
Obj96Ani_DownRight:	dc.b   3,$11,$12,$13,$14,$FF ; Tails is moving up-left
	even
Obj96Ani_Spindash:	dc.b   2,$1A,$1B,$1C,$1D,$FF
	even
Obj96Ani_Skidding:	dc.b   2,$1E,$1F,$20,$21,$FF
	even
Obj96Ani_Pushing:	dc.b   9,$1E,$1F,$20,$21,$FF
	even
Obj96Ani_Hanging:	dc.b   9,$1A,$1B,$1C,$1D,$FF
	even
Obj96Ani_Fly:		dc.b   3,$27,$28,$FF
	even
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 99 - Knuckles
; ---------------------------------------------------------------------------

Obj99:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj99_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj99_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj99_Index(pc,d0.w),d1
		jmp	Obj99_Index(pc,d1.w)
; ===========================================================================
Obj99_Index:	dc.w Obj99_Main-Obj99_Index
		dc.w Obj99_Control-Obj99_Index
		dc.w Obj99_Hurt-Obj99_Index
		dc.w Obj99_Death-Obj99_Index
		dc.w Obj99_ResetLevel-Obj99_Index
; ===========================================================================

Obj99_Main:				; XREF: Obj99_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_Knuckles,4(a0)
		make_art_tile	ArtTile_Main,0,1
		btst	#7,$22(a0)
		beq.s	Obj99_Cont
		make_art_tile	ArtTile_Partner,0,1

Obj99_Cont:
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$1E,$28(a0)
		btst	#7,$22(a0)
		bne.s	Obj99_CreateDust
		move.w	#$600,($FFFFF760).w ; Sonic's top speed
		move.w	#$C,($FFFFF762).w ; Sonic's acceleration
		move.w	#$80,($FFFFF764).w ; Sonic's deceleration
		move.b	#5,($FFFFB1C0).w
		bra.s	Obj99_Control

Obj99_CreateDust:
		move.b	#5,($FFFFB400).w

Obj99_Control:				; XREF: Obj01_Index
		btst	#7,$22(a0)
		bne.s	loc5_12C58
		bsr.w	Character_PanCamera
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	loc5_12C5A	; if not, branch
		btst	#4,($FFFFF605).w ; is button C pressed?
		beq.s	loc5_12C5A	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Knuckles	into a ring/item
		clr.b	($FFFFF7CC).w
		rts	
; ===========================================================================

loc5_12C58:
		tst.b	($FFFFF674).w	; are controls locked?
		bne.s	loc5_12C62	; if yes, branch
	;	move.b	#0,$2B(a0)
		move.w	($FFFFF606).w,($FFFFF670).w ; enable joypad control
		btst	#0,($FFFFF604).w
		beq.s	loc5_12C62
		move.w	($FFFFF604).w,($FFFFF670).w ; enable joypad control	
		bclr	#0,($FFFFF670).w

loc5_12C62:
		bsr.w	CPU_Control
		bra.s	loc5_12C64

loc5_12C5A:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc5_12C64	; if yes, branch
		bset	#0,($FFFFF602).w
		btst	#0,($FFFFF604).w
		bne.s	loc5_12C64
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc5_12C64:
		btst	#0,$2A(a0) ; are controls	locked?
		beq.s	loc5_12C66	; if yes, branch
		move.b	#0,$2B(a0)
		bra.s	loc5_12C7E

loc5_12C66:
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj99_Modes(pc,d0.w),d1
		jsr	Obj99_Modes(pc,d1.w)

loc5_12C7E:
		bsr.s	Knuckles_Display
		bsr.w	Main_RecordPos
		bsr.w	Character_Water
		btst	#7,$22(a0)
		bne.s	loc5_12C7E2
		cmpi.w	#-$600,$20(a0)	; is Sonic at running speed?
		bgt.s	loc5_12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	loc5_12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	loc5_12C7E2

loc5_12C7E1:
		cmpi.w	#$600,$20(a0)	; is Sonic at running speed?
		blt.s	loc5_12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	loc5_12C7E2
		add.w	#2,($FFFFF75E).w

loc5_12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	loc5_12CA6
		tst.b	$1C(a0)
		bne.s	loc5_12CA6
		move.b	$1D(a0),$1C(a0)

loc5_12CA6:
		bsr.w	Knuckles_Animate
		tst.b	$2A(a0)
		bmi.s	loc5_12CB6
		jsr	TouchResponse

loc5_12CB6:
		bra.w	LoadCharacterDynPLC
; ===========================================================================
Obj99_Modes:	dc.w Obj99_MdNormal-Obj99_Modes
		dc.w Obj99_MdJump-Obj99_Modes
		dc.w Obj99_MdRoll-Obj99_Modes
		dc.w Obj99_MdJump2-Obj99_Modes

Knuckles_Display:				; XREF: loc5_12C7E
		move.w	$30(a0),d0
		beq.s	Obj99_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj99_Display
		lsr.w	#3,d0
		bcc.s	Obj99_ChkInvin

Obj99_Display:
		jsr	DisplaySprite

Obj99_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does Knuckles have invincibility?
		beq.w	Obj99_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj99_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj99_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj99_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj99_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w
		jsr	LoadMusic

Obj99_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj99_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Knuckles have speed	shoes?
		beq.s	Obj99_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj99_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj99_ExitChk
		move.w	#$600,($FFFFF760).w ; restore Knuckles"s speed
		move.w	#$C,($FFFFF762).w ; restore Knuckles"s acceleration
		move.w	#$80,($FFFFF764).w ; restore Knuckles"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

Obj99_ExitChk:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Knuckles
; ---------------------------------------------------------------------------

Obj99_MdNormal:				; XREF: Obj99_Modes
		bsr.w	Character_SpinDash
		bsr.w	Character_Jump
		bsr.w	Character_SlopeResist
		bsr.w	Character_Move
		bsr.w	Character_Roll
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj99_MdJump:				; XREF: Obj99_Modes
	;	clr.b	$39(a0)
		tst.b	$2B(a0)
		bne.s	Obj99_MdAir_Gliding
		bsr.w	Knuckles_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc5_12E5C
		subi.w	#$28,$12(a0)

loc5_12E5C:
		tst.w	$12(a0)
		bmi.s	loc5_12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	loc5_12E5E
		move.b	#$C,$1C(a0)

loc5_12E5E:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	
; ===========================================================================

Obj99_MdAir_Gliding:				  ; ...
		bsr.w	Knuckles_GlideSpeedControl
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Knuckles_GlideControl

return_3156B8:
		rts	

; =============== S U B	R O U T	I N E =======================================


Knuckles_GlideControl:				  ; ...

; FUNCTION CHUNK AT 00315C40 SIZE 0000003C BYTES

		move.b	$2B(a0),d0
		beq.s	return_3156B8
		cmp.b	#2,d0
		beq.w	Knuckles_FallingFromGlide
		cmp.b	#3,d0
		beq.w	Knuckles_Sliding
		cmp.b	#4,d0
		beq.w	Knuckles_Climbing_Wall
		cmp.b	#5,d0
		beq.w	Knuckles_Climbing_Up

Knuckles_NormalGlide:
		move.b	#$A,$16(a0)
		move.b	#$A,$17(a0)
		bsr.w	Knuckles_DoLevelCollision2
		btst	#5,($FFFFF7AC).w
		bne.w	Knuckles_BeginClimb
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		btst	#1,($FFFFF7AC).w
		beq.s	Knuckles_BeginSlide
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF602).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF670).w,d0

	.player1:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		bne.s	loc_31574C
		move.b	#2,$2B(a0)
		move.b	#$C,$1C(a0)
		bclr	#0,$22(a0)
		tst.w	$10(a0)
		bpl.s	loc_315736
		bset	#0,$22(a0)

loc_315736:					  ; ...
		asr	$10(a0)
		asr	$10(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		rts
; ---------------------------------------------------------------------------

loc_31574C:					  ; ...
		bra.w	sub_315C7C
; ---------------------------------------------------------------------------

Knuckles_BeginSlide:				  ; ...
		bclr	#0,$22(a0)
		tst.w	$10(a0)
		bpl.s	loc_315762
		bset	#0,$22(a0)

loc_315762:					  ; ...
		move.b	$26(a0),d0
		add.b	#$20,d0
		and.b	#$C0,d0
		beq.s	loc_315780
		move.w	$20(a0),$10(a0)
		move.w	#0,$12(a0)
		bra.w	Knuckles_ResetOnFloor_Part2
; ---------------------------------------------------------------------------

loc_315780:					  ; ...
		move.b	#3,$2B(a0)
		move.b	#$CC,$1A(a0)
		move.b	#$7F,$23(a0)
		move.b	#0,$1B(a0)
		cmp.b	#$C,$28(a0)
		bcs.s	return_3157AC
		btst	#7,$22(a0)
		bne.s	.jump
		move.b	#6,($FFFFB1E4).w
		move.b	#$15,($FFFFB1DA).w
		rts

.jump:
		move.b	#6,($FFFFB424).w
		move.b	#$15,($FFFFB41A).w

return_3157AC:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_BeginClimb:				  ; ...
		tst.b	($FFFFF7AD).w
		bmi.w	loc_31587A
		move.b	$3F(a0),d5
		move.b	$1F(a0),d0
		add.b	#$40,d0
		bpl.s	loc_3157D8
		bset	#0,$22(a0)
		bsr.w	loc_14FD6
		or.w	d0,d1
		bne.s	Knuckles_FallFromGlide
		addq.w	#1,8(a0)
		bra.s	loc_3157E8
; ---------------------------------------------------------------------------

loc_3157D8:					  ; ...
		bclr	#0,$22(a0)
		bsr.w	sub_14E50
		or.w	d0,d1
		bne.w	loc_31586A

loc_3157E8:					  ; ...
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)

loc_315804:					  ; ...
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.b	#4,$2B(a0)
		move.b	#$B7,$1A(a0)
		move.b	#$7F,$23(a0)
		move.b	#0,$1B(a0)
		move.b	#3,$1F(a0)
		move.w	8(a0),$A(a0)
		sfx		sfx_Grab
		rts
; ---------------------------------------------------------------------------

Knuckles_FallFromGlide:				  ; ...
		move.w	8(a0),d3
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		subq.w	#1,d3

loc_31584A:					  ; ...
		move.w	$C(a0),d2
		sub.w	#$B,d2
		jsr	Character_HitFloor2
		tst.w	d1
		bmi.s	loc_31587A
		cmp.w	#$C,d1
		bcc.s	loc_31587A
		add.w	d1,$C(a0)
		bra.w	loc_3157E8
; ---------------------------------------------------------------------------

loc_31586A:					  ; ...
		move.w	8(a0),d3
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		addq.w	#1,d3
		bra.s	loc_31584A
; ---------------------------------------------------------------------------

loc_31587A:					  ; ...
		move.b	#2,$2B(a0)
		move.b	#$C,$1C(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		bset	#1,($FFFFF7AC).w
		rts
; ---------------------------------------------------------------------------

Knuckles_FallingFromGlide:			  ; ...
		bsr.w	Character_ChgJumpDir
		add.w	#$38,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc_3158B2
		sub.w	#$28,$12(a0)

loc_3158B2:					  ; ...
		bsr.w	Knuckles_DoLevelCollision2
		btst	#1,($FFFFF7AC).w
		bne.s	return_315900
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.b	$16(a0),d0
		sub.b	#$13,d0
		ext.w	d0
		add.w	d0,$C(a0)
		move.b	$26(a0),d0
		add.b	#$20,d0
		and.b	#$C0,d0
		beq.s	loc_3158F0
		bra.w	Knuckles_ResetOnFloor_Part2
; ---------------------------------------------------------------------------

loc_3158F0:					  ; ...
		bsr.w	Knuckles_ResetOnFloor_Part2
		move.w	#$F,$2E(a0)
		move.b	#$13,$1C(a0)
		sfx		sfx_GlideLand

return_315900:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_Sliding:				  ; ...
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF602).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF670).w,d0

	.player1:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.s	loc_315926
		tst.w	$10(a0)
		bpl.s	loc_31591E
		add.w	#$20,$10(a0)
		bmi.s	loc_31591C
		bra.s	loc_315926
; ---------------------------------------------------------------------------

loc_31591C:					  ; ...
		bra.s	loc_315958
; ---------------------------------------------------------------------------

loc_31591E:					  ; ...
		sub.w	#$20,$10(a0)
		bpl.s	loc_315958

loc_315926:					  ; ...
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.b	$16(a0),d0
		sub.b	#$13,d0
		ext.w	d0
		add.w	d0,$C(a0)
		bsr.w	Knuckles_ResetOnFloor_Part2
		move.w	#$F,$2E(a0)
		move.b	#$12,$1C(a0)
		rts
; ---------------------------------------------------------------------------

loc_315958:					  ; ...
		move.b	#$A,$16(a0)
		move.b	#$A,$17(a0)
		bsr.w	Knuckles_DoLevelCollision2
		bsr.w	Character_HitFloor2
		cmp.w	#$E,d1
		bge.s	loc_315988
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	loc_315958_NoSound
		sfx		sfx_GroundSlide

loc_315958_NoSound:
		rts
; ---------------------------------------------------------------------------

loc_315988:					  ; ...
		move.b	#2,$2B(a0)
		move.b	#$C,$1C(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		bset	#1,($FFFFF7AC).w
		rts
; ---------------------------------------------------------------------------

Knuckles_Climbing_Wall:				  ; ...
		tst.b	($FFFFF7AD).w
		bmi.w	loc_315BAE
		move.w	8(a0),d0
		cmp.w	$A(a0),d0
		bne.w	loc_315BAE
		btst	#3,$22(a0)
		bne.w	loc_315BAE
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		move.l	($FFFFFFD0).w,($FFFFF796).w	
		cmp.b	#$D,$3F(a0)
		beq.s	loc_3159F0
		move.l	($FFFFFFD4).w,($FFFFF796).w	

loc_3159F0:					  ; ...
		move.b	$3F(a0),d5
		move.b	#$A,$16(a0)
		move.b	#$A,$17(a0)
		moveq	#0,d1
		btst	#7,$22(a0)
		bne.s	.player2
		btst	#0,($FFFFF602).w
		beq.w	loc_315A76
		bra.s	.player1

	.player2:	
		btst	#0,($FFFFF670).w
		beq.w	loc_315A76

	.player1:	
		move.w	$C(a0),d2
		sub.w	#$B,d2
		bsr.w	sub_315C22
		cmp.w	#4,d1
		bge.w	Knuckles_ClimbUp	  ; Climb onto the floor above you
		tst.w	d1
		bne.w	loc_315B30
		move.b	$3F(a0),d5
		move.w	$C(a0),d2
		subq.w	#8,d2
		move.w	8(a0),d3
		bsr.w	sub_3192E6		  ; Doesn't exist in S2
		tst.w	d1
		bpl.s	loc_315A46
		sub.w	d1,$C(a0)
		moveq	#1,d1
		bra.w	loc_315B04
; ---------------------------------------------------------------------------

loc_315A46:					  ; ...
		subq.w	#1,$C(a0)

loc_315A54:					  ; ...
		moveq	#1,d1
		move.w	($FFFFF72C).w,d0
		cmp.w	#-$100,d0
		beq.w	loc_315B04
		add.w	#$10,d0
		cmp.w	$C(a0),d0
		ble.w	loc_315B04
		move.w	d0,$C(a0)
		bra.w	loc_315B04
; ---------------------------------------------------------------------------

loc_315A76:					  ; ...
		btst	#7,$22(a0)
		bne.s	.player2
		btst	#1,($FFFFF602).w
		beq.w	loc_315B04
		bra.s	.player1

	.player2:	
		btst	#1,($FFFFF670).w
		beq.w	loc_315B04

	.player1:
		cmp.b	#$BD,$1A(a0)
		bne.s	loc_315AA2
		move.b	#$B7,$1A(a0)
		addq.w	#3,$C(a0)
		subq.w	#3,8(a0)
		btst	#0,$22(a0)
		beq.s	loc_315AA2
		addq.w	#6,8(a0)

loc_315AA2:					  ; ...
		move.w	$C(a0),d2
		add.w	#$B,d2
		bsr.w	sub_315C22
		tst.w	d1
		bne.w	loc_315BAE
		move.b	$3E(a0),d5
		move.w	$C(a0),d2
		add.w	#9,d2
		move.w	8(a0),d3
		bsr.w	Character_HitWall
		tst.w	d1
		bpl.s	loc_315AF4
		add.w	d1,$C(a0)
		move.b	($FFFFF768).w,$26(a0)
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		bsr.w	Knuckles_ResetOnFloor_Part2
		move.b	#5,$1C(a0)
		rts
; ---------------------------------------------------------------------------

loc_315AF4:					  ; ...
		addq.w	#1,$C(a0)

loc_315B02:					  ; ...
		moveq	#-1,d1

loc_315B04:					  ; ...
		tst.w	d1
		beq.s	loc_315B30
		subq.b	#1,$1F(a0)
		bpl.s	loc_315B30
		move.b	#3,$1F(a0)
		add.b	$1A(a0),d1
		cmp.b	#$B7,d1
		bcc.s	loc_315B22
		move.b	#$BC,d1

loc_315B22:					  ; ...
		cmp.b	#$BC,d1
		bls.s	loc_315B2C
		move.b	#$B7,d1

loc_315B2C:					  ; ...
		move.b	d1,$1A(a0)

loc_315B30:					  ; ...
		move.b	#$20,$23(a0)
		move.b	#0,$1B(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF603).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF671).w,d0

	.player1:	
	;	move.b	($FFFFFFEE).w,d1
	;	neg.b	d1
	;	add.b	#$70,d1
		and.b	#$70,d0		; is A,	B or C pressed?
		beq.s	return_315B94
		move.w	#$FC80,$12(a0)
		move.w	#$400,$10(a0)
		bchg	#0,$22(a0)
		bne.s	loc_315B6A
		neg.w	$10(a0)

loc_315B6A:					  ; ...
		bset	#1,$22(a0)
		move.b	#1,$3C(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.b	#2,$1C(a0)
		bset	#2,$22(a0)
		move.b	#0,$2B(a0)
		rts

return_315B94:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_ClimbUp:				  ; ...
		move.b	#5,$2B(a0)		  ; Climb up to	the floor above	you
		cmp.b	#$BD,$1A(a0)
		beq.s	return_315BAC
		move.b	#0,$1F(a0)
		bsr.s	sub_315BDA

return_315BAC:					  ; ...
		rts
; ---------------------------------------------------------------------------

loc_315BAE:					  ; ...
		move.b	#2,$2B(a0)
		move.w	#$C0C,$1C(a0)
		move.b	#$CB,$1A(a0)
		move.b	#7,$23(a0)
		move.b	#1,$1B(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		rts
; End of function Knuckles_GlideControl


; =============== S U B	R O U T	I N E =======================================


sub_315BDA:					  ; ...
		moveq	#0,d0
		move.b	$1F(a0),d0
		lea	word_315C12(pc,d0.w),a1
		move.b	(a1)+,$1A(a0)
		move.b	(a1)+,d0
		ext.w	d0
		btst	#0,$22(a0)
		beq.s	loc_315BF6
		neg.w	d0

loc_315BF6:					  ; ...
		add.w	d0,8(a0)
		move.b	(a1)+,d1
		ext.w	d1
		add.w	d1,$C(a0)
		move.b	(a1)+,$23(a0)
		addq.b	#4,$1F(a0)
		move.b	#0,$1B(a0)
		rts
; End of function sub_315BDA

; ---------------------------------------------------------------------------
word_315C12:	dc.w $BD03,$FD06,$BE08,$F606,$BFF8,$F406,$D208,$FB06; 0	; ...

; =============== S U B	R O U T	I N E =======================================


sub_315C22:					  ; ...

; FUNCTION CHUNK AT 00319208 SIZE 00000020 BYTES
; FUNCTION CHUNK AT 003193D2 SIZE 00000024 BYTES

		move.b	$3F(a0),d5
		btst	#0,$22(a0)
		bne.s	loc_315C36
		move.w	8(a0),d3
		bra.w	loc_319208
; ---------------------------------------------------------------------------

loc_315C36:					  ; ...
		move.w	8(a0),d3
		subq.w	#1,d3
		bra.w	loc_3193D2
; End of function sub_315C22

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR Knuckles_GlideControl

Knuckles_Climbing_Up:				  ; ...
		tst.b	$23(a0)
		bne.s	return_315C7A
		bsr.w	sub_315BDA
		cmp.b	#$10,$1F(a0)
		bne.s	return_315C7A
		move.w	#0,$20(a0)
		move.w	#0,$10(a0)
		move.w	#0,$12(a0)
		btst	#0,$22(a0)
		beq.s	loc_315C70
		subq.w	#1,8(a0)

loc_315C70:					  ; ...
		bsr.w	Knuckles_ResetOnFloor_Part2
		move.b	#5,$1C(a0)

return_315C7A:					  ; ...
		rts
; END OF FUNCTION CHUNK	FOR Knuckles_GlideControl

; =============== S U B	R O U T	I N E =======================================


sub_315C7C:					  ; ...
		move.b	#$20,$23(a0)
		move.b	#0,$1B(a0)
		move.w	#$1D1D,$1C(a0)
		bclr	#5,$22(a0)
		bclr	#0,$22(a0)
		bclr	#0,1(a0)
		moveq	#0,d0
		move.b	$1F(a0),d0
		add.b	#$10,d0
		lsr.w	#5,d0
		move.b	byte_315CC2(pc,d0.w),d1
		move.b	d1,$1A(a0)
		cmp.b	#$C4,d1
		bne.s	return_315CC0
		bset	#0,$22(a0)
		bset	#0,1(a0)
		move.b	#$C0,$1A(a0)

return_315CC0:					  ; ...
		rts
; End of function sub_315C7C

; ---------------------------------------------------------------------------
byte_315CC2:	dc.b $C0,$C1,$C2,$C3,$C4,$C3,$C2,$C1; 0	; ...

; =============== S U B	R O U T	I N E =======================================


Knuckles_GlideSpeedControl:			  ; ...
		cmp.b	#1,$2B(a0)
		bne.w	loc_315D88
		move.w	$20(a0),d0
		cmp.w	#$400,d0
		bcc.s	loc_315CE2
		addq.w	#8,d0
		bra.s	loc_315CFC
; ---------------------------------------------------------------------------

loc_315CE2:					  ; ...
		cmp.w	#$1800,d0
		bcc.s	loc_315CFC
		move.b	$1F(a0),d1
		and.b	#$7F,d1
		bne.s	loc_315CFC
		addq.w	#4,d0
		tst.b	($FFFFFE19).w
		beq.s	loc_315CFC
		addq.w	#8,d0

loc_315CFC:					  ; ...
		move.w	d0,$20(a0)
		move.b	$1F(a0),d0
		btst	#7,$22(a0)
		bne.s	.player2
		btst	#2,($FFFFF602).w
		beq.s	loc_315D1C
		bra.s	.player1

	.player2:	
		btst	#2,($FFFFF670).w
		beq.s	loc_315D1C

	.player1:
		cmp.b	#$80,d0
		beq.s	loc_315D1C
		tst.b	d0
		bpl.s	loc_315D18
		neg.b	d0

loc_315D18:					  ; ...
		addq.b	#2,d0
		bra.s	loc_315D3A
; ---------------------------------------------------------------------------

loc_315D1C:					  ; ...
		btst	#7,$22(a0)
		bne.s	.player2
		btst	#3,($FFFFF602).w
		beq.s	loc_315D30
		bra.s	.player1

	.player2:	
		btst	#3,($FFFFF670).w
		beq.s	loc_315D30

	.player1:
		tst.b	d0
		beq.s	loc_315D30
		bmi.s	loc_315D2C
		neg.b	d0

loc_315D2C:					  ; ...
		addq.b	#2,d0
		bra.s	loc_315D3A
; ---------------------------------------------------------------------------

loc_315D30:					  ; ...
		move.b	d0,d1
		and.b	#$7F,d1
		beq.s	loc_315D3A
		addq.b	#2,d0

loc_315D3A:					  ; ...
		move.b	d0,$1F(a0)
		move.b	$1F(a0),d0
		jsr	CalcSine
		muls.w	$20(a0),d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		cmp.w	#$80,$12(a0)
		blt.s	loc_315D62
		sub.w	#$20,$12(a0)
		bra.s	loc_315D68
; ---------------------------------------------------------------------------

loc_315D62:					  ; ...
		add.w	#$20,$12(a0)

loc_315D68:					  ; ...
		move.w	($FFFFF72C).w,d0
		cmp.w	#$FF00,d0
		beq.w	loc_315D88
		add.w	#$10,d0
		cmp.w	$C(a0),d0
		ble.w	loc_315D88
		asr	$10(a0)
		asr	$20(a0)

loc_315D88:					  ; ...
		btst	#7,$22(a0)
		bne.s	return_315D9A
		cmp.w	#$60,($FFFFF73E).w
		beq.s	return_315D9A
		bcc.s	loc_315D96
		addq.w	#4,($FFFFF73E).w

loc_315D96:					  ; ...
		subq.w	#2,($FFFFF73E).w

return_315D9A:					  ; ...
		rts
; End of function Knuckles_GlideSpeedControl
; ===========================================================================

Obj99_MdRoll:				; XREF: Obj99_Modes
		bsr.w	Character_Jump
		bsr.w	Character_RollRepel
		bsr.w	Character_RollSpeed
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		bsr.w	Character_AnglePos
		bsr.w	Character_SlopeRepel
		rts	
; ===========================================================================

Obj99_MdJump2:				; XREF: Obj99_Modes
		clr.b	$39(a0)
		bsr.w	Knuckles_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	loc5_12EA6
		subi.w	#$28,$12(a0)
		btst	#7,$22(a0)
		bne.s	loc5_12EA6
		btst	#6,($FFFFFE2C).w
		beq.s	loc5_12EA6
		move.w	$10(a0),d0		; move Knuckles's X-velocity to d0 
		tst.w	d0			; is his speed positive? (is he running to the right?)
		bpl.s	Obj99_MdJump2_Abs	; if yes, branch
		neg.w	d0			; otherwise negate it

Obj99_MdJump2_Abs:
		cmpi.w	#$40,d0		; if Knuckles speed less than $250?
		blt.s	loc5_12EA6		; if yes, branch
		move.w	$C(a0),d0		; move Knuckles's Y-position to d0
		sub.w	($FFFFF646).w,d0	; sub the water height from it
		cmpi.w	#$F,d0			; is Knuckles slightly in the water?
		bgt.s	loc5_12EA6		; if not, branch
		subi.w	#$90,$12(a0)		; jump out of water
		move.b	#2,$1C(a0)		; jump out of water

loc5_12EA6:
		bsr.w	Character_JumpAngle
		bsr.w	Character_Floor
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Knuckles_JumpHeight:			; XREF: Obj99_MdJump; Obj99_MdJump2
		tst.b	$3C(a0)
		beq.s	Knuckles_UpwardsVelocityCap
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	loc5_134AE
		move.w	#-$200,d1

loc5_134AE:
		cmp.w	$12(a0),d1
		ble.w	Knuckles_CheckGlide	  ; Check if Knuckles should begin a glide
		btst	#7,$22(a0)
		bne.s	Knuckles_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	Knuckles_JumpHeight3

Knuckles_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

Knuckles_JumpHeight3:	
	;	move.b	($FFFFFFEE).w,d1
	;	neg.b	d1
	;	add.b	#$70,d1
	;	and.b	d1,d0		; is A,	B or C pressed?
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	locret5_134C2	; if yes, branch
		move.w	d1,$12(a0)

locret5_134C2:
		rts	
; ===========================================================================

loc5_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	locret5_134D2
		move.w	#-$FC0,$12(a0)

locret5_134D2:
		rts	
; ===========================================================================



; ---------------------------------------------------------------------------

Knuckles_UpwardsVelocityCap:			  ; ...
		tst.b	$39(a0)
		bne.s	return_316538
		cmp.w	#-$FC0,$12(a0)
		bge.s	return_316538
		move.w	#-$FC0,$12(a0)

return_316538:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_CheckGlide:				  ; ...
		tst.b	$2B(a0)
		bne.w	return_3165D2
		btst	#7,$22(a0)
		bne.s	.player2
		move.b	($FFFFF603).w,d0
		bra.s	.player1

	.player2:	
		move.b	($FFFFF671).w,d0

	.player1:	
		move.b	($FFFFFFEE).w,d1
		neg.b	d1
		add.b	#$70,d1
		and.b	d1,d0		; is A,	B or C pressed?
		beq.w	return_3165D2

Knuckles_BeginGlide:				  ; ...
		bclr	#2,$22(a0)
		move.b	#$A,$16(a0)
		move.b	#$A,$17(a0)
		bclr	#4,$22(a0)
		move.b	#1,$2B(a0)
		add.w	#$200,$12(a0)
		bpl.s	loc_31659E
		move.w	#0,$12(a0)

loc_31659E:					  ; ...
		moveq	#0,d1
		move.w	#$400,d0
		move.w	d0,$20(a0)
		btst	#0,$22(a0)
		beq.s	loc_3165B4
		neg.w	d0
		moveq	#-$80,d1

loc_3165B4:					  ; ...
		move.w	d0,$10(a0)
		move.b	d1,$1F(a0)
		move.w	#0,$26(a0)
		move.b	#0,($FFFFF7AC).w
		bset	#1,($FFFFF7AC).w
		bsr.w	sub_315C7C

return_3165D2:					  ; ...
		rts

; ---------------------------------------------------------------------------
byte_16FEE:	dc.b $C0
		dc.b $C1
		dc.b $C2
		dc.b $C3
		dc.b $C4
		dc.b $C3
		dc.b $C2
		dc.b $C1
; End of function Knuckles_JumpHeight


; =============== S U B	R O U T	I N E =======================================


Knuckles_DoLevelCollision2:			  ; ...
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5
		move.w	$10(a0),d1
		move.w	$12(a0),d2
		jsr	CalcAngle
		sub.b	#$20,d0
		and.b	#$C0,d0
		cmp.b	#$40,d0
		beq.w	Knuckles_HitLeftWall2
		cmp.b	#$80,d0
		beq.w	Knuckles_HitCeilingAndWalls2
		cmp.b	#$C0,d0
		beq.w	Knuckles_HitRightWall2
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	loc_316998
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

loc_316998:					  ; ...
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_3169B0
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

loc_3169B0:					  ; ...
		bsr.w	Character_HitFloor
		tst.w	d1
		bpl.s	return_3169CC
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		bclr	#1,($FFFFF7AC).w

return_3169CC:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_HitLeftWall2:				  ; ...
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	Knuckles_HitCeilingAlt
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

Knuckles_HitCeilingAlt:				  ; ...
		bsr.w	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	Knuckles_GlideHitFloor
		neg.w	d1
		cmp.w	#$14,d1
		bcc.s	loc_316A08
		add.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	return_316A06
		move.w	#0,$12(a0)

return_316A06:					  ; ...
		rts
; ---------------------------------------------------------------------------

loc_316A08:					  ; ...
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	return_316A20
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

return_316A20:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_GlideHitFloor:				  ; ...
		tst.w	$12(a0)
		bmi.s	return_316A44
		bsr.w	Character_HitFloor
		tst.w	d1
		bpl.s	return_316A44
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		bclr	#1,($FFFFF7AC).w

return_316A44:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_HitCeilingAndWalls2:			  ; ...
		bsr.w	CheckLeftWallDist
		tst.w	d1
		bpl.s	loc_316A5E
		sub.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

loc_316A5E:					  ; ...
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_316A76
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

loc_316A76:					  ; ...
		bsr.w	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	return_316A88
		sub.w	d1,$C(a0)
		move.w	#0,$12(a0)

return_316A88:					  ; ...
		rts
; ---------------------------------------------------------------------------

Knuckles_HitRightWall2:				  ; ...
		bsr.w	sub_14EB4
		tst.w	d1
		bpl.s	loc_316AA2
		add.w	d1,8(a0)
		move.w	#0,$10(a0)
		bset	#5,($FFFFF7AC).w

loc_316AA2:					  ; ...
		bsr.w	Character_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_316ABC
		sub.w	d1,$C(a0)
		tst.w	$12(a0)
		bpl.s	return_316ABA
		move.w	#0,$12(a0)

return_316ABA:					  ; ...
		rts
; ---------------------------------------------------------------------------

loc_316ABC:					  ; ...
		tst.w	$12(a0)
		bmi.s	return_316ADE
		bsr.w	Character_HitFloor
		tst.w	d1
		bpl.s	return_316ADE
		add.w	d1,$C(a0)
		move.b	d3,$26(a0)
		move.w	#0,$12(a0)
		bclr	#1,($FFFFF7AC).w

return_316ADE:					  ; ...
		rts
; End of function Knuckles_DoLevelCollision2

; ===========================================================================
; ---------------------------------------------------------------------------
; Knuckles	when he	gets hurt
; ---------------------------------------------------------------------------

Obj99_Hurt:				; XREF: Obj99_Index
		clr.w	($FFFFFEB2).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	loc5_1380C
		subi.w	#$20,$12(a0)

loc5_1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
		bsr.w	Main_RecordPos
		bsr.w	Knuckles_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	stop Knuckles falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Knuckles_HurtStop:				; XREF: Obj99_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$C(a0),d0
		bcs.w	JMP_KillKnuckles
		bsr.w	Character_Floor
		btst	#1,$22(a0)
		bne.s	locret5_13860
		moveq	#0,d0
		move.w	d0,$12(a0)
		move.w	d0,$10(a0)
		move.w	d0,$20(a0)
		move.b	#0,$1C(a0)
		subq.b	#2,$24(a0)
		move.w	#$78,$30(a0)

locret5_13860:
		rts	
; End of function Knuckles_HurtStop

JMP_KillKnuckles:
		jmp	KillSonic
; ===========================================================================
; ---------------------------------------------------------------------------
; Knuckles	when he	dies
; ---------------------------------------------------------------------------

Obj99_Death:				; XREF: Obj99_Index
		bsr.w	GameOver
		jsr	ObjectFall
		bsr.w	Main_RecordPos
		bsr.w	Knuckles_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Knuckles	when the level is restarted
; ---------------------------------------------------------------------------

Obj99_ResetLevel:			; XREF: Obj99_Index
		tst.w	($FFFFF73A).w
		bne.s	Obj99_ResetLevel2
		tst.w	($FFFFF73C).w
		bne.s	Obj99_ResetLevel2
		move.b	#2,$24(a0)	; => Obj01_Control

Obj99_ResetLevel2:
		bsr.w	Sonic_Animate
		bsr.w	LoadCharacterDynPLC
		jmp	(DisplaySprite).l

; ---------------------------------------------------------------------------
; Subroutine to	animate	Knuckles's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Knuckles_Animate:				; XREF: Obj99_Control; et al
		lea	(KnucklesAniData).l,a1
		moveq	#0,d0
		move.b	$1C(a0),d0
		cmp.b	$1D(a0),d0	; is animation set to restart?
		beq.s	KnuAnim_Do	; if not, branch
		move.b	d0,$1D(a0)	; set to "no restart"
		move.b	#0,$1B(a0)	; reset	animation
		move.b	#0,$23(a0)	; reset	frame duration
		bclr	#5,$22(a0)

KnuAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	KnuAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.s	KnuAnim_Delay	; if time remains, branch
		move.b	d0,$23(a0)	; load frame duration

KnuAnim_Do2:
		moveq	#0,d1
		move.b	$1B(a0),d1	; load current frame number
		move.b	1(a1,d1.w),d0	; read sprite number from script
		cmp.b	#$FD,d0					; MJ: is it a flag from FD to FF?
		bhs	KnuAnim_End_FF				; MJ: if so, branch to flag routines
 
KnuAnim_Next:
		move.b	d0,$1A(a0)	; load sprite number
		addq.b	#1,$1B(a0)	; next frame number

KnuAnim_Delay:
		rts	
; ===========================================================================

KnuAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	KnuAnim_End_FE	; if not, branch
		move.b	#0,$1B(a0)	; restart the animation
		move.b	1(a1),d0	; read sprite number
		bra.s	KnuAnim_Next
; ===========================================================================

KnuAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	KnuAnim_End_FD	; if not, branch
		move.b	2(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,$1B(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0	; read sprite number
		bra.s	KnuAnim_Next
; ===========================================================================

KnuAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	KnuAnim_End	; if not, branch
		move.b	2(a1,d1.w),$1C(a0) ; read next byte, run that animation

KnuAnim_End:
		rts	
; ===========================================================================

KnuAnim_WalkRun:				; XREF: KnuAnim_Do
		addq.b	#1,d0		; is animation walking/running?
		bne.w	KnuAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	$26(a0),d0
		bmi.s	loc_31704E
		beq.s	loc_31704E
		subq.b	#1,d0

loc_31704E:					  ; ...
		move.b	$22(a0),d2
		andi.b	#1,d2		; is Knuckles mirrored horizontally?
		bne.s	loc5_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc5_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc5_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc5_13A78:
		andi.b	#$FC,1(a0)
		eor.b	d1,d2
		or.b	d2,1(a0)
		btst	#5,$22(a0)
		bne.w	KnuAnim_Push
		tst.b	$2B(a0)
		bne.w	KnuAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	$20(a0),d2	; get Knuckles's speed
		bpl.s	loc5_13A32
		neg.w	d2

loc5_13A32:
		lea	(KnuAni_Run).l,a1 ; use	running	animation
		cmpi.w	#$600,d2	; is Knuckles at running speed?
		bcc.s	loc5_13AB4	; if yes, branch
		lea	(KnuAni_Walk).l,a1 ; use walking animation
		add.b	d0,d0

loc5_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		moveq	#0,d1
		move.b	$1B(a0),d1
		move.b	1(a1,d1.w),d0
		cmp.b	#$FF,d0
		bne.s	loc_3170C2
		move.b	#0,$1B(a0)
		move.b	1(a1),d0

loc_3170C2:					  ; ...
		move.b	d0,$1A(a0)
		add.b	d3,$1A(a0)
		subq.b	#1,$23(a0)
		bpl.s	return_3170E4
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc5_13AC2
		moveq	#0,d2

loc5_13AC2:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		bsr.w	KnuAnim_Do2
		add.b	d3,$1A(a0)	; modify frame number

return_3170E4:
		rts	

; ===========================================================================			

KnuAnim_RollJump:				; XREF: KnuAnim_WalkRun
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.w	KnuAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	KnuAnim_Push	; if not, branch
		move.w	$20(a0),d2	; get Knuckles's speed
		bpl.s	loc5_13ADE
		neg.w	d2

loc5_13ADE:
		lea	(KnuAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Knuckles moving fast?
		bcc.s	loc5_13AF0	; if yes, branch
		lea	(KnuAni_Roll).l,a1 ; use slower	animation

loc5_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc5_13AFA
		moveq	#0,d2

loc5_13AFA:
		lsr.w	#8,d2
		move.b	d2,$23(a0)	; modify frame duration
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	KnuAnim_Do2
; ===========================================================================

KnuAnim_Push:				; XREF: KnuAnim_RollJump
		subq.b	#1,$23(a0)	; subtract 1 from frame	duration
		bpl.w	KnuAnim_Delay	; if time remains, branch
		move.w	$20(a0),d2	; get Knuckles's speed
		bmi.s	loc5_13B1E
		neg.w	d2

loc5_13B1E:
		addi.w	#$800,d2
		bpl.s	loc5_13B26
		moveq	#0,d2

loc5_13B26:
		lsr.w	#6,d2
		move.b	d2,$23(a0)	; modify frame duration
		lea	(KnuAni_Push).l,a1
		move.b	$22(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,1(a0)
		or.b	d1,1(a0)
		bra.w	KnuAnim_Do2
; End of function Knuckles_Animate

; ===========================================================================

ShadowAniData:
	include "_anim\Shadow.asm"

SilverAniData:
	include "_anim\Silver.asm"

TailsAniData:
	include "_anim\Tails.asm"

KnucklesAniData:
	include "_anim\Knuckles.asm"

LoadSSCharDynPLC:
		movea.l	#SSCharDynPLC,a2	; get DPLC location
		move.l	#Art_SSChar,d6	; get art location
		move.w	#(ArtTile_Main*$20),d4		; offset in VRAM to store art
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF766).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End3	; if is, don't load new DPLC
		move.b	d0,($FFFFF766).w	; remember queued frame
		bra.w	Load_DPLC

DPLC_End3:
		rts

LoadTailsTailsDynPLC:
		movea.l	#TailsTailsDynPLC,a2	; get DPLC location
		move.l	#Art_TailsTails,d6	; get art location
		move.w	#(ArtTile_PartnerSec*$20),d4		; offset in VRAM to store art
		cmpi.b	#$95,($FFFFB000).w
		bne.s	LoadTailsTailsDynPLC2
		move.w	#(ArtTile_MainSec*$20),d4		; offset in VRAM to store art
		
LoadTailsTailsDynPLC2:
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF767).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End2	; if is, don't load new DPLC
		move.b	d0,($FFFFF767).w	; remember queued frame
		bra.w	Load_DPLC

LoadCharacterDynPLC:
		btst	#7,$22(a0)
		bne.s	LoadPartnerDynPLC

LoadMainDynPLC:
		moveq	#0,d0
		move.b	(Current_Character).w,d0
		move.b	(Current_Partner).w,d1
		cmpi.b	#9,(a0)
		bne.s	@notBS
		move.b	d0,d1

	@notBS:
		lsl.w	#3,d0
		add.b	d1,d0
		lsl.w	#3,d0
		lea	CharacterArtList(pc,d0.w),a1
		movea.l	(a1)+,a2
		move.l	(a1),d6
		move.w	#(ArtTile_Main*$20),d4		; offset in VRAM to store art
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF766).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End2	; if is, don't load new DPLC
		move.b	d0,($FFFFF766).w	; remember queued frame
		bra.w	Load_DPLC

LoadPartnerDynPLC:
		moveq	#0,d0
		move.b	(Current_Partner).w,d0
		move.b	(Current_Character).w,d1
		lsl.w	#3,d0
		add.b	d1,d0
		lsl.w	#3,d0
		lea	CharacterArtList(pc,d0.w),a1
		movea.l	(a1)+,a2
		move.l	(a1),d6
		move.w	#(ArtTile_Partner*$20),d4		; offset in VRAM to store art
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	($FFFFF76D).w,d0	; check if equal with last queued frame
		beq.s	DPLC_End2	; if is, don't load new DPLC
		move.b	d0,($FFFFF76D).w	; remember queued frame
		bra.w	Load_DPLC

DPLC_End2:
		rts
; ===========================================================================
CharacterArtList:
		dc.l SonicDynPLC, Art_Sonic ; Sonic
		dc.l SonicDynPLC, Art_Sonic ; Sonic and Tails
		dc.l SonicDynPLC, Art_Sonic ; Sonic and Knuckles
		dc.l SonicDynPLC, Art_Sonic ; Sonic and Shadow
		dc.l SonicDynPLC, Art_Sonic ; Sonic and Silver
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l TailsDynPLC, Art_Tails ; Tails and Sonic
		dc.l TailsDynPLC, Art_Tails ; Tails
		dc.l TailsDynPLC, Art_Tails ; Tails and Knuckles
		dc.l TailsDynPLC, Art_Tails ; Tails and Shadow
		dc.l TailsDynPLC, Art_Tails ; Tails and Silver
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l KnucklesDynPLC, Art_Knuckles ; Knuckles and Sonic
		dc.l KnucklesDynPLC, Art_Knuckles2 ; Knuckles and Tails
		dc.l KnucklesDynPLC, Art_Knuckles ; Knuckles
		dc.l KnucklesDynPLC, Art_Knuckles2 ; Knuckles and Shadow
		dc.l KnucklesDynPLC, Art_Knuckles ; Knuckles and Silver
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l ShadowDynPLC, Art_Shadow ; Shadow and Sonic
		dc.l ShadowDynPLC, Art_Shadow2 ; Shadow and Tails
		dc.l ShadowDynPLC, Art_Shadow ; Shadow and Knuckles
		dc.l ShadowDynPLC, Art_Shadow ; Shadow
		dc.l ShadowDynPLC, Art_Shadow ; Shadow and Silver
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l SilverDynPLC, Art_Silver2 ; Silver and Sonic
		dc.l SilverDynPLC, Art_Silver ; Silver and Tails
		dc.l SilverDynPLC, Art_Silver ; Silver and Knuckles
		dc.l SilverDynPLC, Art_Silver ; Silver and Shadow
		dc.l SilverDynPLC, Art_Silver ; Silver
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
		dc.l 0, 0 ; Null
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to queue any pattern load cue
; Input: a2 - DPLC file, d4 - VRAM address, d6 - Art file, d0 - frame number
; ---------------------------------------------------------------------------

Load_DPLC:
		add.w	d0,d0		; multiply by 2
		adda.w	(a2,d0.w),a2	; get the right DPLC location
		moveq	#0,d5		; quckly clear d5
		move.b	(a2)+,d5	; then move the amount of requests to d5
		subq.w	#1,d5		; subtract 1
		bmi.s	DPLC_End	; if negative, branch away

DPLC_ReadEntry:
		moveq	#0,d1
		move.b	(a2)+,d1	; get first byte to d1, and increment pointer
		lsl.w	#8,d1		; shift 8 bits left
		move.b	(a2)+,d1 	; move second byte to d1

		move.w	d1,d3		; move d1 to d3
		lsr.w	#8,d3		; shift 8 bits right
		andi.w	#$F0,d3		; leave only bits 7, 6, 5, and 4
		addi.w	#$10,d3		; add $10 to d3

		andi.w	#$FFF,d1	; filter out bits 15, 14, 13 and 12
		lsl.l	#5,d1		; shift 5 bits left
		add.l	d6,d1		; add the art address to d1
		move.w	d4,d2		; move VRAM location to d2
		add.w	d3,d4		; add d3 to VRAM address
		add.w	d3,d4		; add d3 to VRAM address

		jsr	QueueDMATransfer; Save it to the DMA queue
		dbf	d5,DPLC_ReadEntry; repeat for number of requests

DPLC_End:
		rts			; return

; End of function LoadDPLC

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 01 - SSChar
; ---------------------------------------------------------------------------

Obj0D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0D_Index(pc,d0.w),d1
		jmp	Obj0D_Index(pc,d1.w)
; ===========================================================================
Obj0D_Index:	dc.w Obj0D_Main-Obj0D_Index
		dc.w Obj0D_Control-Obj0D_Index
		dc.w Obj0D_Hurt-Obj0D_Index
		dc.w Obj0D_Death-Obj0D_Index
; ===========================================================================

Obj0D_Main:				; XREF: Obj0D_Index
		move.b	#$C,$3E(a0)	; MJ: set collision to 1st
		move.b	#$D,$3F(a0)	; MJ: set collision to 1st
		move.w	$3E(a0),($FFFFFE54).w
		addq.b	#2,$24(a0)
		move.b	#$13,$16(a0)
		move.b	#9,$17(a0)
		move.l	#Map_SSChar,4(a0)
		make_art_tile	ArtTile_Main,0,1
		move.w	#$100,$18(a0)
		move.b	#$18,$14(a0)
		move.b	#4,1(a0)
		move.b	#$1E,$28(a0)
		move.w	#$600,($FFFFF760).w ; SSChar's top speed
		move.w	#$C,($FFFFF762).w ; SSChar's acceleration
		move.w	#$80,($FFFFF764).w ; SSChar's deceleration

Obj0D_Control:				; XREF: Obj0D_Index
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#6,d0
		move.w	Obj0D_Modes(pc,d0.w),d1
		jsr	Obj0D_Modes(pc,d1.w)

	.12C7E:
		bsr.s	SSChar_Display
	;	bsr.w	Main_RecordPos
		cmpi.w	#-$600,$20(a0)	; is SSChar at running speed?
		bgt.s	.12C7E1
		cmp.w	#-$40,($FFFFF75E).w
		beq.s	.12C7E2
		sub.w	#2,($FFFFF75E).w
		bra.s	.12C7E2

	.12C7E1:
		cmpi.w	#$600,$20(a0)	; is SSChar at running speed?
		blt.s	.12C7E2
		cmp.w	#$40,($FFFFF75E).w
		beq.s	.12C7E2
		add.w	#2,($FFFFF75E).w

	.12C7E2:
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	.12CA6
		tst.b	$1C(a0)
		bne.s	.12CA6
		move.b	$1D(a0),$1C(a0)

	.12CA6:
		jsr	Sonic_Animate
		jsr	TouchResponse

	.12CB6:
		jsr	LoadSSCharDynPLC
		rts
; ===========================================================================
Obj0D_Modes:	dc.w Obj0D_MdNormal-Obj0D_Modes
		dc.w Obj0D_MdJump-Obj0D_Modes
		dc.w Obj0D_MdRoll-Obj0D_Modes
		dc.w Obj0D_MdJump2-Obj0D_Modes
; ===========================================================================

SSChar_Display:				; XREF: 	.12C7E
		move.w	$30(a0),d0
		beq.s	Obj0D_Display
		subq.w	#1,$30(a0)
		btst	#7,$22(a0)
		bne.s	Obj0D_Display
		lsr.w	#3,d0
		bcc.s	Obj0D_ChkInvin

Obj0D_Display:
		jsr	DisplaySprite

Obj0D_ChkInvin:
		btst	#1,($FFFFFE2C).w	; does SSChar have invincibility?
		beq.w	Obj0D_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj0D_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj0D_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj0D_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj0D_RmvInvin	; change to bcs.w
		move.b	#0,($FFFFF75D).w	; store level music

Obj0D_RmvInvin:
		bclr	#1,($FFFFFE2C).w ; cancel invincibility

Obj0D_ChkShoes:
		tst.b	($FFFFFE2E).w	; does SSChar have speed	shoes?
		beq.s	Obj0D_ExitChk	; if not, branch
		tst.w	$34(a0)		; check	time remaining
		beq.s	Obj0D_ExitChk
		subq.w	#1,$34(a0)	; subtract 1 from time
		bne.s	Obj0D_ExitChk
		move.w	#$600,($FFFFF760).w ; restore SSChar"s speed
		move.w	#$C,($FFFFF762).w ; restore SSChar"s acceleration
		move.w	#$80,($FFFFF764).w ; restore SSChar"s deceleration
		move.b	#0,($FFFFFE2E).w ; cancel speed	shoes
		command	mus_ShoesOff ;	use normal speed
; ===========================================================================

Obj0D_ExitChk:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	SSChar
; ---------------------------------------------------------------------------

Obj0D_MdNormal:				; XREF: Obj0D_Modes
		bsr.w	Character_SpinDash
		bsr.w	Character_Jump
		bsr.w	Character_Roll
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		rts	
; ===========================================================================

Obj0D_MdJump:				; XREF: Obj0D_Modes
	;	clr.b	$39(a0)
		bsr.w	SSChar_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	.12E5C
		subi.w	#$28,$12(a0)

	.12E5C:
		tst.w	$12(a0)
		bmi.s	.12E5E
		cmpi.b	#$10,$1C(a0)
		bne.s	.12E5E
		move.b	#$C,$1C(a0)

	.12E5E:
		bsr.w	Character_Floor
		rts	
; ===========================================================================

Obj0D_MdRoll:				; XREF: Obj0D_Modes
		bsr.w	Character_Jump
		bsr.w	Character_LevelBound
		jsr	SpeedToPos
		rts	
; ===========================================================================

Obj0D_MdJump2:				; XREF: Obj0D_Modes
		bsr.w	SSChar_JumpHeight
		bsr.w	Character_ChgJumpDir
		bsr.w	Character_LevelBound
		jsr	ObjectFall
		btst	#6,$22(a0)
		beq.s	.12EA6
		subi.w	#$28,$12(a0)

	.12EA6:
		bsr.w	Character_Floor
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SSChar_JumpHeight:
		tst.b	$3C(a0)
		beq.s	loc9_134C4
		move.w	#-$400,d1
		btst	#6,$22(a0)
		beq.s	.134AE
		move.w	#-$200,d1

	.134AE:
		btst	#7,$22(a0)
		bne.s	SSChar_JumpHeight2
		move.b	($FFFFF602).w,d0	; is ABC pressed?
		bra.s	SSChar_JumpHeight3

SSChar_JumpHeight2:	
		move.b	($FFFFF670).w,d0	; is ABC pressed?

SSChar_JumpHeight3:	
		andi.b	#$70,d0		; is A,	B or C pressed?
		bne.s	.134C2	; if yes, branch
		move.w	d1,$12(a0)

	.134C2:
		rts	
; ===========================================================================

loc9_134C4:
		cmpi.w	#-$FC0,$12(a0)
		bge.s	.134D2
		move.w	#-$FC0,$12(a0)

	.134D2:
		rts	
; End of function SSChar_JumpHeight

; ===========================================================================
; ---------------------------------------------------------------------------
; SSChar	when he	gets hurt
; ---------------------------------------------------------------------------

Obj0D_Hurt:				; XREF: Obj0D_Index
		clr.w	($FFFFFEB2).w
		jsr	SpeedToPos
		addi.w	#$30,$12(a0)
		btst	#6,$22(a0)
		beq.s	.1380C
		subi.w	#$20,$12(a0)

	.1380C:
		bsr.w	Character_HurtStop
		bsr.w	Character_LevelBound
	;	bsr.w	Main_RecordPos
		jsr	Sonic_Animate
		bsr.w	LoadSSCharDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; SSChar	when he	dies
; ---------------------------------------------------------------------------

Obj0D_Death:				; XREF: Obj0D_Index
		bsr.w	GameOver
		jsr	ObjectFall
	;	bsr.w	Main_RecordPos
		jsr	Sonic_Animate
		bsr.w	LoadSSCharDynPLC
		jmp	DisplaySprite

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0C - The Tornado on the Special Stage
; ----------------------------------------------------------------------------

Obj0C:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0C_Index(pc,d0.w),d1
		jsr	Obj0C_Index(pc,d1.w)
		jmp	DisplaySprite
; ===========================================================================
Obj0C_Index:	dc.w Obj0C_Init-Obj0C_Index
			dc.w Obj0C_Main-Obj0C_Index
; ===========================================================================

Obj0C_Init:
		addq.b	#2,$24(a0)
		move.l	#Map_SSTornado,4(a0)
		move.w	#$8DA4,2(a0)
		move.b	#4,1(a0)
		move.b	#$60,$14(a0)
		move.w	#$180,$18(a0)
		moveq	#$30,d0
		jsr	LoadPLC2		; load standard	patterns
		move.w	#$200,$10(a0)
		addq.b	#4,$24(a0)
		move.w	#$400,2(a0)

Obj0C_Main:
		move.w	#0,$12(a0)
		btst	#0,($FFFFF602).w
		beq.s	Obj0C_Special2
		move.w	#-$200,$12(a0)


Obj0C_Special2:
		btst	#1,($FFFFF602).w
		beq.s	Obj0C_Special3
		move.w	#$200,$12(a0)

Obj0C_Special3:
		rts

; ---------------------------------------------------------------------------
; Sprite mappings - The Tornado in the Special Stage
; ---------------------------------------------------------------------------
Map_SSTornado:
	include "_maps\sstornado.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0A - drowning countdown numbers and small bubbles (EEZ)
; ---------------------------------------------------------------------------

Obj0A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj0A_Index(pc,d0.w),d1
		jmp	Obj0A_Index(pc,d1.w)
; ===========================================================================
Obj0A_Index:	dc.w Obj0A_Main-Obj0A_Index, Obj0A_Animate-Obj0A_Index
		dc.w Obj0A_ChkWater-Obj0A_Index, Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index,	Obj0A_Countdown-Obj0A_Index
		dc.w Obj0A_AirLeft-Obj0A_Index,	Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index
; ===========================================================================

Obj0A_Main:				; XREF: Obj0A_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj64,4(a0)
		move.w	#$8390,2(a0)
		move.b	#$84,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$80,$18(a0)
		move.b	$28(a0),d0
		bpl.s	loc_13D00
		addq.b	#8,$24(a0)
		move.l	#Map_obj0A,4(a0)
		move.w	#$440,2(a0)
		andi.w	#$7F,d0
		move.b	d0,$33(a0)
		bra.w	Obj0A_Countdown
; ===========================================================================

loc_13D00:
		move.b	d0,$1C(a0)
		move.w	8(a0),$30(a0)
		move.w	#-$88,$12(a0)

Obj0A_Animate:				; XREF: Obj0A_Index
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite

Obj0A_ChkWater:				; XREF: Obj0A_Index
		move.w	($FFFFF646).w,d0
		cmp.w	$C(a0),d0	; has bubble reached the water surface?
		bcs.s	Obj0A_Wobble	; if not, branch
		move.b	#6,$24(a0)
		addq.b	#7,$1C(a0)
		cmpi.b	#$D,$1C(a0)
		beq.s	Obj0A_Display
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Wobble:
		tst.b	($FFFFF7C7).w
		beq.s	loc_13D44
		addq.w	#4,$30(a0)

loc_13D44:
		move.b	$26(a0),d0
		addq.b	#1,$26(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,8(a0)
		bsr.s	Obj0A_ShowNumber
		jsr	SpeedToPos
		tst.b	1(a0)
		bpl.s	Obj0A_Delete
		btst	#6,($FFFFFE2C).w	; does Sonic have a bubble shield?
		bne.s	Obj0A_Delete	; if so, branch
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj0A_Display:				; XREF: Obj0A_Index
		bsr.s	Obj0A_ShowNumber
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete2:				; XREF: Obj0A_Index
		jmp	DeleteObject
; ===========================================================================

Obj0A_AirLeft:				; XREF: Obj0A_Index
		cmpi.w	#$C,($FFFFFE14).w ; check air remaining
		bhi.s	Obj0A_Delete3	; if higher than $C, branch
		subq.w	#1,$38(a0)
		bne.s	Obj0A_Display2
		move.b	#$E,$24(a0)
		addq.b	#7,$1C(a0)
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Display2:
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		tst.b	1(a0)
		bpl.s	Obj0A_Delete3
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete3:
		jmp	DeleteObject
; ===========================================================================

Obj0A_ShowNumber:			; XREF: Obj0A_Wobble; Obj0A_Display
		tst.w	$38(a0)
		beq.s	locret_13E1A
		subq.w	#1,$38(a0)
		bne.s	locret_13E1A
		cmpi.b	#7,$1C(a0)
		bcc.s	locret_13E1A
		move.w	#$F,$38(a0)
		clr.w	$12(a0)
		move.b	#$80,1(a0)
		move.w	8(a0),d0
		sub.w	($FFFFF700).w,d0
		addi.w	#$80,d0
		move.w	d0,8(a0)
		move.w	$C(a0),d0
		sub.w	($FFFFF704).w,d0
		addi.w	#$80,d0
		move.w	d0,$A(a0)
		move.b	#$C,$24(a0)

locret_13E1A:
		rts	
; ===========================================================================
Obj0A_WobbleData:
		dc.b 0, 0, 0, 0, 0, 0,	1, 1, 1, 1, 1, 2, 2, 2,	2, 2, 2
		dc.b 2,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 4, 3
		dc.b 3,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 2, 2, 2, 2
		dc.b 2,	2, 2, 1, 1, 1, 1, 1, 0,	0, 0, 0, 0, 0, -1, -1
		dc.b -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2
		dc.b -2, -2, -2, -2, -1, -1, -1, -1, -1
		dc.b 0, 0, 0, 0, 0, 0,	1, 1, 1, 1, 1, 2, 2, 2,	2, 2, 2
		dc.b 2,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 4, 3
		dc.b 3,	3, 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 2, 2, 2, 2
		dc.b 2,	2, 2, 1, 1, 1, 1, 1, 0,	0, 0, 0, 0, 0, -1, -1
		dc.b -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2
		dc.b -2, -2, -2, -2, -1, -1, -1, -1, -1
; ===========================================================================

Obj0A_Countdown:			; XREF: Obj0A_Index
		tst.w	$2C(a0)
		bne.w	loc_13F86
		btst	#6,($FFFFFE2C).w	; was a bubble shield monitor broken?
		bne.w	locret_1408C	; if yes, branch
		cmpi.b	#6,($FFFFB024).w
		bcc.w	locret_1408C
		btst	#6,($FFFFB022).w
		beq.w	locret_1408C
		subq.w	#1,$38(a0)
		bpl.w	loc_13FAC
		move.w	#59,$38(a0)
		move.w	#1,$36(a0)
		jsr	(RandomNumber).l
		andi.w	#1,d0
		move.b	d0,$34(a0)
		move.w	($FFFFFE14).w,d0 ; check air remaining
		cmpi.w	#$19,d0
		beq.s	Obj0A_WarnSound	; play sound if	air is $19
		cmpi.w	#$14,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$F,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$C,d0
		bhi.s	Obj0A_ReduceAir	; if air is above $C, branch
		
loc_13F02:
		subq.b	#1,$32(a0)
		bpl.s	Obj0A_ReduceAir
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)
		sfx		sfx_Diamonds
		bra.s	Obj0A_ReduceAir
; ===========================================================================

Obj0A_WarnSound:			; XREF: Obj0A_Countdown
		sfx		sfx_AirDing ;	play "ding-ding" warning sound

Obj0A_ReduceAir:
		subq.w	#1,($FFFFFE14).w ; subtract 1 from air remaining
		bcc.w	Obj0A_GoMakeItem ; if air is above 0, branch
		sfx		sfx_Drown ;	play drowning sound
		command	mus_FadeOut
		move.b	#$A,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$78,$2C(a0)
		move.l	a0,-(sp)
		lea	($FFFFB000).w,a0
		bsr.w	Player_ResetOnFloor
		move.b	#$81,$2A(a0) ; lock controls
		move.b	#$17,$1C(a0)	; use Sonic's drowning animation
		bset	#1,$22(a0)
		bset	#7,2(a0)
		move.w	#0,$12(a0)
		move.w	#0,$10(a0)
		move.w	#0,$20(a0)
		move.b	#1,($FFFFF744).w
		movea.l	(sp)+,a0
		rts	
; ===========================================================================

loc_13F86:
		subq.w	#1,$2C(a0)
		bne.s	loc_13F94
		move.b	#6,($FFFFB024).w
		rts	
; ===========================================================================

loc_13F94:
		move.l	a0,-(sp)
		lea	($FFFFB000).w,a0
		jsr	SpeedToPos
		addi.w	#$10,$12(a0)
		movea.l	(sp)+,a0
		bra.s	loc_13FAC
; ===========================================================================

Obj0A_GoMakeItem:			; XREF: Obj0A_ReduceAir
		bra.s	Obj0A_MakeItem
; ===========================================================================

loc_13FAC:
		tst.w	$36(a0)
		beq.w	locret_1408C
		subq.w	#1,$3A(a0)
		bpl.w	locret_1408C

Obj0A_MakeItem:
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		move.w	d0,$3A(a0)
		jsr	SingleObjLoad
		bne.w	locret_1408C
		move.b	#$A,0(a1)	; load object
		move.w	($FFFFB008).w,8(a1) ; match X position to Sonic
		moveq	#6,d0
		btst	#0,($FFFFB022).w
		beq.s	loc_13FF2
		neg.w	d0
		move.b	#$40,$26(a1)

loc_13FF2:
		add.w	d0,8(a1)
		move.w	($FFFFB00C).w,$C(a1)
		move.b	#6,$28(a1)
		tst.w	$2C(a0)
		beq.w	loc_1403E
		andi.w	#7,$3A(a0)
		addi.w	#0,$3A(a0)
		move.w	($FFFFB00C).w,d0
		subi.w	#$C,d0
		move.w	d0,$C(a1)
		jsr	(RandomNumber).l
		move.b	d0,$26(a1)
		move.w	($FFFFFE04).w,d0
		andi.b	#3,d0
		bne.s	loc_14082
		move.b	#$E,$28(a1)
		bra.s	loc_14082
; ===========================================================================

loc_1403E:
		btst	#7,$36(a0)
		beq.s	loc_14082
		move.w	($FFFFFE14).w,d2
		lsr.w	#1,d2
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_1406A
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,$28(a1)
		move.w	#$1C,$38(a1)

loc_1406A:
		tst.b	$34(a0)
		bne.s	loc_14082
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,$28(a1)
		move.w	#$1C,$38(a1)

loc_14082:
		subq.b	#1,$34(a0)
		bpl.s	locret_1408C
		clr.w	$36(a0)

locret_1408C:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	play music for EEZ/FFZ3 after a countdown
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ResumeMusic:				; XREF: Obj64_Wobble; Character_Water; Obj0A_ReduceAir
		move.w	#$1E,($FFFFFE14).w
		clr.b	($FFFFB372).w
		rts	
; End of function ResumeMusic

; ===========================================================================
Ani_obj0A:
	include "_anim\obj0A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - drowning countdown numbers (EEZ)
; ---------------------------------------------------------------------------
Map_obj0A:
	include "_maps\obj0A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 38 - Shield
; ---------------------------------------------------------------------------

Obj38:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w  Shield_Index(pc,d0.w),d1
		jmp	 Shield_Index(pc,d1.w)
; ===========================================================================		
Shield_Index:				 
		dc.w	Shield_Init-Shield_Index		
		dc.w	FlameShield-Shield_Index
		dc.w	LightningShield-Shield_Index
		dc.w	BubbleShield-Shield_Index
		dc.w	Shield_Underwater2-Shield_Index
; ===========================================================================		
Shield_Init:
		lea	($FFFFB000).w,a1
		addq.b	#2,$24(a0)
		move.b  #4,1(a0)						
		move.w  #$80,$18(a0)
		move.b  #$18,$14(a0)
		move.b	#$FF,$3A(a0)
		btst	#0,($FFFFFE2C).w
		beq.s	Shield_Delete
		make_art_tile	ArtTile_Shield,0,1
		btst	#4,($FFFFFE2C).w
		beq.s	Shield_ChkLightning
		move.b  #3,$1C(a0)
		move.l	#Map_fshield,4(a0)  
		bra.s	FlameShield

Shield_ChkLightning:
		btst	#5,($FFFFFE2C).w
		beq.s	Shield_ChkBubble
		move.b  #1,$1C(a0)
		addq.b	#2,$24(a0)
		move.l	#Map_lshield,4(a0)  
		bra.w	LightningShield

Shield_ChkBubble:
		btst	#6,($FFFFFE2C).w
		beq.s	Shield_Delete
		move.b  #2,$1C(a0)
		addq.b	#4,$24(a0)
		move.l	#Map_bshield,4(a0)  
		bra.w	BubbleShield

Shield_Delete:
		jmp	DeleteObject

FlameShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a FShield
		bne.w  SonicHasFShield					; If so, branch to do nothing
		btst	#6,$22(a1)
		beq.s	FShieldProperties	; if not, branch
		andi.b	#$8E,($FFFFFE2C).w
		jmp	DeleteObject


FShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position

FShieldCont:
		bclr	#0,$22(a0)
		btst	#0,$22(a1)
		beq.s   FShieldCont2
		bset	#0,$22(a0)

FShieldCont2:
		lea	 (Ani_obj38).l,a1  
		jsr	 AnimateSprite
		move.w	#$80,$18(a0)	; Layer FShield over player sprite
		cmpi.b	#$F,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	FShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer FShield behind player sprite

FShield_Display:	; +  
		moveq	#0,d0				 ; Load Shield Map into place  	
		movea.l	#FShieldDynPLC,a2	; get DPLC location
		move.w	#(ArtTile_Shield*$20),d4		; offset in VRAM to store art
		move.l	#UnC_FlameShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	FShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC				

FShield_Display2:
		jmp	 DisplaySprite	

SonicHasFShield:
		rts	

LightningShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a LShield
		bne.w  SonicHasLShield					; If so, branch to do nothing
		btst	#6,$22(a1)
		beq.s	LShieldProperties	; if not, branch

Shield_Underwater:
		move.b	#8,$24(a0)
		andi.b	#$8E,($FFFFFE2C).w	; Sets Status_Shield, Status_FireShield, Status_LtngShield, and Status_BublShield to 0

		; Flashes the underwater palette white
		lea	($FFFFFA80).w,a1
		lea	($FFFFFA00).w,a2
		move.w	#$1F,d0			; Size of Water_palette/4-1

loc_197F2:
		move.l	(a1),(a2)+			; Backup palette entries
		move.l	#$0EEE0EEE,(a1)+		; Overwrite palette entries with white
		dbf	d0,loc_197F2				; Loop until entire thing is overwritten

		move.b	#4,$23(a0)
		move.b	#1,$30(a0)
		jmp	DestroyEnemiesUW

LShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position

LShieldCont:
		lea	 (Ani_obj38).l,a1  
		jsr	 AnimateSprite
		move.w	#$80,$18(a0)	; Layer Shield over player sprite
		cmpi.b	#$E,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	LShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer LShield behind player sprite

LShield_Display:	; +  
		moveq	#0,d0				 ; Load Shield Map into place  	
		movea.l	#LShieldDynPLC,a2	; get DPLC location
		move.w	#(ArtTile_Shield*$20),d4		; offset in VRAM to store art
		move.l	#UnC_LightningShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	LShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC				

LShield_Display2:
		jmp	 DisplaySprite	

SonicHasLShield:
		rts	

BubbleShield:
		lea	($FFFFB000).w,a1
		btst	#0,($FFFFFE2C).w
		beq.w	Shield_Delete
		btst   #1,($FFFFFE2C).w				; Test if Sonic has a BShield
		bne.w  SonicHasBShield					; If so, branch to do nothing
		move.w	($FFFFF646).w,d0

BShieldProperties:	
		move.w  8(a1),8(a0)			; Load Main Character X-position
		move.w  $C(a1),$C(a0)			; Load Main Character Y-position

BShieldCont:
		lea	 (Ani_obj38).l,a1  
		jsr	 AnimateSprite
		move.w	#$80,$18(a0)	; Layer BShield over player sprite 
		cmpi.b	#$D,$1A(a0)	; Are these the frames that display in front of the player?
		blo.s	BShield_Display		; If so, branch
		move.w	#$200,$18(a0)	; If not, layer BShield behind player sprite

BShield_Display:	; +  
		moveq	#0,d0 	
		movea.l	#BShieldDynPLC,a2	; get DPLC location
		move.w	#(ArtTile_Shield*$20),d4		; offset in VRAM to store art
		move.l	#UnC_BubbleShield,d6	; get art location
		
		moveq	#0,d0
		move.b	$1A(a0),d0	; load frame number
		cmp.b	$3A(a0),d0	; check if equal with last queued frame
		beq.w	BShield_Display2	; if is, don't load new DPLC
		move.b	d0,$3A(a0)	; remember queued frame
		jsr 	Load_DPLC				

BShield_Display2:
		jmp	 DisplaySprite	

SonicHasBShield:
		rts	

Shield_Underwater2:
		subq.b	#1,$23(a0)		; Is it time to end the white flash?
		bpl.s	locret_198BC			; If not, return
		lea	($FFFFFA00).w,a1
		lea	($FFFFFA80).w,a2
		move.w	#$1F,d0			; Size of Water_palette/4-1

loc_198B6:
		move.l	(a1)+,(a2)+			; Restore backed-up underwater palette
		dbf	d0,loc_198B6				; Loop until entire thing is restored
		jmp	DeleteObject

locret_198BC:
		rts

; ---------------------------------------------------------------------------
; Object 4A - New Invincibility Object
; ---------------------------------------------------------------------------

Obj4A:					; XREF: Obj_Index
Invincibility_Main:
		moveq	#0,d0
		move.b	$24(a0),d0
Invincibility_Init:		
		addq.b	#2,$24(a0)
		move.l	#Map_obj4A,4(a0)	; loads mapping
		move.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		make_art_tile	ArtTile_Shield,0,1
		move.l	#UnC_Stars,d1
		move.w	#(ArtTile_Shield*$20),d2
		move.w	#$200,d3
		jsr	(QueueDMATransfer).l
; ===========================================================================

Obj4A_Stars:				; XREF: Obj38_Index
		btst	#1,($FFFFFE2C).w	; does Sonic have invincibility?
		beq.s	Obj4A_Delete2	; if not, branch
		move.w	($FFFFF7A8).w,d0
		move.b	$1C(a0),d1
		subq.b	#1,d1
; ===========================================================================

Obj4A_StarTrail:			; XREF: Obj4A_Stars
		lsl.b	#7,d1
		move.b	d1,d2
		add.b	d1,d1
		add.b	d2,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	$30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		cmpi.b	#$18,d1
		bcs.s	Obj4A_StarTrail2
		moveq	#0,d1

Obj4A_StarTrail2:
		move.b	d1,$30(a0)

Obj4A_StarTrail2a:
		lea	($FFFFE500).w,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,8(a0)
		move.w	(a1)+,$C(a0)
		move.b	($FFFFB022).w,$22(a0)
		lea	(Ani_obj4A).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

Obj4A_Delete2:				; XREF: Obj4A_Stars
		jmp	(DeleteObject).l			
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 08 - water splash (EEZ)
; ---------------------------------------------------------------------------

Obj08:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj08_Index(pc,d0.w),d1
		jmp	Obj08_Index(pc,d1.w)
; ===========================================================================
Obj08_Index:	dc.w Obj08_Main-Obj08_Index
		dc.w Obj08_Display-Obj08_Index
		dc.w Obj08_Delete-Obj08_Index
; ===========================================================================

Obj08_Main:				; XREF: Obj08_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj08,4(a0)
		ori.b	#4,1(a0)
		move.w	#$80,$18(a0)
		move.b	#$10,$14(a0)
		move.w	#$4259,2(a0)
		move.w	($FFFFB008).w,8(a0) ; copy x-position from Sonic

Obj08_Display:				; XREF: Obj08_Index
		move.w	($FFFFF646).w,$C(a0) ; copy y-position from water height
		lea	(Ani_obj08).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj08_Delete:				; XREF: Obj08_Index
		jmp	DeleteObject	; delete when animation	is complete
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - shield and invincibility stars
; ---------------------------------------------------------------------------
Map_obj4A:
	include "_maps\obj4A.asm"

Ani_obj4A:
	include "_anim\obj4A.asm"

Map_lshield:
	include "_maps\obj38shield.asm"

Map_bshield:
	include "_maps\obj38bubbleshield.asm"

Map_fshield:
	include "_maps\obj38flameshield.asm"

Ani_obj38:
	include "_anim\obj38.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage entry	from beta
; ---------------------------------------------------------------------------
Ani_obj08:
	include "_anim\obj08.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - water splash (EEZ)
; ---------------------------------------------------------------------------
Map_obj08:
	include "_maps\obj08.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Character_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3E(a0),d5			; MJ: load L/R/B soldity bit
		btst	#3,$22(a0)
		beq.s	loc_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	$26(a0),d0
		addi.b	#$20,d0
		bpl.s	loc_14624
		move.b	$26(a0),d0
		bpl.s	loc_1461E
		subq.b	#1,d0

loc_1461E:
		addi.b	#$20,d0
		bra.s	loc_14630
; ===========================================================================

loc_14624:
		move.b	$26(a0),d0
		bpl.s	loc_1462C
		addq.b	#1,d0

loc_1462C:
		addi.b	#$1F,d0

loc_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Character_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Character_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Character_WalkVertR
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Character_Angle
		tst.w	d1
		beq.s	locret_146BE
		bpl.s	loc_146C0
		cmpi.w	#-$E,d1
		blt.s	locret_146E6
		add.w	d1,$C(a0)

locret_146BE:
		rts	
; ===========================================================================

loc_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc_146CC

loc_146C6:
		add.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_146CC:
		tst.b	$38(a0)
		bne.s	loc_146C6
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; ===========================================================================

locret_146E6:
		rts	
; End of function Character_AnglePos

; ===========================================================================
		move.l	8(a0),d2
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.l	d2,8(a0)
		move.w	#$38,d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
; ===========================================================================

locret_1470A:
		rts	
; ===========================================================================
		move.l	$C(a0),d3
		move.w	$12(a0),d0
		subi.w	#$38,d0
		move.w	d0,$12(a0)
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,$C(a0)
		rts	
		rts	
; ===========================================================================
		move.l	8(a0),d2
		move.l	$C(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d2,8(a0)
		move.l	d3,$C(a0)
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_Angle:				; XREF: Character_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc_1475E:
		btst	#0,d2
		bne.s	loc_1476A
		move.b	d2,$26(a0)
		rts	
; ===========================================================================

loc_1476A:
		move.b	$26(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,$26(a0)
		rts	
; End of function Character_Angle

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_WalkVertR:			; XREF: Character_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Character_Angle
		tst.w	d1
		beq.s	locret_147F0
		bpl.s	loc_147F2
		cmpi.w	#-$E,d1
		blt.w	locret_1470A
		add.w	d1,8(a0)

locret_147F0:
		rts	
; ===========================================================================

loc_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc_147FE

loc_147F8:
		add.w	d1,8(a0)
		rts	
; ===========================================================================

loc_147FE:
		tst.b	$38(a0)
		bne.s	loc_147F8
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Character_WalkVertR

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_WalkCeiling:			; XREF: Character_AnglePos
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Character_Angle
		tst.w	d1
		beq.s	locret_14892
		bpl.s	loc_14894
		cmpi.w	#-$E,d1
		blt.w	locret_146E6
		sub.w	d1,$C(a0)

locret_14892:
		rts	
; ===========================================================================

loc_14894:
		cmpi.w	#$E,d1
		bgt.s	loc_148A0

loc_1489A:
		sub.w	d1,$C(a0)
		rts	
; ===========================================================================

loc_148A0:
		tst.b	$38(a0)
		bne.s	loc_1489A
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Character_WalkCeiling

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_WalkVertL:
		move.w	$C(a0),d2				; MJ: Load Y position
		move.w	8(a0),d3				; MJ: Load X position
		moveq	#0,d0					; MJ: clear d0
		move.b	$17(a0),d0				; MJ: load height
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d2					; MJ: subtract from Y position
		move.b	$16(a0),d0				; MJ: load width
		ext.w	d0					; MJ: set left byte pos or neg
		sub.w	d0,d3					; MJ: subtract from X position
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4			; MJ: load address of the angle value set
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		bsr.w	Character_Angle
		tst.w	d1
		beq.s	locret_14934
		bpl.s	loc_14936
		cmpi.w	#-$E,d1
		blt.w	locret_1470A
		sub.w	d1,8(a0)

locret_14934:
		rts

; ===========================================================================

loc_14936:
		cmpi.w	#$E,d1
		bgt.s	loc_14942

loc_1493C:
		sub.w	d1,8(a0)
		rts	

; ===========================================================================

loc_14942:
		tst.b	$38(a0)
		bne.s	loc_1493C
		bset	#1,$22(a0)
		bclr	#5,$22(a0)
		move.b	#1,$1D(a0)
		rts	
; End of function Character_WalkVertL

; ---------------------------------------------------------------------------
; Subroutine to	find which tile	the object is standing on
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Floor_ChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0780,d0				; MJ: get within 780 (E00 pixels) in multiples of 80
		add.w	d0,d0					; MJ: multiply by 2
		move.w	d3,d1					; MJ: load X position
		lsr.w	#7,d1					; MJ: shift to right side
		andi.w	#$007F,d1				; MJ: get within 7F
		add.w	d1,d0					; MJ: add calc'd Y to calc'd X
		moveq	#-1,d1					; MJ: prepare FFFF in d3
		movea.l	($FFFF8000).w,a1			; MJ: load address of Layout to a1
		move.b	(a1,d0.w),d1				; MJ: collect correct chunk ID based on the X and Y position
		andi.w	#$FF,d1					; MJ: keep within FF
		lsl.w	#$07,d1					; MJ: multiply by 80
		move.w	d2,d0					; MJ: load Y position
		andi.w	#$0070,d0				; MJ: keep Y within 80 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID
		move.w	d3,d0					; MJ: load X position
		lsr.w	#3,d0					; MJ: divide by 8
		andi.w	#$000E,d0				; MJ: keep X within 10 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID

loc_14996:
		movea.l	d1,a1					; MJ: set address (Chunk to read)
		rts						; MJ: return
; ===========================================================================

loc_1499A:
		andi.w	#$7F,d1
		btst	#6,1(a0)
		beq.s	loc_149B2
		addq.w	#1,d1
		cmpi.w	#$29,d1
		bne.s	loc_149B2
		move.w	#$51,d1

loc_149B2:
		ror.w	#7,d1
		ror.w	#2,d1
		move.w	d2,d0
		add.w	d0,d0
		andi.w	#$070,d0
		add.w	d0,d1
		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$0E,d0
		add.w	d0,d1
		movea.l	d1,a1
		rts

Floor_BGChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0					; MJ: load Y position
		add.w	($FFFFFE00),d0
		andi.w	#$0780,d0				; MJ: get within 780 (E00 pixels) in multiples of 80
		add.w	d0,d0					; MJ: multiply by 2
		move.w	d3,d1					; MJ: load X position
		lsr.w	#7,d1					; MJ: shift to right side
		andi.w	#$007F,d1				; MJ: get within 7F
		add.w	d1,d0					; MJ: add calc'd Y to calc'd X
		moveq	#-1,d1					; MJ: prepare FFFF in d3
		add.w	#$80,d0
		movea.l	($FFFF8000).w,a1			; MJ: load address of Layout to a1
		move.b	(a1,d0.w),d1				; MJ: collect correct chunk ID based on the X and Y position
		andi.w	#$FF,d1					; MJ: keep within FF
		lsl.w	#$07,d1					; MJ: multiply by 80
		move.w	d2,d0					; MJ: load Y position
		add.w	($FFFFFE00),d0
		andi.w	#$0070,d0				; MJ: keep Y within 80 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID
		move.w	d3,d0					; MJ: load X position
		lsr.w	#3,d0					; MJ: divide by 8
		andi.w	#$000E,d0				; MJ: keep X within 10 pixels
		add.w	d0,d1					; MJ: add to ror'd chunk ID

loc2_14996:
		movea.l	d1,a1					; MJ: set address (Chunk to read)
		rts						; MJ: return
; ===========================================================================

loc2_1499A:
		andi.w	#$7F,d1
		btst	#6,1(a0)
		beq.s	loc2_149B2
		addq.w	#1,d1
		cmpi.w	#$29,d1
		bne.s	loc2_149B2
		move.w	#$51,d1

loc2_149B2:
		ror.w	#7,d1
		ror.w	#2,d1
		move.w	d2,d0
		add.w	($FFFFFE00),d0
		add.w	d0,d0
		andi.w	#$070,d0
		add.w	d0,d1
		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$0E,d0
		add.w	d0,d1
		movea.l	d1,a1
		rts
; End of function Floor_ChkTile

FindFloor:
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_149DE
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE:
		tst.b	($FFFFFE07).w
		beq.s	loc_149DE2				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_149DE2
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE2:
		add.w	a3,d2
		bsr.w	FindFloor2
		sub.w	a3,d2
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_149EC:
		movea.l	($FFFFF796).w,a2			; MJ: load collision index address
		move.b	(a2,d0.w),d0				; MJ: load correct Collision ID based on the Block ID
		andi.w	#$FF,d0					; MJ: clear the left byte
		beq.s	loc_149DE				; MJ: if collision ID is 00, branch
		movea.l	($FFFFF78C).w,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: collect correct angle based on the collision ID
		lsl.w	#4,d0					; MJ: multiply collision ID by 10
		move.w	d3,d1					; MJ: load X position
		btst	#$A,d4					; MJ: is the block mirrored?
		beq.s	loc_14A12				; MJ: if not, branch
		not.w	d1					; MJ: reverse bits of the X position
		neg.b	(a4)					; MJ: reverse the angle ID

loc_14A12:
		btst	#$B,d4					; MJ: is the block flipped?
		beq.s	loc_14A22				; MJ: if not, branch
		addi.b	#$40,(a4)				; MJ: increase angle ID by 40..
		neg.b	(a4)					; MJ: ..reverse the angle ID..
		subi.b	#$40,(a4)				; MJ: ..and subtract 40 again 

loc_14A22:
		andi.w	#$F,d1					; MJ: get only within 10 (d1 is pixel based on the collision block)
		add.w	d0,d1					; MJ: add collision ID (x10) (d0 is the collision block being read)
		movea.l	($FFFFF784).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0				; MJ: load solid value
		ext.w	d0					; MJ: clear left byte
		eor.w	d6,d4					; MJ: set ceiling/wall bits
		btst	#$B,d4					; MJ: is sonic walking on the left wall?
		beq.s	loc_14A3E				; MJ: if not, branch
		neg.w	d0					; MJ: reverse solid value

loc_14A3E:
		tst.w	d0					; MJ: is the solid data null?
		beq.w	loc_149DE				; MJ: if so, branch
		bmi.s	loc_14A5A				; MJ: if it's negative, branch
		cmpi.b	#$10,d0					; MJ: is it 10?
		beq.s	loc_14A66				; MJ: if so, branch
		move.w	d2,d1					; MJ: load Y position
		andi.w	#$F,d1					; MJ: get only within 10 pixels
		add.w	d1,d0					; MJ: add to solid value
		move.w	#$F,d1					; MJ: set F
		sub.w	d0,d1					; MJ: minus solid value from F
		rts			; d1 = position?	; MJ: return

; ===========================================================================

loc_14A5A:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_149DE

loc_14A66:
		sub.w	a3,d2
		bsr.w	FindFloor2
		add.w	a3,d2
		subi.w	#$10,d1
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindFloor2:				; XREF: FindFloor
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14A86
		btst	d5,d4
		bne.s	loc_14A94

loc_14A86:
		tst.b	($FFFFFE07).w
		beq.s	loc_14A862				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14A862
		btst	d5,d4
		bne.s	loc_14A94

loc_14A862:
		move.w	#$F,d1
		move.w	d2,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14A94:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14A86
		movea.l	($FFFFF78C).w,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14ABA
		not.w	d1
		neg.b	(a4)

loc_14ABA:
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14ACA
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14ACA:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF784).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14AE6
		neg.w	d0

loc_14AE6:
		tst.w	d0
		beq.s	loc_14A86
		bmi.s	loc_14AFC
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14AFC:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14A86
		not.w	d1
		rts	

; End of function FindFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall:
		bsr.w	Floor_ChkTile				; MJ: get chunk/block location
		move.w	(a1),d0					; MJ: load block ID from chunk
		move.w	d0,d4					; MJ: copy to d4
		andi.w	#$3FF,d0				; MJ: clear flip/mirror/etc data
		beq.s	loc_14B1E				; MJ: if it was null, branch
		btst	d5,d4					; MJ: check solid set (C top solid | D Left/right solid)
		bne.s	loc_14B2C				; MJ: if the specific solid is set, branch

loc_14B1E:
		tst.b	($FFFFFE07).w
		beq.s	loc_14B1E2				; if so, branch
		bsr.w	Floor_BGChkTile				; MJ: get chunk/block location
		move.w	(a1),d0					; MJ: load block ID from chunk
		move.w	d0,d4					; MJ: copy to d4
		andi.w	#$3FF,d0				; MJ: clear flip/mirror/etc data
		beq.s	loc_14B1E2				; MJ: if it was null, branch
		btst	d5,d4					; MJ: check solid set (C top solid | D Left/right solid)
		bne.s	loc_14B2C				; MJ: if the specific solid is set, branch

loc_14B1E2:
		add.w	a3,d3					; MJ: add 10 to X position
		bsr.w	FindWall2
		sub.w	a3,d3					; MJ: minus 10 from X position
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_14B2C:
		movea.l	($FFFFF796).w,a2	; MJ: load address of collision for level
		move.b	(a2,d0.w),d0		; MJ: load correct colision ID based on the block ID
		andi.w	#$FF,d0					; MJ: keep within FF
		beq.s	loc_14B1E				; MJ: if it's null, branch
		movea.l	($FFFFF78C).w,a2				; MJ: load angle map data to a2
		move.b	(a2,d0.w),(a4)				; MJ: load angle set location based on collision ID
		lsl.w	#4,d0					; MJ: multiply by 10
		move.w	d2,d1					; MJ: load Y position
		btst	#$B,d4					; MJ: is the block ID flipped?
		beq.s	loc_14B5A				; MJ: if not, branch
		not.w	d1
		addi.b	#$40,(a4)				; MJ: increase angle set by 40
		neg.b	(a4)					; MJ: negate to opposite
		subi.b	#$40,(a4)				; MJ: decrease angle set by 40

loc_14B5A:
		btst	#$A,d4					; MJ: is the block ID mirrored?
		beq.s	loc_14B62				; MJ: if not, branch
		neg.b	(a4)					; MJ: negate to opposite

loc_14B62:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF788).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14B7E
		neg.w	d0

loc_14B7E:
		tst.w	d0
		beq.s	loc_14B1E
		bmi.s	loc_14B9A
		cmpi.b	#$10,d0
		beq.s	loc_14BA6
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14B9A:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14B1E

loc_14BA6:
		sub.w	a3,d3
		bsr.w	FindWall2
		add.w	a3,d3
		subi.w	#$10,d1
		rts	
; End of function FindWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall2:				; XREF: FindWall
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14BC6
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC6:
		tst.b	($FFFFFE07).w
		beq.s	loc_14BC62				; if so, branch
		bsr.w	Floor_BGChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_14BC62
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC62:
		move.w	#$F,d1
		move.w	d3,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14BD4:
		movea.l	($FFFFF796).w,a2	; MJ: load address of collision for level
		move.b	(a2,d0.w),d0		; MJ: load correct colision ID based on the block I
		andi.w	#$FF,d0
		beq.s	loc_14BC6
		movea.l	($FFFFF78C).w,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#$B,d4					; MJ: C to B (because S2 format has two solids)
		beq.s	loc_14C02
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14C02:
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C0A
		neg.b	(a4)

loc_14C0A:
		andi.w	#$F,d1
		add.w	d0,d1
		movea.l	($FFFFF788).l,a2			; MJ: load collision array
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$A,d4					; MJ: B to A (because S2 format has two solids)
		beq.s	loc_14C26
		neg.w	d0

loc_14C26:
		tst.w	d0
		beq.s	loc_14BC6
		bmi.s	loc_14C3C
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	

; ===========================================================================

loc_14C3C:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14BC6
		not.w	d1
		rts	
; End of function FindWall2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_WalkSpeed:			; XREF: Character_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc_14D1A
		move.b	d1,d0
		bpl.s	loc_14D14
		subq.b	#1,d0

loc_14D14:
		addi.b	#$20,d0
		bra.s	loc_14D24
; ===========================================================================

loc_14D1A:
		move.b	d1,d0
		bpl.s	loc_14D20
		addq.b	#1,d0

loc_14D20:
		addi.b	#$1F,d0

loc_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc_14D3C
		addq.w	#8,d2

loc_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Character_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Silver_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc2_14D1A
		move.b	d1,d0
		bpl.s	loc2_14D14
		subq.b	#1,d0

loc2_14D14:
		addi.b	#$20,d0
		bra.s	loc2_14D24
; ===========================================================================

loc2_14D1A:
		move.b	d1,d0
		bpl.s	loc2_14D20
		addq.b	#1,d0

loc2_14D20:
		addi.b	#$1F,d0

loc2_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc2_14D3C
		addq.w	#8,d2

loc2_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Silver_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Shadow_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc3_14D1A
		move.b	d1,d0
		bpl.s	loc3_14D14
		subq.b	#1,d0

loc3_14D14:
		addi.b	#$20,d0
		bra.s	loc3_14D24
; ===========================================================================

loc3_14D1A:
		move.b	d1,d0
		bpl.s	loc3_14D20
		addq.b	#1,d0

loc3_14D20:
		addi.b	#$1F,d0

loc3_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc3_14D3C
		addq.w	#8,d2

loc3_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Shadow_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Tails_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc4_14D1A
		move.b	d1,d0
		bpl.s	loc4_14D14
		subq.b	#1,d0

loc4_14D14:
		addi.b	#$20,d0
		bra.s	loc4_14D24
; ===========================================================================

loc4_14D1A:
		move.b	d1,d0
		bpl.s	loc4_14D20
		addq.b	#1,d0

loc4_14D20:
		addi.b	#$1F,d0

loc4_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc4_14D3C
		addq.w	#8,d2

loc4_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Shadow_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Knuckles_WalkSpeed:			; XREF: Silver_Move
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.l	8(a0),d3
		move.l	$C(a0),d2
		move.w	$10(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	$12(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc5_14D1A
		move.b	d1,d0
		bpl.s	loc5_14D14
		subq.b	#1,d0

loc5_14D14:
		addi.b	#$20,d0
		bra.s	loc5_14D24
; ===========================================================================

loc5_14D1A:
		move.b	d1,d0
		bpl.s	loc5_14D20
		addq.b	#1,d0

loc5_14D20:
		addi.b	#$1F,d0

loc5_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc4_14D3C
		addq.w	#8,d2

loc5_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Knuckles_WalkSpeed

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14D48:				; XREF: Character_Jump
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3F(a0),d5			; MJ: load L/R/B soldity bit
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		addi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_14FD6
		cmpi.b	#$80,d0
		beq.w	Character_DontRunOnWalls
		cmpi.b	#$C0,d0
		beq.w	sub_14E50

; End of function sub_14D48
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_HitFloor:				; XREF: Character_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

Character_HitFloor2:
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,$3E(a0)			; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:
		move.b	$3E(a0),d5			; MJ: load L/R/B soldity bit
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#0,d2

loc_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc_14DDE:
		btst	#0,d3
		beq.s	locret_14DE6
		move.b	d2,d3

locret_14DE6:
		rts	

; End of function Character_HitFloor

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14DF0:				; XREF: Character_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#0,d2

loc_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E16
		move.b	d2,d3

locret_14E16:
		rts	

; ---------------------------------------------------------------------------
; Subroutine allowing objects to interact with the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor:
		move.w	8(a0),d3

; End of function ObjHitFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor2:
		move.w	$C(a0),d2
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d2
		moveq	#$C,d5					; MJ: set solid type to check
		cmpi.b	#1,(a0)			; MJ: is the parent object Sonic?
		beq.s	ObjHitFloor2_Part2		; MJ: if not, branch and only use first collision set
		cmpi.b	#2,(a0)			; MJ: is the parent object Sonic?
		beq.s	ObjHitFloor2_Part2		; MJ: if not, branch and only use first collision set
		cmpi.b	#$8E,(a0)			; MJ: is the parent object Sonic?
		beq.s	ObjHitFloor2_Part2		; MJ: if not, branch and only use first collision set
		bra.s	ObjHitFloor2_Part3

ObjHitFloor2_Part2:
		move.b	$3E(a0),d5			; MJ: load solid type to check
		move.l	($FFFFFFD0).w,($FFFFF796).w		; MJ: load first collision data location
		cmpi.b	#$C,d5					; MJ: is second collision set to be used?
		beq.s	.first					; MJ: if not, branch
		move.l	($FFFFFFD4).w,($FFFFF796).w		; MJ: load second collision data location
.first:	
ObjHitFloor2_Part3:
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3		; height of a 16x16 tile
		move.w	#0,d6
		bsr.w	FindFloor		; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E4E
		move.b	#0,d3

	locret_14E4E:
		rts	
; End of function ObjHitFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14E50:				; XREF: sub_14D48
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$40,d2
		bra.w	loc_14DD0

; End of function sub_14E50


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14EB4:				; XREF: Character_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14EBC:
		addi.w	#$A,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#-$40,d2
		bra.w	loc_14E0A

; End of function sub_14EB4

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallRight:
		add.w	8(a0),d3
		move.w	$C(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14F06
		move.b	#-$40,d3

locret_14F06:
		rts	

; End of function ObjHitWallRight

; ---------------------------------------------------------------------------
; Subroutine preventing	Sonic from running on walls and	ceilings when he
; touches them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_DontRunOnWalls:			; XREF: Character_Floor; et al
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#-$80,d2
		bra.w	loc_14DD0
; End of function Character_DontRunOnWalls

; ===========================================================================
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_14F7C:
		subi.w	#$A,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	#-$80,d2
		bra.w	loc_14E0A

; ---------------------------------------------------------------------------
; This doesn't exist in S2...
; START	OF FUNCTION CHUNK FOR sub_315C22

loc_319208:					  ; ...
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		move.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall
		move.b	#$C0,d2
		bra.w	loc_14E0A
; END OF FUNCTION CHUNK	FOR sub_315C22

; =============== S U B	R O U T	I N E =======================================

; Doesn't exist in S2

sub_3192E6:					  ; ...
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eor.w	#$F,d2
		lea	($FFFFF768).w,a4
		move.w	#-$10,a3
		move.w	#$800,d6
		bsr.w	FindFloor
		move.b	#$80,d2

loc_319306:
		bra.w	loc_14E0A
; End of function sub_3192E6


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitCeiling:
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$0800,d6
		bsr.w	FindFloor				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14FD4
		move.b	#-$80,d3

locret_14FD4:
		rts	
; End of function ObjHitCeiling

; ===========================================================================

loc_14FD6:				; XREF: sub_14D48
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	d1,-(sp)
		move.w	$C(a0),d2
		move.w	8(a0),d3
		moveq	#0,d0
		move.b	$17(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	$16(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.w	(sp)+,d0
		move.b	#$40,d2
		bra.w	loc_14DD0

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Character_HitWall:				; XREF: Character_Floor
		move.w	$C(a0),d2
		move.w	8(a0),d3

loc_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	#$40,d2
		bra.w	loc_14E0A
; End of function Character_HitWall

; =============== S U B	R O U T	I N E =======================================


CheckLeftWallDist:				  ; ...
		move.w	$C(a0),d2
		move.w	8(a0),d3

CheckLeftWallDist_Part2:			  ; ...
		sub.w	#$A,d3
		eor.w	#$F,d3
		lea	($FFFFF768).w,a4
		move.w	#$FFF0,a3
		move.w	#$400,d6
		bsr.w	FindWall
		move.b	#$40,d2
		bra.w	loc_14E0A
; End of function CheckLeftWallDist

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR sub_315C22

loc_3193D2:					  ; ...
		move.b	$17(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eor.w	#$F,d3
		lea	($FFFFF768).w,a4
		move.w	#$FFF0,a3
		move.w	#$400,d6
		bsr.w	FindWall
		move.b	#$40,d2
		bra.w	loc_14E0A
; END OF FUNCTION CHUNK	FOR sub_315C22

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallLeft:
		add.w	8(a0),d3
		move.w	$C(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall				; MJ: check solidity
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_15098
		move.b	#$40,d3

locret_15098:
		rts	
; End of function ObjHitWallLeft

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 79 - lamppost
; ---------------------------------------------------------------------------

Obj79:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj79_Index(pc,d0.w),d1
		jmp	Obj79_Index(pc,d1.w)
; ===========================================================================
Obj79_Index:	dc.w Obj79_Main-Obj79_Index
		dc.w Obj79_BlueLamp-Obj79_Index
		dc.w Obj79_Animate-Obj79_Index
		dc.w Obj79_Twirl-Obj79_Index
		dc.w Obj79_Star-Obj79_Index
; ===========================================================================

Obj79_Main:				; XREF: Obj79_Index
		addq.b	#2,$24(a0)
		move.l	#Map_obj79,4(a0)
		make_art_tile	ArtTile_Lamp,0,1
		move.b	#4,1(a0)
		move.b	#8,$14(a0)
		move.w	#$280,$18(a0)
		move.w  $1E(a0),d0	; get address in respawn table
		movea.w d0,a2   ; load address into a2
		btst	#0,(a2)
		bne.s	Obj79_RedLamp
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	$28(a0),d2	; get lamppost number
		andi.b	#$7F,d2
		cmp.b	d2,d1		; is lamppost number higher than the number hit?
		blo.s	Obj79_BlueLamp	; if yes, branch

Obj79_RedLamp:
		bset	#0,(a2)
		move.b	#2,$1C(a0)
; ===========================================================================

Obj79_BlueLamp:				; XREF: Obj79_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret_16F90	; if yes, branch
		tst.b	($FFFFB02A).w
		bmi.w	locret_16F90
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	$28(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		bcs.s	Obj79_HitLamp
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)
		move.b	#4,$24(a0)
		move.b	#2,$1C(a0)

return_1F22E:
		bra.w	Obj79_Animate
; ===========================================================================

Obj79_HitLamp:
		move.w	($FFFFB008).w,d0
		sub.w	8(a0),d0
		addq.w	#8,d0
		cmpi.w	#$10,d0
		bcc.w	locret_16F90
		move.w	($FFFFB00C).w,d0
		sub.w	$C(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$68,d0
		bcc.s	locret_16F90
		sfx		sfx_Starpost ;	play lamppost sound
		addq.b	#2,$24(a0)
		jsr	SingleObjLoad
		bne.s	loc_16F76
		move.b	#$79,0(a1)	; load twirling	lamp object
		move.b	#6,$24(a1)	; use "Obj79_Twirl" routine
		move.w	8(a0),$30(a1)
		move.w	$C(a0),$32(a1)
		subi.w	#$14,$32(a1)
		move.l	4(a0),4(a1)
		move.w	2(a0),2(a1)
		move.b	#4,1(a1)
		move.b	#8,$14(a1)
		move.w	#$200,$18(a1)
		move.b	#2,$1A(a1)
		move.w	#$20,$36(a1)
		move.w	a0,$3E(a1)
		bsr.w	Obj79_MakeSpecialStars

loc_16F76:
		move.b	#1,$1C(a0)	; use "post only" frame, with no lamp
		bsr.w	Obj79_StoreInfo
		move.w	$1E(a0),d0
		movea.w	d0,a2	; load address into a2
		bset	#0,(a2)

locret_16F90:
		bra.w	Obj79_Animate
; ===========================================================================

Obj79_Animate:
		lea	(Ani_obj79).l,a1
		jsr	(AnimateSprite).l
		jmp	MarkObjGone
; ===========================================================================

Obj79_Twirl:				; XREF: Obj79_Index
		subq.w	#1,$36(a0)
		bpl.s	loc_16FA0
		movea.w	$3E(a0),a1
		cmpi.b	#$79,(a1) ; 'y'
		bne.s	loc_1F25C
		move.b	#2,$1C(a1)
		move.b	#0,$1A(a1)

loc_1F25C:				; CODE XREF: h+82DAj
		jmp	(DeleteObject).l
; ===========================================================================

loc_16FA0:
		move.b	$26(a0),d0
		subi.b	#$10,$26(a0)
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$C00,d1
		swap	d1
		add.w	$30(a0),d1
		move.w	d1,8(a0)
		muls.w	#$C00,d0
		swap	d0
		add.w	$32(a0),d0
		move.w	d0,$C(a0)
		jmp	(MarkObjGone).l
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	store information when you hit a lamppost
; ---------------------------------------------------------------------------

Obj79_StoreInfo:			; XREF: Obj79_HitLamp
		move.b	$28(a0),($FFFFFE30).w 		; lamppost number
		move.b	($FFFFFE30).w,($FFFFFE31).w
		move.w	8(a0),($FFFFFE32).w		; x-position
		move.w	$C(a0),($FFFFFE34).w		; y-position
		move.w	($FFFFFE20).w,($FFFFFE36).w 	; rings
		move.b	($FFFFB03E).w,($FFFFFE54).w 	; solid bits
		move.l	($FFFFFE22).w,($FFFFFE38).w 	; time
		move.b	($FFFFF742).w,($FFFFFE3C).w 	; routine counter for dynamic level mod
		move.w	($FFFFF72E).w,($FFFFFE3E).w 	; lower y-boundary of level
		move.w	($FFFFF700).w,($FFFFFE40).w 	; screen x-position
		move.w	($FFFFF704).w,($FFFFFE42).w 	; screen y-position
		move.w	($FFFFF708).w,($FFFFFE44).w 	; bg position
		move.w	($FFFFF70C).w,($FFFFFE46).w 	; bg position
		move.w	($FFFFF710).w,($FFFFFE48).w 	; bg position
		move.w	($FFFFF714).w,($FFFFFE4A).w 	; bg position
		move.w	($FFFFF718).w,($FFFFFE4C).w 	; bg position
		move.w	($FFFFF71C).w,($FFFFFE4E).w 	; bg position
		move.w	($FFFFF648).w,($FFFFFE50).w 	; water height
		move.b	($FFFFF64D).w,($FFFFFE52).w 	; rountine counter for water
		move.b	($FFFFF64E).w,($FFFFFE53).w 	; water direction
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load stored info when you start	a level	from a lamppost
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj79_LoadInfo:				; XREF: LevelSizeLoad
		move.b	($FFFFFE31).w,($FFFFFE30).w
		move.w	($FFFFFE32).w,($FFFFB008).w
		move.w	($FFFFFE34).w,($FFFFB00C).w
		move.w	($FFFFFE36).w,($FFFFFE20).w
		move.b	($FFFFFE54).w,($FFFFB03E).w 	; solid bits
		clr.w	($FFFFFE20).w
		clr.b	($FFFFFE1B).w
		move.l	($FFFFFE38).w,($FFFFFE22).w
		move.b	#59,($FFFFFE25).w
		subq.b	#1,($FFFFFE24).w
		move.b	($FFFFFE3C).w,($FFFFF742).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.w	($FFFFFE3E).w,($FFFFF72E).w
		move.w	($FFFFFE3E).w,($FFFFF726).w
		move.w	($FFFFFE40).w,($FFFFF700).w
		move.w	($FFFFFE42).w,($FFFFF704).w
		move.w	($FFFFFE44).w,($FFFFF708).w
		move.w	($FFFFFE46).w,($FFFFF70C).w
		move.w	($FFFFFE48).w,($FFFFF710).w
		move.w	($FFFFFE4A).w,($FFFFF714).w
		move.w	($FFFFFE4C).w,($FFFFF718).w
		move.w	($FFFFFE4E).w,($FFFFF71C).w
		tst.b	(Water_flag).w
		beq.s	loc_170E4
		move.w	($FFFFFE50).w,($FFFFF648).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.b	($FFFFFE53).w,($FFFFF64E).w

loc_170E4:
		tst.b	($FFFFFE30).w
		bpl.s	locret_170F6
		move.w	($FFFFFE32).w,d0
		subi.w	#$A0,d0
		move.w	d0,($FFFFF728).w

locret_170F6:
		rts	
; End of function Obj79_LoadInfo

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamppost
; ---------------------------------------------------------------------------
Map_obj79:
	include "_maps\obj79.asm"

Ani_obj79:
	include "_anim\obj79.asm"

Map_obj79stars:
	include "_maps\obj79stars.asm"
; ===========================================================================

Obj79_MakeSpecialStars:				; CODE XREF: h+828Ep
		moveq	#3,d1
		moveq	#0,d2

loc_1F4C8:				; CODE XREF: h+85BCj
		jsr	SingleObjLoad2
		bne.s	locret_1F534
		move.b	0(a0),0(a1)
		move.l	#Map_obj79stars,4(a1)
		move.w	2(a0),2(a1)
		move.b	#4,1(a1)
		move.b	#8,$24(a1)
		move.w	8(a0),d0
		move.w	d0,8(a1)
		move.w	d0,$30(a1)
		move.w	$C(a0),d0
		subi.w	#$30,d0	; '0'
		move.w	d0,$C(a1)
		move.w	d0,$32(a1)
		move.w	$18(a0),$18(a1)
		move.b	#8,$14(a1)
		move.b	#1,$1A(a1)
		move.w	#-$400,$10(a1)
		move.w	#0,$12(a1)
		move.w	d2,$34(a1)
		addi.w	#$40,d2	; '.'
		dbf	d1,loc_1F4C8

locret_1F534:				; CODE XREF: h+8558j
		rts	
; ===========================================================================

Obj79_Star:				; DATA XREF: h+814Eo
		move.b	$21(a0),d0
		beq.w	loc_1F554
		andi.b	#1,d0
		beq.s	loc_1F550
		move.b	#$10,($FFFFF600).w

loc_1F550:				; CODE XREF: h+85CEj
		clr.b	$21(a0)

loc_1F554:				; CODE XREF: h+85C6j
		addi.w	#$A,$34(a0)
		move.w	$34(a0),d0
		andi.w	#$FF,d0
		jsr	(CalcSine).l
		asr.w	#5,d0
		asr.w	#3,d1
		move.w	d1,d3
		move.w	$34(a0),d2
		andi.w	#$3E0,d2
		lsr.w	#5,d2
		moveq	#2,d5
		moveq	#0,d4
		cmpi.w	#$10,d2
		ble.s	loc_1F584
		neg.w	d1

loc_1F584:				; CODE XREF: h+860Cj
		andi.w	#$F,d2
		cmpi.w	#8,d2
		ble.s	loc_1F594
		neg.w	d2
		andi.w	#7,d2

loc_1F594:				; CODE XREF: h+8618j h+8628j
		lsr.w	#1,d2
		beq.s	loc_1F59A
		add.w	d1,d4

loc_1F59A:				; CODE XREF: h+8622j
		asl.w	#1,d1
		dbf	d5,loc_1F594
		asr.w	#4,d4
		add.w	d4,d0
		addq.w	#1,$36(a0)
		move.w	$36(a0),d1
		cmpi.w	#$80,d1	; 'โฌ'
		beq.s	loc_1F5BE
		bgt.s	loc_1F5C4

loc_1F5B4:				; CODE XREF: h+8660j
		muls.w	d1,d0
		muls.w	d1,d3
		asr.w	#7,d0
		asr.w	#7,d3
		bra.s	loc_1F5D6
; ===========================================================================

loc_1F5BE:				; CODE XREF: h+863Cj
		move.b	#$D8,$20(a0)

loc_1F5C4:				; CODE XREF: h+863Ej
		cmpi.w	#$180,d1
		ble.s	loc_1F5D6
		neg.w	d1
		addi.w	#$200,d1
		bpl.s	loc_1F5B4
		jmp	DeleteObject
; ===========================================================================

loc_1F5D6:				; CODE XREF: h+8648j h+8654j
		move.w	$30(a0),d2
		add.w	d3,d2
		move.w	d2,8(a0)
		move.w	$32(a0),d2
		add.w	d0,d2
		move.w	d2,$C(a0)
		addq.b	#1,$1B(a0)
		move.b	$1B(a0),d0
		andi.w	#6,d0
		lsr.w	#1,d0
		cmpi.b	#3,d0
		bne.s	loc_1F600
		moveq	#1,d0

loc_1F600:				; CODE XREF: h+8688j
		move.b	d0,$1A(a0)

loc_1F604:
		jmp	MarkObjGone

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8A - "SONIC TEAM PRESENTS" and	credits
; ---------------------------------------------------------------------------

Obj8A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj8A_Index(pc,d0.w),d1
		jmp	Obj8A_Index(pc,d1.w)
; ===========================================================================
Obj8A_Index:	dc.w Obj8A_Main-Obj8A_Index
		dc.w Obj8A_Display-Obj8A_Index
; ===========================================================================

Obj8A_Main:				; XREF: Obj8A_Index
		addq.b	#2,$24(a0)
		move.w	#$120,8(a0)
		move.w	#$F0,$A(a0)
		move.l	#Map_obj8A,4(a0)
		move.w	#$5A0,2(a0)
		move.w	($FFFFFFF4).w,d0 ; load	credits	index number
		move.b	d0,$1A(a0)	; display appropriate sprite
		move.b	#0,1(a0)
		move.w	#0,$18(a0)
		cmpi.b	#4,($FFFFF600).w ; is the scene	number 04 (title screen)?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$A6,2(a0)
		move.b	#$A,$1A(a0)	; display "SONIC TEAM PRESENTS"
		tst.b	($FFFFFFE3).w	; is hidden credits cheat on?
		beq.s	Obj8A_Display	; if not, branch
		cmpi.b	#$72,($FFFFF604).w ; is	Start+A+C+Down being pressed?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$EEE,($FFFFFBC0).w ; 3rd pallet, 1st entry = white
		move.w	#$880,($FFFFFBC2).w ; 3rd pallet, 2nd entry = cyan
		jmp	DeleteObject
; ===========================================================================

Obj8A_Display:				; XREF: Obj8A_Index
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - "SONIC TEAM	PRESENTS" and credits
; ---------------------------------------------------------------------------
Map_obj8A:
	include "_maps\obj8A.asm"

; ---------------------------------------------------------------------------
; Defeated boss	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossDefeated:
		move.b	($FFFFFE0F).w,d0
		andi.b	#7,d0
		bne.s	locret_178A2
		jsr	SingleObjLoad
		bne.s	locret_178A2
		move.b	#$3F,0(a1)	; load explosion object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,8(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,$C(a1)

locret_178A2:
	;	cmpi.w	#$502,($FFFFFE10).w ; is level FZ (FFZ3) ?
	;	beq.s locret_178A2  ; if yes, branch
	;	clr.b	($FFFFFE1E).w	; stop time counter
		rts	
; End of function BossDefeated

; ---------------------------------------------------------------------------
; Subroutine to	move a boss
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossMove:
		move.l	$30(a0),d2
		move.l	$38(a0),d3
		move.w	$10(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	$12(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$30(a0)
		move.l	d3,$38(a0)
		rts	
; End of function BossMove

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3E - prison capsule
; ---------------------------------------------------------------------------

Obj3E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj3E_Index(pc,d0.w),d1
		jsr	Obj3E_Index(pc,d1.w)
		move.w	8(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bls.s	Obj3E_Done
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	Obj3E_Delete	; if it's zero, object was placed in debug mode
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn entry, so object can be loaded again
		bra.s	Obj3E_Delete

Obj3E_Done:
		jmp	DisplaySprite
; ===========================================================================

Obj3E_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj3E_Index:	dc.w Obj3E_Main-Obj3E_Index
		dc.w Obj3E_BodyMain-Obj3E_Index
		dc.w Obj3E_Switched-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_MakeAnimal-Obj3E_Index
		dc.w Obj3E_Animals-Obj3E_Index
		dc.w Obj3E_EndAct-Obj3E_Index

Obj3E_Var:	dc.b 2,	$20, 6,	0	; routine, width, priority, frame
		dc.b 4,	$C, 5, 6
; ===========================================================================

Obj3E_Main:				; XREF: Obj3E_Index
		move.l	#Map_obj3E,4(a0)
		move.w	#$39D,2(a0)
		move.b	#4,1(a0)
		move.w	$C(a0),$30(a0)
		moveq	#0,d0
		move.b	$28(a0),d0
		lsl.w	#2,d0
		lea	Obj3E_Var(pc,d0.w),a1
		move.b	(a1)+,$24(a0)
		move.b	(a1)+,$14(a0)
		move.b	(a1)+,$18(a0)
		move.w 	$18(a0),d1
		lsr.w 	#1,d1
		andi.w 	#$380,d1
		move.w 	d1,$18(a0)
		move.b	(a1)+,$1A(a0)
		cmpi.w	#8,d0		; is object type number	02?
		bne.s	Obj3E_Not02	; if not, branch
		move.b	#6,$20(a0)
		move.b	#8,$21(a0)
		rts

Obj3E_Not02:
		tst.b	$28(a0)
		bne.s	Obj3E_Return
		moveq	#0,d2
		move.w	$C(a0),d2
		subi.w	#$28,d2
		jsr	SingleObjLoad
		bne.s	Obj3E_Return
		move.b	#$3E,0(a1)	; load button object
		move.b	#1,$28(a1)
		move.w	8(a0),8(a1)
		move.w	d2,$C(a1)
		moveq	#$11,d0
		jmp	LoadPLC	; load signpost	patterns

Obj3E_Return:
		rts	
; ===========================================================================

Obj3E_BodyMain:				; XREF: Obj3E_Index
		cmpi.b	#2,($FFFFF7A7).w
		beq.s	Obj3E_ChkOpened
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	8(a0),d4
		jmp	SolidObject
; ===========================================================================

Obj3E_ChkOpened:
		tst.b	$25(a0)		; has the prison been opened?
		beq.s	Obj3E_DoOpen	; if yes, branch
		clr.b	$25(a0)
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

Obj3E_DoOpen:
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	8(a0),d4
		lea	(Ani_obj3E).l,a1
		jsr	AnimateSprite
		jmp	SolidObject
; ===========================================================================

Obj3E_Switched:				; XREF: Obj3E_Index
		move.w	#$17,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	8(a0),d4
		jsr	SolidObject
		move.w	$30(a0),$C(a0)
		tst.b	$25(a0)
		beq.s	locret_1AC60
		addq.w	#8,$C(a0)
		move.b	#$A,$24(a0)
		clr.b	($FFFFFE1E).w	; stop time counter
		clr.b	($FFFFF7AA).w	; lock screen position
		sfx		sfx_Switch

locret_1AC60:
		rts	
; ===========================================================================

Obj3E_MakeAnimal:
		move.b	#2,($FFFFF7A7).w
		move.b	#$C,$24(a0)	; replace explosions with animals
		move.w	#$96,$32(a0)
		moveq	#7,d6
		move.w	#$9A,d5
		moveq	#-$1C,d4

Obj3E_Loop:
		jsr	SingleObjLoad
		bne.s	locret_1ACF8
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		add.w	d4,8(a1)
		addq.w	#7,d4
		move.w	d5,$36(a1)
		subq.w	#8,d5
		dbf	d6,Obj3E_Loop	; repeat 7 more	times

locret_1ACF8:
		rts	
; ===========================================================================

Obj3E_Animals:				; XREF: Obj3E_Index
		moveq	#7,d0
		and.b	($FFFFFE0F).w,d0
		bne.s	loc_1AD38
		jsr	SingleObjLoad
		bne.s	loc_1AD38
		move.b	#$28,0(a1)	; load animal object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		addi.w	#$1C,$C(a1)
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		subq.w	#6,d0
		tst.w	d1
		bpl.s	loc_1AD2E
		neg.w	d0

loc_1AD2E:
		add.w	d0,8(a1)
		move.w	#$C,$36(a1)

loc_1AD38:
		subq.w	#1,$32(a0)
		bne.s	locret_1AD48
		addq.b	#2,$24(a0)
		move.w	#180,$32(a0)

locret_1AD48:
		rts	
; ===========================================================================

Obj3E_EndAct:				; XREF: Obj3E_Index
		moveq	#$3E,d0
		moveq	#$28,d1
		moveq	#$40,d2
		lea	($FFFFB040).w,a1 ; load	object RAM

Obj3E_FindObj28:
		cmp.b	(a1),d1		; is object $28	(animal) loaded?
		beq.s	Obj3E_Obj28Found ; if yes, branch
		adda.w	d2,a1		; next object RAM
		dbf	d0,Obj3E_FindObj28 ; repeat $3E	times
	;	tst.w	($FFFFFE08).w	; is debug mode	on?
	;	bne.s	Obj3E_Obj28Found	; if yes, branch
	;	btst	#1,($FFFFB022).w	; is Sonic's in-air flag set?
	;	bne.s 	Obj3E_Obj28Found
		jsr	GotThroughAct
		jmp	DeleteObject
; ===========================================================================

Obj3E_Obj28Found:
		rts	
; ===========================================================================
Ani_obj3E:
	include "_anim\obj3E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - prison capsule
; ---------------------------------------------------------------------------
Map_obj3E:
	include "_maps\obj3E.asm"
	even

; ---------------------------------------------------------------------------
; Object touch response	subroutine - $20(a0) in	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TouchResponse:				; XREF: Obj01
		nop
		jsr	(Touch_Rings).l
		move.w	8(a0),d2	; load Sonic's x-axis value
		move.w	$C(a0),d3	; load Sonic's y-axis value
		moveq	#0,d5
		move.b	$16(a0),d5	; load Sonic's height
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$39,$1A(a0)	; is Sonic ducking?
		bne.s	Touch_NoDuck	; if not, branch
		addi.w	#$C,d3
		moveq	#$A,d5

Touch_NoDuck:
		moveq	#0,d4
		move.b	$17(a0),d4	; load Sonic's height
		addq.b	#1,d4
		sub.w	d4,d2
		add.w	d5,d5
		add.w	d4,d4
		lea	($FFFFB800).w,a1 ; begin checking the object RAM
		move.w	#$5F,d6

Touch_Loop:
		tst.b	1(a1)
		bpl.s	Touch_NextObj
		move.b	$20(a1),d0	; load touch response number
		bne.s	Touch_Height	; if touch response is not 0, branch

Touch_NextObj:
		lea	$40(a1),a1	; next object RAM
		dbf	d6,Touch_Loop	; repeat $5F more times

		moveq	#0,d0
		rts	
; ===========================================================================
Touch_Sizes:	dc.b   4,  4		; width, height
		dc.b  $14, $14
		dc.b   $C, $14
		dc.b  $14,  $C
		dc.b	4, $10
		dc.b   $C, $12
		dc.b  $10, $10
		dc.b	6,   6
		dc.b  $18,  $C
		dc.b   $C, $10
		dc.b  $10,  $C
		dc.b	8,   8
		dc.b  $14, $10
		dc.b  $14,   8
		dc.b   $E,  $E
		dc.b  $18, $18
		dc.b  $28, $10
		dc.b  $10, $18
		dc.b	8, $10
		dc.b  $20, $70
		dc.b  $40, $20
		dc.b  $80, $20
		dc.b  $20, $20
		dc.b	8,   8
		dc.b	4,   4
		dc.b  $20,   8
		dc.b   $C,  $C
		dc.b	8,   4
		dc.b  $18,   4
		dc.b  $28,   4
		dc.b	4,   8
		dc.b	4, $18
		dc.b	4, $28
		dc.b	4, $20
		dc.b  $18, $18
		dc.b   $C, $18
		dc.b  $48,   8
; ===========================================================================

Touch_Height:				; XREF: TouchResponse
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Touch_Sizes(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	8(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_1AE98
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	Touch_Width
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AE98:
		cmp.w	d4,d0
		bhi.w	Touch_NextObj

Touch_Width:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	$C(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_1AEB6
		add.w	d1,d1
		add.w	d0,d1
		bcs.s	Touch_ChkValue
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AEB6:
		cmp.w	d5,d0
		bhi.w	Touch_NextObj

Touch_ChkValue:
		move.b	$20(a1),d1	; load touch response number
		andi.b	#$C0,d1		; is touch response $40	or higher?
		beq.w	Touch_Enemy	; if not, branch
		cmpi.b	#$C0,d1		; is touch response $C0	or higher?
		beq.w	Touch_Special	; if yes, branch
		tst.b	d1		; is touch response $80-$BF ?
		bmi.w	Touch_ChkHurt	; if yes, branch

; touch	response is $40-$7F

		move.b	$20(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0		; is touch response $46	?
		beq.s	Touch_Monitor	; if yes, branch
		cmpi.w	#$5A,$30(a0)
		bcc.w	locret_1AEF2
	;	cmpi.b	#$12,d0		; is STouch response $46	?
	;	bne.s	Touch_SSRing	; if yes, branch
	;	btst	#7,$22(a0)
	;	bne.s	locret_1AEF2

Touch_SSRing:
		addq.b	#2,$24(a1)	; advance the object's routine counter

locret_1AEF2:
		rts	
; ===========================================================================

Touch_Monitor:
		btst	#7,$22(a0)
		beq.s	Touch_MonitorControl
		btst	#7,($FFFFB02B).w
		bne.s	Touch_MonitorControl
		tst.w	($FFFFF672).w
		beq.s	locret_1AEF2

Touch_MonitorControl:
		tst.w	$12(a0)		; is Sonic moving upwards?
		bpl.s	loc_1AF1E	; if not, branch
		move.w	$C(a0),d0
		subi.w	#$10,d0
		cmp.w	$C(a1),d0
		bcs.s	locret_1AF2E
		neg.w	$12(a0)		; reverse Sonic's y-motion
		move.w	#-$180,$12(a1)
		tst.b	$25(a1)
		bne.s	locret_1AF2E
		addq.b	#4,$25(a1)	; advance the monitor's routine counter
		rts	
; ===========================================================================

loc_1AF1E:
		cmpi.b	#7,0(a0)
		beq.s	loc_1AF20
		cmpi.b	#$B,0(a0)
		beq.s	loc_1AF20
		cmpi.b	#$96,0(a0)
		beq.s	loc_1AF20
		cmpi.b	#2,$1C(a0)	; is Sonic rolling/jumping?
		bne.s	locret_1AF2E
		neg.w	$12(a0)		; reverse Sonic's y-motion

loc_1AF20:
		addq.b	#2,$24(a1)	; advance the monitor's routine counter

locret_1AF2E:
		rts	
; ===========================================================================

Touch_Enemy:				; XREF: Touch_ChkValue
		cmpi.b	#$99,0(a0)
		bne.s	Touch_NotKnuckles
		cmp.b	#1,$21(a0)
		beq.s	loc_1AF40
		cmp.b	#3,$21(a0)
		beq.s	loc_1AF40

Touch_NotKnuckles:
		cmpi.b	#$96,0(a0)
		beq.s	loc_1AF40
		cmpi.b	#7,0(a0)
		beq.s	loc_1AF40
		cmpi.b	#$B,0(a0)
		beq.s	loc_1AF40
		btst	#1,($FFFFFE2C).w	; is Sonic invincible?
		bne.s	loc_1AF40	; if yes, branch
		cmpi.b	#2,$1C(a0)	; is Sonic rolling?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#9,$1C(a0)	; is Sonic Spin Dashing?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$B,$1C(a0)	; is Sonic somersaulting?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$C,$1C(a0)	; is Sonic falling?
		bne.w	Touch_ChkHurt	; if not, branch
		cmpi.b	#$1F,$1C(a0)	; is Sonic dropdashing?
		bne.w	Touch_ChkHurt	; if not, branch

loc_1AF40:
		tst.b	$21(a1)
		beq.s	Touch_KillEnemy
		cmpi.b	#$99,0(a0)
		bne.s	Touch_NotKnuckles2
		cmp.b	#1,$2B(a0)
		bne.s	Touch_NotKnuckles2
		move.b	#2,$2B(a0)
		move.b	#$C,$1C(a0)

Touch_NotKnuckles2:
		neg.w	$10(a0)
		neg.w	$12(a0)
		asr	$10(a0)
		asr	$12(a0)
		move.b	#0,$20(a1)
		subq.b	#1,$21(a1)
		bne.s	locret_1AF68
		bset	#7,$22(a1)

locret_1AF68:
		rts	
; ===========================================================================

Touch_KillEnemy:
		bset	#7,$22(a1)
		move.b	#$27,0(a1)	; change object	to points
		move.b	#0,$24(a1)
		cmpi.b	#7,0(a0)
		beq.s	Touch_DeleteSpear
		cmpi.b	#$B,0(a0)
		beq.s	Touch_DeleteSpear
		tst.w	$12(a0)
		bmi.s	loc_1AFC2
		move.w	$C(a0),d0
		cmp.w	$C(a1),d0
		bcc.s	loc_1AFCA
		neg.w	$12(a0)
		rts	
; ===========================================================================

loc_1AFC2:
		addi.w	#$100,$12(a0)
		rts	
; ===========================================================================

loc_1AFCA:
		subi.w	#$100,$12(a0)
		rts	
; ===========================================================================

loc_1AFDA:				; XREF: Touch_CatKiller
		bset	#7,$22(a1)

Touch_ChkHurt:				; XREF: Touch_ChkValue
		cmpi.b	#$96,0(a0)
		beq.s	Touch_ChkHurt_Return
		cmpi.b	#7,0(a0)
		beq.s	Touch_Destroy
		cmpi.b	#$B,0(a0)
		beq.s	Touch_Destroy
		move.b	($FFFFFE2C).w,d0
		andi.b	#$73,d0					; Does player have any shields or is invincible?
		beq.s	Touch_ChkHurt_NoPowerUp			; If not, branch
		and.b	$2B(a1),d0			; Does one of the player's shields grant immunity to this object??
		bne.s	Touch_ChkHurt_Return			; If so, branch
		btst	#0,($FFFFFE2C).w	; Does the player have a shield (strange time to ask)
		bne.s	Touch_ChkHurt_HaveShield		; If so, branch

Touch_ChkHurt2:
		btst	#1,($FFFFFE2C).w	; Is player invincible?
		beq.s	Touch_Hurt				; If not, branch

Touch_ChkHurt_Return:
		moveq	#-1,d0
		rts

Touch_DeleteSpear:
		jmp	(DeleteObject).l

Touch_Destroy:
		bset	#7,$22(a0)
		move.b	#$27,0(a0)	; change object	to points
		move.b	#0,$24(a0)
		rts
; ===========================================================================

Touch_ChkHurt_NoPowerUp:
		; Note that this check could apply to the Insta-Shield,
		; but the check that branches to this requires the player not be invincible.
		; The Insta-Shield grants temporary invincibility. See the problem?
		cmpi.b	#1,$29(a0)			; Is player Insta-Shield-attacking (Sonic), flying (Tails) or gliding (Knuckles)?
		bne.s	Touch_ChkHurt2				; If not, branch

Touch_ChkHurt_HaveShield:
		move.b	$2B(a1),d0
		andi.b	#8,d0					; Should the object be bounced away by a shield?
		beq.s	Touch_ChkHurt2				; If not, branch

Touch_ChkHurt_Bounce_Projectile:
		move.w	8(a0),d1
		move.w	$C(a0),d2
		sub.w	8(a1),d1
		sub.w	$C(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$800,d1
		asr.l	#8,d1
		move.w	d1,$10(a1)
		muls.w	#-$800,d0
		asr.l	#8,d0
		move.w	d0,$12(a1)
		clr.b	$20(a1)
		bra.s	Touch_ChkHurt_Return

Touch_Hurt:				; XREF: Touch_ChkHurt
		nop	
		tst.w	$30(a0)
		bne.s	Touch_ChkHurt_Return
		movea.l	a1,a2

; End of function TouchResponse
; continue straight to HurtSonic

; ---------------------------------------------------------------------------
; Hurting Sonic	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HurtSonic:
		btst	#7,$22(a0)
		bne.s	Hurt_2p
		btst	#0,($FFFFFE2C).w	; does Sonic have a shield?
		bne.s	Hurt_Shield	; if yes, branch
		tst.w	($FFFFFE20).w	; does Sonic have any rings?
		beq.w	Hurt_NoRings	; if not, branch
		jsr	SingleObjLoad
		bne.s	Hurt_Shield
		move.b	#$37,0(a1)	; load bouncing	multi rings object
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)

Hurt_Shield:
		andi.b	#$8E,($FFFFFE2C).w

Hurt_2P:
		move.b	#4,$24(a0)
		jsr	Player_ResetOnFloor
		bset	#1,$22(a0)
		move.w	#-$400,$12(a0)	; make Sonic bounce away from the object
		move.w	#-$200,$10(a0)
		btst	#6,$22(a0)
		beq.s	Hurt_Reverse
		move.w	#-$200,$12(a0)
		move.w	#-$100,$10(a0)

Hurt_Reverse:
		move.w	8(a0),d0
		cmp.w	8(a2),d0
		bcs.s	Hurt_ChkSpikes	; if Sonic is left of the object, branch
		neg.w	$10(a0)		; if Sonic is right of the object, reverse

Hurt_ChkSpikes:
		move.b	#0,$39(a0)	; clear Spin Dash flag
		move.w	#0,$20(a0)
		move.b	#$1A,$1C(a0)
		move.w	#$78,$30(a0)
		cmpi.b	#$36,(a2)	; was damage caused by spikes?
		beq.s	Hurt_SetSpikeSound	; if not, branch
		cmpi.b	#$16,(a2)	; was damage caused by EEZ harpoon?
		bne.s	Hurt_Sound	; if not, branch

Hurt_SetSpikeSound:
		sfx		sfx_SpikeHit		; load spikes damage sound
		moveq	#-1,d0
		rts	

Hurt_Sound:
		sfx		sfx_RingLoss		; load normal damage sound
		moveq	#-1,d0
		rts	
; ===========================================================================

Hurt_NoRings:
		tst.w	($FFFFFFFA).w	; is debug mode	cheat on?
		bne.w	Hurt_Shield	; if yes, branch
; End of function HurtSonic

; ---------------------------------------------------------------------------
; Subroutine to	kill Sonic
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


KillSonic:
		tst.w	($FFFFFE08).w	; is debug mode	active?
		bne.s	Kill_NoDeath	; if yes, branch
		btst	#7,$22(a0)
		bne.s	Kill_NoDeath
		move.w	#0,($FFFFFE20).w ; clear rings
		clr.b	($FFFFFE2C).w
		move.b	#6,$24(a0)
		jsr	Player_ResetOnFloor
		bset	#1,$22(a0)
		move.w	#-$700,$12(a0)
		move.w	#0,$10(a0)
		move.w	#0,$20(a0)
		move.b	#$18,$1C(a0)
		bset	#7,2(a0)
		move.w	#$35,d0		; play normal death sound
		cmpi.b	#$36,(a2)	; check	if you were killed by spikes
		bne.s	Kill_Sound
		move.w	#$37,d0		; play spikes death sound

Kill_Sound:
		sfx		sfx_Death

Kill_NoDeath:
		moveq	#-1,d0
		rts	
; End of function KillSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Touch_Special:				; XREF: Touch_ChkValue
		move.b	$20(a1),d1
		andi.b	#$3F,d1
		cmpi.b	#$B,d1		; is touch response $CB	?
		beq.s	Touch_CatKiller	; if yes, branch
		cmpi.b	#$C,d1		; is touch response $CC	?
		beq.s	Touch_Yadrin	; if yes, branch
		cmpi.b	#$17,d1		; is touch response $D7	?
		beq.s	Touch_D7orE1	; if yes, branch
		cmpi.b	#$18,d1
		beq.s	Touch_Stars
		cmpi.b	#$21,d1		; is touch response $E1	?
		beq.s	Touch_D7orE1	; if yes, branch
		rts	
; ===========================================================================

Touch_CatKiller:			; XREF: Touch_Special
		bra.w	loc_1AFDA
; ===========================================================================

Touch_Yadrin:				; XREF: Touch_Special
		sub.w	d0,d5
		cmpi.w	#8,d5
		bcc.s	loc_1B144
		move.w	8(a1),d0
		subq.w	#4,d0
		btst	#0,$22(a1)
		beq.s	loc_1B130
		subi.w	#$10,d0

loc_1B130:
		sub.w	d2,d0
		bcc.s	loc_1B13C
		addi.w	#$18,d0
		bcs.s	loc_1B140
		bra.s	loc_1B144
; ===========================================================================

loc_1B13C:
		cmp.w	d4,d0
		bhi.s	loc_1B144

loc_1B140:
		bra.w	Touch_ChkHurt
; ===========================================================================

loc_1B144:
		bra.w	Touch_Enemy
; ===========================================================================

Touch_D7orE1:				; XREF: Touch_Special
		addq.b	#1,$21(a1)
		rts	

Touch_Stars:
	move.w	a0,d1
	subi.w	#$FFFFB000,d1
	beq.s	Touch_Stars2
	addq.b	#1,$21(a1)

Touch_Stars2:
	addq.b	#1,$21(a1)
	rts
; End of function Touch_Special

; ---------------------------------------------------------------------------
; Subroutine to	show the special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_ShowLayout:				; XREF: SpecialStage
		bsr.w	BS_AniWallsRings
		bsr.w	BS_AniItems
		move.w	d5,-(sp)
		lea	($FFFF8000).w,a1
		move.b	($FFFFF780).w,d0
		jsr	(CalcSine).l
		move.w	d0,d4
		move.w	d1,d5
		muls.w	#$18,d4
		muls.w	#$18,d5
		moveq	#0,d2
		move.w	($FFFFF700).w,d2
		divu.w	#$18,d2
		swap	d2
		neg.w	d2
		addi.w	#-$B4,d2
		moveq	#0,d3
		move.w	($FFFFF704).w,d3
		divu.w	#$18,d3
		swap	d3
		neg.w	d3
		addi.w	#-$B4,d3
		move.w	#$F,d7

loc_1B19E:
		movem.w	d0-d2,-(sp)
		movem.w	d0-d1,-(sp)
		neg.w	d0
		muls.w	d2,d1
		muls.w	d3,d0
		move.l	d0,d6
		add.l	d1,d6
		movem.w	(sp)+,d0-d1
		muls.w	d2,d0
		muls.w	d3,d1
		add.l	d0,d1
		move.l	d6,d2
		move.w	#$F,d6

loc_1B1C0:
		move.l	d2,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		move.l	d1,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		add.l	d5,d2
		add.l	d4,d1
		dbf	d6,loc_1B1C0

		movem.w	(sp)+,d0-d2
		addi.w	#$18,d3
		dbf	d7,loc_1B19E

		move.w	(sp)+,d5
		lea	($FF0000).l,a0
		moveq	#0,d0
		move.w	($FFFFF704).w,d0
		divu.w	#$18,d0
		mulu.w	#$80,d0
		adda.l	d0,a0
		moveq	#0,d0
		move.w	($FFFFF700).w,d0
		divu.w	#$18,d0
		adda.w	d0,a0
		lea	($FFFF8000).w,a4
		move.w	#$F,d7

loc_1B20C:
		move.w	#$F,d6

loc_1B210:
		moveq	#0,d0
		move.b	(a0)+,d0
		beq.s	loc_1B268
		cmpi.b	#$4E,d0
		bhi.s	loc_1B268
		move.w	(a4),d3
		addi.w	#$120,d3
		cmpi.w	#$70,d3
		bcs.s	loc_1B268
		cmpi.w	#$1D0,d3
		bcc.s	loc_1B268
		move.w	2(a4),d2
		addi.w	#$F0,d2
		cmpi.w	#$70,d2
		bcs.s	loc_1B268
		cmpi.w	#$170,d2
		bcc.s	loc_1B268
		lea	($FF4000).l,a5
		lsl.w	#3,d0
		lea	(a5,d0.w),a5
		movea.l	(a5)+,a1
		move.w	(a5)+,d1
		add.w	d1,d1
		adda.w	(a1,d1.w),a1
		movea.w	(a5)+,a3
		moveq	#0,d1
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_1B268
		jsr	sub_D762

loc_1B268:
		addq.w	#4,a4
		dbf	d6,loc_1B210

		lea	$70(a0),a0
		dbf	d7,loc_1B20C

		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_1B288
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_1B288:
		move.b	#0,-5(a2)
		rts	
; End of function BS_ShowLayout

; ---------------------------------------------------------------------------
; Subroutine to	animate	walls and rings	in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_AniWallsRings:			; XREF: BS_ShowLayout
		lea	($FF4005).l,a1
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_1B2C8
		move.b	#3,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#7,($FFFFFEC3).w

loc_1B2C8:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_1B2E4
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		andi.b	#1,($FFFFFEC5).w

loc_1B2E4:
		move.b	($FFFFFEC5).w,d0
		move.b	d0,$138(a1)
		move.b	d0,$148(a1)
		move.b	d0,$150(a1)
		move.b	d0,$1D8(a1)
		move.b	d0,$1E0(a1)
		move.b	d0,$1E8(a1)
		move.b	d0,$1F0(a1)
		move.b	d0,$1F8(a1)
		move.b	d0,$200(a1)
		subq.b	#1,($FFFFFEC6).w
		bpl.s	loc_1B326
		move.b	#4,($FFFFFEC6).w
		addq.b	#1,($FFFFFEC7).w
		andi.b	#3,($FFFFFEC7).w

loc_1B326:
		move.b	($FFFFFEC7).w,d0
		move.b	d0,$160(a1)
		move.b	d0,$168(a1)
		move.b	d0,$170(a1)
		move.b	d0,$178(a1)
		move.b	d0,$180(a1)
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_1B350
		move.b	#7,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_1B350:
		lea	($FF4016).l,a1
		lea	(BS_WaRiVramSet).l,a0
		moveq	#0,d0
		move.b	($FFFFFEC1).w,d0
		add.w	d0,d0
		lea	(a0,d0.w),a0
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	2(a0),8(a1)
		move.w	4(a0),$10(a1)
		move.w	6(a0),$18(a1)
		move.w	8(a0),$20(a1)
		move.w	$A(a0),$28(a1)
		move.w	$C(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		rts	

BS_LoadWalls:
		moveq	#0,d0
		move.b	($FFFFF780).w,d0	; get the Special Stage angle
		lsr.b	#1,d0			; modify so it can be used as a frame ID
		andi.w	#$1F,d0
		cmp.b	($FFFFF743).w,d0	; does the modified angle match the recorded value?
		beq.s	BS_LoadRings			; if so, branch

		lea	($C00000).l,a6
		lea	(Unc_SSWalls).l,a1	; load wall art
		move.w	d0,d1
		lsl.w	#8,d1
		add.w	d1,d1
		add.w	d1,a1

		move.l	#$68400000,($C00004).l

		move.w	#$F,d1			; number of 8x8 tiles
		jsr	LoadTiles
		move.b	d0,($FFFFF743).w	; record the modified angle for comparison

BS_LoadRings:
		movea.l	#RingDynPLC,a2	; get DPLC location
		move.w	#$D800,d4		; offset in VRAM to store art
		move.l	#Art_Ring,d6	; get art location
		moveq	#0,d0
		move.b	($FFFFFEC3).w,d0	; load frame number
		jmp 	Load_DPLC
; End of function BS_AniWallsRings

; ===========================================================================
BS_WaRiVramSet:	dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
; ---------------------------------------------------------------------------
; Subroutine to	remove items when you collect them in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_RemoveCollectedItem:			; XREF: Obj09_ChkItems
		lea	($FF4400).l,a2
		move.w	#$1F,d0

loc_1B4C4:
		tst.b	(a2)
		beq.s	locret_1B4CE
		addq.w	#8,a2
		dbf	d0,loc_1B4C4

locret_1B4CE:
		rts	
; End of function BS_RemoveCollectedItem

; ---------------------------------------------------------------------------
; Subroutine to	animate	special	stage items when you touch them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_AniItems:				; XREF: BS_ShowLayout
		lea	($FF4400).l,a0
		move.w	#$1F,d7

loc_1B4DA:
		moveq	#0,d0
		move.b	(a0),d0
		beq.s	loc_1B4E8
		lsl.w	#2,d0
		movea.l	BS_AniIndex-4(pc,d0.w),a1
		jsr	(a1)

loc_1B4E8:
		addq.w	#8,a0

loc_1B4EA:
		dbf	d7,loc_1B4DA

		rts	
; End of function BS_AniItems

; ===========================================================================
BS_AniIndex:	dc.l BS_AniRingSparks
		dc.l BS_AniBumper
		dc.l BS_Ani1Up
		dc.l BS_AniReverse
		dc.l BS_AniEmeraldSparks
		dc.l BS_AniGlassBlock
		dc.l BS_AniBlock
; ===========================================================================

BS_AniRingSparks:			; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B530
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniRingData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B530
		clr.l	(a0)
		clr.l	4(a0)

locret_1B530:
		rts	
; ===========================================================================
BS_AniRingData:	dc.b $42, $43, $44, $45, 0, 0
; ===========================================================================

BS_AniBumper:				; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B566
		move.b	#7,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniBumpData(pc,d0.w),d0
		bne.s	loc_1B564
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#$25,(a1)
		rts	
; ===========================================================================

loc_1B564:
		move.b	d0,(a1)

locret_1B566:
		rts	
; ===========================================================================
BS_AniBumpData:	dc.b $32, $33, $32, $33, 0, 0
; ===========================================================================

BS_Ani1Up:				; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B596
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_Ani1UpData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B596
		clr.l	(a0)
		clr.l	4(a0)

locret_1B596:
		rts	
; ===========================================================================
BS_Ani1UpData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

BS_AniReverse:				; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B5CC
		move.b	#7,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniRevData(pc,d0.w),d0
		bne.s	loc_1B5CA
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#$2B,(a1)
		rts	
; ===========================================================================

loc_1B5CA:
		move.b	d0,(a1)

locret_1B5CC:
		rts	
; ===========================================================================
BS_AniRevData:	dc.b $2B, $31, $2B, $31, 0, 0
; ===========================================================================

BS_AniEmeraldSparks:			; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B60C
		move.b	#5,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniEmerData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B60C
		clr.l	(a0)
		clr.l	4(a0)
		move.b	#4,($FFFFB024).w
		sfx		sfx_Goal ;	play special stage GOAL	sound
		command	mus_FadeOut

locret_1B60C:
		rts	
; ===========================================================================
BS_AniEmerData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

BS_AniGlassBlock:			; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B640
		move.b	#1,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniGlassData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B640
		move.b	4(a0),(a1)
		clr.l	(a0)
		clr.l	4(a0)

locret_1B640:
		rts		
; ===========================================================================
BS_AniGlassData:dc.b $4F, $50, $51, $4F, $50, $51, $4F, $50, $51, $4F, $50, $51

BS_AniBlock:			; XREF: BS_AniIndex
		subq.b	#1,2(a0)
		bpl.s	locret_1B640
		move.b	#1,2(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	4(a0),a1
		move.b	BS_AniBlockData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret2_1B640
		move.b	4(a0),(a1)
		clr.l	(a0)
		clr.l	4(a0)

locret2_1B640:
		rts		
; ===========================================================================
BS_AniBlockData:dc.b $4B, $4C, $4D, $4B, $4C, $4D, $4B, $4C, $4D, $4B, $4C, $4D
; ---------------------------------------------------------------------------
; Special stage	layout pointers
; ---------------------------------------------------------------------------
BS_LayoutIndex:
	dc.l BS_1
	dc.l BS_2
	dc.l BS_3
	dc.l BS_4
	dc.l BS_5
	dc.l BS_6
	even

; ---------------------------------------------------------------------------
; Special stage	start locations
; ---------------------------------------------------------------------------
BS_StartLoc:	incbin	misc\sloc_ss.bin
		even

; ---------------------------------------------------------------------------
; Subroutine to	load special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_Load:	; XREF: SpecialStage
  		move.b ($FFFFFE16).w,d0
  		cmpi.b #5,d0 ; Does sonic have 5 emeralds?
  		bls.s BS_LoadData ; If lower or same, branch
  		move.b #0,($FFFFFE16).w ; reset if higher than 6

BS_LoadData:
		lsl.w	#2,d0
		lea	BS_StartLoc(pc,d0.w),a1
		move.w	(a1)+,($FFFFB008).w
		move.w	(a1)+,($FFFFB00C).w
		movea.l	BS_LayoutIndex(pc,d0.w),a0
		lea	($FF4000).l,a1
		move.w	#0,d0
		jsr	(EniDec).l
		lea	($FF0000).l,a1
		move.w	#$FFF,d0

BS_ClrRAM3:
		clr.l	(a1)+
		dbf	d0,BS_ClrRAM3

		lea	($FF1020).l,a1
		lea	($FF4000).l,a0
		moveq	#$3F,d1

loc_1B6F6:
		moveq	#$3F,d2

loc_1B6F8:
		move.b	(a0)+,(a1)+
		dbf	d2,loc_1B6F8

		lea	$40(a1),a1
		dbf	d1,loc_1B6F6

		lea	($FF4008).l,a1
		lea	(BS_MapIndex).l,a0
		moveq	#$50,d1

loc_1B714:
		move.l	(a0)+,(a1)+
		move.w	#0,(a1)+
		move.b	-4(a0),-1(a1)
		move.w	(a0)+,(a1)+
		dbf	d1,loc_1B714

		lea	($FF4400).l,a1
		move.w	#$3F,d1

loc_1B730:

		clr.l	(a1)+
		dbf	d1,loc_1B730

		rts	
; End of function BS_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Special stage	mappings and VRAM pointers
; ---------------------------------------------------------------------------
BS_MapIndex:
	dc.l Map_SSWalls	; address of mappings ;1
	dc.w $142		; VRAM setting
	dc.l Map_SSWalls ;2
	dc.w $142
	dc.l Map_SSWalls ;3
	dc.w $142
	dc.l Map_SSWalls ;4
	dc.w $142
	dc.l Map_SSWalls ;5
	dc.w $142
	dc.l Map_SSWalls ;6
	dc.w $142
	dc.l Map_SSWalls ;7
	dc.w $142
	dc.l Map_SSWalls ;8
	dc.w $142
	dc.l Map_SSWalls ;9
	dc.w $142
	dc.l Map_SSWalls ;A
	dc.w $2142
	dc.l Map_SSWalls ;B
	dc.w $2142
	dc.l Map_SSWalls ;C
	dc.w $2142
	dc.l Map_SSWalls ;D
	dc.w $2142
	dc.l Map_SSWalls ;E
	dc.w $2142
	dc.l Map_SSWalls ;F
	dc.w $2142
	dc.l Map_SSWalls ;10
	dc.w $2142
	dc.l Map_SSWalls ;11
	dc.w $2142
	dc.l Map_SSWalls ;12
	dc.w $2142
	dc.l Map_SSWalls ;13
	dc.w $4142
	dc.l Map_SSWalls ;14
	dc.w $4142
	dc.l Map_SSWalls ;15
	dc.w $4142
	dc.l Map_SSWalls ;16
	dc.w $4142
	dc.l Map_SSWalls ;17
	dc.w $4142
	dc.l Map_SSWalls ;18
	dc.w $4142
	dc.l Map_SSWalls ;19
	dc.w $4142
	dc.l Map_SSWalls ;1A
	dc.w $4142
	dc.l Map_SSWalls ;1B
	dc.w $4142
	dc.l Map_SSWalls ;1C
	dc.w $6142
	dc.l Map_SSWalls ;1D
	dc.w $6142
	dc.l Map_SSWalls ;1E
	dc.w $6142
	dc.l Map_SSWalls ;1F
	dc.w $6142
	dc.l Map_SSWalls ;20
	dc.w $6142
	dc.l Map_SSWalls ;21
	dc.w $6142
	dc.l Map_SSWalls ;22
	dc.w $6142
	dc.l Map_SSWalls ;23
	dc.w $6142
	dc.l Map_SSWalls ;24
	dc.w $6142
	dc.l Map_SS_Bump ;25
	dc.w $223B
	dc.l Map_SS_R ;26
	dc.w $2570
	dc.l Map_SS_R ;27
	dc.w $2251
	dc.l Map_SS_R ;28
	dc.w $370
	dc.l Map_SS_Up ;29
	dc.w $4263
	dc.l Map_SS_Down ;2A
	dc.w $4263
	dc.l Map_SS_R ;2B
	dc.w $22F0
	dc.l Map_SS_RedWhi ;2C
	dc.w $4470
	dc.l Map_SS_Glass ;2D
	dc.w $5F0
	dc.l Map_SS_Glass ;2E
	dc.w $65F0
	dc.l Map_SS_Glass ;2F
	dc.w $45F0
	dc.l Map_SS_Glass ;30
	dc.w $25F0
	dc.l Map_SS_R ;31
	dc.w $42F0
	dc.l Map_SS_Bump+$1000000	; add frame no.	* $1000000 ;32
	dc.w $223B
	dc.l Map_SS_Bump+$2000000 ;33
	dc.w $223B
	dc.l Map_SS_R ;34
	dc.w $2797
	dc.l Map_SS_R ;35
	dc.w $27A0
	dc.l Map_SS_R ;36
	dc.w $27A9
	dc.l Map_SS_R ;37
	dc.w $2797
	dc.l Map_SS_R ;38
	dc.w $27A0
	dc.l Map_SS_R ;39
	dc.w $27A9
	dc.l Map_obj25 ;3A
	dc.w $6C0
	dc.l Map_SS_Chaos3 ;3B
	dc.w $770
	dc.l Map_SS_Chaos3 ;3C
	dc.w $2770
	dc.l Map_SS_Chaos3 ;3D
	dc.w $4770
	dc.l Map_SS_Chaos3 ;3E
	dc.w $6770
	dc.l Map_SS_Chaos1 ;3F
	dc.w $770
	dc.l Map_SS_Chaos2 ;40
	dc.w $770
	dc.l Map_SS_R ;41
	dc.w $44F0
	dc.l Map_obj25+$1000000 ;42
	dc.w $6C0
	dc.l Map_obj25+$2000000 ;43
	dc.w $6C0
	dc.l Map_obj25+$3000000 ;44
	dc.w $6C0
	dc.l Map_obj25+$4000000 ;45
	dc.w $6C0
	dc.l Map_SS_Glass ;46
	dc.w $23F0
	dc.l Map_SS_Glass+$1000000 ;47
	dc.w $23F0
	dc.l Map_SS_Glass+$2000000 ;48
	dc.w $23F0
	dc.l Map_SS_Glass+$3000000 ;49
	dc.w $23F0
	dc.l Map_SS_R+$2000000
	dc.w $4F0
	dc.l Map_SSWalls ;4B
	dc.w $6142
	dc.l Map_SSWalls ;4C
	dc.w $2142
	dc.l Map_SSWalls ;4D
	dc.w $4142
	dc.l Map_SS_Glass ;4F
	dc.w $65F0
	dc.l Map_SS_Glass ;50
	dc.w $25F0
	dc.l Map_SS_Glass ;51
	dc.w $45F0

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "R" block
; ---------------------------------------------------------------------------
Map_SS_R:
	include "_maps\SSRblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage breakable glass blocks and red-white blocks
; ---------------------------------------------------------------------------
Map_SS_Glass:
	include "_maps\SSglassblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "UP" block
; ---------------------------------------------------------------------------
Map_SS_Up:
	include "_maps\SSUPblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "DOWN" block
; ---------------------------------------------------------------------------
Map_SS_Down:
	include "_maps\SSDOWNblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage block
; ---------------------------------------------------------------------------
Map_SS_RedWhi:
	include "_maps\SSRedWhi.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage chaos	emeralds
; ---------------------------------------------------------------------------
Map_SS_Chaos1:	dc.w byte_1B96C-Map_SS_Chaos1
		dc.w byte_1B97E-Map_SS_Chaos1
Map_SS_Chaos2:	dc.w byte_1B972-Map_SS_Chaos2
		dc.w byte_1B97E-Map_SS_Chaos2
Map_SS_Chaos3:	dc.w byte_1B978-Map_SS_Chaos3
		dc.w byte_1B97E-Map_SS_Chaos3
byte_1B96C:	dc.b 1
		dc.b $F8, 5, 0,	0, $F8
byte_1B972:	dc.b 1
		dc.b $F8, 5, 0,	4, $F8
byte_1B978:	dc.b 1
		dc.b $F8, 5, 0,	8, $F8
byte_1B97E:	dc.b 1
		dc.b $F8, 5, 0,	$C, $F8
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 09 - Sonic (special stage)
; ---------------------------------------------------------------------------

Obj09:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj09_Normal	; if not, branch
		bsr.w	BS_FixCamera
		bra.w	DebugMode
; ===========================================================================

Obj09_Normal:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj09_Index(pc,d0.w),d1
		jmp	Obj09_Index(pc,d1.w)
; ===========================================================================
Obj09_Index:	dc.w Obj09_Main-Obj09_Index
		dc.w Obj09_ChkDebug-Obj09_Index
		dc.w Obj09_ExitStage-Obj09_Index
		dc.w Obj09_Exit2-Obj09_Index
; ===========================================================================

Obj09_Main:				; XREF: Obj09_Index
		addq.b	#2,$24(a0)
		move.b	#$E,$16(a0)
		move.b	#7,$17(a0)
		move.l	#Map_Sonic,4(a0)
		tst.b	(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Knuckles,4(a0)
		cmpi.b	#2,(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Shadow,4(a0)
		cmpi.b	#3,(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Silver,4(a0)
		cmpi.b	#4,(Current_Character).w
		beq.s	Obj09_Main2
		move.l	#Map_Tails,4(a0)
		move.b	#$96,($FFFFB3C0).w ; load Obj05 (Tails' Tails)
		move.w	a0,($FFFFB3F2).w ; set its parent object to this

Obj09_Main2:
		move.w	#$780,2(a0)
		move.b	#4,1(a0)
		move.w	#0,$18(a0)
		move.b	#2,$1C(a0)
		bset	#2,$22(a0)
		bset	#1,$22(a0)

Obj09_ChkDebug:				; XREF: Obj09_Index
		tst.w	($FFFFFFFA).w	; is debug mode	cheat enabled?
		beq.s	Obj09_NoDebug	; if not, branch
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Obj09_NoDebug	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring

Obj09_NoDebug:
		move.b	#0,$30(a0)
		moveq	#0,d0
		move.b	$22(a0),d0
		andi.w	#2,d0
		move.w	Obj09_Modes(pc,d0.w),d1
		jsr	Obj09_Modes(pc,d1.w)
		jsr	LoadMainDynPLC
		jmp	DisplaySprite
; ===========================================================================
Obj09_Modes:	dc.w Obj09_OnWall-Obj09_Modes
		dc.w Obj09_InAir-Obj09_Modes
; ===========================================================================

Obj09_OnWall:				; XREF: Obj09_Modes
		bclr	#7,$22(a0)	; clear "Sonic has jumped" flag
		bsr.w	Obj09_Jump
		bsr.w	Obj09_Move
		bsr.w	Obj09_Fall
		bra.s	Obj09_Display
; ===========================================================================

Obj09_InAir:				; XREF: Obj09_Modes
		bsr.w	Obj09_JumpHeight
		bsr.w	Obj09_Move
		bsr.w	Obj09_Fall

Obj09_Display:				; XREF: Obj09_OnWall
		bsr.w	Obj09_ChkItems
		bsr.w	Obj09_ChkItems2
		jsr	SpeedToPos
		bsr.w	BS_FixCamera
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		bra.w	Char_Animate

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Move:				; XREF: Obj09_OnWall; Obj09_InAir
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj09_ChkRight	; if not, branch
		bsr.w	Obj09_MoveLeft

Obj09_ChkRight:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_1BA78	; if not, branch
		bsr.w	Obj09_MoveRight

loc_1BA78:
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0
		bne.s	loc_1BAA8
		move.w	$14(a0),d0
		beq.s	loc_1BAA8
		bmi.s	loc_1BA9A
		subi.w	#$C,d0
		bcc.s	loc_1BA94
		move.w	#0,d0

loc_1BA94:
		move.w	d0,$14(a0)
		bra.s	loc_1BAA8
; ===========================================================================

loc_1BA9A:
		addi.w	#$C,d0
		bcc.s	loc_1BAA4
		move.w	#0,d0

loc_1BAA4:
		move.w	d0,$14(a0)

loc_1BAA8:
		move.b	($FFFFF780).w,d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		neg.b	d0
		jsr	(CalcSine).l
		muls.w	$14(a0),d1
		add.l	d1,8(a0)
		muls.w	$14(a0),d0
		add.l	d0,$C(a0)
		movem.l	d0-d1,-(sp)
		move.l	$C(a0),d2
		move.l	8(a0),d3
		bsr.w	sub_1BCE8
		beq.s	loc_1BAF2
		movem.l	(sp)+,d0-d1
		sub.l	d1,8(a0)
		sub.l	d0,$C(a0)
		move.w	#0,$14(a0)
		rts	
; ===========================================================================

loc_1BAF2:
		movem.l	(sp)+,d0-d1
		rts	
; End of function Obj09_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveLeft:				; XREF: Obj09_Move
		bset	#0,$22(a0)
		move.w	$14(a0),d0
		beq.s	loc_1BB06
		bpl.s	loc_1BB1A

loc_1BB06:
		subi.w	#$C,d0
		cmpi.w	#-$800,d0
		bgt.s	loc_1BB14
		move.w	#-$800,d0

loc_1BB14:
		move.w	d0,$14(a0)
		rts	
; ===========================================================================

loc_1BB1A:
		subi.w	#$40,d0
		bcc.s	loc_1BB22
		nop	

loc_1BB22:
		move.w	d0,$14(a0)
		rts	
; End of function Obj09_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveRight:			; XREF: Obj09_Move
		bclr	#0,$22(a0)
		move.w	$14(a0),d0
		bmi.s	loc_1BB48
		addi.w	#$C,d0
		cmpi.w	#$800,d0
		blt.s	loc_1BB42
		move.w	#$800,d0

loc_1BB42:
		move.w	d0,$14(a0)
		bra.s	locret_1BB54
; ===========================================================================

loc_1BB48:
		addi.w	#$40,d0
		bcc.s	loc_1BB50
		nop	

loc_1BB50:
		move.w	d0,$14(a0)

locret_1BB54:
		rts	
; End of function Obj09_MoveRight


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Jump:				; XREF: Obj09_OnWall
		move.b	($FFFFF603).w,d0
		andi.b	#$70,d0		; is A,	B or C pressed?
		beq.s	Obj09_NoJump	; if not, branch
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$680,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#$680,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		bset	#1,$22(a0)
		bset	#7,$22(a0)	; set "Sonic has jumped" flag
		move.b	($FFFFFFF6).w,d0
		move.b	d0,mQueue+2.w ;	play jumping sound

Obj09_NoJump:
		rts	
; End of function Obj09_Jump

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to limit Sonic's upward vertical speed
; ---------------------------------------------------------------------------
 
Obj09_JumpHeight:			; XREF: Obj09_InAir
		move.b	($FFFFF602).w,d0	; is the jump button up?
		andi.b	#$70,d0
		bne.s	locret_1BBB4		; if not, branch to return
		btst	#7,$22(a0)		; did Sonic jump or is he just falling or hit by a bumper?
		beq.s	locret_1BBB4		; if not, branch to return
		move.b	($FFFFF780).w,d0	; get SS angle
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l			
		move.w	$12(a0),d2		; get Y speed
		muls.w	d2,d0			; multiply Y speed by sin
		asr.l	#8,d0			; find the new Y speed
		move.w	$10(a0),d2		; get X speed
		muls.w	d2,d1			; multiply X speed by cos
		asr.l	#8,d1			; find the new X speed
		add.w	d0,d1			; combine the two speeds
		cmpi.w	#$400,d1		; compare the combined speed with the jump release speed
		ble.s	locret_1BBB4		; if it's less, branch to return
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$400,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#$400,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)		; set the speed to the jump release speed
		bclr	#7,$22(a0)		; clear "Sonic has jumped" flag
 
locret_1BBB4:
		rts
; ---------------------------------------------------------------------------
; Subroutine to	fix the	camera on Sonic's position (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BS_FixCamera:				; XREF: Obj09
		move.w	$C(a0),d2
		move.w	8(a0),d3
		move.w	($FFFFF700).w,d0
		subi.w	#$A0,d3
		bcs.s	loc_1BBCE
		sub.w	d3,d0
		sub.w	d0,($FFFFF700).w

loc_1BBCE:
		move.w	($FFFFF704).w,d0
		subi.w	#$70,d2
		bcs.s	locret_1BBDE
		sub.w	d2,d0
		sub.w	d0,($FFFFF704).w

locret_1BBDE:
		rts	
; End of function BS_FixCamera

; ===========================================================================

Obj09_ExitStage:			; XREF: Obj09_Index
		andi.w	#$FFC0,($FFFFF782).w
		addi.w	#$40,($FFFFF782).w
		cmpi.w	#$1800,($FFFFF782).w
		bne.s	loc_1BBF4
		move.b	#$C,($FFFFF600).w

loc_1BBF4:
		cmpi.w	#$3000,($FFFFF782).w
		blt.s	loc_1BC12
		move.w	#0,($FFFFF782).w
		move.w	#$4000,($FFFFF780).w
		addq.b	#2,$24(a0)
		move.w	#$3C,$38(a0)

loc_1BC12:
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		bsr.s	Char_Animate
		jsr	LoadMainDynPLC
		bsr.w	BS_FixCamera
		jmp	DisplaySprite
; ===========================================================================

Obj09_Exit2:				; XREF: Obj09_Index
		subq.w	#1,$38(a0)
		bne.s	loc_1BC40
		move.b	#$C,($FFFFF600).w

loc_1BC40:
		bsr.s	Char_Animate
		jsr	LoadMainDynPLC
		bsr.w	BS_FixCamera
		jmp	DisplaySprite

Char_Animate:
		tst.b	(Current_Character).w
		beq.w	JMP_SonicAnimate
		cmpi.b	#1,(Current_Character).w
		beq.w	JMP_TailsAnimate
		cmpi.b	#2,(Current_Character).w
		beq.w	JMP_KnucklesAnimate
		cmpi.b	#2,(Current_Character).w
		beq.w	JMP_ShadowAnimate
		jmp		Silver_Animate

Partner_Animate:
		tst.b	(Current_Partner).w
		beq.w	JMP_SonicAnimate
		cmpi.b	#1,(Current_Partner).w
		beq.w	JMP_TailsAnimate
		cmpi.b	#2,(Current_Partner).w
		beq.w	JMP_KnucklesAnimate
		cmpi.b	#2,(Current_Partner).w
		beq.w	JMP_ShadowAnimate
		jmp		Silver_Animate

JMP_SonicAnimate:
		jmp	Sonic_Animate
JMP_ShadowAnimate:
		jmp	Shadow_Animate
JMP_KnucklesAnimate:
		jmp	Knuckles_Animate
JMP_TailsAnimate:
		jmp	Tails_Animate

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Fall:				; XREF: Obj09_OnWall; Obj09_InAir
		move.l	$C(a0),d2
		move.l	8(a0),d3
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		jsr	(CalcSine).l
		move.w	$10(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d0
		add.l	d4,d0
		move.w	$12(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d1
		add.l	d4,d1
		add.l	d0,d3
		bsr.w	sub_1BCE8
		beq.s	loc_1BCB0
		sub.l	d0,d3
		moveq	#0,d0
		move.w	d0,$10(a0)
		bclr	#1,$22(a0)
		add.l	d1,d2
		bsr.w	sub_1BCE8
		beq.s	loc_1BCC6
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_1BCB0:
		add.l	d1,d2
		bsr.w	sub_1BCE8
		beq.s	loc_1BCD4
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,$12(a0)
		bclr	#1,$22(a0)

loc_1BCC6:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,$10(a0)
		move.w	d1,$12(a0)
		rts	
; ===========================================================================

loc_1BCD4:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,$10(a0)
		move.w	d1,$12(a0)
		bset	#1,$22(a0)
		rts	
; End of function Obj09_Fall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1BCE8:				; XREF: Obj09_Move; Obj09_Fall
		lea	($FF0000).l,a1
		moveq	#0,d4
		swap	d2
		move.w	d2,d4
		swap	d2
		addi.w	#$44,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		swap	d3
		move.w	d3,d4
		swap	d3
		addi.w	#$14,d4
		divu.w	#$18,d4
		adda.w	d4,a1
		moveq	#0,d5
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		adda.w	#$7E,a1
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		move.b	(a1)+,d4
		bsr.s	sub_1BD30
		tst.b	d5
		rts	
; End of function sub_1BCE8


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1BD30:				; XREF: sub_1BCE8
		beq.s	locret_1BD44
		cmpi.b	#$28,d4
		beq.s	locret_1BD44
		cmpi.b	#$3A,d4
		bcs.s	loc_1BD46
		cmpi.b	#$4B,d4
		bcc.s	loc_1BD46

locret_1BD44:
		rts	
; ===========================================================================

loc_1BD46:
		move.b	d4,$30(a0)
		move.l	a1,$32(a0)
		moveq	#-1,d5
		rts	
; End of function sub_1BD30


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ChkItems:				; XREF: Obj09_Display
		lea	($FF0000).l,a1
		moveq	#0,d4
		move.w	$C(a0),d4
		addi.w	#$50,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		move.w	8(a0),d4
		addi.w	#$20,d4
		divu.w	#$18,d4
		adda.w	d4,a1
		move.b	(a1),d4
		bne.s	Obj09_ChkCont
		tst.b	$3A(a0)
		bne.w	Obj09_MakeGhostSolid
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkCont:
		cmpi.b	#$3A,d4		; is the item a	ring?
		bne.s	Obj09_Chk1Up
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_GetCont
		move.b	#1,(a2)
		move.l	a1,4(a2)

Obj09_GetCont:
		jsr	CollectRing

Obj09_NoCont:
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_Chk1Up:
; ===========================================================================

Obj09_ChkEmer:
		cmpi.b	#$3B,d4		; is the item an emerald?
		bcs.s	Obj09_ChkGhost
		cmpi.b	#$40,d4
		bhi.s	Obj09_ChkGhost
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_GetEmer
		move.b	#5,(a2)
		move.l	a1,4(a2)

Obj09_GetEmer:
		cmpi.b	#6,($FFFFFE57).w ; do you have all the emeralds?
		beq.s	Obj09_NoEmer	; if yes, branch
		subi.b	#$3B,d4
		moveq	#0,d0
		move.b	($FFFFFE57).w,d0
		lea	($FFFFFE58).w,a2
		move.b	d4,(a2,d0.w)
		addq.b	#1,($FFFFFE57).w ; add 1 to number of emeralds
		clr.b	($FFFFFE1E).w	; stop the time counter

Obj09_NoEmer:
		music		mus_Emerald ;	play emerald music
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkGhost:
		cmpi.b	#$41,d4		; is the item a	ghost block?
		bne.s	Obj09_ChkGhostTag
		move.b	#1,$3A(a0)	; mark the ghost block as "passed"

Obj09_ChkGhostTag:
		cmpi.b	#$4A,d4		; is the item a	switch for ghost blocks?
		bne.s	Obj09_NoGhost
		cmpi.b	#1,$3A(a0)	; have the ghost blocks	been passed?
		bne.s	Obj09_NoGhost	; if not, branch
		move.b	#2,$3A(a0)	; mark the ghost blocks	as "solid"

Obj09_NoGhost:
		moveq	#-1,d4
		rts	
; ===========================================================================

Obj09_MakeGhostSolid:
		cmpi.b	#2,$3A(a0)	; is the ghost marked as "solid"?
		bne.s	Obj09_GhostNotSolid ; if not, branch
		lea	($FF1020).l,a1
		moveq	#$3F,d1

Obj09_GhostLoop2:
		moveq	#$3F,d2

Obj09_GhostLoop:
		cmpi.b	#$41,(a1)	; is the item a	ghost block?
		bne.s	Obj09_NoReplace	; if not, branch
		move.b	#$2C,(a1)	; replace ghost	block with a solid block

Obj09_NoReplace:
		addq.w	#1,a1
		dbf	d2,Obj09_GhostLoop
		lea	$40(a1),a1
		dbf	d1,Obj09_GhostLoop2

Obj09_GhostNotSolid:
		clr.b	$3A(a0)
		moveq	#0,d4
		rts	
; End of function Obj09_ChkItems


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ChkItems2:			; XREF: Obj09_Display
		move.b	$30(a0),d0
		bne.s	Obj09_ChkBumper
		subq.b	#1,$36(a0)
		bpl.s	loc_1BEA0
		move.b	#0,$36(a0)

loc_1BEA0:
		subq.b	#1,$37(a0)
		bpl.s	locret_1BEAC
		move.b	#0,$37(a0)

locret_1BEAC:
		rts	
; ===========================================================================

Obj09_ChkBumper:
		cmpi.b	#$25,d0		; is the item a	bumper?
		bne.s	Obj09_GOAL
		move.l	$32(a0),d1
		subi.l	#$FF0001,d1
		move.w	d1,d2
		andi.w	#$7F,d1
		mulu.w	#$18,d1
		subi.w	#$14,d1
		lsr.w	#7,d2
		andi.w	#$7F,d2
		mulu.w	#$18,d2
		subi.w	#$44,d2
		sub.w	8(a0),d1
		sub.w	$C(a0),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,$10(a0)
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,$12(a0)
		bset	#1,$22(a0)
		bclr	#7,$22(a0)	; clear "Sonic has jumped" flag
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_BumpSnd
		move.b	#2,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,4(a2)

Obj09_BumpSnd:
		sfx		sfx_Bumper ;	play bumper sound
		rts
; ===========================================================================

Obj09_GOAL:
		cmpi.b	#$27,d0		; is the item a	"GOAL"?
		bne.s	Obj09_UPblock
		addq.b	#2,$24(a0)	; run routine "Obj09_ExitStage"
		sfx		sfx_Goal ;	play "GOAL" sound
		clr.b	($FFFFFE1E).w	; stop the time counter
		command	mus_FadeOut
		rts	
; ===========================================================================

Obj09_UPblock:
		cmpi.b	#$29,d0		; is the item an "UP" block?
		bne.s	Obj09_DOWNblock
		tst.b	$36(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$36(a0)
	;	btst	#6,($FFFFF783).w
	;	beq.s	Obj09_UPsnd
		addi.w 	#$20,($FFFFF782).w	; increase stage rotation speed
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.b	#$2A,(a1)	; change item to a "DOWN" block

Obj09_UPsnd:
		sfx		sfx_ActionBlock ;	play up/down sound
		rts
; ===========================================================================

Obj09_DOWNblock:
		cmpi.b	#$2A,d0		; is the item a	"DOWN" block?
		bne.s	Obj09_Rblock
		tst.b	$36(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$36(a0)
	;	btst	#6,($FFFFF783).w
	;	bne.s	Obj09_DOWNsnd
		subi.w 	#$20,($FFFFF782).w	; increase stage rotation speed
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.b	#$29,(a1)	; change item to an "UP" block

Obj09_DOWNsnd:
		sfx		sfx_ActionBlock ;	play up/down sound
		rts
; ===========================================================================

Obj09_Rblock:
		cmpi.b	#$2B,d0		; is the item an "R" block?
		bne.s	Obj09_ChkGlass
		tst.b	$37(a0)
		bne.w	Obj09_NoGlass
		move.b	#$1E,$37(a0)
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_RevStage
		move.b	#4,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,4(a2)

Obj09_RevStage:
		neg.w	($FFFFF782).w	; reverse stage	rotation
		sfx		sfx_ActionBlock ;	play sound
		rts
; ===========================================================================

Obj09_ChkGlass:
		cmpi.b	#$2D,d0		; is the item a	glass block?
		beq.s	Obj09_Glass	; if yes, branch
		cmpi.b	#$2E,d0
		beq.s	Obj09_Glass
		cmpi.b	#$2F,d0
		beq.s	Obj09_Glass
		cmpi.b	#$30,d0
		bne.s	Obj09_Block	; if not, branch

Obj09_Glass:
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_GlassSnd
		move.b	#6,(a2)
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.l	a1,4(a2)
		move.b	(a1),d0
		addq.b	#1,d0		; change glass type when touched
		cmpi.b	#$30,d0
		bls.s	Obj09_GlassUpdate ; if glass is	still there, branch
		clr.b	d0		; remove the glass block when it's destroyed

Obj09_GlassUpdate:
		move.b	d0,$4(a2)	; update the stage layout

Obj09_GlassSnd:
		sfx		sfx_Diamonds ;	play glass block sound
		rts
; ===========================================================================

Obj09_Block:
		cmpi.b	#$24,d0		; is the item a	block?
		bhi.s	Obj09_NoGlass	; if yes, branch
		bsr.w	BS_RemoveCollectedItem
		bne.s	Obj09_BlockSnd
		move.b	#7,(a2)
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.l	a1,4(a2)
		move.b	(a1),d0
		cmpi.b	#$1C,d0		; is the item a	block?
		beq.s	Obj09_BlockGreen	; if yes, branch
		cmpi.b	#$A,d0		; is the item a	block?
		beq.s	Obj09_BlockYellow	; if yes, branch
		cmpi.b	#$13,d0		; is the item a	block?
		beq.s	Obj09_BlockPurple	; if yes, branch
		bra.s	Obj09_NoGlass

Obj09_BlockGreen:
		move.w	#$A,d0
		bra.s	Obj09_BlockUpdate

Obj09_BlockYellow:
		move.w	#$13,d0
		bra.s	Obj09_BlockUpdate

Obj09_BlockPurple:
		move.b	#$27,d0		; remove the glass block when it's destroyed

Obj09_BlockUpdate:
		move.b	d0,$4(a2)	; update the stage layout

Obj09_BlockSnd:
		sfx		sfx_Diamonds ;	play glass block sound

Obj09_NoGlass:
		rts	
; End of function Obj09_ChkItems2

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 03 - Collision plane/layer switcher
; ----------------------------------------------------------------------------
; Sprite_1FCDC:
Obj03:
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	PSwapper_Index(pc,d0.w),d1
		jsr	PSwapper_Index(pc,d1.w)
		tst.w	($FFFFFFE2).w
		bne.s	Obj03_MarkObjGone
		; like RememberState, but doesn't display (Sonic 2's MarkObjGone3)
		move.w	8(a0),d0	; get object position
		andi.w	#$FF80,d0	; round down to nearest $80
		move.w	($FFFFF700).w,d1 ; get screen position
		subi.w	#128,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0		; approx distance between object and screen
		cmpi.w	#128+320+192,d0
		bhi.s	.offscreen
		rts

	.offscreen:
		move.w	$1E(a0),d0	; get address in respawn table
		beq.s	.delete		; if it's zero, don't remember object
		movea.w	d0,a2	; load address into a2
		bclr	#7,(a2)	; clear respawn table entry, so object can be loaded again

	.delete:
		jmp	DeleteObject

Obj03_MarkObjGone:
		jmp	MarkObjGone
; ===========================================================================
; off_1FCF0:
PSwapper_Index:
		dc.w PSwapper_Init-PSwapper_Index	; 0
		dc.w PSwapper_MainX-PSwapper_Index	; 2
		dc.w PSwapper_MainY-PSwapper_Index	; 4
; ===========================================================================
; loc_1FCF6:
PSwapper_Init:
		addq.b	#2,$24(a0) ; => PSwapper_MainX
		move.l	#Map_PathSwapper,4(a0)
		make_art_tile	ArtTile_Rings,0,1
		ori.b	#4,1(a0)
		move.b	#$10,$14(a0)
		move.w	#$280,$18(a0)
		move.b	$28(a0),d0
		btst	#2,d0
		beq.s	PSwapper_Init_CheckX
;PSwapper_Init_CheckY:
		addq.b	#2,$24(a0) ; => PSwapper_MainY
		andi.w	#7,d0
		move.b	d0,$1A(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),$32(a0)
		move.w	$C(a0),d1
		lea	($FFFFB000).w,a1 ; a1=character
		cmp.w	$C(a1),d1
		bhs.s	PSwapper_InitP2
		move.b	#1,$34(a0)

PSwapper_InitP2:
		lea	($FFFFB380).w,a1 ; a1=character
		cmp.w	$C(a1),d1
		bhs.w	PSwapper_MainY
		move.b	#1,$35(a0)
		bra.w	PSwapper_MainY
; ===========================================================================
word_1FD68:
	dc.w   $20
	dc.w   $40	; 1
	dc.w   $80	; 2
	dc.w  $100	; 3
; ===========================================================================
; loc_1FD70:
PSwapper_Init_CheckX:
		andi.w	#3,d0
		move.b	d0,$1A(a0)
		add.w	d0,d0
		move.w	word_1FD68(pc,d0.w),$32(a0)
		move.w	8(a0),d1
		lea	($FFFFB000).w,a1 ; a1=character
		cmp.w	8(a1),d1
		bhs.s	.jump
		move.b	#1,$34(a0)

.jump:
		lea	($FFFFB380).w,a1 ; a1=character
		cmp.w	8(a1),d1
		bhs.s	PSwapper_MainX
		move.b	#1,$35(a0)

; loc_1FDA4:
PSwapper_MainX:
		tst.w	($FFFFFE08).w
		bne.w	.locret
		move.w	8(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1 ; a1=character
		bsr.s	.jump4
		lea	($FFFFB380).w,a1 ; a1=character

.jump4:
		tst.b	(a2)+
		bne.w	PSwapper_MainX_Alt
		cmp.w	8(a1),d1
		bhi.s	.locret
		move.b	#1,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		blt.s	.locret
		cmp.w	d3,d4
		bge.s	.locret
		move.b	$28(a0),d0
		bpl.s	.jump
		btst	#1,$22(a1)
		bne.s	.locret
.jump:
		btst	#0,1(a0)
		bne.s	.jump2
		move.b	#$C,$3E(a1)	; MJ: set collision to 1st
		move.b	#$D,$3F(a1)	; MJ: set collision to 1st
		btst	#3,d0
		beq.s	.jump2
		move.b	#$E,$3E(a1)	; MJ: set collision to 2nd
		move.b	#$F,$3F(a1)	; MJ: set collision to 2nd
.jump2:
		andi.w	#$7FFF,2(a1)
		btst	#5,d0
		beq.s	.jump3
		ori.w	#(1<<15),2(a1)
.jump3:
		tst.b	($FFFFFFE2).w
		beq.s	.locret
		sfx		sfx_Alarm
.locret:
		rts
; ===========================================================================
; loc_1FE38:
PSwapper_MainX_Alt:
		cmp.w	8(a1),d1
		bls.s	.locret
		move.b	#0,-1(a2)
		move.w	$C(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	$C(a1),d4
		cmp.w	d2,d4
		blt.s	.locret
		cmp.w	d3,d4
		bge.s	.locret
		move.b	$28(a0),d0
		bpl.s	.jump
		btst	#1,$22(a1)
		bne.s	.locret
.jump:
		btst	#0,1(a0)
		bne.s	.jump2
		move.b	#$C,$3E(a1)	; MJ: set collision to 1st
		move.b	#$D,$3F(a1)	; MJ: set collision to 1st
		btst	#4,d0
		beq.s	.jump2
		move.b	#$E,$3E(a1)	; MJ: set collision to 2nd
		move.b	#$F,$3F(a1)	; MJ: set collision to 2nd
.jump2:
		andi.w	#$7FFF,2(a1)
		btst	#6,d0
		beq.s	.jump3
		ori.w	#(1<<15),2(a1)
.jump3:
		tst.b	($FFFFFFE2).w
		beq.s	.locret
		sfx		sfx_Alarm
.locret:
		rts
; ===========================================================================

PSwapper_MainY:
		tst.w	($FFFFFE08).w
		bne.w	.locret
		move.w	$C(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1 ; a1=character
		bsr.s	.jump4
		lea	($FFFFB380).w,a1 ; a1=character

.jump4:
		tst.b	(a2)+
		bne.s	PSwapper_MainY_Alt
		cmp.w	$C(a1),d1
		bhi.s	.locret
		move.b	#1,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		blt.s	.locret
		cmp.w	d3,d4
		bge.s	.locret
		move.b	$28(a0),d0
		bpl.s	.jump
		btst	#1,$22(a1)
		bne.s	.locret
.jump:
		btst	#0,1(a0)
		bne.s	.jump2
		move.b	#$C,$3E(a1)	; MJ: set collision to 1st
		move.b	#$D,$3F(a1)	; MJ: set collision to 1st
		btst	#3,d0
		beq.s	.jump2
		move.b	#$E,$3E(a1)	; MJ: set collision to 2nd
		move.b	#$F,$3F(a1)	; MJ: set collision to 2nd
.jump2:
		andi.w	#$7FFF,2(a1)
		btst	#5,d0
		beq.s	.jump3
		ori.w	#(1<<15),2(a1)
.jump3:
		tst.b	($FFFFFE08).w
		beq.s	.locret
		sfx		sfx_Alarm

.locret:
		rts
; ===========================================================================
; loc_1FF42:
PSwapper_MainY_Alt:
		cmp.w	$C(a1),d1
		bls.s	.locret
		move.b	#0,-1(a2)
		move.w	8(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	8(a1),d4
		cmp.w	d2,d4
		blt.s	.locret
		cmp.w	d3,d4
		bge.s	.locret
		move.b	$28(a0),d0
		bpl.s	.jump
		btst	#1,$22(a1)
		bne.s	.locret
.jump:
		btst	#0,1(a0)
		bne.s	.jump2
		move.b	#$C,$3E(a1)	; MJ: set collision to 1st
		move.b	#$D,$3F(a1)	; MJ: set collision to 1st
		btst	#4,d0
		beq.s	.jump2
		move.b	#$E,$3E(a1)	; MJ: set collision to 2nd
		move.b	#$F,$3F(a1)	; MJ: set collision to 2nd
.jump2:
		andi.w	#$7FFF,2(a1)
		btst	#6,d0
		beq.s	.jump3
		ori.w	#(1<<15),2(a1)
.jump3:
		tst.b	($FFFFFFE2).w
		beq.s	.locret
		sfx		sfx_Alarm
.locret:
		rts
; ===========================================================================
; -------------------------------------------------------------------------------
; sprite mappings
; -------------------------------------------------------------------------------
Map_PathSwapper:	include "_maps\obj03.asm"
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	animate	level graphics
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_Load:				; XREF: Demo_Time; loc_F54
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	AniArt_Pause	; if yes, branch
		lea	($C00000).l,a6
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	AniArt_Index(pc,d0.w),d0
		jmp	AniArt_Index(pc,d0.w)
; ===========================================================================

AniArt_Pause:
		rts	
; End of function AniArt_Load

; ===========================================================================
AniArt_Index:	dc.w AniArt_none-AniArt_Index, AniArt_BBZ-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_none-AniArt_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Green Hill
; ---------------------------------------------------------------------------

AniArt_BBZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.w	locret_1C10C
		move.b	#8,($FFFFF7B1).w
		moveq	#0,d1
		move.b	($FFFFF7B0).w,d1
		addq.b	#1,($FFFFF7B0).w
		cmpi.b	#3,($FFFFF7B0).w
		bne.s	loc_1C0E8
		move.b	#0,($FFFFF7B0).w

loc_1C0E8:
		move.b	byte_1C10E(pc,d1.w),d1
		mulu.w	#$C0,d1
		lea	(Art_BBZTorch).l,a0 ; load pulsing patterns
		add.l	a0,d1
		move.w	#$20,d2
		move.w	#$60,d3
		jsr	(QueueDMATransfer).l

locret_1C10C:
		rts	
; ===========================================================================
byte_1C10E:	dc.b 2,	1, 0, 0
; ===========================================================================

AniArt_none:				; XREF: AniArt_Index
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load (d1 - 1) 8x8 tiles
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTiles:
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		dbf	d1,LoadTiles
		rts	
; End of function LoadTiles

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 21 - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------

Obj21:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	$24(a0),d0
		move.w	Obj21_Index(pc,d0.w),d1
		jmp	Obj21_Index(pc,d1.w)
; ===========================================================================
Obj21_Index:	dc.w Obj21_Main-Obj21_Index
		dc.w Obj21_Display-Obj21_Index
; ===========================================================================

Obj21_Main:				; XREF: Obj21_Main
		addq.b	#2,$24(a0)
		move.w	#$84,8(a0)
		move.w	#$104,$A(a0)
		move.l	#Map_obj21,4(a0)
		make_art_tile	ArtTile_Rings,0,1
		cmpi.b	#9,($FFFFB000).w ; test if Special Stage Sonic is present
		bne.s	.skip	; if yes, branch
		make_art_tile	ArtTile_HUDBaseSS,0,1	;Mercury HUD Centiseconds
		move.l	#Map_obj21SS,4(a0)
	
	.skip:
		move.b	#0,1(a0)
		move.w	#0,$18(a0)

Obj21_Display:
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------
Map_obj21:
	include "_maps\obj21.asm"

Map_obj21SS:
	include "_maps\obj21SS.asm"

; ---------------------------------------------------------------------------
; Subroutine to	update the HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudUpdate:
		tst.w	($FFFFFFFA).w	; is debug mode	on?
		bne.w	HudDebug	; if yes, branch
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	Hud_ChkTime	; if not, branch
		bpl.s	loc_1C6E4
		bsr.w	Hud_LoadZero

loc_1C6E4:
		clr.b	($FFFFFE1D).w
		hudVRAM	(ArtTile_HudRings*$20)		; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr.w	Hud_Rings

Hud_ChkTime:
		tst.b	($FFFFFE1E).w	; does the time	need updating?
		beq.w	Hud_ChkBonus	; if not, branch
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.w	Hud_ChkBonus	; if yes, branch
		lea	($FFFFFE22).w,a1
		cmpi.l	#$93B63,(a1)+	; is the time 9'59"99?
		beq.s	loc_1C734	; if yes, branch	;Mercury HUD In Special Stage (bsr.s => bsr.w)
		move.b	($FFFFFE2D).w,d1
		addi.b	#1,d1
		cmpi.b	#3,d1
		bne.s	Hud_ChkTime_skip
		move.b	#0,d1
		
Hud_ChkTime_skip:
		move.b	d1,($FFFFFE2D).w
		cmpi.b	#2,d1
		beq.s	Hud_ChkTime_skip2
		addi.b	#1,d1
		
Hud_ChkTime_skip2:
		add.b	d1,-(a1)
		tst.b	($FFFFFE2F).w
		bne.s	loc_1C734
		cmpi.b	#100,(a1)
		bcs.s	Hud_DoCent
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#60,(a1)
		bcs.s	loc_1C734
		move.b	#0,(a1)
		addq.b	#1,-(a1)
		cmpi.b	#9,(a1)
		bcs.s	loc_1C734
		move.b	#9,(a1)

loc_1C734:
		move.b	#0,($FFFFFE2F).w
		hudVRAM	(ArtTile_HUDMin*$20)
		moveq	#0,d1
		move.b	($FFFFFE23).w,d1 ; load	minutes
		bsr.w	Hud_Mins
		hudVRAM	(ArtTile_HUDSec*$20)
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1 ; load	seconds
		bsr.w	Hud_Secs

Hud_DoCent:
		hudVRAM	(ArtTile_HUDCent*$20)		; set VRAM address
		moveq	#0,d1
		move.b	($FFFFFE25).w,d1 ; load	seconds
		bsr.w	Hud_Secs

Hud_ChkLives:

Hud_ChkBonus:
		tst.b	($FFFFF7D6).w	; do time/ring bonus counters need updating?
		beq.s	Hud_End		; if not, branch
		clr.b	($FFFFF7D6).w
		locVRAM	(ArtTile_HUDBonus*$20)
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr.w	Hud_TimeRingBonus

Hud_End:
		rts	

; ===========================================================================

HudDebug:				; XREF: HudUpdate
		bsr.w	HudDb_XY
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	HudDb_ObjCount	; if not, branch
		bpl.s	HudDb_Rings
		bsr.w	Hud_LoadZero

HudDb_Rings:
		clr.b	($FFFFFE1D).w
		hudVRAM	(ArtTile_HUDRings*$20)		; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr.w	Hud_Rings

HudDb_ObjCount:
		hudVRAM	(ArtTile_HUDSec*$20)		; set VRAM address
		moveq	#0,d1
		move.b	($FFFFF62C).w,d1 ; load	"number	of objects" counter
		bsr.w	Hud_Secs

HudDb_ChkBonus:
		tst.b	($FFFFF7D6).w	; does the ring/time bonus counter need	updating?
		beq.s	HudDb_End	; if not, branch
		clr.b	($FFFFF7D6).w
		locVRAM	(ArtTile_HUDBonus*$20)		; set VRAM address
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr.w	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr.w	Hud_TimeRingBonus

HudDb_End:
		rts	
; End of function HudUpdate

; ---------------------------------------------------------------------------
; Subroutine to	load "0" on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadZero:				; XREF: HudUpdate
		locVRAM	(ArtTile_HUDRings*$20)
		lea	Hud_TilesZero(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadZero

; ---------------------------------------------------------------------------
; Subroutine to	load " on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadMarks:				; XREF: HUD_Update
		locVRAM	(ArtTile_HUDMarks*$20)
		lea	Hud_TilesMarks(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadMarks

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Base:				; XREF: Level; BS_EndLoop; EndingSequence
		lea	($C00000).l,a6
		bsr.s	Hud_LoadMarks
		locVRAM	(ArtTile_HUDBase*$20)
		lea	Hud_TilesBase(pc),a2
		move.w	#9,d2

loc_1C83E:				; XREF: Hud_LoadZero
		lea	Art_Hud(pc),a1

loc_1C842:
		move.w	#$F,d1
		move.b	(a2)+,d0
		bmi.s	loc_1C85E
		ext.w	d0
		lsl.w	#5,d0
		lea	(a1,d0.w),a3

loc_1C852:
		move.l	(a3)+,(a6)
		dbf	d1,loc_1C852

loc_1C858:
		dbf	d2,loc_1C842

		rts	
; ===========================================================================

loc_1C85E:
		move.l	#0,(a6)
		dbf	d1,loc_1C85E

		bra.s	loc_1C858
; End of function Hud_Base

; ===========================================================================
Hud_TilesMarks:	dc.b $16, 0, 0, 0
Hud_TilesBase:	dc.b $16, 0, 0, 0, $14, 0, 0, $FF, $FF, 0
Hud_TilesZero:	dc.b $FF, $FF, 0, 0
; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY:				; XREF: HudDebug
		locVRAM	(ArtTile_HUDBase*$20)		; set VRAM address
		move.w	($FFFFF700).w,d1 ; load	camera x-position
		swap	d1
		move.w	($FFFFB008).w,d1 ; load	Sonic's x-position
		bsr.s	HudDb_XY2
		move.w	($FFFFF704).w,d1 ; load	camera y-position
		swap	d1
		move.w	($FFFFB00C).w,d1 ; load	Sonic's y-position
; End of function HudDb_XY


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY2:
		moveq	#7,d6
		lea	(Art_Text).l,a1

HudDb_XYLoop:
		rol.w	#4,d1
		move.w	d1,d2
		andi.w	#$F,d2
		cmpi.w	#$A,d2
		bcs.s	loc_1C8B2
		addq.w	#7,d2

loc_1C8B2:
		lsl.w	#5,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		swap	d1
		dbf	d6,HudDb_XYLoop	; repeat 7 more	times

		rts	
; End of function HudDb_XY2

; ---------------------------------------------------------------------------
; Subroutine to	load rings numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Rings:				; XREF: HudUpdate
		lea	(Hud_100).l,a2
		moveq	#2,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_RingLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc2_1C8EC:
		sub.l	d3,d1
		bcs.s	loc2_1C8F4
		addq.w	#1,d2
		bra.s	loc2_1C8EC
; ===========================================================================

loc2_1C8F4:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc2_1C8FE
		move.w	#1,d4

loc2_1C8FE:
		tst.w	d4
		beq.s	loc2_1C92C
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc2_1C92C:
		addi.l	#$400000,d0
		dbf	d6,Hud_RingLoop

		rts	
; End of function Hud_Rings

; ===========================================================================
; ---------------------------------------------------------------------------
; HUD counter sizes
; ---------------------------------------------------------------------------
Hud_100000:	dc.l 100000		; XREF: Hud_Score
Hud_10000:	dc.l 10000
Hud_1000:	dc.l 1000		; XREF: Hud_TimeRingBonus
Hud_100:	dc.l 100		; XREF: Hud_Rings
Hud_10:		dc.l 10			; XREF: ContScrCounter; Hud_Secs; Hud_Lives
Hud_1:		dc.l 1			; XREF: Hud_Mins

; ---------------------------------------------------------------------------
; Subroutine to	load time numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Mins:				; XREF: Hud_ChkTime
		lea	(Hud_1).l,a2
		moveq	#0,d6
		bra.s	loc_1C9BA
; End of function Hud_Mins


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Secs:				; XREF: Hud_ChkTime
		lea	(Hud_10).l,a2
		moveq	#1,d6

loc_1C9BA:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_TimeLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C9C4:
		sub.l	d3,d1
		bcs.s	loc_1C9CC
		addq.w	#1,d2
		bra.s	loc_1C9C4
; ===========================================================================

loc_1C9CC:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C9D6
		move.w	#1,d4

loc_1C9D6:
		lsl.w	#6,d2
		move.l	d0,4(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		addi.l	#$400000,d0
		dbf	d6,Hud_TimeLoop
		rts	
; End of function Hud_Secs

; ---------------------------------------------------------------------------
; Subroutine to	load time/ring bonus numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_TimeRingBonus:			; XREF: Hud_ChkBonus
		lea	(Hud_1000).l,a2
		moveq	#3,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_BonusLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA1E:
		sub.l	d3,d1
		bcs.s	loc_1CA26
		addq.w	#1,d2
		bra.s	loc_1CA1E
; ===========================================================================

loc_1CA26:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CA30
		move.w	#1,d4

loc_1CA30:
		tst.w	d4
		beq.s	Hud_ClrBonus
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1CA5A:
		dbf	d6,Hud_BonusLoop ; repeat 3 more times

		rts	
; ===========================================================================

Hud_ClrBonus:
		moveq	#$F,d5

Hud_ClrBonusLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrBonusLoop

		bra.s	loc_1CA5A
; End of function Hud_TimeRingBonus


; ---------------------------------------------------------------------------
; Subroutine to	update the HUD in the Special Stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HUD_Update_SS:
		lea	($C00000).l,a6
		tst.w	($FFFFFFFA).w	; is debug mode	on?
		bne.w	HudDebug_SS	; if yes, branch
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	Hud_ChkTime_SS	; if not, branch
		bpl.s	.dorings
		bsr.w	Hud_LoadZero_SS

	.dorings:
		clr.b	($FFFFFE1D).w
		locVRAMd0	(ArtTile_HUDRingsSS*$20)	;Mercury Macros
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1	; load number of rings
		bsr.w	Hud_Rings

Hud_ChkTime_SS:
		tst.b	($FFFFFE1E).w	; does the time	need updating?
		beq.w	Hud_ChkLives_SS	; if not, branch	;Mercury HUD Centiseconds (bsr.s => bsr.w)
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.w	Hud_ChkLives_SS	; if yes, branch	;Mercury HUD Centiseconds (bsr.s => bsr.w)
		lea	($FFFFFE22).w,a1

		cmpi.l	#$93B63,(a1)+	; is the time 9'59"99?
		beq.w	TimeOver_SS	; if yes, branch	;Mercury HUD In Special Stage (bsr.s => bsr.w)
		move.b	($FFFFFEBF).w,d1
		addi.b	#1,d1
		cmpi.b	#3,d1
		bne.s	.skip
		move.b	#0,d1
		
	.skip:
		move.b	d1,($FFFFFEBF).w
		cmpi.b	#2,d1
		beq.s	.skip2
		addi.b	#1,d1
		
	.skip2:
		add.b	d1,-(a1)
		cmpi.b	#100,(a1)
		bcs.s	Hud_DoCent_SS
	
		move.b	#0,(a1)		; clear jiffy
		addq.b	#1,-(a1)	; inc sec
		cmpi.b	#60,(a1)	; if 60
		bcs.s	.dotime
		move.b	#0,(a1)		; clear sec
		addq.b	#1,-(a1)	; inc min
		cmpi.b	#9,(a1)		; if 9
		bcs.s	.dotime
		move.b	#9,(a1)		; set min to 9

	.dotime:
		locVRAMd0	(ArtTile_HUDMinSS*$20)	;Mercury Macros
		moveq	#0,d1
		move.b	($FFFFFE23).w,d1 ; load	minutes
		bsr.w	Hud_Mins
		locVRAMd0	(ArtTile_HUDSecSS*$20)	;Mercury Macros
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1 ; load	seconds
		bsr.w	Hud_Secs
		
	Hud_DoCent_SS:
		locVRAMd0	(ArtTile_HUDCentSS*$20)	;Mercury Macros
		moveq	#0,d1
		move.b	($FFFFFE25).w,d1 ; load	seconds
		bsr.w	Hud_Secs
		

Hud_ChkLives_SS:
		
	.return:
		rts	
; ===========================================================================

TimeOver_SS:				; XREF: Hud_ChkTime_SS
		clr.b	($FFFFFE1E).w	; stop the time counter
		rts	
; ===========================================================================

HudDebug_SS:				; XREF: HUD_Update
		bsr.w	HudDb_XY_SS
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	HudDb_ObjCount_SS	; if not, branch
		bpl.s	HudDb_Rings_SS
		bsr.w	Hud_LoadZero_SS

HudDb_Rings_SS:
		clr.b	($FFFFFE1D).w
		locVRAMd0	(ArtTile_HUDRingsSS*$20)	;Mercury Macros		
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1	; load number of rings
		bsr.w	Hud_Rings

HudDb_ObjCount_SS:
		locVRAMd0	(ArtTile_HUDSecSS*$20)	;Mercury Macros
		moveq	#0,d1
		move.b	($FFFFF62C).w,d1 ; load "number of objects" counter
		bsr.w	Hud_Secs

	.return:
		rts	
; End of function HUD_Update_SS

; ---------------------------------------------------------------------------
; Subroutine to	load "0" on the	HUD in the Special Stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadZero_SS:				; XREF: HUD_Update_SS
		locVRAM	(ArtTile_HUDRingsSS*$20)	;Mercury Macros		
		lea	Hud_TilesZero(pc),a2
		move.w	#2,d2
		bra.w	loc_1C83E
; End of function Hud_LoadZero_SS

; ---------------------------------------------------------------------------
; Subroutine to	load " on the	HUD in the Special Stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadMarks_SS:				; XREF: HUD_Update_SS
		locVRAM	(ArtTile_HUDMarksSS*$20)
		lea	Hud_TilesMarks(pc),a2
		move.w	#2,d2
		bra.w	loc_1C83E
; End of function Hud_LoadMarks_SS

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon) in Special Stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Base_SS:				; XREF: GM_Special
		lea	($C00000).l,a6
		bsr.s	Hud_LoadMarks_SS
		locVRAM	(ArtTile_HUDBaseSS*$20)	;Mercury Macros
		lea	Hud_TilesBase(pc),a2
		move.w	#$E,d2
		bra.w	loc_1C83E
; End of function Hud_Base_SS

; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns in Special Stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY_SS:				; XREF: HudDebug_SS
		locVRAM	(ArtTile_HUDBaseSS*$20)	;Mercury Macros
		move.w	($FFFFF700).w,d1 ; load camera x-position
		swap	d1
		move.w	($FFFFB008).w,d1 ; load Sonic's x-position
		bsr.w	HudDb_XY2
		move.w	($FFFFF704).w,d1 ; load camera y-position
		swap	d1
		move.w	($FFFFB00C).w,d1 ; load Sonic's y-position
		bra.w	HudDb_XY2
		;rts
; End of function HudDb_XY_SS

; ===========================================================================
Art_Hud:	incbin	artunc\HUD.bin		; 8x16 pixel numbers on HUD
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; When debug mode is currently in use
; ---------------------------------------------------------------------------

DebugMode:				; XREF: Obj01; Obj09
		moveq	#0,d0
		move.b	($FFFFFE08).w,d0
		move.w	Debug_Index(pc,d0.w),d1
		jmp	Debug_Index(pc,d1.w)
; ===========================================================================
Debug_Index:	dc.w Debug_Main-Debug_Index
		dc.w Debug_Skip-Debug_Index
; ===========================================================================

Debug_Main:				; XREF: Debug_Index
		addq.b	#2,($FFFFFE08).w
		move.w	($FFFFF72C).w,($FFFFFEF0).w ; buffer level x-boundary
		move.w	($FFFFF726).w,($FFFFFEF2).w ; buffer level y-boundary
		move.w	#0,($FFFFF72C).w
		move.w	#$720,($FFFFF726).w
		andi.w	#$7FF,($FFFFB00C).w
		andi.w	#$7FF,($FFFFF704).w
		andi.w	#$3FF,($FFFFF70C).w
		move.b	#0,(Scroll_Lock).w
		move.b	#0,$1A(a0)
		move.b	#0,$1C(a0)
		clr.w	$10(a0)
		clr.w	$12(a0)
		clr.w	$20(a0)
		btst	#3,$22(a0)	; is Sonic standing on an object?	;Mercury Constants
		beq.s	.setpos		; if not, branch
		bclr	#3,$22(a0)	; clear Sonic's standing flag	;Mercury Constants
		moveq	#0,d0
		move.b	$3D(a0),d0	; get object id	;Mercury Constants
		clr.b	$3D(a0)	; clear object id	;Mercury Constants
		lsl.w	#6,d0
		addi.l	#$FFFFD000&$FFFFFF,d0
		movea.l	d0,a2
		bclr	#3,$22(a2)	; clear object's standing flag	;Mercury Constants
		clr.b	$25(a2)

.setpos:
		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)?
		bne.s	Debug_Zone	; if not, branch
		move.w	#0,($FFFFF782).w ; stop	special	stage rotating
		move.w	#0,($FFFFF780).w ; make	special	stage "upright"
		moveq	#6,d0		; use 6th debug	item list
		bra.s	Debug_UseList
; ===========================================================================

Debug_Zone:
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

Debug_UseList:
		lea	(DebugList).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		cmp.b	($FFFFFE06).w,d6
		bhi.s	loc_1CF9E
		move.b	#0,($FFFFFE06).w

loc_1CF9E:
		bsr.w	Debug_ShowItem
		move.b	#$C,($FFFFFE0A).w
		move.b	#1,($FFFFFE0B).w

Debug_Skip:				; XREF: Debug_Index
		moveq	#6,d0
		cmpi.b	#$10,($FFFFF600).w
		beq.s	loc_1CFBE
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

loc_1CFBE:
		lea	(DebugList).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		bsr.w	Debug_Control
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_Control:
		moveq	#0,d4
		move.w	#1,d1
		move.b	($FFFFF605).w,d4
		andi.w	#$F,d4		; is up/down/left/right	pressed?
		bne.s	loc_1D018	; if yes, branch
		move.b	($FFFFF604).w,d0
		andi.w	#$F,d0
		bne.s	loc_1D000
		move.b	#$C,($FFFFFE0A).w
		move.b	#$F,($FFFFFE0B).w
		bra.w	Debug_BackItem
; ===========================================================================

loc_1D000:
		subq.b	#1,($FFFFFE0A).w
		bne.s	loc_1D01C
		move.b	#1,($FFFFFE0A).w
		addq.b	#1,($FFFFFE0B).w
		bne.s	loc_1D018
		move.b	#-1,($FFFFFE0B).w

loc_1D018:
		move.b	($FFFFF604).w,d4

loc_1D01C:
		moveq	#0,d1
		move.b	($FFFFFE0B).w,d1
		addq.w	#1,d1
		swap	d1
		asr.l	#4,d1
		move.l	$C(a0),d2
		move.l	8(a0),d3
		btst	#0,d4		; is up	being pressed?
		beq.s	loc_1D03C	; if not, branch
		sub.l	d1,d2
		bcc.s	loc_1D03C
		moveq	#0,d2

loc_1D03C:
		btst	#1,d4		; is down being	pressed?
		beq.s	loc_1D052	; if not, branch
		add.l	d1,d2
		cmpi.l	#$7FF0000,d2
		bcs.s	loc_1D052
		move.l	#$7FF0000,d2

loc_1D052:
		btst	#2,d4
		beq.s	loc_1D05E
		sub.l	d1,d3
		bcc.s	loc_1D05E
		moveq	#0,d3

loc_1D05E:
		btst	#3,d4
		beq.s	loc_1D066
		add.l	d1,d3

loc_1D066:
		move.l	d2,$C(a0)
		move.l	d3,8(a0)

Debug_BackItem:
		btst	#6,($FFFFF604).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_NextItem	; if not, branch
		subq.b	#1,($FFFFFE06).w ; go back 1 item
		bcc.s	Debug_NoLoop
		add.b	d6,($FFFFFE06).w
		bra.s	Debug_NoLoop
; ===========================================================================

Debug_NextItem:
		btst	#6,($FFFFF605).w ; is button A pressed?
		beq.s	Debug_MakeItem	; if not, branch
		addq.b	#1,($FFFFFE06).w ; go forwards 1 item
		cmp.b	($FFFFFE06).w,d6
		bhi.s	Debug_NoLoop
		move.b	#0,($FFFFFE06).w ; loop	back to	first item

Debug_NoLoop:
		bra.w	Debug_ShowItem
; ===========================================================================

Debug_MakeItem:
		btst	#5,($FFFFF605).w ; is button C pressed?
		beq.s	Debug_Exit	; if not, branch
		jsr	SingleObjLoad
		bne.s	Debug_Exit
		move.w	8(a0),8(a1)
		move.w	$C(a0),$C(a1)
		move.b	4(a0),0(a1)	; create object
		move.b	1(a0),1(a1)
		move.b	1(a0),$22(a1)
		andi.b	#$7F,$22(a1)
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.b	4(a2,d0.w),$28(a1)
		rts	
; ===========================================================================

Debug_Exit:
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Debug_DoNothing	; if not, branch
		moveq	#0,d0
		move.w	d0,($FFFFFE08).w ; deactivate debug mode
		move.l	#Map_Sonic,($FFFFB004).w
		move.w	#(ArtTile_Main+$8000),($FFFFB002).w
		move.b	d0,($FFFFB01C).w
		move.w	d0,$A(a0)
		move.w	d0,$E(a0)
		move.w	($FFFFFEF0).w,($FFFFF72C).w ; restore level boundaries
		move.w	($FFFFFEF2).w,($FFFFF726).w
		cmpi.b	#$10,($FFFFF600).w ; are you in	the special stage?
		bne.s	Debug_DoNothing	; if not, branch
		clr.w	($FFFFF780).w
		move.w	#$40,($FFFFF782).w ; set new level rotation speed
		move.l	#Map_Sonic,($FFFFB004).w
		move.w	#$780,($FFFFB002).w
		move.b	#2,($FFFFB01C).w
		bset	#2,($FFFFB022).w
		bset	#1,($FFFFB022).w

Debug_DoNothing:
		rts	
; End of function Debug_Control


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_ShowItem:				; XREF: Debug_Main
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.l	(a2,d0.w),4(a0)	; load mappings	for item
		move.w	6(a2,d0.w),2(a0) ; load	VRAM setting for item
		move.b	5(a2,d0.w),$1A(a0) ; load frame	number for item
		rts	
; End of function Debug_ShowItem

; ===========================================================================
; ---------------------------------------------------------------------------
; Debug	list pointers
; ---------------------------------------------------------------------------
DebugList:

; ---------------------------------------------------------------------------
; Debug	list - AAZ
; ---------------------------------------------------------------------------
Debug_AAZ:
	dc.w 2
	dc.l Map_obj25+$25000000
	dc.b 0,	0, $27,	$B2
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - BBZ
; ---------------------------------------------------------------------------
Debug_BBZ:
	dc.w 2			; number of items in list
	dc.l Map_obj25+$25000000	; mappings pointer, object type * 10^6
	dc.b 0,	0, $27,	$B2		; subtype, frame, VRAM setting (2 bytes)
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - CCZ
; ---------------------------------------------------------------------------
Debug_CCZ:
	dc.w 2
	dc.l Map_obj25+$25000000
	dc.b 0,	0, $27,	$B2
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - DDZ
; ---------------------------------------------------------------------------
Debug_DDZ:
	dc.w 2
	dc.l Map_obj25+$25000000
	dc.b 0,	0, $27,	$B2
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - EEZ
; ---------------------------------------------------------------------------
Debug_EEZ:
	dc.w 2
	dc.l Map_obj25+$25000000
	dc.b 0,	0, $27,	$B2
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - FFZ
; ---------------------------------------------------------------------------
Debug_FFZ:
	dc.w 2
	dc.l Map_obj25+$25000000
	dc.b 0,	0, $27,	$B2
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Debug	list - GGZ
; ---------------------------------------------------------------------------
Debug_GGZ:
	dc.w 2			; number of items in list
	dc.l Map_obj25+$25000000	; mappings pointer, object type * 10^6
	dc.b 0,	0, $27,	$B2		; subtype, frame, VRAM setting (2 bytes)
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even
; ---------------------------------------------------------------------------
; Debug	list - Special Stage
; ---------------------------------------------------------------------------
Debug_SSZ:
	dc.w 2			; number of items in list
	dc.l Map_obj25+$25000000	; mappings pointer, object type * 10^6
	dc.b 0,	0, $27,	$B2		; subtype, frame, VRAM setting (2 bytes)
	dc.l Map_obj26+$26000000
	dc.b 0,	0, 6, $80
	even

; ---------------------------------------------------------------------------
; Main level load blocks
;
; ===FORMAT===
; level	patterns + (1st	PLC num	* 10^6)
; 16x16	mappings + (2nd	PLC num	* 10^6)
; 256x256 mappings
; blank, music (unused), pal index (unused), pal index
; ---------------------------------------------------------------------------
MainLoadBlocks:
	dc.l Kos_AAZ+$4000000
	dc.l Blk16_AAZ+$5000000
	dc.l Blk256_AAZ
	dc.b 0,	$81, 4,	4
	dc.l Kos_BBZ+$6000000
	dc.l Blk16_BBZ+$7000000
	dc.l Blk256_BBZ
	dc.b 0,	$82, 5,	5
	dc.l Kos_CCZ+$8000000
	dc.l Blk16_CCZ+$9000000
	dc.l Blk256_CCZ
	dc.b 0,	$83, 6,	6
	dc.l Kos_DDZ+$A000000
	dc.l Blk16_DDZ+$B000000
	dc.l Blk256_DDZ
	dc.b 0,	$84, 7,	7
	dc.l Kos_EEZ+$C000000
	dc.l Blk16_EEZ+$D000000
	dc.l Blk256_EEZ
	dc.b 0,	$85, 8,	8
	dc.l Kos_FFZ+$E000000
	dc.l Blk16_FFZ+$F000000
	dc.l Blk256_FFZ
	dc.b 0,	$86, 9,	9
	dc.l Kos_GGZ+$1E000000
	dc.l Blk16_GGZ+$1F000000
	dc.l Blk256_GGZ
	dc.b 0,	$86, $18, $18
	dc.l Kos_SSZ+$21000000
	dc.l Blk16_SSZ+$22000000
	dc.l Blk256_SSZ
	dc.b 0,	$8C, $19, $19
	even

; ---------------------------------------------------------------------------
; Pattern load cues
; ---------------------------------------------------------------------------
ArtLoadCues:
	dc.w PLC_Main-ArtLoadCues, PLC_Main2-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_AAZ-ArtLoadCues, PLC_AAZ2-ArtLoadCues
	dc.w PLC_BBZ-ArtLoadCues, PLC_BBZ2-ArtLoadCues
	dc.w PLC_CCZ-ArtLoadCues, PLC_CCZ2-ArtLoadCues
	dc.w PLC_DDZ-ArtLoadCues, PLC_DDZ2-ArtLoadCues
	dc.w PLC_EEZ-ArtLoadCues, PLC_EEZ2-ArtLoadCues
	dc.w PLC_FFZ-ArtLoadCues, PLC_FFZ2-ArtLoadCues
	dc.w PLC_TitleCard-ArtLoadCues,	PLC_CCZBoss-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_Prison-ArtLoadCues
	dc.w PLC_SpeStage-ArtLoadCues, PLC_AAZAnimals-ArtLoadCues
	dc.w PLC_BBZAnimals-ArtLoadCues,	PLC_CCZAnimals-ArtLoadCues
	dc.w PLC_DDZAnimals-ArtLoadCues, PLC_CCZAnimals-ArtLoadCues
	dc.w PLC_FFZAnimals-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_GGZAnimals-ArtLoadCues
	dc.w PLC_GGZ-ArtLoadCues, PLC_GGZ2-ArtLoadCues
	dc.w PLC_SSZAnimals-ArtLoadCues, PLC_SSZ-ArtLoadCues
	dc.w PLC_SSZ2-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_None-ArtLoadCues
	dc.w PLC_None-ArtLoadCues, PLC_TornadoSign-ArtLoadCues
	dc.w PLC_Tornado-ArtLoadCues
; ---------------------------------------------------------------------------
; Pattern load cues - standard block 1
; ---------------------------------------------------------------------------
PLC_Main:	dc.w 2
		dc.l Nem_Lamp		; lamppost
		dc.w ArtTile_Lamp*$20
		dc.l Nem_Monitors	; monitors
		dc.w ArtTile_Monitor*$20 
		dc.l Nem_Ring		; rings
		dc.w ArtTile_Rings*$20
; ---------------------------------------------------------------------------
; Pattern load cues - standard block 2
; ---------------------------------------------------------------------------
PLC_Main2:	dc.w 0
		dc.l Nem_Monitors	; monitors
		dc.w ArtTile_Monitor*$20  
; ---------------------------------------------------------------------------
; Pattern load cues - Green Hill
; ---------------------------------------------------------------------------
PLC_AAZ:	dc.w 1
		dc.l Nem_Swing		; swinging platform
		dc.w $6D80			; $200 bytes
		dc.l Nem_Bridge		; bridge
		dc.w $6F80			; $100 bytes

PLC_AAZ2:	dc.w 3
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Labyrinth
; ---------------------------------------------------------------------------
PLC_BBZ:		dc.w 3
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20
		dc.l Nem_RainSnow
		dc.w $6100
		dc.l Nem_Sun
		dc.w $6140
		dc.l Nem_Orbinaut
		dc.w ArtTile_Orbinaut*$20

PLC_BBZ2:	dc.w 2
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Marble
; ---------------------------------------------------------------------------
PLC_CCZ:		dc.w 0
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20

PLC_CCZ2:	dc.w 2			; $200 bytes
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Star Light
; ---------------------------------------------------------------------------
PLC_DDZ:	dc.w 0
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20

PLC_DDZ2:	dc.w 2
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Spring Yard
; ---------------------------------------------------------------------------
PLC_EEZ:	dc.w 0
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20

PLC_EEZ2:	dc.w 2
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Scrap Brain
; ---------------------------------------------------------------------------
PLC_FFZ:	dc.w 2
		dc.l Nem_Fish
		dc.w $A000
		dc.l Nem_Water		; water	surface
		dc.w $7000
		dc.l Nem_Bubbles	; bubbles and numbers
		dc.w $7200

PLC_FFZ2:	dc.w 3
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Scrap Brain
; ---------------------------------------------------------------------------
PLC_GGZ:	dc.w 2
		dc.l Nem_Fish
		dc.w $A000
		dc.l Nem_Water		; water	surface
		dc.w $7000
		dc.l Nem_Bubbles	; bubbles and numbers
		dc.w $7200

PLC_GGZ2:	dc.w 3
		dc.l Nem_Spikes		; spikes
		dc.w ArtTile_Spikes*$20
		dc.l Nem_DSpring	; diagonal spring
		dc.w ArtTile_DSpring*$20
		dc.l Nem_HSpring	; horizontal spring
		dc.w ArtTile_HSpring*$20
		dc.l Nem_VSpring	; vertical spring
		dc.w ArtTile_VSpring*$20
; ---------------------------------------------------------------------------
; Pattern load cues - Special Stage
; ---------------------------------------------------------------------------
PLC_SSZ:		dc.w 0
		dc.l Nem_Tornado
		dc.w $8000

PLC_SSZ2:	dc.w 0
		dc.l Nem_Spikes		; spikes
		dc.w $8680			; $200 bytes
; ---------------------------------------------------------------------------
; Pattern load cues - title card
; ---------------------------------------------------------------------------
PLC_TitleCard:	dc.w 0
		dc.l Nem_TitleCard
		dc.w ArtTile_Animal1*$20
; ---------------------------------------------------------------------------
; Pattern load cues - act 3 boss
; ---------------------------------------------------------------------------
PLC_CCZBoss:	dc.w 4
		dc.l Nem_Swing		; swinging platform
		dc.w $6F00
; ---------------------------------------------------------------------------
; Pattern load cues - beta special stage warp effect
; ---------------------------------------------------------------------------
PLC_Prison:	dc.w 0
		dc.l Nem_Prison		; prison capsule
		dc.w $73A0
; ---------------------------------------------------------------------------
; Pattern load cues - special stage
; ---------------------------------------------------------------------------
PLC_SpeStage:	dc.w $10
		dc.l Nem_SSBg	; bubble and cloud background
		dc.w 0
		dc.l Nem_SSFg	; bird and fish	background
		dc.w $4000
		dc.l Nem_Bumper		; bumper
		dc.w $4760
		dc.l Nem_SSGOAL		; GOAL block
		dc.w $4A20
		dc.l Nem_SSUpDown	; UP and DOWN blocks
		dc.w $4C60
		dc.l Nem_SSRBlock	; R block
		dc.w $5E00
		dc.l Nem_SS1UpBlock	; 1UP block
		dc.w $6E00
		dc.l Nem_SSEmStars	; emerald collection stars
		dc.w $7E00
		dc.l Nem_SSRedWhite	; red and white	block
		dc.w $8E00
		dc.l Nem_Ring		; rings
		dc.w $D800
		dc.l Nem_SSGhost	; ghost	block
		dc.w $9E00
		dc.l Nem_SSWBlock	; W block
		dc.w $AE00
		dc.l Nem_SSGlass	; glass	block
		dc.w $BE00
		dc.l Nem_SSEmerald	; emeralds
		dc.w $EE00
		dc.l Nem_SSZone1	; ZONE 1 block
		dc.w $F2E0
		dc.l Nem_SSZone2	; ZONE 2 block
		dc.w $F400
		dc.l Nem_SSZone3	; ZONE 3 block
		dc.w $F520
		dc.l Nem_SSZone4	; ZONE 4 block
		dc.w $F2E0
		dc.l Nem_SSZone5	; ZONE 5 block
		dc.w $F400
		dc.l Nem_SSZone6	; ZONE 6 block
		dc.w $F520
; ---------------------------------------------------------------------------
; Pattern load cues - AAZ animals
; ---------------------------------------------------------------------------
PLC_AAZAnimals:	dc.w 1
		dc.l Nem_Rabbit		; rabbit
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Flicky		; flicky
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - BBZ animals
; ---------------------------------------------------------------------------
PLC_BBZAnimals:	dc.w 1
		dc.l Nem_BlackBird	; blackbird
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Seal		; seal
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - CCZ animals
; ---------------------------------------------------------------------------
PLC_CCZAnimals:	dc.w 1
		dc.l Nem_Squirrel	; squirrel
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Seal		; seal
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - DDZ animals
; ---------------------------------------------------------------------------
PLC_DDZAnimals:	dc.w 1
		dc.l Nem_Pig		; pig
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Flicky		; flicky
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - EEZ animals
; ---------------------------------------------------------------------------
PLC_EEZAnimals:	dc.w 1
		dc.l Nem_Pig		; pig
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Chicken	; chicken
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - FFZ animals
; ---------------------------------------------------------------------------
PLC_FFZAnimals:	dc.w 1
		dc.l Nem_Rabbit		; rabbit
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Chicken	; chicken
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - SSZ animals
; ---------------------------------------------------------------------------
PLC_GGZAnimals:	dc.w 1
		dc.l Nem_Rabbit		; rabbit
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Flicky		; flicky
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - SSZ animals
; ---------------------------------------------------------------------------
PLC_SSZAnimals:	dc.w 1
		dc.l Nem_Rabbit		; rabbit
		dc.w ArtTile_Animal1*$20
		dc.l Nem_Flicky		; flicky
		dc.w ArtTile_Animal2*$20
; ---------------------------------------------------------------------------
; Pattern load cues - ending sequence
; ---------------------------------------------------------------------------
PLC_Ending:	dc.w 9
		dc.l Nem_EndEm		; emeralds
		dc.w $78A0
		dc.l Nem_EndSonic	; Sonic
		dc.w $7C20
		dc.l Nem_Rabbit		; rabbit
		dc.w $AA60
		dc.l Nem_Chicken	; chicken
		dc.w $ACA0
		dc.l Nem_BlackBird	; blackbird
		dc.w $AE60
		dc.l Nem_Seal		; seal
		dc.w $B0A0
		dc.l Nem_Pig		; pig
		dc.w $B260
		dc.l Nem_Flicky		; flicky
		dc.w $B4A0
		dc.l Nem_Squirrel	; squirrel
		dc.w $B660
		dc.l Nem_EndStH		; "SONIC THE HEDGEHOG"
		dc.w $B8A0
; ---------------------------------------------------------------------------
; Pattern load cues - plane sign
; ---------------------------------------------------------------------------
PLC_TornadoSign:	dc.w 0
		dc.l Nem_TornadoSign
		dc.w ArtTile_TornadoSign*$20

; ---------------------------------------------------------------------------
; Pattern load cues - tornado
; ---------------------------------------------------------------------------
PLC_Tornado:	dc.w 0
		dc.l Nem_Tornado
		dc.w $B480

PLC_None:	dc.w 0
		dc.l Nem_ResultEm	; emeralds
		dc.w $A820

Nem_Orbinaut:	incbin	artnem\orbinaut.bin	; orbinaut
		even
Nem_SegaLogo:	incbin	artnem\segalogo.bin	; large Sega logo
		even
Eni_SegaLogo:	incbin	mapeni\segalogo.bin	; large Sega logo (mappings)
		even
Nem_TitleFg:	incbin	artnem\titlefor.bin	; title screen foreground
		even
Nem_Title:	incbin	artnem\title.bin	; Sonic on title screen
		even
Nem_TitleTM:	incbin	artnem\titletm.bin	; TM on title screen
		even
Nem_Menu:	incbin	artnem\menu.bin
		even
Options_Mappings:	incbin  'mapeni\options.bin'
		even
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic
; ---------------------------------------------------------------------------
Map_Sonic:
	include "_maps\Sonic.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Shadow
; ---------------------------------------------------------------------------
Map_Shadow:
	include "_maps\Shadow.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Silver
; ---------------------------------------------------------------------------
Map_Silver:
	include "_maps\Silver.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Tails
; ---------------------------------------------------------------------------
Map_Tails:
	include "_maps\Tails.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Tails' tails
; ---------------------------------------------------------------------------
Map_TailsTails:
	include "_maps\TailsTails.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Knuckles
; ---------------------------------------------------------------------------
Map_Knuckles:
	include "_maps\Knuckles.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Sonic
; ---------------------------------------------------------------------------
Map_SSChar:
	include "_maps\SSChar.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Sonic
; ---------------------------------------------------------------------------
SonicDynPLC:
	include "_maps\Sonic dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Shadow
; ---------------------------------------------------------------------------
ShadowDynPLC:
	include "_maps\Shadow dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
SilverDynPLC:
	include "_maps\Silver dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
TailsDynPLC:
	include "_maps\Tails dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
TailsTailsDynPLC:
	include "_maps\Tails Tails dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
KnucklesDynPLC:
	include "_maps\Knuckles dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for Silver
; ---------------------------------------------------------------------------
SSCharDynPLC:
	include "_maps\SSChar dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Lightning Shield
; ---------------------------------------------------------------------------
LShieldDynPLC:
	include "_maps\Lightning Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Bubble Shield
; ---------------------------------------------------------------------------
BShieldDynPLC:
	include "_maps\Bubble Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Flame Shield
; ---------------------------------------------------------------------------
FShieldDynPLC:
	include "_maps\Flame Shield dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for the Big Ring
; ---------------------------------------------------------------------------
SSRingDynPLC:
	include "_maps\SS Ring dynamic pattern load cues.asm"

; ---------------------------------------------------------------------------
; Uncompressed graphics	loading	array for rings
; ---------------------------------------------------------------------------
RingDynPLC:	
	include	"_maps\Ring DPLCs.asm"	; rings

; ---------------------------------------------------------------------------
; Uncompressed graphics	- Powerups
; ---------------------------------------------------------------------------
UnC_LightningShield:	incbin		artunc/shield.bin
		even
UnC_BubbleShield:	incbin		artunc/shieldbubble.bin
		even
UnC_FlameShield:	incbin		artunc/shieldflame.bin
		even
UnC_Stars:	incbin		artunc/stars.bin	; invincibility stars
		even
Art_Ring:	incbin	artunc\rings.bin	; rings
		even
Art_Explode:	incbin	artunc\explosio.bin	; explosion
		even
; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
Nem_TornadoSign: 	incbin  artnem\tornadosign.bin
		even
Nem_Tornado: 	incbin  artnem\tornado.bin
		even
Nem_RainSnow: 	incbin  artnem\rainsnow.bin
		even
Nem_Sun: 	incbin  artnem\sun.bin
		even
Nem_EEZSwitch: 	incbin  artnem\switch.bin
		even
Nem_Prison: 	incbin  artnem\prison.bin
		even
; ---------------------------------------------------------------------------
; Sprite mappings - walls of the special stage
; ---------------------------------------------------------------------------
Map_SSWalls:
	include "_maps\SSwalls.asm"
; ---------------------------------------------------------------------------
; Sprite mappings - bumpers in the special stage
; ---------------------------------------------------------------------------
Map_SS_Bump:
	include "_maps\SSbump.asm"
; ---------------------------------------------------------------------------
; Compressed graphics - special stage
; ---------------------------------------------------------------------------
Unc_SSWalls:	incbin	artunc\sswalls.bin	; special stage walls
		even
Eni_SSBg:	incbin	mapeni\ssbg.bin	; special stage background (mappings)
		even
Nem_SSBg:	incbin	artnem\ssbg.bin	; special stage clouds background
		even
Eni_SSFg:	incbin	mapeni\ssfg.bin	; special stage foregrond (mappings)
		even
Nem_SSFg:	incbin	artnem\ssfg.bin	; special stage clouds foreground
		even
Nem_SSGOAL:	incbin	artnem\ssgoal.bin	; special stage GOAL block
		even
Nem_SSRBlock:	incbin	artnem\ssr.bin		; special stage R block
		even
Nem_SS1UpBlock:	incbin	artnem\ss1up.bin	; special stage 1UP block
		even
Nem_SSEmStars:	incbin	artnem\ssemstar.bin	; special stage stars from a collected emerald
		even
Nem_SSRedWhite:	incbin	artnem\ssredwhi.bin	; special stage red/white block
		even
Nem_SSZone1:	incbin	artnem\sszone1.bin	; special stage AAZ block
		even
Nem_SSZone2:	incbin	artnem\sszone2.bin	; BBZ block
		even
Nem_SSZone3:	incbin	artnem\sszone3.bin	; CCZ block
		even
Nem_SSZone4:	incbin	artnem\sszone4.bin	; DDZ block
		even
Nem_SSZone5:	incbin	artnem\sszone5.bin	; EEZ block
		even
Nem_SSZone6:	incbin	artnem\sszone6.bin	; FFZ block
		even
Nem_SSUpDown:	incbin	artnem\ssupdown.bin	; special stage UP/DOWN block
		even
Nem_SSEmerald:	incbin	artnem\ssemeral.bin	; special stage chaos emeralds
		even
Nem_SSGhost:	incbin	artnem\ssghost.bin	; special stage ghost block
		even
Nem_SSWBlock:	incbin	artnem\ssw.bin		; special stage W block
		even
Nem_SSGlass:	incbin	artnem\ssglass.bin	; special stage destroyable glass block
		even
Nem_ResultEm:	incbin	artnem\ssresems.bin	; chaos emeralds on special stage results screen
		even
Nem_Bumper:		incbin	artnem\bumper.bin	; chaos emeralds on special stage results screen
		even	
; ---------------------------------------------------------------------------
; Compressed graphics - BBZ stuff
; ---------------------------------------------------------------------------
Nem_Swing:	incbin	artnem\BBZswing.bin	; BBZ swinging platform
		even
Nem_Bridge:	incbin	artnem\BBZbridg.bin	; BBZ bridge
		even
Nem_Spikes:	incbin	artnem\spikes.bin	; spikes
		even
Nem_BBZWall1:	incbin	artnem\BBZwall1.bin	; BBZ destroyable wall
		even
Nem_BBZPlatform:	incbin	artnem\BBZptfm.bin	; BBZ platform
		even
; ---------------------------------------------------------------------------
; Compressed graphics - EEZ stuff
; ---------------------------------------------------------------------------
Nem_Water:	incbin	artnem\EEZwater.bin	; EEZ water surface
Nem_Bubbles:	incbin	artnem\EEZbubble.bin	; EEZ bubbles and countdown numbers
		even

; ---------------------------------------------------------------------------
; Compressed graphics - AAZ stuff
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
; Compressed graphics - FFZ stuff
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
; Compressed graphics - enemies
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
Nem_TitleCard:	incbin	artnem\ttlcards.bin	; title cards
		even
Nem_Hud:	incbin	artnem\hud.bin		; HUD (rings, time, score)
		even
Nem_Ring:	incbin	artnem\rings.bin	; rings
		even
Nem_Monitors:	incbin	artnem\monitors.bin	; monitors
		even
Nem_HSpring:	incbin	artnem\springh.bin	; horizontal spring
		even
Nem_VSpring:	incbin	artnem\springv.bin	; vertical spring
		even
Nem_DSpring:	incbin	artnem\springd.bin	; diagonal spring
		even
Nem_SignPost:	incbin	artnem\signpost.bin	; end of level signpost
		even
Nem_Lamp:	incbin	artnem\lamppost.bin	; lamppost
		even
; ---------------------------------------------------------------------------
; Compressed graphics - animals
; ---------------------------------------------------------------------------
Nem_Rabbit:	incbin	artnem\rabbit.bin	; rabbit
		even
Nem_Chicken:	incbin	artnem\chicken.bin	; chicken
		even
Nem_BlackBird:	incbin	artnem\blackbrd.bin	; blackbird
		even
Nem_Seal:	incbin	artnem\seal.bin		; seal
		even
Nem_Pig:	incbin	artnem\pig.bin		; pig
		even
Nem_Flicky:	incbin	artnem\flicky.bin	; flicky
		even
Nem_Squirrel:	incbin	artnem\squirrel.bin	; squirrel
		even
Nem_Fish:	incbin	artnem\fish.bin	; fish
		even
; ---------------------------------------------------------------------------
; Compressed graphics - primary patterns and block mappings
; ---------------------------------------------------------------------------

Nem_TIT:	incbin	artnem\8x8tit1.bin	; Title primary patterns
		even
Blk16_TIT:	incbin	map16\title.bin
		even
Blk256_TIT:	incbin	map256\title.bin
		even
Blk16_BBZ:	incbin	map16\BBZ.bin
		even
Kos_BBZ:	incbin	artkos\8x8BBZ.bin	; BBZ primary patterns
		even
Blk256_BBZ:	incbin	map256\BBZ.bin
		even
Blk16_EEZ:	incbin	map16\EEZ.bin
		even
Kos_EEZ:		incbin	artkos\8x8EEZ.bin	; EEZ primary patterns
		even
Blk256_EEZ:	incbin	map256\EEZ.bin
		even
Blk16_AAZ:	incbin	map16\AAZ.bin
		even
Kos_AAZ:	incbin	artkos\8x8AAZ.bin	; AAZ primary patterns
		even
Blk256_AAZ:	incbin	map256\AAZ.bin
		even
Blk16_FFZ:	incbin	map16\FFZ.bin
		even
Kos_FFZ:	incbin	artkos\8x8FFZ.bin	; FFZ primary patterns
		even
Blk256_FFZ:	incbin	map256\FFZ.bin
		even
Blk16_SSZ:	incbin	map16\ssz.bin
		even
Kos_SSZ:	incbin	artkos\8x8ssz.bin	; SSZ primary patterns
		even
Blk256_SSZ:	incbin	map256\ssz.bin
		even
Blk16_CCZ:	incbin	map16\CCZ.bin
		even
Kos_CCZ:	incbin	artkos\8x8CCZ.bin	; CCZ primary patterns
		even
Blk256_CCZ:	incbin	map256\CCZ.bin
		even
Blk16_GGZ:	incbin	map16\GGZ.bin
		even
Kos_GGZ:	incbin	artkos\8x8GGZ.bin	; GGZ primary patterns
		even
Blk256_GGZ:	incbin	map256\GGZ.bin
		even
Blk16_DDZ:	incbin	map16\DDZ.bin
		even
Kos_DDZ:	incbin	artkos\8x8DDZ.bin	; DDZ primary patterns
		even
Blk256_DDZ:	incbin	map256\DDZ.bin
		even
; ---------------------------------------------------------------------------
; Compressed graphics - bosses and ending sequence
; ---------------------------------------------------------------------------
Nem_EndEm:	incbin	artnem\endemera.bin	; ending sequence chaos emeralds
		even
Nem_EndSonic:	incbin	artnem\endsonic.bin	; ending sequence Sonic
		even
Nem_TryAgain:	incbin	artnem\tryagain.bin	; ending "try again" screen
		even
Kos_EndFlowers:	incbin	artkos\flowers.bin	; ending sequence animated flowers
		even
Nem_EndFlower:	incbin	artnem\endflowe.bin	; ending sequence flowers
		even
Nem_CreditText:	incbin	artnem\credits.bin	; credits alphabet
		even
Nem_EndStH:	incbin	artnem\endtext.bin	; ending sequence "Sonic the Hedgehog" text
		even
; ---------------------------------------------------------------------------
; Collision data
; ---------------------------------------------------------------------------
AngleMap:	incbin	collide\anglemap.bin	; floor angle map
		even
AngleMap3K:	incbin	collide\anglemap3K.bin	; Sonic 3K's floor angle map
		even
AngleMap2:	incbin	collide\anglemap2.bin	; Sonic 2's floor angle map
		even
AngleMapCD:	incbin	collide\anglemapCD.bin	; Sonic CD's floor angle map
		even
CollArray1:	incbin	collide\carray_n.bin	; normal collision array
		even
CollArray2:	incbin	collide\carray_r.bin	; rotated collision array
		even
CollArray3K1:	incbin	collide\carray3K_n.bin	; normal collision array
		even
CollArray3K2:	incbin	collide\carray3K_r.bin	; rotated collision array
		even
CollArray21:	incbin	collide\carray2_n.bin	; normal collision array
		even
CollArray22:	incbin	collide\carray2_r.bin	; rotated collision array
		even
CollArrayCD1:	incbin	collide\carrayCD_n.bin	; normal collision array
		even
CollArrayCD2:	incbin	collide\carrayCD_r.bin	; rotated collision array
		even
Col_BBZ_1:	incbin	collide\BBZ1.bin	; BBZ index 1
		even
Col_BBZ_2:	incbin	collide\BBZ2.bin	; BBZ index 2
		even
Col_EEZ_1:	incbin	collide\EEZ1.bin		; EEZ index 1
		even
Col_EEZ_2:	incbin	collide\EEZ2.bin		; EEZ index 2
		even
Col_AAZ_1:	incbin	collide\AAZ1.bin	; AAZ index 1
		even
Col_AAZ_2:	incbin	collide\AAZ2.bin	; AAZ index 2
		even
Col_FFZ_1:	incbin	collide\FFZ1.bin	; FFZ index 1
		even
Col_FFZ_2:	incbin	collide\FFZ2.bin	; FFZ index 2
		even
Col_END_1:	incbin	collide\end1.bin	; Ending index 1
		even
Col_END_2:	incbin	collide\end2.bin	; Ending index 2
		even
Col_SSZ_1:	incbin	collide\SSZ1.bin	; SSZ index 1
		even
Col_SSZ_2:	incbin	collide\SSZ2.bin	; SSZ index 2
		even
Col_CCZ_1:	incbin	collide\CCZ1.bin	; CCZ index 1
		even
Col_CCZ_2:	incbin	collide\CCZ2.bin	; CCZ index 2
		even
Col_GGZ_1:	incbin	collide\GGZ1.bin	; GGZ index 1
		even
Col_GGZ_2:	incbin	collide\GGZ2.bin	; GGZ index 2
		even
Col_DDZ_1:	incbin	collide\DDZ1.bin	; DDZ index 1
		even
Col_DDZ_2:	incbin	collide\DDZ2.bin	; DDZ index 2
		even
; ---------------------------------------------------------------------------
; Special layouts
; ---------------------------------------------------------------------------
BS_1:		incbin	sslayout\1.bin
		even
BS_2:		incbin	sslayout\2.bin
		even
BS_3:		incbin	sslayout\3.bin
		even
BS_4:		incbin	sslayout\4.bin
		even
BS_5:		incbin	sslayout\5.bin
		even
BS_6:		incbin	sslayout\6.bin
		even
; ---------------------------------------------------------------------------
; Animated uncompressed graphics
; ---------------------------------------------------------------------------
Art_BBZTorch:	incbin 	artunc\BBZtorch.bin ; BBZ torch background
		even

; ---------------------------------------------------------------------------
; Level	layout index
; ---------------------------------------------------------------------------
Level_Index:	dc.l Level_AAZ1, byte_68F88, byte_68F88
		dc.l Level_AAZ2, byte_68F88, byte_68F88
		dc.l Level_AAZ3, byte_68F88, byte_68F88
		dc.l Level_AAZ4, byte_68F88, byte_68F88
		dc.l Level_BBZ1, byte_68F88, byte_68F88	; MJ: Table needs to be read in long-word as the layouts are now bigger
		dc.l Level_BBZ2, byte_68F88, byte_68F88
		dc.l Level_BBZ3, byte_68F88, byte_68F88
		dc.l Level_BBZ4, byte_68F88, byte_68F88
		dc.l Level_CCZ1, byte_68F88, byte_68F88
		dc.l Level_CCZ2, byte_68F88, byte_68F88
		dc.l Level_CCZ3, byte_68F88, byte_68F88
		dc.l Level_CCZ4, byte_68F88, byte_68F88
		dc.l Level_DDZ1, byte_68F88, byte_68F88
		dc.l Level_DDZ2, byte_68F88, byte_68F88
		dc.l Level_DDZ3, byte_68F88, byte_68F88
		dc.l Level_DDZ4, byte_68F88, byte_68F88
		dc.l Level_EEZ1, byte_68F88, byte_68F88
		dc.l Level_EEZ2, byte_68F88, byte_68F88
		dc.l Level_EEZ3, byte_68F88, byte_68F88
		dc.l Level_EEZ4, byte_68F88, byte_68F88
		dc.l Level_FFZ1, byte_68F88, byte_68F88
		dc.l Level_FFZ2, byte_68F88, byte_68F88
		dc.l Level_FFZ3, byte_68F88, byte_68F88
		dc.l Level_FFZ4, byte_68F88, byte_68F88
		dc.l Level_GGZ1, byte_68F88, byte_68F88
		dc.l Level_GGZ2, byte_68F88, byte_68F88
		dc.l Level_GGZ3, byte_68F88, byte_68F88
		dc.l Level_GGZ4, byte_68F88, byte_68F88
		dc.l Level_SSZ1, byte_68F88, byte_68F88
		dc.l Level_SSZ2, byte_68F88, byte_68F88
		dc.l Level_SSZ3, byte_68F88, byte_68F88
		dc.l Level_SSZ4, byte_68F88, byte_68F88

Title_Index:	dc.l Level_TIT, byte_68F88, byte_68F88

Level_TIT:	incbin	levels\title.bin
		even
Level_BBZ1:	incbin	levels\BBZ1.bin
		even
Level_BBZ2:	incbin	levels\BBZ2.bin
		even
Level_BBZ3:	incbin	levels\BBZ3.bin
		even
Level_BBZ4:	incbin	levels\BBZ4.bin
		even

Level_EEZ1:	incbin	levels\EEZ1.bin
		even
Level_EEZ2:	incbin	levels\EEZ2.bin
		even
Level_EEZ3:	incbin	levels\EEZ3.bin
		even
Level_EEZ4:	incbin	levels\EEZ4.bin
		even

Level_AAZ1:	incbin	levels\AAZ1.bin
		even
Level_AAZ2:	incbin	levels\AAZ2.bin
		even
Level_AAZ3:	incbin	levels\AAZ3.bin
		even
Level_AAZ4:	incbin	levels\AAZ4.bin
		even

Level_FFZ1:	incbin	levels\FFZ1.bin
		even
Level_FFZ2:	incbin	levels\FFZ2.bin
		even
Level_FFZ3:	incbin	levels\FFZ3.bin
		even
Level_FFZ4:	incbin	levels\FFZ4.bin
		even
Level_End:	incbin	levels\ending.bin
		even

Level_SSZ1:	incbin	levels\ssz1.bin
		even
Level_SSZ2:	incbin	levels\ssz2.bin
		even
Level_SSZ3:	incbin	levels\ssz3.bin
		even
Level_SSZ4:	incbin	levels\ssz4.bin
		even

Level_CCZ1:	incbin	levels\CCZ1.bin
		even
Level_CCZ2:	incbin	levels\CCZ2.bin
		even
Level_CCZ3:	incbin	levels\CCZ3.bin
		even
Level_CCZ4:	incbin	levels\CCZ4.bin
		even

Level_GGZ1:	incbin	levels\GGZ1.bin
		even
Level_GGZ2:	incbin	levels\GGZ2.bin
		even
Level_GGZ3:	incbin	levels\GGZ3.bin
		even
Level_GGZ4:	incbin	levels\GGZ4.bin
		even

Level_DDZ1:	incbin	levels\DDZ1.bin
		even
Level_DDZ2:	incbin	levels\DDZ2.bin
		even
Level_DDZ3:	incbin	levels\DDZ3.bin
		even
Level_DDZ4:	incbin	levels\DDZ4.bin
		even

byte_68F88:	dc.b 0,	0, 0, 0

; ---------------------------------------------------------------------------
; Ring locations index
; ---------------------------------------------------------------------------
RingPos_Index:	dc.w RingPos_AAZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_AAZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_AAZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_AAZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_BBZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_BBZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_BBZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_BBZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_CCZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_DDZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_EEZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_EEZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_EEZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_EEZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FFZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FFZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FFZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_FFZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_GGZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_GGZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_GGZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_GGZ4-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ1-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ2-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ3-RingPos_Index, RingPos_Null-RingPos_Index
		dc.w RingPos_SSZ4-RingPos_Index, RingPos_Null-RingPos_Index

RingPos_BBZ1:	incbin	rings\BBZ1_INDIVIDUAL.bin
		even
RingPos_BBZ2:	incbin	rings\BBZ2_INDIVIDUAL.bin
		even
RingPos_BBZ3:	incbin	rings\BBZ3_INDIVIDUAL.bin
		even
RingPos_BBZ4:	incbin	rings\BBZ4_INDIVIDUAL.bin
		even
RingPos_EEZ1:	incbin	rings\EEZ1_INDIVIDUAL.bin
		even
RingPos_EEZ2:	incbin	rings\EEZ2_INDIVIDUAL.bin
		even
RingPos_EEZ3:	incbin	rings\EEZ3_INDIVIDUAL.bin
		even
RingPos_EEZ4:	incbin	rings\EEZ4_INDIVIDUAL.bin
		even
RingPos_AAZ1:	incbin	rings\AAZ1_INDIVIDUAL.bin
		even
RingPos_AAZ2:	incbin	rings\AAZ2_INDIVIDUAL.bin
		even
RingPos_AAZ3:	incbin	rings\AAZ3_INDIVIDUAL.bin
		even
RingPos_AAZ4:	incbin	rings\AAZ4_INDIVIDUAL.bin
		even
RingPos_FFZ1:	incbin	rings\FFZ1_INDIVIDUAL.bin
		even
RingPos_FFZ2:	incbin	rings\FFZ2_INDIVIDUAL.bin
		even
RingPos_FFZ3:	incbin	rings\FFZ3_INDIVIDUAL.bin
		even
RingPos_FFZ4:	incbin	rings\FFZ4_INDIVIDUAL.bin
		even
RingPos_End:	incbin	rings\ending.bin
		even
RingPos_SSZ1:	incbin	rings\SSZ1_INDIVIDUAL.bin
		even
RingPos_SSZ2:	incbin	rings\SSZ2_INDIVIDUAL.bin
		even
RingPos_SSZ3:	incbin	rings\SSZ3_INDIVIDUAL.bin
		even
RingPos_SSZ4:	incbin	rings\SSZ4_INDIVIDUAL.bin
		even
RingPos_CCZ1:	incbin	rings\CCZ1_INDIVIDUAL.bin
		even
RingPos_CCZ2:	incbin	rings\CCZ2_INDIVIDUAL.bin
		even
RingPos_CCZ3:	incbin	rings\CCZ3_INDIVIDUAL.bin
		even
RingPos_CCZ4:	incbin	rings\CCZ4_INDIVIDUAL.bin
		even
RingPos_GGZ1:	incbin	rings\GGZ1_INDIVIDUAL.bin
		even
RingPos_GGZ2:	incbin	rings\GGZ2_INDIVIDUAL.bin
		even
RingPos_GGZ3:	incbin	rings\GGZ3_INDIVIDUAL.bin
		even
RingPos_GGZ4:	incbin	rings\GGZ4_INDIVIDUAL.bin
		even
RingPos_DDZ1:	incbin	rings\DDZ1_INDIVIDUAL.bin
		even
RingPos_DDZ2:	incbin	rings\DDZ2_INDIVIDUAL.bin
		even
RingPos_DDZ3:	incbin	rings\DDZ3_INDIVIDUAL.bin
		even
RingPos_DDZ4:	incbin	rings\DDZ4_INDIVIDUAL.bin
		even
RingPos_Null:	dc.b $FF, $FF, 0, 0

; ---------------------------------------------------------------------------
; Sprite locations index
; ---------------------------------------------------------------------------
ObjPos_Index:	dc.w ObjPos_AAZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_AAZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_AAZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_AAZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_BBZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_BBZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_BBZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_BBZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_CCZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_DDZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_EEZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_EEZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_EEZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_EEZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FFZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FFZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FFZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FFZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GGZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GGZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GGZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GGZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SSZ4-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.b $FF, $FF, 0, 0, 0,	0
ObjPos_BBZ1:	incbin	objpos\BBZ1.bin
		even
ObjPos_BBZ2:	incbin	objpos\BBZ2.bin
		even
ObjPos_BBZ3:	incbin	objpos\BBZ3.bin
		even
ObjPos_BBZ4:	incbin	objpos\BBZ4.bin
		even
ObjPos_EEZ1:	incbin	objpos\EEZ1.bin
		even
ObjPos_EEZ2:	incbin	objpos\EEZ2.bin
		even
ObjPos_EEZ3:	incbin	objpos\EEZ3.bin
		even
ObjPos_EEZ4:	incbin	objpos\EEZ4.bin
		even
ObjPos_AAZ1:	incbin	objpos\AAZ1.bin
		even
ObjPos_AAZ2:	incbin	objpos\AAZ2.bin
		even
ObjPos_AAZ3:	incbin	objpos\AAZ3.bin
		even
ObjPos_AAZ4:	incbin	objpos\AAZ4.bin
		even
ObjPos_FFZ1:	incbin	objpos\FFZ1.bin
		even
ObjPos_FFZ2:	incbin	objpos\FFZ2.bin
		even
ObjPos_FFZ3:	incbin	objpos\FFZ3.bin
		even
ObjPos_FFZ4:	incbin	objpos\FFZ4.bin
		even
ObjPos_End:	incbin	objpos\ending.bin
		even
ObjPos_SSZ1:	incbin	objpos\SSZ1.bin
		even
ObjPos_SSZ2:	incbin	objpos\SSZ2.bin
		even
ObjPos_SSZ3:	incbin	objpos\SSZ3.bin
		even
ObjPos_SSZ4:	incbin	objpos\SSZ4.bin
		even
ObjPos_CCZ1:	incbin	objpos\CCZ1.bin
		even
ObjPos_CCZ2:	incbin	objpos\CCZ2.bin
		even
ObjPos_CCZ3:	incbin	objpos\CCZ3.bin
		even
ObjPos_CCZ4:	incbin	objpos\CCZ4.bin
		even
ObjPos_GGZ1:	incbin	objpos\GGZ1.bin
		even
ObjPos_GGZ2:	incbin	objpos\GGZ2.bin
		even
ObjPos_GGZ3:	incbin	objpos\GGZ3.bin
		even
ObjPos_GGZ4:	incbin	objpos\GGZ4.bin
		even
ObjPos_DDZ1:	incbin	objpos\DDZ1.bin
		even
ObjPos_DDZ2:	incbin	objpos\DDZ2.bin
		even
ObjPos_DDZ3:	incbin	objpos\DDZ3.bin
		even
ObjPos_DDZ4:	incbin	objpos\DDZ4.bin
		even
ObjPos_Null:	dc.b $FF, $FF, 0, 0, 0,	0				
; ===========================================================================
		align 2
Art_Dust:	incbin	"artunc\spindust.bin"
ART_SEGA:		incbin	"artnem\splash.bin"
MAPS_SEGA:		incbin	"mapeni\splash.bin"
			even
Pal_SEGANew:		incbin	"pallet\splash.bin"
; ===============================================================
; ---------------------------------------------------------------
; Vladikcomper's Parallax Engine
; Version 0.50
; ---------------------------------------------------------------
; 2014, Vladikcomper
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Main routine that runs the script
; ---------------------------------------------------------------
; INPUT:
;	a1	Script
; ---------------------------------------------------------------

ExecuteParallaxScript:
	lea	($FFFFE000).w,a0

	move.w	($FFFFF700).w,d0			; d0 = BG Position
	add.w	($FFFFF730).w,d0
	swap	d0
	clr.w	d0
	moveq	#0,d7
	
.ProcessBlock:
	move.b	(a1)+,d7			; load scrolling mode for the current block in script
	bmi.s	.Return				; if end of list reached, branch
	move.w	.ParallaxRoutines(pc,d7),d6
	move.b	(a1)+,d7			; load scrolling mode parameter
	jmp	.ParallaxRoutines(pc,d6)

.Return:
	rts

; ---------------------------------------------------------------
.ParallaxRoutines:
	dc.w	.Parallax_Normal-.ParallaxRoutines
	dc.w	.Parallax_Moving-.ParallaxRoutines  
	dc.w	.Parallax_Linear-.ParallaxRoutines
	dc.w	.Parallax_Ripple-.ParallaxRoutines

; ---------------------------------------------------------------
; Scrolling routine: Static solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Normal:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	move.w	($FFFFF700).w,d1
	neg.w	d1
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	jmp	.0(pc,d6)

	; Main functional block (2 bytes per loop)
.0	rept	32
	move.l	d1,(a0)+
	endr
	dbf	d5,.0

	jmp	.ProcessBlock			; process next bloku!
	
; ---------------------------------------------------------------
; Scrolling routine: Moving solid block
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Moving:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	move.w	($FFFFF700).w,d1
	neg.w	d1
	swap	d1
	neg.w	d1				; d1 = $00BB, where BB is -X*Coef
	
	; Add frame factor
	move.w	(Universal_Timer2).w,d3
	lsr.w	d7,d3
	sub.w	d3,d1

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#5,d5				; d5 = N/32
	andi.w	#31,d6				; d6 = N%32
	neg.w	d6				; d6 = -N%32
	add.w	#32,d6				; d6 = 32-N%32
	add.w	d6,d6
	jmp	.0(pc,d6)


; ---------------------------------------------------------------
; Scrolling routine: Linear Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Linear:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	move.w	($FFFFF700).w,d3
	neg.w	d3
	swap	d3

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	.1(pc,d6)

	; Main functional block (10 bytes per loop)
.1	rept	16
	swap	d1
	move.w	d1,d3
	move.l	d3,(a0)+
	swap	d1
	add.l	d2,d1
	endr
	dbf	d5,.1

	jmp	.ProcessBlock			; process next bloku!

; ---------------------------------------------------------------
; Scrolling routine: Ripple Parallax / Psedo-surface
; ---------------------------------------------------------------
; Input:
;	d7	.w	$00PP, where PP is parameter
;
; Notice:
;	Don't pollute the high byte of d7!
;
; ---------------------------------------------------------------

.Parallax_Ripple:

	; Calculate positions
	move.l	d0,d1				; d1 = X (16.16)
	swap	d1				; d1 = X (Int)
	mulu.w	(a1)+,d1			; d1 = X*Coef (24.8)
	lsl.l	#8,d1				; d1 = X*Coef (16.16)
	neg.l	d1				; d1 = Initial position	 v
	move.l	d1,d2
	asr.l	d7,d2				; d2 = Linear factor

	move.w	(Universal_Timer2).w,d3
	andi.w	#7,d3
	bne.s	.3
	subq.w	#1,($FFFFA800).w
.3
	move.w	($FFFFA800).w,d3
	andi.w	#$1F,d3
	lea	(SwScrl_RippleData2).l,a2
	lea	(a2,d3.w),a2

	move.w	($FFFFF700).w,d3
	neg.w	d3
	swap	d3

	; Execute code according to number of lines set
	move.w	(a1)+,d6			; d6 = N, where N is Number of lines
	move.w	d6,d5				; d5 = N	
	lsr.w	#4,d5				; d5 = N/16
	andi.w	#15,d6				; d6 = N%16
	neg.w	d6				; d6 = -N%16
	add.w	#16,d6				; d6 = 16-N%16
	move.w	d6,d4
	add.w	d6,d6
	add.w	d6,d6
	add.w	d4,d6
	add.w	d6,d6
	jmp	.2(pc,d6)

	; Main functional block (10 bytes per loop)
.2	rept	16
	move.l	d2,d1
	swap	d1
	move.b	(a2)+,d4
	ext.w	d4
	add.w	d4,d1
	move.w	d1,d3
	move.l	d3,(a0)+
	swap	d1
	endr
	dbf	d5,.2

	jmp	.ProcessBlock			; process next bloku!

; ---------------------------------------------------------------------------
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Art_Sonic:	incbin	artunc\sonic.bin	; Sonic
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Silver
; ---------------------------------------------------------------------------
Art_Silver:	incbin	artunc\silver.bin	; Silver
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Silver
; ---------------------------------------------------------------------------
Art_Silver2:	incbin	artunc\silver2.bin	; Silver
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Shadow
; ---------------------------------------------------------------------------
Art_Shadow:	incbin	artunc\shadow.bin	; Shadow
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Shadow
; ---------------------------------------------------------------------------
Art_Shadow2:	incbin	artunc\shadow2.bin	; Shadow
		even
		align $2000
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Tails
; ---------------------------------------------------------------------------
Art_Tails:	incbin	artunc\tails.bin	; Tails
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Tails' Tails
; ---------------------------------------------------------------------------
Art_TailsTails:	incbin	artunc\tailstails.bin	; Tails
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Knuckles
; ---------------------------------------------------------------------------
Art_Knuckles:	incbin	artunc\knuckles.bin	; Knuckles
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Knuckles
; ---------------------------------------------------------------------------
Art_Knuckles2:	incbin	artunc\knuckles2.bin	; Knuckles
		even
; ---------------------------------------------------------------------------
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Art_SSChar:	incbin	artunc\sschar.bin	; Sonic
		even
;-------------------------------------------------------------------------------
Menu_Font:
				incbin  'artnem\menufont.bin'
Menu_Box:
				incbin  'artnem\menubox.bin'
Level_Icons:
				incbin  'artnem\levelico.bin'  
Menu_Mappings:
				incbin  'mapeni\menubg.bin'
Icons_Mappings:
				incbin  'mapeni\iconsmap.bin'
Sonic_Miles_Spr:										 
				incbin  'artunc\soncmils.bin'
; ---------------------------------------------------------------------------
; Sprite mappings - zone title cards
; ---------------------------------------------------------------------------

Map_obj34:
  	include "_maps\obj34.asm"  
; ===============================================================
		include "AMPS/code/smps2asm.asm"
		include "AMPS/code/68k.asm"

DualPCM:
		PUSHS					; store section information for Main
Z80Code		SECTION	org(0), file("AMPS/.z80")	; create a new section for Dual PCM
		z80prog 0				; init z80 program
zchkoffs = 1
		include "AMPS/code/z80.asm"		; code for Dual PCM
DualPCM_sz:	z80prog					; end z80 program
		POPS					; go back to Main section

		PUSHS					; store section information for Main
mergecode	SECTION	file("AMPS/.z80.dat"), org(0)	; create settings file for storing info about how to merge things
		dc.l offset(DualPCM), Z80_Space		; store info about location of file and size available

	if zchkoffs
		rept zfuturec
			popp zoff			; grab the location of the patch
			popp zbyte			; grab the correct byte
			dc.w zoff			; write the address
			dc.b zbyte, '>'			; write the byte and separator
		endr
	endif
		POPS					; go back to Main section

	ds.b Z80_Space					; reserve space for the Z80 driver
	even
	opt ae+
		include	"error/ErrorHandler.asm"
EndOfRom:
		END
